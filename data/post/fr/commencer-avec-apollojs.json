{"date":"2019-02-15T00:00:00.000Z","title":"Apollojs, mise en place d'une API GraphQL","excerpt":"Dans cet article nous partageons les bonnes pratiques que nous avons mis en place au sein de nos projets GraphQL. Pour faire simple nous allons mettre en place une API GraphQL devant une API Rest existante, l'ensemble des développements se fera en Node.js avec Apollo GraphQL.","readingTime":"29mn","authors":["fpasquet","captainjojo"],"categories":["javascript"],"content":"\nDepuis un an nous utilisons GraphQL dans l'ensemble de nos projets au studio. Nous avons commencé directement avec l'implémentation Node.js et AppoloJS qui était en version 1. Depuis juin la version nous a permis de mettre en place une architecture plus solide et plus simple à maintenir.\n\nLa plupart de nos projets n'étant pas \"from scratch\" nous avons eu à migrer des API Rest en API GraphQL le plus rapidement possible. Il nous arrive aussi de mettre une surcouche GraphQL aux apis externes que nous devons utiliser.\n\nDans cet article nous partageons les bonnes pratiques que nous avons mis en place au sein de nos projets GraphQL. Pour faire simple nous allons mettre en place une API GraphQL devant une API Rest existante, l'ensemble des développements se fera en `Node.js` avec [`Apollo GraphQL`](https://www.apollographql.com/).\n\n## Sommaire\n\n- [Comment structurer son projet](#comment-structurer-son-projet)\n- [Implémenter notre schéma GraphQL](#implementer-notre-schema-graphql)\n- [Créer un dataSource REST](#creer-un-datasource-rest)\n- [Analyser les resolvers GraphQL](#analyser-les-resolvers-graphql)\n- [Optimiser les dataSources GraphQL](#optimiser-les-datasources-graphql)\n\n## Comment structurer son projet\n\nLa première chose que nous avons optimisée c'est l'arborescence du projet, en tant que développeur nous savons qu'il faut avoir une architecture claire et simple pour permettre à un développeur de travailler le plus rapidement possible et de ne pas avoir à chercher où placer son code.\n\nNous allons tout d'abord commencer par cloner le projet starter kit qui se trouve sur notre [github](https://github.com/fpasquet/apollo-server-starter-kit). Vous pouvez aussi le tester directement sur [codesandbox](https://codesandbox.io/s/github/eleven-labs/apollo-server-starter-kit/tree/master).\n\nÀ quoi ressemble ce starter kit et que contient-il ? Voici l'arborescence de notre serveur Apollo :\n\n```bash\n.\n├── src\n│   ├── dataLayers\n│   ├── dataSources\n│   ├── definitions\n│   ├── resolvers\n│   ├── directives\n│   ├── subscriptions\n│   └── index.js\n└── package.json\n```\n\nNous retrouvons ici :\n\n- `\"src/index.js\"` est notre point d'entrée pour notre API GraphQL, il contient la configuration du server GraphQL\n- `\"src/definitions/\"` comprendra tous nos fichiers définissant notre schéma GraphQL (`Queries`, `Mutations`, `Types`, `Inputs`, `Interfaces`, `Directives`, `Enums` ...)\n- `\"src/resolvers/\"`, `\"src/directives/\"` et `\"src/subscriptions/\"` contiendra nos différents résolveurs\n- `\"src/dataLayers\"` contiendra tout ce qui concerne la couche d'abstractions de données, dans notre exemple nous en aurons deux, une pour le REST et une autre pour le SQL avec `Knex.js`.\n- `\"src/dataSources/\"` quant à lui incluera les classes qui encapsulent l'extraction des données. Il peut être lié à une API REST (RESTDataSource), une base de données... Apollo Server implémente une classe qui intègre la mise en cache, la dé-duplication et le traitement des erreurs. Dans chacune des classes, nous pourrons ajouter des dataLoaders qui optimiseront notre API GraphQL. Les dataLoaders sont des fonctions de dé-duplication et du traitement par lots d'objets avec un système de cache intégré.\n\n## Implémenter notre schéma GraphQL\n\nVous pourrez lire dans de nombreux articles GraphQL que la première chose à faire est de définir son schéma, on dit que GraphQL est `schema first`.\n\nPetit conseil sur l'implémentation de votre schéma, ne reprenez pas la structure et le nommage de votre API REST, car le nommage de votre schéma GraphQL doit être fonctionnel et non technique. Une personne non technique doit comprendre du premier coup d'oeil votre API GraphQL, rien quand regardant votre schéma.\n\nL'API GraphQL sera sur le thème de Game Of Thrones, on affichera les différents personnages et les différentes maisons. Pour ce faire, nous utiliserons l'API REST qui se trouve sur le dépôt [github](https://github.com/fpasquet/got-api).\n\n\n### Ajoutons les types\n\nAjoutons notre type `Character` dans le fichier `src/definitions/Type/Character.graphql` :\n\n```graphql\ntype Character {\n  key: ID!\n  name: String!\n  imageUrl: String\n  father: Character\n  mother: Character\n  spouse: Character\n  childrens: [Character]\n  house: House\n}\n```\n\nAjoutons notre type `House` dans le fichier `src/definitions/Type/House.graphql` :\n\n```graphql\ntype House {\n  key: ID!\n  name: String!\n  imageUrl: String\n  lord: Character\n  heirs: [Character]\n  characters: [Character]\n}\n```\n\nAjoutons nos queries dans le fichier `src/definitions/Query.graphql` :\n\n```graphql\nextend type Query {\n  characters: [Character]\n  character(key: ID!): Character\n  houses: [House]\n  house(key: ID!): House\n}\n```\n\nPour plus de détails sur l'implémentation des types graphQL nous vous invitons à lire la documentation [ici](https://graphql.org/learn/schema/#type-system).\n\nUne démo de cette étape est présente sur [CodeSandbox](https://codesandbox.io/s/github/eleven-labs/article-starter-kit-graphql/tree/step/definitions).\n\n## Créer un dataSource REST\n\nLes _dataSources_ Apollo permettent d'encapsuler la récupération des données pour un service particulier (Ex: Api Rest, BDD Mysql, etc ...). Les _dataSources_ prennent en compte directement la gestion du cache, la dé-duplication ainsi que le traitement des erreurs. Vous n'avez donc plus besoin d'écrire le code spécifique pour l'interaction avec votre serveur REST, Apollo s'occupe de gérer les interactions.\n\nNous allons donc créer deux _dataSources_ REST un pour les personnages et l'autre pour les maisons.\n\nAjoutons notre premier DataSource pour les personages dans le fichier `src/dataSources/CharacterRESTDataSource.js`:\n\n```js\nconst { compact } = require(\"lodash\");\nconst { RESTDataSource } = require(\"apollo-datasource-rest\")\n\nclass CharacterRESTDataSource extends RESTDataSource {\n  get baseURL() {\n      return this.context.ENDPOINT_GOT_API;\n  }\n\n  get characters() {\n    return this.get(\"/characters\");\n  }\n\n  findCharacterByKey(key) {\n    return this.get(`/character/${key}`).catch(error => {\n      if (error.extensions.response.status === 404) {\n        return null;\n      }\n      return error;\n    })\n  }\n\n  async filterCharactersByKeys(keys) {\n    let characters = keys.map(key => this.findCharacterByKey(key));\n    return Promise.all(characters).then(([...results]) => compact(results));\n  }\n\n  async filterCharactersByHouseKey(houseKey) {\n    const characters = await this.characters;\n    return characters.filter(character => character.royalHouseKey === houseKey);\n  }\n}\n\nmodule.exports = CharacterRESTDataSource;\n```\nAjoutons notre deuxième DataSource pour les maisons dans le fichier `src/dataSources/HouseRESTDataSource.js` :\n\n```js\nconst { RESTDataSource } = require(\"apollo-datasource-rest\");\n\nclass HouseRESTDataSource extends RESTDataSource {\n    get baseURL() {\n        return this.context.ENDPOINT_GOT_API;\n    }\n\n    get houses() {\n        return this.get(\"/houses\");\n    }\n\n    findHouseByKey(key) {\n        return this.get(`/house/${key}`).catch(error => {\n            if (error.extensions.response.status === 404) {\n                return null;\n            }\n            return error;\n        })\n    }\n}\n\nmodule.exports = HouseRESTDataSource;\n```\n\nLa démo [CodeSandbox](https://codesandbox.io/s/github/eleven-labs/article-starter-kit-graphql/tree/step/dataSources).\n\n## Ajoutons nos resolvers\n\nLes resolvers sont la brique centrale de GraphQL, c'est ici que vous expliquez à votre serveur comment récupérer chaque Query et Type que vous avez définis dans votre schéma.\n\nComme vous pouvez le constater, la configuration des resolvers doit suivre votre configuration de typage.\nIci dans les resolvers vous n'avez plus qu'à appeler votre Datasource qui se chargera de récupérer les données.\n\nAjoutons notre premier `resolver` pour les personnages dans le fichier `src/resolvers/character.js` :\n\n```js\nconst { ApolloError } = require(\"apollo-server\");\n\nconst resolvers = {\n  Query: {\n    characters: (\n      parent,\n      args,\n      { dataSources: { CharacterRESTDataSource } },\n      info\n    ) => CharacterRESTDataSource.characters,\n    character: (\n      parent,\n      { key },\n      { dataSources: { CharacterRESTDataSource } },\n      info\n    ) => CharacterRESTDataSource.findCharacterByKey(key).then(character => character ? character : new ApolloError(\"Character not found.\", \"RESOURCE_NOT_FOUND\")),\n  },\n  Character: {\n    father: (parent, args, { dataSources: { CharacterRESTDataSource } }) => parent.fatherKey ? CharacterRESTDataSource.findCharacterByKey(parent.fatherKey) : null,\n    mother: (parent, args, { dataSources: { CharacterRESTDataSource } }) => parent.motherKey ? CharacterRESTDataSource.findCharacterByKey(parent.motherKey) : null,\n    spouse: (parent, args, { dataSources: { CharacterRESTDataSource } }) => parent.spouseKey || parent.queenKey ? CharacterRESTDataSource.findCharacterByKey(parent.spouseKey || parent.queenKey) : null,\n    childrens: (parent, args, { dataSources: { CharacterRESTDataSource } }) => parent.childrensKey ? CharacterRESTDataSource.filterCharactersByKeys(parent.childrensKey) : null,\n    house: (parent, args, { dataSources: { HouseRESTDataSource } }) => parent.royalHouseKey ? HouseRESTDataSource.findHouseByKey(parent.royalHouseKey) : null,\n  }\n};\n\nmodule.exports = resolvers;\n```\n\nAjoutons notre deuxième `resolver` pour les maisons dans le fichier `src/resolvers/house.js` :\n\n```js\nconst { ApolloError } = require(\"apollo-server\");\n\nconst resolvers = {\n  Query: {\n    houses: async (\n      parent,\n      args,\n      { dataSources: { HouseRESTDataSource } },\n      info\n    ) => HouseRESTDataSource.houses,\n    house: (\n      parent,\n      { key },\n      { dataSources: { HouseRESTDataSource } },\n      info\n    ) => HouseRESTDataSource.findHouseByKey(key).then(house => house ? house : new ApolloError(\"House not found.\", \"RESOURCE_NOT_FOUND\")),\n  },\n  House: {\n    lord: (parent, args, { dataSources: { CharacterRESTDataSource } }) => parent.lordKey ? CharacterRESTDataSource.findCharacterByKey(parent.lordKey) : null,\n    heirs: (parent, args, { dataSources: { CharacterRESTDataSource } }) => parent.heirsKey ? CharacterRESTDataSource.filterCharactersByKeys(parent.heirsKey) : null,\n    characters: (parent, args, { dataSources: { CharacterRESTDataSource } }) => CharacterRESTDataSource.filterCharactersByHouseKey(parent.key),\n  }\n};\n\nmodule.exports = resolvers;\n```\n\nUne fois vos resolvers terminés, vous pouvez les tester dans l'interface `playground` qui est fournie directement dans Apollo. Il s'agit d'un IDE permettant de lancer des Query et Mutation sur votre API. Vous pouvez aussi voir la documentation qui est autogénérée grâce aux typages fort de votre API GraphQL.\n\n```graphql\nquery CHARACTERS(\n  $withMother: Boolean = false\n  $withFather: Boolean = false\n  $withSpouse: Boolean = false\n  $withChildrens: Boolean = false\n  $withHouse: Boolean = false\n) {\n  characters {\n    ...FullCharacter\n  }\n}\n\nquery HOUSES(\n  $withLord: Boolean = false\n  $witHeirs: Boolean = false\n  $witCharacters: Boolean = false\n) {\n  houses {\n    ...FullHouse\n  }\n}\n\nfragment FullCharacter on Character {\n  ...Character\n  mother @include(if: $withMother) {\n    ...Character\n  }\n  father @include(if: $withFather) {\n    ...Character\n  }\n  spouse @include(if: $withSpouse) {\n    ...Character\n  }\n  childrens @include(if: $withChildrens) {\n    ...Character\n  }\n  house @include(if: $withHouse) {\n    ...House\n  }\n}\n\nfragment FullHouse on House {\n  key\n  name\n  imageUrl\n  lord @include(if: $withLord) {\n    ...Character\n  }\n  heirs @include(if: $witHeirs) {\n    ...Character\n  }\n  characters @include(if: $witCharacters) {\n    ...Character\n  }\n}\n\nfragment Character on Character {\n  key\n  name\n  imageUrl\n}\n\nfragment House on House {\n  key\n  name\n  imageUrl\n}\n```\n\nDans l'exemple de query nous utilisons, les `fragment` agissent comme des `include`. Cela permet de ne pas répéter plusieurs fois le même code dans des Queries. L'utilisation est assez simple une fois votre `fragment` créé vous pouvez l'utiliser dans vos queries en utilisant `...`, ça fonctionne de la même manière que l'affectation par décomposition ([https://developer.mozilla.org/fr/docs/Web/JavaScript](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/Affecter_par_d%C3%A9composition)).\n\nLa démo [CodeSandbox](https://codesandbox.io/s/github/eleven-labs/article-starter-kit-graphql/tree/step/resolvers).\n\n## Analyser les resolvers GraphQL\n\nMaintenant que notre API est prête à être utilisée, nous devons mettre en place du monitoring. Cela va nous permettre de suivre les performances et d'optimiser les points de congestion.\n\nPour cela, nous allons créer une extension qui va nous permettre d'analyser notre API GraphQL, et par la suite de l'optimiser.\n\nAjoutons un collecteur de données pour le Datasource REST dans le fichier `src/dataLayers/restCollector.js`:\n\n```js\nclass RestCollector {\n  constructor() {\n    this._initializeData();\n  }\n\n  _initializeData() {\n    this.globalExecutionTimeRequest = 0;\n    this.maxExecutionTimeRequest = null;\n    this.minExecutionTimeRequest = null;\n    this.requests = [];\n  }\n\n  reset() {\n    this._initializeData();\n  }\n\n  addRequest({ executionTimeRequest, request }) {\n    if (\n      !this.maxExecutionTimeRequest ||\n      executionTimeRequest > this.maxExecutionTimeRequest\n    ) {\n      this.maxExecutionTimeRequest = executionTimeRequest;\n    }\n    if (\n      !this.minExecutionTimeRequest ||\n      executionTimeRequest < this.minExecutionTimeRequest\n    ) {\n      this.minExecutionTimeRequest = executionTimeRequest;\n    }\n    this.globalExecutionTimeRequest += executionTimeRequest;\n    this.requests.push({\n      executionTimeRequest: `${executionTimeRequest} ms`,\n      request\n    });\n\n    return this;\n  }\n\n  static getInstance() {\n    if (!RestCollector.instance) {\n      RestCollector.instance = new RestCollector();\n    }\n\n    return RestCollector.instance;\n  }\n}\n\nmodule.exports = RestCollector.getInstance();\n```\nCela va nous permettre de récupérer des données de performance lors de chaque appel à notre ApiRest.\n\nLes appels étant réalisés dans notre DataSource, nous allons étendre notre RestDataSource pour ajouter notre collecteur. Pour cela, on va créer le fichier `src/dataLayers/restDataSource.js`:\n\n```js\nconst { AuthenticationError, ForbiddenError, ApolloError } = require(\"apollo-server\");\nconst { RESTDataSource: BaseRESTDataSource } = require('apollo-datasource-rest');\nconst RestCollector = require('./restCollector');\n\nclass RESTDataSource extends BaseRESTDataSource {\n\n    willSendRequest(request) {\n        this.startTime = process.hrtime();\n        this.request = request;\n    }\n\n    getErrorFromResponseAndBody(response, body) {\n        return {\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: `${response.status}: ${response.statusText}`\n        };\n    }\n\n    errorFromResponse(response, body) {\n        const { message, code } = this.getErrorFromResponseAndBody(response, body);\n\n        let error;\n        if (response.status === 401) {\n            error = new AuthenticationError(message);\n        } else if (response.status === 403) {\n            error = new ForbiddenError(message);\n        } else {\n            error = new ApolloError(message, code);\n        }\n\n        Object.assign(error.extensions, {\n            response: {\n                url: response.url,\n                status: response.status,\n                statusText: response.statusText,\n                body,\n            },\n        });\n\n        return error;\n    }\n\n    async didReceiveResponse(response, _request) {\n        const hrend = process.hrtime(this.startTime);\n        const body = await this.parseBody(response);\n\n        RestCollector.addRequest({\n            executionTimeRequest: hrend[1] / 1000000,\n            request: {\n                url: response.url,\n                method: this.request.method,\n                params: this.request.params,\n                headers: this.request.headers,\n                status: response.status,\n                statusText: response.statusText,\n                error: !response.ok ? this.getErrorFromResponseAndBody(response, body) : null\n            }\n        });\n\n        if (response.ok) {\n            return body;\n        } else {\n            throw this.errorFromResponse(response, body);\n        }\n    }\n}\n\nmodule.exports = RESTDataSource;\n```\n\nMaintenant que chaque `request` nous renvoie des valeurs de performance, nous voulons les récupérer pour les ajouter dans la réponse GraphQL.\n\nAjoutons une extension dans le fichier `src/dataLayers/restExtension.js` qui permettra d'ajouter les éléments dans notre réponse GraphQL.\n\n```js\nconst RestCollector = require('./restCollector');\n\nclass RestExtension {\n\n    willSendResponse(graphqlResponse) {\n        let logging = `--------- START_MONITORING_REST ---------\\n`;\n        logging += `Duration min request: ${RestCollector.minExecutionTimeRequest} ms\\n`;\n        logging += `Duration max request: ${RestCollector.maxExecutionTimeRequest} ms\\n`;\n        logging += `Duration total request: ${RestCollector.globalExecutionTimeRequest} ms\\n`;\n        logging += `Numbers of requests: ${RestCollector.requests.length}\\n`;\n        logging += `Requests REST: ${JSON.stringify(RestCollector.requests)}\\n`;\n        logging += `--------- END_MONITORING_REST ---------`;\n        console.log(logging);\n\n        RestCollector.reset();\n\n        return graphqlResponse;\n    }\n\n    format() {\n        return ['rest', {\n            minExecutionTimeRequest: RestCollector.minExecutionTimeRequest,\n            maxExecutionTimeRequest: RestCollector.maxExecutionTimeRequest,\n            globalExecutionTimeRequest: RestCollector.globalExecutionTimeRequest,\n            numbersOfRequests: RestCollector.requests.length,\n            requests: RestCollector.requests,\n        }];\n    }\n}\n\nmodule.exports = RestExtension;\n```\n\nEt pour finir, on exporte tout dans un fichier à la racine `src/dataLayers/index.js`:\n\n```js\nconst RestExtension = require(\"./restExtension\");\nconst RESTDataSource = require('./restDataSource');\n\nmodule.exports = {\n    RestExtension,\n    RESTDataSource\n}\n```\n\nEt maintenant nous l'activons en modifiant notre serveur apollo, via le fichier  `index.js` :\n\n```js\n...\nconst { RestExtension } = require(\"./dataLayers/rest\");\n...\n\nconst server = new ApolloServer({\n  ...\n  extensions: [() => new RestExtension()],\n  ...\n});\n```\n\nEt modifions nos deux _RESTDataSources_ en important l'extend de notre DataSource.\n\n```js\nconst { RESTDataSource } = require(\"apollo-datasource-rest\");\n```\n\npar\n\n```js\nconst { RESTDataSource } = require(\"../dataLayers/rest\");\n```\n\nAprès avoir activé l'extension, on va constater que dans les réponses de chacun de nos appels, on peut voir apparaître un objet extensions qui contient les données de performance :\n\n```json\n{\n    \"data\": {...},\n    \"extensions\": {\n        \"rest\": {\n            \"minExecutionTimeRequest\": 0.44865,\n            \"maxExecutionTimeRequest\": 561.711479,\n            \"globalExecutionTimeRequest\": 171837.08310799988,\n            \"numbersOfRequests\": 396\n        },\n        \"requests\": [\n            {\n                \"executionTimeRequest\": \"43.088889 ms\",\n                \"request\": {\n                    \"url\": \"http://localhost:8080/api/characters\",\n                    \"method\": \"GET\",\n                    \"params\": {},\n                    \"headers\": {},\n                    \"status\": 200,\n                    \"statusText\": \"OK\",\n                    \"error\": null\n                }\n            },\n            {\n                \"executionTimeRequest\": \"294.645117 ms\",\n                \"request\": {\n                    \"url\": \"http://localhost:8080/api/house/L2luZGV4LnBocC9Ib3VzZV9UYXJnYXJ5ZW4=\",\n                    \"method\": \"GET\",\n                    \"params\": {},\n                    \"headers\": {},\n                    \"status\": 200,\n                    \"statusText\": \"OK\",\n                    \"error\": null\n                }\n            },\n            ...\n        ]\n    }\n}\n```\n\nComme vous pouvez le constater nous avons un temps d'exécution un peu long... Dans la prochaine étape nous verrons comment l'optimiser.\n\nLa démo [CodeSandbox](https://codesandbox.io/s/github/eleven-labs/article-starter-kit-graphql/tree/step/rest-extension).\n\n## Optimiser les dataSources GraphQL\n\nNous allons donc optimiser nos DataSources en implémentant des DataLoaders :\n\nLes Dataloaders sont des utilitaires génériques fournis par Facebook sur le projet github suivant : [https://github.com/facebook/dataloader](https://github.com/facebook/dataloader). Ils permettent de gérer la récupération des sources de données (ici via une ApiRest) en utilisant du cache et de la récupération via `batch`. Cela permet de gagner en performance.\n\nOn commencera par notre dataSource des personnages, `src/dataSource/CharacterRESTDataSource.js`:\n\n```js\nconst { compact } = require(\"lodash\");\nconst DataLoader = require(\"dataloader\");\nconst { RESTDataSource } = require(\"../dataLayers/rest\");\n\nclass CharacterRESTDataSource extends RESTDataSource {\n    get baseURL() {\n        return this.context.ENDPOINT_GOT_API;\n    }\n\n    get limitRequest() {\n        return this.context.LIMIT_REQUEST || 25;\n    }\n\n    get characters() {\n        return this.get(\"/characters\");\n    }\n\n    findCharacterByKey(key) {\n        return this.dataLoaders.characterByKey.load(key);\n    }\n\n    async filterCharactersByKeys(keys) {\n        let characters = keys.map(key => this.findCharacterByKey(key));\n        return Promise.all(characters).then(([...results]) => compact(results));\n    }\n\n    async filterCharactersByHouseKey(houseKey) {\n        return this.characters.then(characters => characters.filter(character => character.royalHouseKey === houseKey));\n    }\n\n    get dataLoaders() {\n        if (!this._dataLoaders) {\n            this._dataLoaders = {\n                characterByKey: this._characterByKeyDataLoader\n            }\n        }\n\n        return this._dataLoaders;\n    }\n\n    get _characterByKeyDataLoader() {\n        return new DataLoader(keys => {\n            let promise;\n            if (keys.length > this.limitRequest) {\n                promise = this.characters;\n            } else {\n                const promises = keys.map(key => this.get(`/character/${key}`).catch(error => {\n                    if (error.extensions.response.status === 404) {\n                        return {};\n                    }\n                    return error;\n                }));\n                promise = Promise.all(promises);\n            }\n\n            return promise.then(items => keys.map(key => items.find(({ key: currentKey }) => currentKey === key)));\n        });\n    }\n}\n\nmodule.exports = CharacterRESTDataSource;\n```\n\nPuis celui des maisons, `src/dataSource/HouseRESTDataSource.js`:\n\n```js\nconst DataLoader = require(\"dataloader\");\nconst { RESTDataSource } = require(\"../dataLayers/rest\");\n\nclass HouseRESTDataSource extends RESTDataSource {\n    get baseURL() {\n        return this.context.ENDPOINT_GOT_API;\n    }\n\n    get limitRequest() {\n        return this.context.LIMIT_REQUEST || 25;\n    }\n\n    get houses() {\n        return this.get(\"/houses\");\n    }\n\n    findHouseByKey(key) {\n        return this.dataLoaders.houseByKey.load(key);\n    }\n\n    get dataLoaders() {\n        if (!this._dataLoaders) {\n            this._dataLoaders = {\n                houseByKey: this._houseByKeyDataLoader\n            }\n        }\n\n        return this._dataLoaders;\n    }\n\n    get _houseByKeyDataLoader() {\n        return new DataLoader(keys => {\n            let promise;\n            if (keys.length > this.limitRequest) {\n                promise = this.houses;\n            } else {\n                const promises = keys.map(key => this.get(`/house/${key}`).catch(error => {\n                    if (error.extensions.response.status === 404) {\n                        return {};\n                    }\n                    return error;\n                }));\n                promise = Promise.all(promises);\n            }\n\n            return promise.then(items => keys.map(key => items.find(({ key: currentKey }) => currentKey === key)));\n        });\n    }\n}\n\nmodule.exports = HouseRESTDataSource;\n```\nDonc notre cas, le Dataloader nous permet de récupérer les `character` de façon optimisée, et nous permet d'effectuer moins de requêtes sur notre API.\n\nGrace à cela vous pouvez constater une amélioration des performances de la query.\n\n```json\n{\n    \"data\": {...},\n    \"extensions\": {\n        \"rest\": {\n          \"minExecutionTimeRequest\": 108.412019,\n          \"maxExecutionTimeRequest\": 190.706104,\n          \"globalExecutionTimeRequest\": 1727.125432,\n          \"numbersOfRequests\": 14,\n          \"requests\": [\n            {\n              \"executionTimeRequest\": \"187.381987 ms\",\n              \"request\": {\n                \"url\": \"https://game-of-throne-api.appspot.com/api/characters\",\n                \"method\": \"GET\",\n                \"params\": {},\n                \"headers\": {},\n                \"status\": 200,\n                \"statusText\": \"OK\",\n                \"error\": null\n              }\n            },\n            {\n              \"executionTimeRequest\": \"108.412019 ms\",\n              \"request\": {\n                \"url\": \"https://game-of-throne-api.appspot.com/api/house/L2luZGV4LnBocC9Ib3VzZV9EdXJyYW5kb24=\",\n                \"method\": \"GET\",\n                \"params\": {},\n                \"headers\": {},\n                \"status\": 200,\n                \"statusText\": \"OK\",\n                \"error\": null\n              }\n            },\n            ...\n        ]\n    }\n}\n```\n\nLa démo [CodeSandbox](https://codesandbox.io/s/github/eleven-labs/article-starter-kit-graphql/tree/step/optimization-with-dataLoaders).\n\n### Conclusion\n\nVous avez ici un exemple clair et poussé d'une API GraphQL. Nous travaillons actullement sur la mise en place de tooling pour gérer le monitoring et la mise en cache. Nous vous invitons à suivre notre blog et à participer à la communauté GraphQL !\n"}