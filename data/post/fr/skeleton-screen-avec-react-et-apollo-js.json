{"date":"2019-10-16T00:00:00.000Z","title":"Une application React plus réactive - Le skeleton screen","excerpt":"Dans cet article, nous allons vous présenter le skeleton screen et vous montrer comment l'implémenter dans votre application React facilement grâce à ApolloJS","readingTime":"16mn","authors":["kcordier"],"categories":["javascript"],"content":"\n## Intro\n\nÊtes-vous quelqu’un de pati… ah non je me [répète](https://blog.eleven-labs.com/fr/optimistic-ui-avec-react-et-apollo-js/).\nAvez vous déjà réalisé une “one page application” (ou une “application web monopage”, dans la langue de Maître Gims) ?\nSi oui, vous devez être au fait de la problématique du temps de chargement lors d’un changement de page.\nCe moment de transition ou les blocs statiques de notre application comme le header et le footer sont affichés mais que le contenu, lui, est encore en chargement dû à une mauvaise connexion ou à une API longue à répondre.\nComment résoudre ce problème que j’aime appeler “la transition mâchoire” ?\n\n![](/imgs/posts/2019-10-16-skeleton-screen/no_loading.gif)\n\nUne première solution est de forcer une hauteur minimum à notre contenu afin d'éviter l’effet mâchoire.\n\n![](/imgs/posts/2019-10-16-skeleton-screen/min_height.gif)\n\nLe problème avec cette solution est que l’on manque d’information quant à l’état de la page : la page est-elle en chargement ? La page demandée est-elle une simple page blanche ? L’application est-elle plantée ?\nPour toutes ces problématiques il nous suffit simplement d’ajouter un loader.\n\n![](/imgs/posts/2019-10-16-skeleton-screen/loader.gif)\n\nBon, tout ça c’est bien, mais on peut faire encore mieux. On peut mettre en place un **Skeleton screen** !\n\n## Skeleton ? Hoouuuu spookie !\n\nDerrière ce nom effrayant se cache une idée de design décrite par [Luke Wroblewski](https://www.lukew.com/about/).\nElle consiste à afficher ce à quoi devrait ressembler la page, mais avec des placeholders à la place des données.\n“Mais pourquoi faire ça ?” vous allez me dire. Selon Luke, le loader pose un véritable problème comme expliqué dans [cet article](https://www.lukew.com/ff/entry.asp?1797).\n\nComme il le stipule, le fait de voir un spiner ou une barre de chargement renvoie l’utilisateur à l’idée d’attendre. Et par conséquent cela donne l'impression que le temps passe plus lentement. Comme quand vous regardez une horloge et que le temps semble ralenti, pour reprendre son exemple.\nLe **skeleton screen** est aujourd’hui utilisé par la plupart des géants d’internet comme youtube ou LinkedIn pour ne citer qu’eux deux.\n\n![](/imgs/posts/2019-10-16-skeleton-screen/skeleton_youtube.png)\nYoutube\n\n![](/imgs/posts/2019-10-16-skeleton-screen/skeleton_linkedin.png)\nLinkedIn\n\nBon, maintenant que nous avons le principe et quelques exemples, comment faire un bon **skeleton screen** ?\nPremièrement, vous devez remplacer les images et les zones de texte par des formes simples de couleur grises.\nSi vous le souhaitez, vous pouvez choisir d’utiliser d’autres couleurs à condition qu’elles soient neutres.\n\nJe déconseille de remplacer mot pour mot tout le contenu, il est préférable de sélectionner des parties importantes de l’affichage.\nComme par exemple : le titre, le sous-titre, l’image, et 2 lignes de descriptions pour prendre le cas du squelette d’un poste LinkedIn.\nIci, exit la date de parution, le nombre de like ou les liens... Nous restons au plus simple.\n\nEnsuite, vous devez ajouter du mouvement. Grâce au css, vous pouvez créer des effets de scintillement qui rappelleront que notre application n’est pas figée. Préférez des vagues de gauche à droite comme nous pouvons le voir sur les différents exemples donnés plus haut.\n\nPour finir, il est préférable de découper ses squelettes par composants plutôt que de réaliser un page complète.\nGrâce à ce découpage vous pouvez réaliser une page qui se construit au fur et à mesure que les différentes parties sont hydratées par les données.\n\nMettons maintenant ça en pratique dans une application React.\n\n## Mise en place du skeleton\n\nEn premier lieu, nous allons créer notre composant placeholder.\n\n```jsx\n// SkeletonItem.jsx\nimport React from 'react';\nimport classNames from 'classnames';\n\nimport './styles.scss';\n\nconst SkeletonItem = ({ style, className }) => (\n    <div className={classNames('skeleton-item', className)} style={style} />\n);\n\nexport default SkeletonItem;\n```\n\nIci rien de compliqué. Il s'agit juste de renvoyer une div avec la classe css **‘skeleton-item’** qui nous permettra de le styliser et de l’animer.\n\nCe composant étant la base de tous les squelettes de notre application, nous ne pouvons pas directement lui donner une hauteur et une largeur. C’est pour cela que nous lui passons un objet style contenant les informations de sa taille, ainsi que d’autre propriétés comme ses marges ou pourquoi pas une couleur secondaire.\n\nÀ côté de ça nous passons aussi un classname à notre composant. Il correspond à la classe de l’objet remplacé.\nCela nous permet de ne pas avoir à redéfinir complètement le style de notre placeholder.\nAjouté à cela nous avons la feuille de style suivante :\n\n```scss\n// styles.scss\n.skeleton-item {\n    background-color: #D8D8D8;\n    border-color: #D8D8D8;\n    display: inline-block;\n    position: relative;\n    overflow: hidden;\n\n    &::after {\n        content: '';\n        position: absolute;\n        top: -125%;\n        left: -100%;\n        width: 40px;\n        height: 350%;\n        opacity: 0;\n        transform: rotate(45deg);\n        background: rgba(255, 255, 255, 0.20);\n        background: linear-gradient(to right, rgba(255, 255, 255, 0.30) 0%, rgba(255, 255, 255, 0) 100%);\n        animation: shine;\n        animation-duration: 4s;\n        animation-iteration-count: infinite;\n        animation-timing-function: ease-out;\n    }\n}\n\n@keyframes shine {\n    from {\n        opacity: 0.5;\n        left: -100%;\n    }\n\n    to {\n        opacity: 1;\n        left: 200%;\n    }\n}\n```\n\nUne fois notre **SkeletonItem** réalisé voilà à quoi il ressemble une fois une taille donnée :\n\n![](/imgs/posts/2019-10-16-skeleton-screen/skeleton_item.gif)\n\nMaintenant que nous avons créé la base, tel un os, assemblons-en plusieurs afin de créer le squelette d’un composant.\nPour notre exemple, nous allons prendre un élément d’une liste comme celui-ci :\n\n![](/imgs/posts/2019-10-16-skeleton-screen/list_item.png)\n\nVoici son code :\n\n```jsx\n// MovieItem.jsx\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { capitalize, truncate } from \"lodash\";\n\nimport { Grid, Paper, Typography, Button } from \"@material-ui/core\";\n\nimport useStyles from \"./styles\";\n\nconst MovieItem = ({ title, image, date, summary }) => {\n    const classes = useStyles();\n\n    return (\n        <Grid item xs={12} sm={6} md={6}>\n            <Paper className={classes.card}>\n                <img\n                  className={classes.cardMedia}\n                  src={image}\n                  alt={capitalize(title)}\n                />\n                <div className={classes.cardContent}>\n                    <div className={classes.cardDetails}>\n                      <Typography\n                        gutterBottom\n                        component=\"h1\"\n                        className={classes.cardTitle}\n                      >\n                          {capitalize(title)}\n                      </Typography>\n                      <Typography className={classes.textDate}>{date}</Typography>\n                      <Typography className={classes.textSummary}>\n                          {truncate(summary, {\n                            length: 215,\n                            separator: /,? +/\n                          })}\n                      </Typography>\n                    </div>\n                    <Button size=\"small\" className={classes.buttonMore}>\n                      More Info\n                    </Button>\n                </div>\n            </Paper>\n        </Grid>\n    );\n};\n\nMovieItem.propTypes = {\n  date: PropTypes.string,\n  name: PropTypes.string,\n  summary: PropTypes.string,\n  image: PropTypes.string\n};\n\nexport default MovieItem;\n```\n\nPour réaliser sa version **skeleton** nous allons garder la structure HTML et garder uniquement l’image, le titre, et une ligne de description. Pour donner un peu plus de contraste, nous avons donné une couleur plus sombre à notre image.\n\n```jsx\n// MovieItemSkeleton.jsx\nimport React, { useRef } from \"react\";\n\nimport { Grid, Paper } from \"@material-ui/core\";\nimport SkeletonItem from \"../../Skelton/Item\";\n\nimport useStyles from \"./styles\";\n\nconst MovieItemSkeleton = () => {\n    const classes = useStyles();\n    const elementRef = useRef(null);\n\n    return (\n        <Grid item xs={12} sm={6} md={6} ref={elementRef}>\n            <Paper className={classes.card}>\n                <SkeletonItem className={classes.cardMedia} style={{ backgroundColor: \"#8e8e8e\", minWidth: \"185px\" }} />\n                <div className={classes.cardContent}>\n                    <div className={classes.cardDetails}>\n                        <SkeletonItem style={{ height: \"20px\", width: \"150px\" }} />\n                        <SkeletonItem style={{ height: \"18px\", width: \"100%\", marginTop: \"32px\" }} />\n                        <SkeletonItem style={{ height: \"18px\", width: \"50%\", marginTop: \"2px\" }} />\n                    </div>\n                </div>\n            </Paper>\n        </Grid>\n    );\n};\n\nexport default MovieItemSkeleton;\n```\n\nEt voila son rendu final :\n\n![](/imgs/posts/2019-10-16-skeleton-screen/item_skeleton.gif)\n\n## Et Apollo Js là-dedans ?\nC’est beau tout ça, mais comment savoir où et quand afficher nos squelettes ?\nPour cela nous allons utiliser le retour des queries Apollo de notre application.\n(Pour en savoir plus sur apollo et comment le mettre en place, je vous invite à aller voir [cet article](https://blog.eleven-labs.com/fr/commencer-avec-apollojs/)).\nContinuons dans notre exemple avec cette page comprenant une liste d'items récupérée via une Query graphQL :\n\n```jsx\n//MoviesPageList.jsx\nimport React from \"react\";\nimport { fromJS } from \"immutable\";\n\nimport { Query } from \"react-apollo\";\n\nimport MovieListBase from \"../../components/Movie/List\";\nimport { MOVIES } from \"../../graphql/queries\";\n\nconst MovieList = () => (\n  <Query query={MOVIES} variables={{ page: 1 }}>\n    {({ error, data: { movies = {} }, fetchMore, loading }) => {\n      if (error) {\n          return <p>Error :(</p>;\n      }\n\n      if (!movies.items) {\n        return \"\";\n      }\n\n      return <MovieListBase movies={fromJS(movies.items || [])} limit={20} />;\n    }}\n  </Query>\n);\n\nexport default MovieList;\n```\n\nParmi les variables retournées par le composant Query, nous avons la variable **‘loading’**. C’est un booléen qui est vrai tout au long du chargement, pour au final être faux lorsque les données ont fini d’être récupérées.\nAinsi nous pouvons afficher notre squelette dans la condition suivante :\n\n```jsx\n//MoviesPageList.jsx\nimport React from \"react\";\nimport { fromJS } from \"immutable\";\n\nimport { Query } from \"react-apollo\";\n\nimport MovieListBase from \"../../components/Movie/List\";\nimport { MOVIES } from \"../../graphql/queries\";\nimport MovieItemSkeleton from \"../../components/Movie/Item/MovieItemSkeleton\";\n\nconst MovieList = () => (\n  <Query query={MOVIES} variables={{ page: 1 }}>\n    {({ error, data: { movies = {} }, loading }) => {\n      if (error) {\n          return <p>Error :(</p>;\n      }\n\n      if (loading) {\n        return <MovieItemSkeleton />;\n      }\n\n      if (!movies.items) {\n        return \"\";\n      }\n\n      return <MovieListBase movies={fromJS(movies.items)} limit={20} />;\n    }}\n  </Query>\n);\n\nexport default MovieList;\n```\n\nEt le rendu est…\n\n![](/imgs/posts/2019-10-16-skeleton-screen/list_skeleton_fail.gif)\n\nBon... Cet exemple est plutôt adapté à des éléments non répétables, comme par exemple une sidebare (voir l’exemple de LinkedIn).\nNe vous inquiétez pas, je ne vais pas vous laisser là, je vais vous expliquer comment finaliser votre liste.\nIci rien de compliqué, il vous suffit simplement de créer un composant **skeleton** pour votre liste comme ceci :\n\n```jsx\n//MovieListSkeleton.jsx\nimport React from \"react\";\n\nimport { Container, Grid } from \"@material-ui/core\";\n\nimport MovieItemSkeleton from \"../Item/MovieItemSkeleton\";\n\nimport useStyles from \"./styles\";\n\nconst MovieListSeleton = () => {\n  const classes = useStyles();\n\n  return (\n    <Container className={classes.cardGrid} maxWidth=\"md\">\n      <Grid container spacing={4}>\n        {[...Array(4)].map((movie, key) => (\n          <MovieItemSkeleton key={key} />\n        ))}\n      </Grid>\n    </Container>\n  );\n};\n\nexport default MovieListSeleton;\n```\n\nIci, au lieu de boucler sur un tableau de données, je boucle sur un tableau de quatre cases vides (à adapter selon votre design) afin d'afficher quatre fois le squelette créé plus haut.\nLe tout assemblé, regardons à quoi ça ressemble :\n\n```jsx\n//MoviesPageList.jsx\nimport React from \"react\";\nimport { fromJS } from \"immutable\";\n\nimport { Query } from \"react-apollo\";\n\nimport MovieListBase from \"../../components/Movie/List\";\nimport { MOVIES } from \"../../graphql/queries\";\nimport MovieListSkeleton from \"../../components/Movie/List/MovieListSkeleton\";\n\nconst MovieList = () => (\n  <Query query={MOVIES} variables={{ page: 1 }}>\n    {({ error, data: { movies = {} }, loading }) => {\n      if (error) {\n          return <p>Error :(</p>;\n      }\n\n      if (loading) {\n        return <MovieListSkeleton />;\n      }\n\n      if (!movies.items) {\n        return \"\";\n      }\n\n      return <MovieListBase movies={fromJS(movies.items)} limit={20} />;\n    }}\n  </Query>\n);\n\nexport default MovieList;\n```\n\n![](/imgs/posts/2019-10-16-skeleton-screen/list_skeleton.gif)\n\nEn bonus la version de notre liste avec apollo hook :\n\n```jsx\nimport React from \"react\";\nimport { fromJS } from \"immutable\";\n\nimport { useQuery } from '@apollo/react-hooks';\n\nimport MovieListBase from \"../../components/Movie/List\";\nimport { MOVIES } from \"../../graphql/queries\";\nimport MovieListSkeleton from \"../../components/Movie/List/MovieListSkeleton\";\n\nconst MovieList = () => {\n    const {\n        error,\n        data: { movies = {} },\n        loading\n    } = useQuery(MOVIES, { variables: { page: 1 } });\n\n    if (error) {\n        return <p>Error :(</p>;\n    }\n\n    if (loading) {\n        return <MovieListSkeleton />;\n    }\n\n    if (!movies.items) {\n        return \"\";\n    }\n\n    return <MovieListBase movies={fromJS(movies.items)} limit={20} />;\n};\n\nexport default MovieList;\n```\n\n## Conclusion\nComme vous avez pu le constater, la mise en place d’un **skeleton** screen n’est en rien compliquée, et peut rendre l’application plus réactive et dynamique pour vos utilisateurs, qui en ressortiront plus heureux.\nN'hésitez pas à tester plusieurs designs de squelette, en changeant les tailles et les couleurs afin qu’ils correspondent au mieux à votre application.\nSi le sujet vous intéresse, je vous invite à lire l’article de Luke Wroblewski linké plus haut, et je vous donne rendez-vous bientôt pour la fin de mon triptyque sur les conseils d’UX qui vont dynamiser vos applications.\n"}