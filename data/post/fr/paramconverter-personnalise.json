{"date":"2016-08-09T00:00:00.000Z","title":"ParamConverter personnalisé","excerpt":"L'article qui suit s'adresse aux développeurs qui ont déjà utilisé le ParamConverter, et qui comprennent le principe de base de son fonctionnement.","readingTime":"4mn","authors":["tthuon"],"categories":["php"],"content":"\nIntroduction\n============\n\nL'article qui suit s'adresse aux développeurs qui ont déjà utilisé le ParamConverter, et qui comprennent le principe de base de son fonctionnement.\n\nJe l'ai rédigé pour expliquer comment résoudre la problématique suivante : mon besoin était de faire passer un token dans un header personnalisé, et de pouvoir le récupérer dans les contrôleurs. Le but était d'éviter de répéter l'acquisition de ce header dans chacun des contrôleurs.\n\nFonctionnement de base\n======================\n\nLe ParamConverter est un outil magique. Depuis un contrôleur, il suffit de typehinter l'argument pour obtenir une instance d'une classe en fonction de l'id dans l'url.\n\n```php\n<?php\n\n/**\n * @Route(\"/post/{post}\")\n */\npublic function getAction(Post $post)\n{\n    return new Response($post->getTitle());\n}\n```\n\nDans mon exemple, Symfony a reconnu le token *post* dans la route. Dans la signature de la méthode, l'argument *$post* est typehinté par la classe *Post*. Symfony, à l'aide du ParamConverter, va tenter de créer une instance de la classe *Post* et l'affecter à la variable *$post*.\n\nJe vous renvoie à la documentation pour le fonctionnement de base du ParamConverter : <http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html>\n\nMais si la valeur que je cherche ne se trouve pas dans l'url, par exemple dans un header, comment faire ?\n\nUn token dans un header\n=======================\n\nPrenons un autre exemple:\n\n```php\n<?php\n\n/**\n * @Route(\"/token\")\n */\npublic function isTokenValidAction($token)\n{\n    return $this->get('app.service')->isValid($token);\n}\n```\n\nLa valeur de mon token doit passer par un header *x-token*. Je vais donc créer un ParamConverter pour aller chercher le token dans le header et non dans l'url.\n\nCréation du ParamConverter\n==========================\n\nTous les ParamConverter doivent implémenter l'interface `Sensio\\Bundle\\FrameworkExtraBundle\\Request\\ParamConverter\\ParamConverterInterface`.\n\nIl y a les méthodes `apply(Request $request, ConfigurationInterface $configuration)`;  et `supports(ConfigurationInterface $configuration);`.\n\n-   supports* vérifie que le ParamConveter peut s'appliquer avec les données fournies dans *$configuration*. Il renvoie  `true` si tout est bon, sinon `false`. Le ParamConverter passe à un autre converter dans ce cas. Il est possible de trier les ParamConverter par priorité.\n-   `apply` va appliquer une règle métier. Dans notre cas, il faudra aller chercher le token dans la requête et replacer la valeur dans l'*attributes* de la requête.\n\nExemple de structure :\n\n```php\n<?php\n\nnamespace AppBundle\\Request\\ParamConverter;\n\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\ConfigurationInterface;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\ParamConverter;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Request\\ParamConverter\\ParamConverterInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass TokenConverter implements ParamConverterInterface\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function apply(Request $request, ConfigurationInterface $configuration)\n    {\n\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supports(ConfigurationInterface $configuration)\n    {\n\n    }\n}\n```\n\nJe commence par la méthode *supports.* Ici, je n'ai pas de classe de référence. Je vais me baser sur le nom de la variable.\n\n```php\npublic function supports(ConfigurationInterface $configuration)\n{\n    return $configuration->getName() === \"token\";\n}\n```\n\nLa méthode doit renvoyer `true` ou `false`.\n\nEnsuite, je remplis la méthode *apply*. C'est ici que je vais chercher la valeur de mon token. Comme j'ai accès à la requête courante, je peux faire comme ceci:\n\n```php\npublic function apply(Request $request, ConfigurationInterface $configuration)\n{\n    $request->attributes->set($configuration->getName(), $request->headers->get('x-token'));\n\n    return true;\n}\n```\n\nLors de la construction du contrôleur, Symfony va chercher toutes les valeurs des arguments du contrôleur dans la variable *attributes* de la requête. C'est pourquoi, j'affecte la valeur de mon token dans la variable *attributes* grâce au méthode du *ParameterBag*.\n\nMon  `ParamConverter` personnalisé est terminé. Je vais maintenant l'utiliser.\n\nDéclaration du service\n======================\n\nUn *compiler pass* va lire les services avec le tag \"request.param\\_converter\". Je peux définir une priorité et un nom. S'il y a une priorité, ils seront triés dans cet ordre.\n\n```xml\n<service id=\"token_converter\" class=\"AppBundle\\Request\\ParamConverter\\CrmTokenConverter\">\n    <tag name=\"request.param_converter\" converter=\"token\" />\n</service>\n```\n\nUtilisation dans le contrôleur\n==============================\n\nPour l'utiliser dans mon contrôleur, j'ajoute l'annotation *ParamConverter* à mon contrôleur avec les options *name* et le nom de converter renseigné dans le service.\n\n```php\n<?php\n\n/**\n * @Route(\"/token\")\n * @ParamConverter(name=\"token\", converter=\"token\")\n */\npublic function isTokenValidAction($token)\n{\n    return $this->get('app.service')->isValid($token);\n}\n```\n\nLorsque je fais ma requête et que je mets une valeur pour le header \"x-token\", ma variable \"$token\" aura la valeur du header.\n\nVoilà comment simplifier le contrôleur et isoler une fonctionnalité dans une classe unitaire.\n\nRéférence:\n\n-   <http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html#creating-a-converter>\n-   <http://api.symfony.com/3.1/Symfony/Component/HttpKernel/Controller/ControllerResolver.html>\n-   <http://api.symfony.com/2.8/Symfony/Component/HttpFoundation/Request.html>\n-   <http://api.symfony.com/2.8/Symfony/Component/HttpFoundation/ParameterBag.html>\n"}