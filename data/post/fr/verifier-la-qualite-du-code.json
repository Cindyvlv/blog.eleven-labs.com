{"date":"2016-01-26T00:00:00.000Z","title":"Vérifier la qualité du code","excerpt":"Aujourd'hui je vais vous parler de la qualité du code (oh really?). Dans cet article, je vais l'aborder sur la partie PHP.","readingTime":"11mn","authors":["tthuon"],"categories":["php","architecture"],"content":"\nAujourd'hui je vais vous parler de la qualité du code (oh really?). Dans cet article, je vais l'aborder sur la partie PHP.\n\nQu'est ce que la qualité du code ?\n==================================\n\nEn PHP, nous pouvons définir la qualité du code par certaines métriques, telles que la couverture des tests ou l'usage des normes PSR. Le but est d'avoir un code compréhensible par tous les développeurs et facilement maintenable.\n\nTout au long de cet article, je vais aborder les points suivants :\n\n-   les normes PSR\n-   la détection des erreurs\n-   l'automatisation de la correction du code\n-   l'intégration continue\n-   le service sass\n\nPSR, késako ?\n=============\n\nPSR, pour *PHP Standard Recommendation,* est un ensemble de normes pour PHP qui permet de faciliter l'interopérabilité des composants entre eux.\n\nElles sont éditées par le php-fig : *PHP Framework Interoperability Groupement*. C'est un groupement de personnes qui travaillent autour de ces recommandations. Tout le monde peut faire partie de ce groupement. Mais seuls certains membres avec le droit de vote peuvent voter sur les nouvelles recommandations. Les membres votants sont généralement des représentants de projets tels que Doctrine, Composer ou Symfony.\n\nIl y a actuellement 7 normes validées :\n\n-   PSR-4 est la norme pour l'auto chargement des classes. PSR-1 étant déprécié.\n-   PSR-1 et PSR-2 vont se concentrer sur la forme du code\n-   PSR-3 est pour la mise en forme de log.\n-   PSR-6 pour la mise en cache d'objets (Redis, memcached)\n-   PSR-7 pour les requêtes/réponses HTTP\n\nToutes ces normes vont permettre de bien structurer le code, d'avoir les mêmes interfaces, et de permettre aux autres développeurs de contribuer plus facilement.\n\nDétection des erreurs\n=====================\n\nAvec toutes ces normes et recommandations, nous avons une bonne base solide. Apprendre et bien connaître ces recommandations peut prendre du temps. Pour cela, il y a des outils pour nous permettre de détecter les erreurs que nous faisons.\n\n### Erreur de style\n\nPour PSR-1 et PSR-2, il y a [PHP Code Sniffer](https://github.com/squizlabs/PHP_CodeSniffer \"Github.com PHP Code Sniffer\"){:rel=\"nofollow noreferrer\"}. Cet outil va se baser sur un ensemble de règles, parcourir le code et afficher toutes les erreurs. Les règles peuvent être enrichies selon les spécificités du framework.\n\nAvec Symfony, il y a cet ensemble de règles : https://github.com/instaclick/Symfony2-coding-standard\n\nExemple d'exécution de la commande phpcs :\n\n```php\nphp bin/phpcs --report=checkstyle --standard=vendor/instaclick/symfony2-coding-standard/Symfony2/ruleset.xml --extensions=php --ignore=Tests,DataFixtures,DoctrineMigrations src/\n```\n\nLa sortie va être un xml:\n\n```xhtml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<checkstyle version=\"1.5.5\">\n<file name=\"../Service/AvailableTimeService.php\">\n <error line=\"28\" column=\"12\" severity=\"error\" message=\"Method name &quot;AvailableTimeService::transform_To_NewValue&quot; is not in camel caps format\" source=\"PSR1.Methods.CamelCapsMethodName.NotCamelCaps\"/>\n</file>\n</checkstyle>\n```\n\nDans cet exemple, le fichier \"AvailableTimeService\" contient une erreur. Cet erreur se situe à la ligne 28 et colonne 12. Le message d'erreur indique que le nom de la méthode n'est pas en camelCase. Or, selon PSR-1, [les méthodes doivent être écrites en camelCase](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md#1-overview){:rel=\"nofollow noreferrer\"}.\n\nLors du premier lancement de la commande, il peut y avoir beaucoup d'erreurs. Au fur et à mesure, ces erreurs se réduisent et vous connaîtrez par coeur ces règles :D .\n\n### Consistance du code\n\n[PHP Mess Detector](https://github.com/phpmd/phpmd \"Github.com PHP Mess Detector\") permet de détecter tout ce qui fait un bon \"*code spaghetti*\". D'où le nom de *mess detector* (littéralement 'détecteur de bordel'). Cet outil va se baser sur des règles telles que la[complexité cyclomatique](http://www-igm.univ-mlv.fr/~dr/XPOSE2008/Mesure%20de%20la%20qualite%20du%20code%20source%20-%20Algorithmes%20et%20outils/complexite-cyclomatique.html){:rel=\"nofollow noreferrer\"} du code, le nombre de conditions dans une méthode, etc...\n\nCet outil va nous aider à rendre le code beaucoup plus simple, lisible et d'éviter les répétitions ou des méthodes à rallonge.\n\nExemple :\n\n```sh\nphp bin/phpmd src/ xml app/phpmd.xml --exclude Tests,DataFixtures,DoctrineMigrations,Test\n```\n\nSortie de la commande :\n\n```html\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<pmd version=\"@project.version@\" timestamp=\"2016-01-21T13:40:01+01:00\">\n  <file name=\"../Service/AvailableTimeService.php\">\n    <violation beginline=\"28\" endline=\"61\" rule=\"CyclomaticComplexity\" ruleset=\"Code Size Rules\" package=\"MyVendor\\Bundle\\AppBundle\\Service\" externalInfoUrl=\"http://phpmd.org/rules/codesize.html#cyclomaticcomplexity\" class=\"AvailableTimeService\" method=\"transformToNewValue\" priority=\"3\">\n      The method transformToNewValue() has a Cyclomatic Complexity of 11. The configured cyclomatic complexity threshold is 10.\n    </violation>\n    <violation beginline=\"28\" endline=\"61\" rule=\"NPathComplexity\" ruleset=\"Code Size Rules\" package=\"MyVendor\\Bundle\\AppBundle\\Service\" externalInfoUrl=\"http://phpmd.org/rules/codesize.html#npathcomplexity\" class=\"AvailableTimeService\" method=\"transformToNewValue\" priority=\"3\">\n      The method transformToNewValue() has an NPath complexity of 243. The configured NPath complexity threshold is 200.\n    </violation>\n  </file>\n</pmd>\n```\n\nPour comprendre ces erreurs, affichons un bout de code :\n\n```php\n<?php\n\nnamespace MyVendor\\Bundle\\AppBundle\\Service;\n\n/**\n * Service to transform old value to new value and reverse\n *\n * @package MyVendor\\Bundle\\AppBundle\\Service\n */\nclass AvailableTimeService\n{\n    /**\n     * @var array\n     */\n    private $mappingTime = [\n        \"5\" => \"5\",\n        \"10\" => \"15\",\n        \"15\" => \"15\",\n        \"20\" => \"15\",\n        \"plus\" => \"plus\",\n    ];\n\n    /**\n     * @param string $value\n     *\n     * @return string\n     */\n    public function transformToNewValue($value)\n    {\n        if ($value === \"5\") {\n            if ($this->mappingTime[\"5\"]) {\n                return $this->mappingTime[\"5\"];\n            }\n        }\n\n        if ($value === \"15\") {\n            if ($this->mappingTime[\"15\"]) {\n                return $this->mappingTime[\"15\"];\n            }\n        }\n\n        if ($value === \"10\") {\n            if ($this->mappingTime[\"10\"]) {\n                return $this->mappingTime[\"10\"];\n            }\n        }\n\n        if ($value === \"20\") {\n            if ($this->mappingTime[\"20\"]) {\n                return $this->mappingTime[\"20\"];\n            }\n        }\n\n        if ($value === \"plus\") {\n            if ($this->mappingTime[\"plus\"]) {\n                return $this->mappingTime[\"plus\"];\n            }\n        }\n\n        return $value;\n    }\n}\n```\n\n*Le code de cet article étant purement fictif, toute ressemblance avec du code existant ou ayant existé ne saurait être que fortuite.* ( :p on ne sait jamais)\n\nÇa fonctionne, mais il est possible de faire mieux. Les alertes retournées par PHPMD indique une complexité cyclomatique importante ainsi qu'une complexité sur le NPath. En clair, c'est complexe et il y a beaucoup de chemins possibles à cause des nombreux \"if\".\n\nAu final, il est possible de réduire le code plus simplement :\n\n```php\n<?php\n\nnamespace MyVendor\\Bundle\\AppBundle\\Service;\n\n/**\n * Service to transform old value to new value and reverse\n *\n * @package MyVendor\\Bundle\\AppBundle\\Service\n */\nclass AvailableTimeService\n{\n    /**\n     * @var array\n     */\n    private $mappingTime = [\n        \"5\" => \"5\",\n        \"10\" => \"15\",\n        \"15\" => \"15\",\n        \"20\" => \"15\",\n        \"plus\" => \"plus\",\n    ];\n\n    /**\n     * @param string $value\n     *\n     * @return string\n     */\n    public function transformToNewValue($value)\n    {\n        if (isset($this->mappingTime[$value])) {\n            $value = $this->mappingTime[$value];\n        }\n\n        return $value;\n    }\n}\n```\n\nBien entendu, la refactorisation de code s'accompagne de tests unitaires afin d'assurer la fiabilité et la stabilité de cette partie.\n\n### La tentation du copier/coller\n\n\"*pff j'ai la flemme de mutualiser ce code, je vais juste le copier coller ici*\"\n\nCombien de fois avez-vous entendu cette phrase ? Et puis le jour où le fonctionnel change, nous oublions et ça fait des choses bizarres.\n\nPour ne pas entrer dans cette mauvaise pratique, il y a [PHP Copy/Paste Detector](https://github.com/sebastianbergmann/phpcpd \"Github PHP CPD\"){:rel=\"nofollow noreferrer\"}. Il détecte les parties de codes qui ont été dupliquées.\n\nPetit exemple :\n\n```sh\nphpcpd src/\n```\n\nEn sortie, la liste des fichiers avec les lignes dupliquées :\n\n```\nphpcpd 2.0.1 by Sebastian Bergmann.\n\nFound 1 exact clones with 81 duplicated lines in 2 files:\n\n  - src/MyVendor/Bundle/AppBundle/Manager/MyManager.php:13-94\n    src/MyVendor/Bundle/AppBundle/Manager/PastedManager.php:13-94\n\n0.25% duplicated lines out of 32388 total lines of code.\n\nTime: 2.21 seconds, Memory: 20.00Mb\n```\n\nLa sortie indique que les fichiers \"MyManager\" et \"PastedManger\" contiennent des lignes dupliquées. L'action à faire est de refactoriser en créant une classe abstraire, par exemple.\n\n### Corriger en un éclair\n\nUne fois les erreurs détectées, il faut les corriger. Personnellement, je n'utilise pas d'outils pour corriger les erreurs de manière automatique. Je me force à apprendre les règles pour que ça deviennent un automatisme.\n\n[PHP CS Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer \"Github PHP CS Fixer\"){:rel=\"nofollow noreferrer\"} va permettre de corriger toutes les erreurs de formatage du code de manière automatisée. Il s'intéresse aux recommandations PSR-1 et PSR-2.\n\n    php bin/php-cs-fixer src/\n\nL'outil va parcourir tout le code et corriger les erreurs. Simple, n'est-ce pas ?\n\nIntégration continue\n====================\n\nTous ces outils, une fois en place, permettent de surveiller et de maintenir la qualité du code. Lancer régulièrement ces commandes doit être une exigence à adopter.\n\nAvec Jenkins, il est possible de lancer ces commandes de manière automatisée. Il suffit de créer un \"job\" et de le programmer. Chacune des commandes abordées dans cet article permettent de produire un rapport au format jUnit.\n\n![rapport jenkins](/imgs/posts/2016-01-26-verifier-la-qualite-du-code/Capture-decran-2016-01-25-a-21.35.56.png)\n\n### SonarQube\n\nPour ceux qui n'ont pas envie d'ajouter chaque outil séparément et de mettre un place un serveur Jenkins, il y a SonarQube.\n\n[SonarQube](http://www.sonarqube.org/){:rel=\"nofollow noreferrer\"} est un projet libre de droit qui permet de vérifier et contrôler la qualité du code. C'est une solution tout-en-un.\n\n### SensioLab Insight\n\n[SensioLab Insight](https://insight.sensiolabs.com/){:rel=\"nofollow noreferrer\"} est un service en SASS. Principalement orienté vers Symfony 2, il s'adapte également au projet PHP sans framework.\n\nCe service va analyser votre code et vous indiquer les faiblesses du code. Un des points intéressants est le temps estimé pour le corriger.\n\n### Blackfire.io\n\nEncore un autre outil Sensio, mais très efficace dans l'analyse des performances d'une application. [Blackfire.io](https://blackfire.io/){:rel=\"nofollow noreferrer\"} va permettre de cibler les points faibles : consommation mémoire, CPU, disque et réseau.\n\nCet outil s'utilise principalement pour le débogage, notamment lorsqu'une route met du temps à répondre.\n\nPour conclure\n=============\n\nTout au long de cet article, nous avons vu les normes et recommandations en PHP, comment détecter les erreurs que nous pouvons faire, et enfin comment les corriger.\n\nAvoir une bonne qualité de code et les mêmes conventions de code permet d'avoir un projet solide et compréhensible par tous les développeurs. C'est la base pour la réussite d'un projet. Ainsi, le projet s'adaptera plus facilement au changement de fonctionnalités.\n\nEn complément, nous avons abordé l'utilisation de ces outils dans un flux d'intégration continue avec Jenkins et SonarQube.\n\nEnfin, des outils en SASS efficaces permettent de déboguer facilement et d'avoir des indicateurs enrichis.\n"}