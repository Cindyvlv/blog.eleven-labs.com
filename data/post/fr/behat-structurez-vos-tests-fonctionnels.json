{"date":"2016-07-19T00:00:00.000Z","title":"Behat : structurez vos tests fonctionnels","excerpt":"Il est important de mettre en place des tests fonctionnels sur les projets afin de s'assurer du bon fonctionnement de l'application.","readingTime":"12mn","authors":["vcomposieux"],"categories":["php"],"content":"Il est important de mettre en place des tests fonctionnels sur les projets afin de s'assurer du bon fonctionnement de l'application.\n\nLorsqu'il s'agit d'une application Symfony, Behat est l'outil le plus souvent utilisé pour réaliser ces tests et c'est tant mieux car cet outil est très complet.\n\nIl faut néanmoins savoir l'utiliser à bon escient afin de couvrir des cas de tests utiles et complets, c'est ce que nous allons voir dans cet article.\n\n# Introduction\n\n## Tests fonctionnels : qu'est-ce ?\n\nLorsque nous parlons de \"tests fonctionnels\", nous entendons bien souvent vouloir tester l'interface de l'application (site web), autrement dit, automatiser des tests qui pourraient être faits par un humain.\n\nOr, il est important d'écrire les cas de tests suivants afin de couvrir le périmètre fonctionnel :\n* `tests d'interface` : il s'agit de réaliser des contrôles d'interface pour s'assurer que le comportement de l'application web réagit correctement,\n* Les `tests d'intégration` : il s'agit de s'assurer que le code (testé unitairement) qui fait tourner l'application réagit bien comme il le devrait lorsque tous les éléments sont assemblés.\n\nIl conviendra alors de lancer à la fois les tests d'intégration et les tests d'interface avec Behat.\n\nAvant de commencer, notez que dans cet exemple, nous allons utiliser un serveur `Selenium` qui recevra les informations fournies par `Mink` (extension de Behat) et qui pilotera ensuite notre navigateur (Chrome, dans notre configuration).n\nPour être clair sur l'architecture, voici un schéma qui résume le rôle de chacun :\n\n![Diagram](/imgs/posts/2016-07-19-behat-structure-functional-tests/diagram.jpg)\n\n# Mise en place de Behat\n\nLa première étape est d'installer Behat et ses extensions en tant que dépendance dans notre fichier `composer.json` :\n\n\n```json\n\"require-dev\": {\n    \"behat/behat\": \"~3.1\",\n    \"behat/symfony2-extension\": \"~2.1\",\n    \"behat/mink\": \"~1.7\",\n    \"behat/mink-extension\": \"~2.2\",\n    \"behat/mink-selenium2-driver\": \"~1.3\",\n    \"emuse/behat-html-formatter\": \"dev-master\"\n}\n```\n\n\nAfin que vos futurs contextes soient autoloadés, nous allons également ajouter la section `PSR-4` suivante :\n\n\n```json\n\"autoload-dev\": {\n    \"psr-4\": {\n        \"Acme\\Tests\\Behat\\Context\\\": \"features/context/\"\n    }\n}\n```\n\n\nMaintenant, créons le fichier de configuration `behat.yml` à la racine de notre projet afin d'architecturer nos tests.\n\nVoici le fichier de configuration à partir duquel nous allons débuter :\n\n\n```json\n<pre class=\"theme:github lang:yaml decode:true\">nndefault:\n    suites: ~\n    extensions:\n        Behat\\Symfony2Extension: ~\n        Behat\\MinkExtension:\n            base_url: \"http://acme.tld/\"\n            selenium2:\n                browser: chrome\n                wd_host: 'http://selenium-host:4444/wd/hub'\n            default_session: selenium2\n        emuse\\BehatHTMLFormatter\\BehatHTMLFormatterExtension:\n            name: html\n            renderer: Twig,Behat2\n            file_name: index\n            print_args: true\n            print_outp: true\n            loop_break: true\n    formatters:\n        pretty: ~\n        html:\n            output_path: %paths.base%/web/reports/behat\n```\n\n\nSi nous prenons les sections dans leur ordre, nous avons avant tout une section `suites` pour le moment vide mais que nous allons alimenter par la suite de cet article.\n\nEnsuite, nous chargeons ici plusieurs extensions de Behat :\n\n* L'extension `Behat\\Symfony2Extension` permettant notamment d'injecter des services Symfony dans nos classes contextes de test,\n* L'extension `Behat\\MinkExtension` qui va nous permettre de piloter notre Selenium (qui pilotera lui-même notre navigateur Chrome), nous lui fournissons donc les informations nécessaires tels que le host et port du serveur Selenium ainsi que la base de l'URL à contacter,\n* L'extension `emuse\\BehatHTMLFormatter\\BehatHTMLFormatterExtension` qui nous permettra de générer un rapport HTML lors du lancement des tests (toujours sympa à présenter au client).\n\nNotons enfin que dans la section **formatters**, nous conservons le formatter **pretty** afin d'avoir une sortie sympa sur notre terminal et que les rapports HTML seront quant à eux générés dans le répertoire `web/reports/behat` afin qu'ils soient accessibles en HTTP (à priori pas de soucis car vous ne devriez pas jouer ces tests en production, attention à la restriction d'accès si c'est le cas).\n\nMaintenant que Behat est prêt et configuré, nous allons préparer nos tests fonctionnels que nous allons découper en deux \"suites\" Behat distinctes : `integration` et `interface`.\n\n# Ecriture des tests fonctionnels (features)\n\nNous allons partir sur des tests permettant de s'assurer du bon fonctionnement d'une page d'inscription.\n\nNous devons avant tout écrire nos scénarios de tests fonctionnels (fichier **.feature**) que nous allons placer dans un répertoire **features/** à la racine du projet.\n\nNous allons donc avoir, par exemple, le scénario suivant :\n\nFichier : `features/registration/register.feature` :\n\n```\nFeature: Register\n    In order to create an account\n    As a user\n    I want to be able to register on the application\n\nScenario: I register when I fill my username and password only\n    Given I am on the registration page\n        And I register with username \"johndoe\" and password \"azerty123\"\n    When I submit the form\n    Then I should see the registration confirmation\n```\n\n\n## Tests d'intégration\n\nIl va maintenant convenir d'implémenter le code qui va nous permettre de tester que le code écrit pour l'inscription d'un utilisateur peut être exécuté et enchaîné sans erreur.\n\nNous allons donc créer un contexte d'intégration propre à l'inscription sous le répertoire `features/context/registration` :\n\nFichier : `features/context/registration/IntegrationRegisterContext` :\n\n\n```php\n<?php\n\nnamespace Acme\\Tests\\Behat\\Context\\Registration;\n\nuse Acme\\AppBundle\\Entity\\User;\nuse Acme\\AppBundle\\Registration\\Registerer;\nuse Behat\\Behat\\Context\\Context;\n\n/**\n * Integration register context.\n */\nclass IntegrationRegisterContext implements Context\n{\n    /**\n     * Registerer\n     */\n    protected $registerer;\n\n    /**\n     * User\n     */\n    protected $user;\n\n    /**\n     * boolean\n     */\n    protected $response;\n\n    /**\n     * Constructor.\n     *\n     * @param Registerer $registerer\n     */\n    public function __construct(Registerer $registerer)\n    {\n        $this->registerer = $registerer;\n    }\n\n    /**\n     * @Given I am on the registration page\n     */\n    public function iAmOnTheRegistrationPage()\n    {\n        $this->user = new User();\n    }\n\n    /**\n     * @Given /I register with username \"(?P<username>[^\"]*)\" and password \"(?P<password>[^\"]*)\"/\n     */\n    public function iRegisterWithUsernameAndPassword($username, $password)\n    {\n        $this->user->setUsername($username);\n        $this->user->setPassword($password);\n    }\n\n    /**\n     * @When I submit the form\n     */\n    public function iSubmitTheForm()\n    {\n        $this->response = $this->registerer->register($this->user);\n    }\n\n    /**\n     * @Then I should see the registration confirmation message\n     */\n    public function iShouldSeeTheRegistrationConfirmation()\n    {\n        if (!$this->response) {\n            throw new \\RuntimeException('User is not registered.');\n        }\n    }\n}\n```\n\n\nL'implémentation du test d'intégration est terminé pour cette feature !\nPassons maintenant au test d'interface !\n\n## Tests d'interface\n\nCe test va se baser sur la même feature et nous n'avons absolument rien modifié dans le test précédemment écrit. C'est pourquoi il est important de bien rédiger ses tests fonctionnels afin qu'ils restent assez génériques pour être implémentés à la fois en test d'intégration et en test d'interface.\n\nCréons donc le contexte qui sera utilisé pour le test d'interface (préfixé par Mink dans notre cas, mais vous pouvez préfixer par ce que vous voulez) sous le même répertoire `features/context/registration` :\n\nFichier : `features/context/registration/MinkRegisterContext` :\n\n\n```php\n<?php\n\nnamespace Acme\\Tests\\Behat\\Context\\Registration;\n\nuse Acme\\AppBundle\\Entity\\User;\nuse Acme\\AppBundle\\Registration\\Registerer;\nuse Behat\\Behat\\Context\\Context;\nuse Behat\\MinkExtension\\Context\\MinkContext;\n\n/**\n * Mink register context.\n */\nclass MinkRegisterContext extends MinkContext\n{\n    /**\n     * @Given I am on the registration page\n     */\n    public function iAmOnTheRegistrationPage()\n    {\n        $this->visit('/register');\n    }\n\n    /**\n     * @Given /I register with username \"(?P<username>[^\"]*)\" and password \"(?P<password>[^\"]*)\"/\n     */\n    public function iRegisterWithUsernameAndPassword($username, $password)\n    {\n        $this->fillField('registration[username]', $username);\n        $this->fillField('registration[password]', $password);\n    }\n\n    /**\n     * @When I submit the form\n     */\n    public function iSubmitTheForm()\n    {\n        $this->pressButton('Register');\n    }\n\n    /**\n     * @Then I should see the registration confirmation message\n     */\n    public function iShouldSeeTheRegistrationConfirmation()\n    {\n        $this->assertPageContainsText('Congratulations, you are now registered!');\n    }\n}\n```\n\n\nNous venons d'implémenter un test d'interface basé sur le même scénario que celui que nous avons utilisé pour notre test d'intégration, reprenant exactement les quatre méthodes implémentées précédemment avec les mêmes annotations Behat.\n\nLa seule différence est que dans ce contexte, Mink va demander à Selenium d'effectuer les actions au niveau de l'interface de notre application en pilotant un navigateur au lieu de tester le code lui-même.\n\n# Définitions des contextes\n\nIl ne nous reste plus qu'à ajouter les contextes créés précédemment sous notre section **suites** dans le fichier de configuration `behat.yml` :\n\n\n```yaml\n    suites:\n        integration:\n            paths:\n                - %paths.base%/features/registration\n            contexts:\n                - Acme\\Tests\\Behat\\Context\\Registration\\IntegrationRegisterContext:\n                    - \"@acme.registration.registerer\"\n        interface:\n            paths:\n                - %paths.base%/features/registration\n            contexts:\n                - Behat\\MinkExtension\\Context\\MinkContext: []\n                - Acme\\Tests\\Behat\\Context\\Registration\\MinkRegisterContext: []\n```\n\n\nIl est important de voir ici que nous découpons clairement les tests en deux suites distinctes : `integration` et `interface` : chacune d'entre elles sera exécutée avec les contextes qui lui sont propres.\n\nEtant donné que nous avons chargés l'extension Symfony2 lors de la mise en place de Behat, nous avons la possibilité d'injecter des services Symfony dans nos contextes, c'est le cas ici avec le service `acme.registration.registerer`.\n\n# Exécution des tests\n\nPour lancer tous les tests, exécutez simplement, à la racine du projet : `bin/behat -c behat.yml`.\nPour lancer uniquement la suite d'integration, par exemple : `bin/behat -c behat.yml --suite=integration`.\n\nLe rapport HTML est quand à lui généré dans `web/reports/behat/`, comme spécifié dans notre configuration, ce qui vous permettra d'avoir un aperçu rapide des tests qui échouent, plutôt pratique lorsque vous avez de nombreux tests.\n\n# Lier plusieurs contextes entre eux**\n\nPour terminer, vous pourrez parfois avoir besoin de lier les contextes entre eux. Par exemple, imaginons que vous ayez une deuxième page sur votre formulaire d'inscription pour renseigner les informations personnelles, vous allez alors créer deux nouveaux contextes **IntegrationProfileContext** et `MinkProfileContext`.\n\nPartons sur le contexte d'intégration pour simplifier l'explication, l'idée est de ne pas dupliquer le code précédemment créé et permettant de tester la première étape `IntegrationRegisterContext` et de réutiliser ces informations dans le nouveau contexte `IntegrationProfileContext`.\n\nCeci est possible grâce à l'annotation `@BeforeScenario` de Behat.\n\nFichier : `features/context/registration/IntegrationProfileContext` :\n\n\n```php\n<?php\n\nnamespace Acme\\Tests\\Behat\\Context\\Registration;\n\nuse Behat\\Behat\\Context\\Context;\nuse Behat\\Behat\\Hook\\Scope\\BeforeScenarioScope;\n\n/**\n * Integration registration profile  context.\n */\nclass IntegrationProfileContext implements Context\n{\n    /**\n     * IntegrationRegisterContext\n     */\n    protected $registerContext;\n\n    /**\n     * @BeforeScenario\n     */\n    public function gatherContexts(BeforeScenarioScope $scope)\n    {\n        $environment = $scope->getEnvironment();\n\n        $this->registerContext = $environment->getContext(\n            'Acme\\Tests\\Behat\\Context\\Registration\\IntegrationRegisterContext'\n        );\n    }\n}\n```\n\n\nVous avez maintenant à disposition une propriété `$registerContext` et pouvez accéder à des informations qui proviennent du contexte précédent.\n\n# Conclusion\n\nTout part de l'écriture des tests fonctionnels qui doivent être bien réfléchis pour ensuite permettre une implémentation technique à la fois en test d'intégration mais aussi en test d'interface.\n\nLa structure choisie pour classer ses tests fonctionnels est aussi importante pour pouvoir s'y retrouver rapidement dans les différents scénarios de test lorsque l'application prend de l'ampleur.\n"}