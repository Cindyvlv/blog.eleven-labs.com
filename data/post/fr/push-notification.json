{"date":"2017-12-19T00:00:00.000Z","title":"Recevez nos push notifications","excerpt":"Notre retour d'expérience sur la mise en place des push notifications","readingTime":"10mn","authors":["captainjojo"],"categories":["javascript"],"content":"\nParce que nous voulons toujours améliorer notre blog, et parce que ce dernier est la vitrine de notre expertise technique, aujourd'hui nous avons mis en place les notifications.\n\n> Mais à quoi cela sert-il ?\n\nCela sert à savoir quand un nouvel article est en ligne. Si vous acceptez les notifications, vous pourrez être averti même sur votre téléphone (sauf Iphone car pas encore disponible chez Apple).\n\nVoyons ensemble comment nous nous y sommes pris.\n\n## Etape 1 : le service worker\n\nTout d'abord, nous avons mis en place un service worker. Le service worker est un script Javascript qui tourne directement sur votre navigateur sans que le site soit activé. Pour plus d'explications, vous pouvez lire ce super document [ici](https://developers.google.com/web/fundamentals/primers/service-workers/){:rel=\"nofollow noreferrer\"}.\n\nLe service worker est la base pour faire de votre site une [PWA](https://developers.google.com/web/progressive-web-apps/){:rel=\"nofollow noreferrer\"}.  Tout d'abord cela nous permet d'avoir le site offline (d'ailleurs testé dès maintenant).\n\nPour cela, lors de la première visite sur le site, le service worker s'enregistre et met en cache les assets et les pages d'articles.\n\nVous pouvez voir cela directement dans votre console de développement dans l'onglet `application`.\n\n![Console Chrome]({{site.baseurl}}/assets/2017-12-19-push-notification/image1.png)\n\nLa mise en place d'un service worker est assez simple. Il faut dire au navigateur compatible avec les service workers où se dernier se trouve. Voici la liste des navigateurs actuellement compatibles ([CanIUse](https://caniuse.com/#search=service%20workers){:rel=\"nofollow noreferrer\"}).\n\n![Can I Use]({{site.baseurl}}/assets/2017-12-19-push-notification/image2.png)\n\nVous devez avoir un fichier contenant l'enregistrement du service workers.\n\n```js\nif (navigator.serviceWorker) {\n    const swPath = (window.site && window.site.sw) || '/sw.js';\n    navigator.serviceWorker.register(swPath).then((reg) => {\n      if (!reg.installing) {\n        return;\n      }\n\n      console.log(\"[*] ServiceWorker is installing...\");\n      const worker = reg.installing;\n\n      worker.addEventListener('statechange', () => {\n        if (worker.state == 'redundant') {\n          console.log('[*] ServiceWorker Install failed');\n        }\n        if (worker.state == 'installed') {\n          console.log('[*] ServiceWorker Install successful!');\n        }\n\n        if (worker.state == 'activated' && !navigator.serviceWorker.controller) {\n          // VOTRE CODE SI LE SERVICE WORKERS EST ACTIVÉ\n        }\n      });\n\n    });\n  }\n```\n\nPuis le service workers permettant d'avoir une site offline ressemble a cela :\n\n```js\nconst CACHE_NAME_PREFIX = 'PREFIX DU CACHE-cache-';\n  const CACHE_NAME = `NOM DU CACHE`;\n\n  const filesToCache = [\n    // LISTE DES FICHIERS A CACHER\n  ];\n\n\nself.addEventListener('install', (e) => {\n    self.skipWaiting();\n    e.waitUntil(caches\n      .open(CACHE_NAME)\n      .then(cache => Promise.all(filesToCache.map(file => cache.add(file))))\n    );\n  });\n\n  self.addEventListener('activate', (e) => {\n    e.waitUntil(caches\n      .keys()\n      .then(cacheNames => Promise.all(cacheNames\n        .filter(cacheName => cacheName.startsWith(CACHE_NAME_PREFIX) && cacheName !== CACHE_NAME)\n        .map(cacheName => caches.delete(cacheName))\n      ))\n    );\n  });\n\n  // Network falling back to the cache strategy (See: https://serviceworke.rs/caching-strategies.html)\n  self.addEventListener('fetch', (e) => {\n    e.respondWith(fetch(e.request)\n      .catch(err => caches\n        .match(e.request)\n        .then(response => response || Promise.reject(err))\n      ));\n  });\n```\n\nDonc voilà, nous avons notre service worker prêt pour y mettre des notifications.\n\n## Enregistrer les utilisateurs\n\nLa première chose à faire dans la mise en place des web notifications, c'est d'ajouter dans votre `manifest.json` votre `gcm_sender_id`  que vous pouvez trouver dans les paramètres du projet Firebase.\n\n![Paramètre Firebase]({{site.baseurl}}/assets/2017-12-19-push-notification/image3.png)\n\nIl faut ensuite enregistrer le token des utilisateurs qui acceptent de recevoir les notifications.\n\nNous avons choisi d'enregistrer les tokens dans une base [Firebase](https://firebase.google.com/){:rel=\"nofollow noreferrer\"}. Cela nous permet d'avoir une base de données en temps réel à moindre coût. De plus, l'utilisation de Firebase est super facile en Javascript via le SDK disponible [ici](https://firebase.google.com/docs/web/setup){:rel=\"nofollow noreferrer\"}.\n\nL'enregistrement du token utilisateur se fait au même endroit que celui du service worker. Il suffit d'y ajouter le code suivant :\n\n```js\n  function subscribeDevice() {\n    navigator.serviceWorker.ready.then((serviceWorkerRegistration) => {\n      return serviceWorkerRegistration.pushManager.subscribe({ userVisibleOnly: true });\n    }).then((subscription) => {\n      const endpointSections = subscription.endpoint.split('/');\n      const subscriptionId = endpointSections[endpointSections.length - 1];\n      fb.auth().onAuthStateChanged((user) => {\n        if (user) {\n          fb.database().ref('token/' + user.uid).set({subscriptionId: subscriptionId});\n        }\n      })\n\n    });\n  }\n\n  function getFirebase() {\n    const config = {\n      apiKey: \"API_KEY\",\n      authDomain: \"AUTH_DOMAIN\",\n      databaseURL: \"DATABASE_URL\",\n      projectId: \"PROJECT_ID\",\n      storageBucket: \"STORAGE_BUCKET\",\n      messagingSenderId: \"SENDERID\"\n    };\n\n    firebase.initializeApp(config);\n\n    return firebase;\n  }\n```\n\nIl faut appeler la fonction `subscribeDevice` si le service worker est disponible dans le navigateur. Si tout est ok, vous avez un petit popup qui vous demande de valider l'autorisation de recevoir les notifications.\n\n![Popup notification]({{site.baseurl}}/assets/2017-12-19-push-notification/image4.png)\n\nSi la personne accepte son token (unique par navigateur), cela devrait apparaître dans votre base de données Firebase.\n\n![BDD Firebase]({{site.baseurl}}/assets/2017-12-19-push-notification/image5.png)\n\nEt voilà, la première étape est terminée, vous avez dans votre base de données l'ensemble des utilisateurs qui acceptent de recevoir vos notifications.\n\n## Etape 2 : Afficher les notifications\n\nDans cette première version nous allons mettre en place une notification très simple. Pour que les notifications soient envoyées même si l'onglet de votre site est fermé, il faut mettre le code d'affichage dans votre service worker.\n\nVous pouvez ajouter cela :\n\n```js\n  self.addEventListener('push', (e) => {\n    console.log('Push message', e);\n\n    var title = 'Un nouvel article est disponible sur le blog d\\'Eleven-labs';\n\n    e.waitUntil(\n      self.registration.showNotification(title, {\n        body: 'Rendez vous sur notre site',\n        icon: 'img/icons/icon-512x512.png',\n      })\n    );\n  });\n```\n\nVous pouvez faire un lien vers votre site lors du clic sur la notification, en ajoutant l'event dans le service worker.\n\n```js\n  self.addEventListener('notificationclick', (event) => {\n    console.log('[Service Worker] Notification click Received.');\n\n    event.notification.close();\n\n    event.waitUntil(\n      clients.openWindow('https://blog.eleven-labs.com/')\n    );\n  });\n```\n\nDonc maintenant l'utilisateur pourra voir votre notification s'afficher.\n\n![Notification]({{site.baseurl}}/assets/2017-12-19-push-notification/image6.png)\n\n> Et comment je l'envoie ?\n\nC'est la meilleur question car c'est à ce moment que c'est un peu plus compliqué.\n\n## Etape 3 : Je push ma notification\n\nSur le papier c'est assez simple, il faut faire un post avec les paramètres suivants :\n\n```js\n{\n          url: 'https://android.googleapis.com/gcm/send',\n          method: 'POST',\n          headers: {\n            'Content-Type' :' application/json',\n            'Authorization': 'key=SERVER_KEY',\n          },\n          body: JSON.stringify(\n            {\n              \"registration_ids\" : [TOKEN_UTILISATEUR]\n            })\n        }\n```\n\nVotre clé serveur est disponible au même endroit que votre `gcm_sender_id` dans Firebase.\n\nAlors oui c'est simple mais comment faire pour faire un envoi à toute ma base de données de tokens ?\n\nComme je suis fan du serverless, et que Firebase le propose, nous avons choisi d'utiliser [Functions](https://firebase.google.com/products/functions/?authuser=0){:rel=\"nofollow noreferrer\"} de Firebase.\n\nPour créer votre Functions, il vous suffit de suivre le tutoriel de Google disponible [ici](https://firebase.google.com/docs/functions/get-started){:rel=\"nofollow noreferrer\"}.\n\nCe qui est pratique c'est que vous pouvez utiliser la librairie Firebase pour tester en local votre code.\n\n```sh\nfirebase serve --only functions\n```\n\nCela permet de créer un serveur Firebase en local et donc de ne pas s'amuser à déployer à chaque modification.\n\nLa Functions est assez simple elle récupère l'ensemble des tokens de la base de données et fait un post sur l'url vue au dessus pour chaque token.\n\n```js\n'use strict';\n\nconst functions = require('firebase-functions');\nconst admin = require('firebase-admin');\nconst request = require('request');\nconst requestPromise = require('request-promise-native');\n\nadmin.initializeApp(functions.config().firebase);\n\nconst requestOptions = {\n  uri: 'https://android.googleapis.com/gcm/send',\n  method: 'POST',\n  headers: {\n    'Content-Type': ' application/json',\n    'Authorization': 'key=SERVER_KEY',\n  },\n};\n\nexports.sendNotification = functions.https.onRequest((req, res) => {\n  var allToken = admin.database().ref('/token');\n\n  // allToken.once('value') is already a promise, so no need of Promise.all\n  return allToken.once('value').then(function(resp) {\n    var allToken = resp.val();\n\n    // Here we generate a list of request promises, and give them to Promise.all\n    // so that we wait for their completion. then we calculate the status (success, failure)\n    Promise.all(Object.keys(allToken).map(function(uid) {\n      var token = allToken[uid];\n\n      return requestPromise(Object.assign(requestOptions, {\n        body: JSON.stringify({ registration_ids: [token.subscriptionId] }),\n      }));\n    }))\n    .then((responses) => {\n      const status = responses.reduce((result, statusResponse) => {\n        const itemObject = JSON.parse(statusResponse);\n\n        return Object.assign({}, result, {\n          success: result.success + itemObject.success,\n          failure: result.failure + itemObject.failure,\n        });\n      }, { success: 0, failure: 0 });\n\n      res.send(status);\n    })\n    .catch((error) => {\n      console.error(error);\n    });\n  }).catch(function(error) {\n    return res.send('Failed send notification:', error);\n  });\n});\n```\n\nSi tout est ok, vous devriez voir la notification apparaître sur votre écran.\n\n## Conclusion\n\nNous avons maintenant une PWA permettant d'envoyer des notifications lors d'un nouvel article. La suite c'est d'avoir des notifications personnalisées. Pour cela, lors de la réception du push par le service workers nous allons faire un call sur une api pour récupérer l'information à afficher.\n\nVous pouvez nous aider à améliorer le blog en allant sur le [Github](https://github.com/eleven-labs/blog.eleven-labs.com){:rel=\"nofollow noreferrer\"}.\n"}