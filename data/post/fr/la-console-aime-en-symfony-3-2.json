{"date":"2016-12-30T00:00:00.000Z","title":"La Console, on aime en Symfony 3.2","excerpt":"La console est un composant essentiel pour beaucoup d’applications web. Nous avons pas mal de nouveautés dans cette nouvelle version de Symfony. Je vous présente dans cet article mes préférées et vous mettrai les liens de celles que je ne détaille pas ici à la fin (on est comme ça chez Eleven).","readingTime":"7mn","authors":["jgreaux"],"categories":["php"],"content":"\nLa console est un composant essentiel pour beaucoup d’applications web. Nous avons pas mal de nouveautés dans cette nouvelle version de Symfony. Je vous présente dans cet article mes préférées et vous mettrai les liens de celles que je ne détaille pas ici à la fin (on est comme ça chez Eleven).\n\n## Les alias dans les commandes\n\nOn l’attendait, ils l’ont fait : nous pouvons désormais créer une liste d’alias à nos commandes. Pour cela, rien de plus simple : ajoutez “setAliases” avec en paramètre un tableau de string comportant tous les alias.\n\nVoici un exemple :\n\n**ElevenLabsAliasCommand.php** :\n\n```php\n<?php\n\nnamespace AppBundle\\Command;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Command\\ContainerAwareCommand;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass ElevenLabsAliasCommand extends ContainerAwareCommand\n{\n    protected function configure()\n    {\n        $this\n            ->setName('eleven-labs:alias-command')\n            ->setDescription('Test alias command')\n            ->setAliases(['space', 'moon'])\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    {\n        $output->writeln('Alias command done');\n    }\n\n}\n```\n\nVoici une petite vidéo pour voir ce que ça rend :\n\n<script type=\"text/javascript\" src=\"https://asciinema.org/a/8i85eeqih2rwmccrtab407qtv.js\" id=\"asciicast-8i85eeqih2rwmccrtab407qtv\" async></script>\n\n## Test des commandes\n\nTester des commandes, on sait faire. Mais lorsque dans les commandes nous devons répondre à des questions par des étapes intermédiaires, ça devient plus difficile. Terminé les complications, il suffit de rajouter dans vos tests la méthode \"setInputs\", avec en paramètre un tableau contenant les réponses à vos étapes.\nVoici rien que pour vous un exemple très simple :\n\n**ElevenLabsTestCommand.php** :\n\n```php\n<?php\n\nnamespace AppBundle\\Command;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Command\\ContainerAwareCommand;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\nuse Symfony\\Component\\Console\\Input\\Input;\n\nclass ElevenLabsTestCommand extends ContainerAwareCommand\n{\n    protected function configure()\n    {\n        $this\n            ->setName('eleven-labs:test-command')\n            ->setDescription('...')\n            ->setAliases(['test']);\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    {\n        $io = new SymfonyStyle($input, $output);\n        $firstname = $io->ask('What is your firstname ?');\n        $lastname = $io->ask('Your last name ?');\n\n        $text = $firstname.' '.$lastname.', welcome on board !';\n\n        $output->writeln($text);\n    }\n\n}\n```\n\n**ElevenLabsTestCommandTest.php** :\n\n```php\n<?php\n\nnamespace AppBundle\\Command;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase;\nuse Symfony\\Component\\Console\\Application;\nuse Symfony\\Component\\Console\\Tester\\CommandTester;\n\nclass ElevenLabsTestCommandTest extends KernelTestCase\n{\n    public function testCommand()\n    {\n        $kernel = $this->createKernel();\n        $kernel->boot();\n\n        $application = new Application($kernel);\n        $application->add(new ElevenLabsTestCommand());\n\n        $command = $application->find('eleven-labs:test-command');\n        $commandTester = new CommandTester($command);\n\n        // Ajouter tous les inputs dans l'ordre, ici nous devons mettre un nom et un prénom\n        $commandTester->setInputs(['Niel', 'Armstrong']);\n\n        $commandTester->execute([\n            'command'  => $command->getName(),\n        ]);\n\n        $output = $commandTester->getDisplay();\n\n        // Nous verifions ici que nous avons bien les mêmes input\n        $this->assertContains('Niel Armstrong, welcome on board !', $output);\n    }\n}\n```\n\n## Single command application\n\nLes “**S**ingle **C**ommand **A**pplication” sont possibles sur Symfony, comme vous pouvez le voir dans la [documentation](http://symfony.com/doc/3.1/components/console/single_command_tool.html){:rel=\"nofollow noreferrer\"}.\nCette feature améliorée dans la version 3.2 nous permet d’ajouter un booléen à la méthode setDefaultCommand(). C’est grâce à ce booléen que nous pouvons désormais basculer l’application en une SCA.\n\nMieux vaut un exemple qu’un long discours, commençons par créer deux simples commandes :\n\n**Command/EspaceCommand.php :**\n\n```php\n<?php\nnamespace Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Command\\Command;\n\n\nclass EspaceCommand extends Command\n{\n    protected function configure()\n    {\n        $this\n            ->setName('espace')\n            ->setDescription('Aller dans l\\'espace')\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    {\n        $output->writeln('Je suis dans l\\'espace');\n    }\n}\n```\n\n**Command/TerreCommand.php :**\n\n```php\n<?php\nnamespace Command;\n\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Command\\Command;\n\n\nclass TerreCommand extends Command\n{\n    protected function configure()\n    {\n        $this\n            ->setName('terre')\n            ->setDescription('Redescendre sur terre')\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    {\n        $output->writeln('Je retourne sur terre');\n    }\n}\n```\n\n**SingleCommand.php :**\n\n```php\n#!/usr/bin/env php\n<?php\n\nrequire __DIR__.'/vendor/autoload.php';\n\nuse Command\\EspaceCommand;\nuse Command\\TerreCommand;\nuse Symfony\\Component\\Console\\Application;\n\n// On initialise les deux commandes\n$espaceCommand = new EspaceCommand();\n$terreCommand = new TerreCommand();\n\n// On créer une nouvelle application, et on lui ajoute nos 2 commandes\n$application = new Application();\n$application->add($espaceCommand);\n$application->add($terreCommand);\n\n// On met la commande EspaceCommand en par défaut et on ajout un booléen à TRUE\n$application->setDefaultCommand($espaceCommand->getName(), true);\n\n$application->run();\n```\n\nDans le fichier SingleCommand, nous avons rajouté un booléen à true, pour indiquer que nous souhaitons avoir une **SCA**.\n\n<script type=\"text/javascript\" src=\"https://asciinema.org/a/ctpdd6v34qfh35try9xtqrrpd.js\" id=\"asciicast-ctpdd6v34qfh35try9xtqrrpd\" async></script>\n\n## LockableTrait\n\nDepuis la version 2.6, il est possible de bloquer une commande si la commande est déjà en train de tourner.\nVoici un petit exemple de comment nous devions faire :\n\n```php\nclass LockableCommand extends Command\n{\n    protected function configure()\n    {\n        // ...\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    {\n        $lock = new LockHandler('update:contents');\n        if (!$lock->lock()) {\n            $output->writeln('The command is already running in another process.');\n            return 0;\n        }\n\n        $lock->release();\n    }\n}\n```\n\nAvec la version 3.2, vous pouvez ajouter le trait directement dans votre commande :\n\n```php\nclass LockableCommand extends Command\n{\n    use LockableTrait;\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    {\n         if (!$this->lock()) {\n            $output->writeln('The command is already running in another process.');\n            return 0;\n         }\n\n         $this->release();\n    }\n}\n```\n\n## Hidden et Options multiples\n\nUne petite nouveauté qui vous permettra de cacher une commande très simplement.\nUne fois la commande cachée, vous pourrez  toujours la lancer, mais elle n’apparaîtra plus dans la liste de vos commandes :\n\n```php\nclass HiddenCommand extends Command\n{\n    protected function configure()\n    {\n        $this\n            ->setName('hidden')\n            ->hidden(true)\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    {\n        // your code here\n    }\n}\n```\n\nEnfin, il est désormais possible de combiner plusieurs options de texte sur le même input, voici un exemple :\n\n``` theme:monokai\n$output->writeln('<fg=green;options=italic,underscore>Texte vert italic et souligné</>');\n```\n\n## Conclusion\n\nVoilà, je vous ai montré les nouveautés que je préfère, mais ce ne sont pas les seules, pour voir toute la liste des nouveautés pour le composant console, je vous conseille de suivre ce lien : <http://symfony.com/blog/symfony-3-2-0-released>\n"}