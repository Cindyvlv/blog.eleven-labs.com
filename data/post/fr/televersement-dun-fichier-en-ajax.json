{"date":"2017-04-20T00:00:00.000Z","title":"Téléversement d’un fichier en AJAX","excerpt":"Aujourd’hui, je voudrais partager avec vous une fonctionnalité très souvent demandée dans une application : le téléversement d’un fichier.","readingTime":"8mn","authors":["tthuon"],"categories":["php"],"content":"\nAujourd’hui, je voudrais partager avec vous une fonctionnalité très souvent demandée dans une application : le téléversement d’un fichier.\nTrès souvent, le téléversement d’un fichier se fait via un formulaire en html avec l’attribut **enctype=\"multipart/form-data\"**. Ensuite le formulaire est posté au serveur. Mais lorsqu’un fichier pèse plusieurs mégaoctet, voir plusieurs gigaoctet, l’utilisateur attend sans avoir de retour sur l’état du téléversement du fichier.\n\nC’est là qu’intervient AJAX ! (wouhou!) Il va nous permettre de rendre le téléversement d’un fichier asynchrone et permet d’avoir des informations sur son état.\n\nJe vous propose de voir comment implémenter un système de téléversement de fichier en JavaScript et avec Symfony côté serveur.\n\n### Implémentation du formulaire Symfony\n\nMon formulaire va contenir deux champs : **name** et **file**. Le premier va contenir le nom du fichier que l’utilisateur veut donner.\nLe second sera la représentation du fichier via l’objet **Symfony\\Component\\HttpFoundation\\File\\UploadedFile**.\n\nSymfony a un **FormType** qui est **FileType**. Comme son nom l’indique, il permet de gérer un champ de formulaire de type fichier.\n\n```php\n<?php\n// src/AppBundle/Form/UploadType.php\nnamespace AppBundle\\Form;\n\nuse Symfony\\Component\\Form\\AbstractType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\FileType;\nuse Symfony\\Component\\Form\\Extension\\Core\\Type\\TextType;\nuse Symfony\\Component\\Form\\FormBuilderInterface;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolver;\n\nclass UploadType extends AbstractType\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            ->add('name', TextType::class)\n            ->add('file', FileType::class)\n        ;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function configureOptions(OptionsResolver $resolver)\n    {\n        $resolver->setDefaults([\n            'data_class' => 'AppBundle\\Entity\\File',\n        ]);\n    }\n}\n```\n\nEn plus de ce formulaire, je vais le lier à une entité **AppBundle\\Entity\\File**, ce qui va me permettre ensuite de le persister dans la base de données.\n\n```php\n<?php\n// src/AppBundle/Entity/File.php\n\nnamespace AppBundle\\Entity;\n\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\nuse Doctrine\\ORM\\Mapping as ORM;\nuse Symfony\\Component\\Validator\\Constraints as Assert;\n\n/**\n * @ORM\\Entity(repositoryClass=\"AppBundle\\Repository\\FileRepository\")\n */\nclass File\n{\n    /**\n     * @ORM\\Id()\n     * @ORM\\Column(type=\"integer\")\n     * @ORM\\GeneratedValue(strategy=\"AUTO\")\n     *\n     * @var int\n     */\n    private $id;\n\n    /**\n     * @ORM\\Column(type=\"string\")\n     * @Assert\\NotBlank(message=\"Name should not be blank.\")\n     * @Assert\\Type(\"string\")\n     *\n     * @var string\n     */\n    private $name;\n\n    /**\n     * @Assert\\NotBlank(message=\"File should not be blank.\")\n     * @Assert\\File(\n     *     mimeTypes={\"image/jpeg\", \"image/png\", \"image/gif\", \"application/x-gzip\", \"application/zip\"},\n     *     maxSize=\"1074000000\"\n     * )\n     *\n     * @var UploadedFile\n     */\n    private $file;\n\n    /**\n     * @ORM\\Column(type=\"string\")\n     *\n     * @var string\n     */\n    private $path;\n```\n\nJ’ai ajouté des contraintes sur le champ **file**. Il me permet de valider que le fichier que je vais téléverser est bien du bon type et d’une taille maximale de 1Go.\n\nCôté contrôleur, je mets en place une route pour afficher mon formulaire. Et une autre pour gérer la requête de téléversement du fichier.\n\n\n```php\n<?php\n// src/AppBundle/Controller/DefaultController.php\nnamespace AppBundle\\Controller;\n\nuse AppBundle\\Form\\UploadType;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\nuse Symfony\\Component\\Form\\FormInterface;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass DefaultController extends Controller\n{\n    /**\n     * @Route(\"/\", name=\"homepage\", methods={\"GET\"})\n     */\n    public function indexAction()\n    {\n        return $this->render('default/index.html.twig');\n    }\n\n    /**\n     * @Route(\"/upload\", name=\"upload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse|FormInterface\n     */\n    public function uploadAction(Request $request)\n    {\n        $form = $this->createForm(UploadType::class);\n        $form->handleRequest($request);\n\n        if ($form->isSubmitted() &amp;&amp; $form->isValid()) {\n            $this->getDoctrine()\n                ->getRepository('AppBundle:File')\n                ->store($form->getData());\n\n            return new JsonResponse([], 201);\n        }\n\n        return $form;\n    }\n}\n```\n\nJ’ai mis en place un écouteur sur l’événement **kernel.view** pour gérer le cas où le formulaire est invalide (voir src/AppBundle/EventListener/ViewListener.php).\n\nJusqu’ici, rien de surprenant. Je vous invite à lire la documentation Symfony pour avoir plus d’informations : [http://symfony.com/doc/current/controller/upload_file.html](http://symfony.com/doc/current/controller/upload_file.html){:rel=\"nofollow noreferrer\"}.\n\nPassons maintenant côté client avec la mise en place du JavaScript.\n\n### Implementation côté client avec JavaScript\n\nEn tant que développeur PHP, je pense que cette partie est la plus intéressante. C’est ici que va prendre place la magie de l’AJAX. Pour rappel, *[AJAX](https://fr.wikipedia.org/wiki/Ajax_(informatique)){:rel=\"nofollow noreferrer\"}** pour **Asynchronous JavaScript XML** permet au navigateur de dialoguer avec le serveur de manière asynchrone.\n\n[XMLHttpRequest](https://developer.mozilla.org/fr/docs/Web/API/XMLHttpRequest/Utiliser_XMLHttpRequest){:rel=\"nofollow noreferrer\"}est un objet JavaScript accessible via le navigateur qui permet de créer des requêtes AJAX.\n\nJe vais d’abord mettre en place le formulaire HTML.\n\n```html\n<form id=\"upload-form\">\n    <label for=\"name\">Name</label> <input id=\"name\" type=\"text\" name=\"name\"><br>\n    <label for=\"file\">File</label> <input id=\"file\" type=\"file\" name=\"file\">\n    <input type=\"submit\">\n</form>\n<p>Progress: <span id=\"progress-value\"></span>%</p>\n<p id=\"upload-complete\"></p>\n<p id=\"errors\"></p>\n```\n\nÀ l’image du formulaire Symfony que je viens de créer plus tôt, il y a deux champs : **name** et **file**.\n\nJ’ai ajouté 3 éléments DOM. Ils vont me permettre d’afficher les éventuelles erreurs et la progression du téléversement.\n\nEnsuite, je vais ajouter un écouteur sur l’événement **submit** du formulaire. Cela va me permettre de faire le téléversement en AJAX à la place du formulaire html.\n\n```javascript\ndocument.getElementById('upload-form').addEventListener('submit', onSubmit);\n\nfunction onSubmit(event) {\n    event.preventDefault();\n\n    var formData = new FormData();\n    formData.append(\"upload[file]\", document.getElementById(\"file\").files[0]);\n    formData.append(\"upload[name]\", document.getElementById(\"name\").value);\n\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"POST\", \"/upload\");\n    xhr.addEventListener('load', onRequestComplete, false);\n    xhr.upload.addEventListener(\"load\", onUploadComplete, false);\n    xhr.upload.addEventListener(\"progress\", onUploadProgress, false);\n    xhr.send(formData);\n}\n```\n\nDans un premier temps, je vais prendre tous les champs du formulaire et les mettre dans l’objet **[FormData](https://developer.mozilla.org/fr/docs/Web/API/FormData){:rel=\"nofollow noreferrer\"}**. Il facilite le transport des valeurs du formulaire. Cet objet sera ensuite utilisé lors de la requête AJAX.\n\nEnsuite, je prépare mon objet **XMLHttpRequest**. Je lui indique l’url vers où poster les données, j’ajoute quelques écouteurs et enfin je passe mon objet **FormData** à la méthode **send()** pour envoyer les données.\n\nDe cette façon, cela va créer une requête de téléversement avec les en-tête **multipart** et tout cela en asynchrone.\n\nExemple de requête HTTP :\n\n```sh\nPOST /upload HTTP/1.1\nHost: localhost:8000\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\nAccept: */*\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nReferer: http://localhost:8000/\nContent-Length: 74305\nContent-Type: multipart/form-data; boundary=---------------------------11413465171617698502697247091\nCookie: PHPSESSID=4vgbbv15gbfevea18tnso6fme6\nConnection: keep-alive\n\n-----------------------------11413465171617698502697247091\nContent-Disposition: form-data; name=\"upload[file]\"; filename=\"shutterstock_321267065.jpg\"\nContent-Type: image/jpeg\n\n// much data here\n-----------------------------11413465171617698502697247091\nContent-Disposition: form-data; name=\"upload[name]\"\n\nmon fichier\n-----------------------------11413465171617698502697247091--\n```\n\nUn des écouteurs me permet de suivre l’avancé du téléversement du fichier : **xhr.upload.addEventListener(\"progress\", onUploadProgress, false);**\n\n```javascript\nfunction onUploadProgress(event) {\n    if (event.lengthComputable) {\n        var percentComplete = event.loaded / event.total;\n        document.getElementById('progress-value').textContent = parseFloat(percentComplete*100).toFixed(2);\n    }\n}\n```\n\nUn objet **ProgressEvent** est passé à la fonction de rappel **onUploadProgress**. Il contient les informations sur la progression du téléversement du fichier. Dans mon exemple, j’affiche le pourcentage d’avancement. Mais on peut imaginer une barre de progression en CSS.\n\nPetite démo en GIF :) et le code complet [https://github.com/lepiaf/file-upload](https://github.com/lepiaf/file-upload){:rel=\"nofollow noreferrer\"}\n\n![](/imgs/posts/2017-04-20-televersement-dun-fichier-en-ajax/upload.gif)\n\n\n### Pour conclure\n\nNous avons vu ensemble comment mettre en place le téléversement d’un fichier de façon asynchrone avec AJAX et Symfony. Cette méthode permet d’encoder et d’envoyer le fichier comme un flux de données binaire. Contrairement a un encodage du fichier en base64, il ne fait pas gonfler le poids du fichier sur le réseau. La représentation du fichier en base64 fait augmenter le poids du fichier de **~33%**. Pour un fichier de quelques kilooctets cette augmentation de poids n'est pas significatif, mais avec un fichier de plusieurs mégaoctets, cela a un impact significatif. De plus, le fichier est correctement géré par le navigateur et le serveur. Cela rend le téléversement plus efficace et permet d’utiliser la représentation d’une ressource fichier côté serveur (**$_FILES** côté PHP).\n\nRéférences :\n\n- [https://developer.mozilla.org/fr/docs/Web/API/XMLHttpRequest/Utiliser_XMLHttpRequest](https://developer.mozilla.org/fr/docs/Web/API/XMLHttpRequest/Utiliser_XMLHttpRequest){:rel=\"nofollow noreferrer\"}\n- [https://gist.github.com/joyrexus/524c7e811e4abf9afe56](https://gist.github.com/joyrexus/524c7e811e4abf9afe56){:rel=\"nofollow noreferrer\"}\n- [http://stackoverflow.com/questions/18240692/is-using-multipart-form-data-any-better-then-json-base64](http://stackoverflow.com/questions/18240692/is-using-multipart-form-data-any-better-then-json-base64){:rel=\"nofollow noreferrer\"}\n- [http://stackoverflow.com/questions/4715415/base64-what-is-the-worst-possible-increase-in-space-usage/4715499](http://stackoverflow.com/questions/4715415/base64-what-is-the-worst-possible-increase-in-space-usage/4715499){:rel=\"nofollow noreferrer\"}\n- [https://tools.ietf.org/html/rfc7578](https://tools.ietf.org/html/rfc7578){:rel=\"nofollow noreferrer\"}\n- [http://www.bortzmeyer.org/7578.html](http://www.bortzmeyer.org/7578.html){:rel=\"nofollow noreferrer\"}\n"}