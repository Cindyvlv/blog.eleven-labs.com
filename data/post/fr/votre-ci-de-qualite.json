{"date":"2017-08-30T00:00:00.000Z","title":"Votre CI de qualité","excerpt":"La qualité est un vaste sujet, surtout quand on l'associe au développement d'applications web. Ce qui est encore plus compliqué, c'est de mettre en place l'environnement d'intégration continue (CI) de suivi de qualité.","readingTime":"28mn","authors":["captainjojo"],"categories":["php","javascript"],"content":"\nLa qualité est un vaste sujet, surtout quand on l'associe au développement d'application web.\n\nCe qui est encore plus compliqué, c'est de mettre en place l'environnement d'intégration continue (CI) de suivi de qualité.\n\nPendant plus de 2 ans, nous avons mis en place une CI de qualité chez LeMonde.fr qui a évolué en fonction de nos besoins. Le but de cet article est de comprendre la stratégie et les technos choisies pour la CI d'un site comme LeMonde.fr\n\n### La partie Symfony\n\nComme pour tout langage de programmation, la première chose que l'on veut vérifier, c'est la syntaxe. La première chose à mettre en place est donc un vérificateur de syntaxe en PHP.\n\n```sh\nphp -l somefile.php\n```\n\nMaintenant, il faut savoir quand faire cette vérification. L'idée numéro 1 étant de laisser le développeur le faire avant d'envoyer son code sur git. Si l'appel n'est pas automatisé, 1 fois sur 3, le développeur ne lance pas la commande.\n\nL'idée est donc de le faire à chaque commit. Pour cela rien de plus simple, on ajoute [un hook de pre-commit](https://git-scm.com/docs/githooks){:rel=\"nofollow noreferrer\"}.\n\nDans le fichier `.git/hooks/pre-commit` il faut ajouter le code suivant.\n\n```sh\n#!/bin/sh\n\nBADWORDS='var_dump|die|todo'\n\nEXITCODE=0\nFILES=`git diff --cached --diff-filter=ACMRTUXB --name-only $against --`\n\nfor FILE in $FILES ; do\n  if [ \"${FILE##*.}\" = \"php\" ]; then\n\n    php -l \"$FILE\"\n    if [ $? -gt 0 ]; then\n      EXITCODE=1\n    fi\n\n    grep -H -i -n -E \"${BADWORDS}\" $FILE\n    if [ $? -eq 0 ]; then\n      EXITCODE=1\n    fi\n\n  fi\ndone\n\nif [ $EXITCODE -gt 0 ]; then\n  echo\n  echo 'Fix the above errors or use:'\n  echo ' git commit --no-validate'\n  echo\nfi\n\nexit $EXITCODE\n```\n\nSi tout est ok, lors de chaque `commit` , le hook va vérifier la syntaxe php.\n\nUne fois cela validé, la suite logique est de faire en sorte que les développeurs codent tous avec les mêmes standards. Ce qui est bien, c'est que PHP a déjà des standards : les **[PSR](http://www.php-fig.org/psr/){:rel=\"nofollow noreferrer\"}**.\n\nEncore faut-il que tous les développeurs les suivent, c'est assez simple en PHP. Nous avons ajouté dans notre hook de pre-commit la commande de vérification disponible dans cet article, *[vérifier la qualité du code](https://blog.eleven-labs.com/fr/verifier-la-qualite-du-code/){:rel=\"nofollow noreferrer\"}*\n\nNous étions satisfaits mais c'était assez contraignant de passer par les hooks git. La première difficulté était que chaque développeur pouvait changer ses hooks, ce qui peut poser des problèmes.\n\nNous avons donc regardé les solutions du marché, et comme nous utilisions Github, [Travis](https://travis-ci.org){:rel=\"nofollow noreferrer\"} était la plus approprié.\n\nLa migration était simple, nous avons ajouté le fichier `.travis.yml` dans notre projet contenant les mêmes scripts de vérification.\n\n```yml\nbefore_script:\n  - ! find . -type f -name \"*.php\" -exec php -d error_reporting=32767 -l {} \\; 2>&1 >&- | grep \"^\"\n```\n\nLa vérification ne se faisait que lors d'une pull request. Il fallait aider le développeur à voir les erreurs de coding style et syntaxe avant, c'est-à-dire pendant son développement.\nNous avons choisi d'utiliser [l'editorconfig](http://editorconfig.org/){:rel=\"nofollow noreferrer\"} ! L'editorconfig est un fichier que l'on ajoute à la racine du repo et qui est utilisé par la plupart des IDE pour vérifier en live la syntaxe.\n\nExemple de fichier .editorconfig\n\n```ini\n# EditorConfig helps developers define and maintain consistent\n# coding styles between different editors and IDEs\n# editorconfig.org\n\nroot = true\n\n[*.md]\ntrim_trailing_whitespace = false\nindent_style = tabs\n\n[*]\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\nindent_size = 4\nindent_style = space\n\n[*.{js,jsx,json}]\nindent_size = 2\nindent_style = space\n\n[Makefile]\nindent_size = 4\nindent_style = tabs\n```\n\n**La syntaxe c'est fait !!!!**\n\nPassons au code ! Comme tout le monde, nous avions des tests unitaires et fonctionnels en [phpunit](https://phpunit.de/){:rel=\"nofollow noreferrer\"}.  Comme nous avions Travis, qui était en place, il fallait seulement ajouter le script pour les lancer dans la configuration.\n\n```yml\n//.travis.yml\nscript:\n  ## PHPUnit\n  - vendor/bin/phpunit\n```\n\n**Bravo vos tests sont dans la CI !!!**\n\nAprès cette importante étape, nous avons cherché à savoir ce qui nous manquait. Nous avions des tests, mais cela n'attestait pas de la qualité de notre code, seulement du fait qu'il était fonctionnel. Pour améliorer la qualité du code, nous avons alors instauré l'obligation d'une relecture par deux autres développeurs de chaque pull request afin qu'elle soit validée. Nous avions la sensation que la qualité était meilleure car les gens posaient les bonnes questions :\n\n 1. pourquoi cette variable ?\n 2. ton nom de fonction est étrange.\n 3. tu pourrais utiliser cette fonction.\n 4. j'ai déjà codé un truc ressemblant.\n 5. etc...\n\nMais il nous est arrivé que certaines pull requests nous aient posé des problèmes. Des questions du type `for` ou `while` sont apparues dans les codes review et cela est devenu trollLand sur certaines pull requests. Comment faire ?\n\nL'idée fut d'avoir un juge de touche Nous avons cherché et nous avons choisi [Scrutinizer](https://scrutinizer-ci.com/). [Scrutinizer](https://scrutinizer-ci.com/){:rel=\"nofollow noreferrer\"} est une solution qui permet de *juger* votre code. Il vous donne une note en prenant en compte plusieurs signes de qualité :\n\n 1. nom de variable\n 2. taille du code\n 3. ré-utilisation\n 4. psr\n 5. etc...\n\nLa mise en place est simple puisque [Scrutinizer](https://scrutinizer-ci.com/){:rel=\"nofollow noreferrer\"} se plugue facilement à Github. Il suffit d'ajouter un fichier `.scrutinizer.yml` dans votre projet.\n\nExemple:\n```yml\nchecks:\n    php:\n        verify_property_names: true\n        verify_argument_usable_as_reference: true\n        verify_access_scope_valid: true\n        variable_existence: true\n        useless_calls: true\n        use_statement_alias_conflict: true\n        use_self_instead_of_fqcn: true\n        uppercase_constants: true\n        unused_variables: true\n        unused_properties: true\n        unused_methods: true\n        unused_parameters: true\n        unreachable_code: true\n        too_many_arguments: true\n        symfony_request_injection: true\n        switch_fallthrough_commented: true\n        sql_injection_vulnerabilities: true\n        single_namespace_per_use: true\n        simplify_boolean_return: true\n        side_effects_or_types: true\n        security_vulnerabilities: true\n        return_doc_comments: true\n        return_doc_comment_if_not_inferrable: true\n        require_scope_for_properties: true\n        require_scope_for_methods: true\n        require_php_tag_first: true\n        remove_extra_empty_lines: true\n        psr2_switch_declaration: true\n        psr2_class_declaration: true\n        property_assignments: true\n        properties_in_camelcaps: true\n        prefer_while_loop_over_for_loop: true\n        precedence_mistakes: true\n        precedence_in_conditions: true\n        phpunit_assertions: true\n        php5_style_constructor: true\n        parse_doc_comments: true\n        parameters_in_camelcaps: true\n        parameter_non_unique: true\n        parameter_doc_comments: true\n        param_doc_comment_if_not_inferrable: true\n        overriding_private_members: true\n        optional_parameters_at_the_end: true\n        one_class_per_file: true\n        non_commented_empty_catch_block: true\n        no_unnecessary_if: true\n        no_unnecessary_final_modifier: true\n        no_underscore_prefix_in_properties: true\n        no_underscore_prefix_in_methods: true\n        no_trait_type_hints: true\n        no_trailing_whitespace: true\n        no_short_variable_names:\n            minimum: '3'\n        no_short_open_tag: true\n        no_short_method_names:\n            minimum: '3'\n        no_property_on_interface: true\n        no_non_implemented_abstract_methods: true\n        no_new_line_at_end_of_file: true\n        no_long_variable_names:\n            maximum: '20'\n        no_goto: true\n        no_global_keyword: true\n        no_exit: true\n        no_eval: true\n        no_error_suppression: true\n        no_empty_statements: true\n        no_duplicate_arguments: true\n        no_debug_code: true\n        no_commented_out_code: true\n        newline_at_end_of_file: true\n        more_specific_types_in_doc_comments: true\n        naming_conventions:\n            local_variable: '^[a-z][a-zA-Z0-9]*$'\n            abstract_class_name: ^Abstract|Factory$\n            utility_class_name: 'Utils?$'\n            constant_name: '^[A-Z][A-Z0-9]*(?:_[A-Z0-9]+)*$'\n            property_name: '^[a-z][a-zA-Z0-9]*$'\n            method_name: '^(?:[a-z]|__)[a-zA-Z0-9]*$'\n            parameter_name: '^[a-z][a-zA-Z0-9]*$'\n            interface_name: '^[A-Z][a-zA-Z0-9]*Interface$'\n            type_name: '^[A-Z][a-zA-Z0-9]*$'\n            exception_name: '^[A-Z][a-zA-Z0-9]*Exception$'\n            isser_method_name: '^(?:is|has|should|may|supports)'\n        line_length:\n            max_length: '120'\n        method_calls_on_non_object: true\n        missing_arguments: true\n        align_assignments: true\n        argument_type_checks: true\n        assignment_of_null_return: true\n        avoid_aliased_php_functions: true\n        avoid_closing_tag: true\n        avoid_conflicting_incrementers: true\n        avoid_corrupting_byteorder_marks: true\n        avoid_duplicate_types: true\n        avoid_entity_manager_injection: true\n        avoid_fixme_comments: true\n        avoid_length_functions_in_loops: true\n        avoid_multiple_statements_on_same_line: true\n        avoid_perl_style_comments: true\n        avoid_superglobals: true\n        avoid_todo_comments: true\n        avoid_unnecessary_concatenation: true\n        avoid_usage_of_logical_operators: true\n        avoid_useless_overridden_methods: true\n        blank_line_after_namespace_declaration: true\n        catch_class_exists: true\n        classes_in_camel_caps: true\n        closure_use_modifiable: true\n        closure_use_not_conflicting: true\n        code_rating: true\n        deadlock_detection_in_loops: true\n        deprecated_code_usage: true\n        duplication: true\n        encourage_postdec_operator: true\n        encourage_shallow_comparison: true\n        encourage_single_quotes: true\n        fix_doc_comments: true\n        fix_line_ending: true\n        fix_use_statements:\n            remove_unused: true\n            preserve_multiple: false\n            preserve_blanklines: false\n            order_alphabetically: true\n        foreach_traversable: true\n        foreach_usable_as_reference: true\n        instanceof_class_exists: true\n        function_in_camel_caps: true\n\ntools:\n    external_code_coverage:\n        timeout: 600\n\nbuild_failure_conditions:\n    - 'elements.rating(<= D).new.exists'\n    - 'issues.label(\"coding-style\").new.exists'\n    - 'issues.severity(>= MINOR).new.exists'\n    - 'project.metric_change(\"scrutinizer.test_coverage\", < -0.10)'\n    - 'patches.label(\"Doc Comments\").exists'\n```\n\nVous pouvez configurer énormément de choses mais surtout les conditions d'acceptation. Comme vous le voyez dans la configuration, on y trouve `build_failure_conditions` qui permet de mettre les seuils d'acceptation de la pull request.\n\nScrutinizer permet aussi de gérer le taux de code coverage, il faut alors l'envoyer à Scrutinizer à partir de la sortie de Travis. Un tutoriel est disponible [ici](https://scrutinizer-ci.com/docs/tools/external-code-coverage/){:rel=\"nofollow noreferrer\"}. Normalement, il vous faut ajouter ceci dans le fichier `.travis.yml`\n\n```yml\nafter_script:\n  ## Scrutinizer\n  - wget https://scrutinizer-ci.com/ocular.phar\n  - php ocular.phar --access-token=\"TOKEN\" code-coverage:upload --format=php-clover ./build/logs/clover.xml\n```\n\nScrutinizer est assez complet et permet de suivre la qualité de votre code au fil du temps, en vous envoyant des mails de suivi et vous proposant des dashboards.\n\n**Encore une étape de terminée !!!!**\n\nNous avons utilisé cette stack pendant plus d'un an, nous étions assez satisfait. Puis un jour, un article sur [les tests de mutation](https://blog.eleven-labs.com/fr/mutation-testing-verifiez-la-qualite-de-vos-tests-unitaires/){:rel=\"nofollow noreferrer\"}, nous a donné envie d'aller plus loin. Nous avons alors essayé les tests de mutation, ce qui nous a permis de voir que même avec un code coverage de 90%, il y avait des tests qui ne faisaient rien ou qui testaient mal le code. Après avoir fait les changements, nous voulions aussi l'introduire dans notre CI. Le premier réflexe étant d'ajouter le script dans la configuration travis. Grosse erreur, le script mettant plus de 20 minutes sur notre projet, nous avions les jobs Travis en attente sur les autres projets. Mais heureusement, Travis avait sorti une nouvelle fonctionnalité qui permet de lancer les jobs en mode CRON et donc de le faire qu'une fois par jour, ce qui est suffisant pour ce genre de test. Il nous suffsait alors d'ajouter la config suivante.\n\n```yml\n//.travis.yml\nscript:\n    - |\n        if [[ \"$TRAVIS_EVENT_TYPE\" == 'cron' && \"$TRAVIS_BRANCH\" == 'master' ]]; then\n            php bin/humbug\n            php bin/humbug stats ./build/humbug/log.json --skip-killed=yes -vvv\n        fi\n```\n\nIl suffit alors de regarder chaque jour le build humbug fait sur la branche master.\n\n**La dernière étape de la partie php est terminée !!!!**\n\n### La partie javascript\n\nL'architecture évoluant, nous avons dû nous adapter et donc travailler de plus en plus avec du javascript.\n\nNous avons alors réfléchi à la même problématique, du javascript oui, mais de qualité.\n\nEncore une fois, nous avons commencé par la syntaxe avec la mise en place [Eslint](https://eslint.org/). Nous avons choisi comme standard la configuration de [airbnb](https://www.npmjs.com/package/eslint-config-airbnb){:rel=\"nofollow noreferrer\"}.\n\n```js\n---\n    extends: \"airbnb\"\n    env:\n        node: true\n        browser: true\n        jest: true\n    settings:\n        import/resolver:\n            webpack:\n                config: 'app/config/webpack.config.js'\n```\n\nPuis nous avons ajouté la vérification à la configuration de Travis.\n\n```yml\n//.travis.yml\nscript:\n  - eslint src app/config --ext .js --ext .jsx\n```\n\nComme nous faisons déjà du javascript dans le frontend, notre Editorconfig était correctement configuré.\n\n**Étape 1, 3 secondes !!!**\n\nNous avons alors fait les tests unitaires. Comme toujours le choix de la techno ne fut pas simple. Mais comme nous faisions du [react](https://facebook.github.io/react/), [jest](https://facebook.github.io/jest/){:rel=\"nofollow noreferrer\"} s'est très vite imposé.\nUne fois les tests développés, nous avons encore une fois ajouté l'appel dans la configuration Travis.\n\n```yml\n//.travis.yml\nscript:\n  - jest\n```\n\n**Étape 2, done !!!!**\n\nComme nous le savions de notre expérience en PHP, tout cela ne suffisait pas. Nous avons donc cherché un outil équivalent à Scrutinizer et nous avons trouvé [Bithound](https://www.bithound.io){:rel=\"nofollow noreferrer\"}. Cet outil est un peu moins poussé, mais il permet de mettre une note sur votre code et surtout de vous alerter quand des librairies extérieures ne sont plus à jour.\n\nLa configuration est comme toujours un fichier à la racine du projet.\n\n```json\n//.bithoundrc\n{\n  \"ignore\": [\n    \"**/node_modules/**\"\n  ],\n  \"test\": [\n    \"**/*.spec.js*\"\n  ],\n  \"critics\": {\n    \"lint\": {\n      \"engine\": \"eslint\"\n    }\n  }\n}\n```\n\nBithound n'est pas mal mais n'apporte pas les mêmes fonctionnalités que Scrutinizer. Il n'y a pas de dashboard de suivi et les checks sont limités.\n\n**Et voila, votre javascript est maintenant de qualité !!!**\n\nNous n'avons malheureusement pas trouvé une technologie permettant de faire des tests de mutation avec Jest, donc nous n'avons pas passé cette étape sur le code javascript. (Avez-vous des solutions ?)\n\n### Partie CSS\n\nOn l'oublie souvent mais le CSS, c'est aussi du code, et la qualité de celui-ci doit aussi être prise en compte.\n\nJamais deux sans trois, on commence par la syntaxe. Pour cela, nous avons utilisé [Stylelint](https://stylelint.io/){:rel=\"nofollow noreferrer\"} qui permet de gérer la syntaxe de vos fichiers CSS. Stylelint permet de nombreuses vérifications:\n\n 1. Ne pas avoir de commentaire vide\n 2. Le nombre de sélecteurs max\n 3. Vérification des accolades\n 4. etc...\n\nSi vous suivez le tutoriel, vous devez écrire un fichier de configuration à la racine de votre repository.\n\nExemple de fichier `.stylelintrc`\n\n```json\n{\n    \"plugins\": [\n        \"stylelint-order\"\n    ],\n    \"rules\": {\n        \"color-hex-case\": \"lower\",\n        \"color-no-invalid-hex\": true,\n\n        \"font-weight-notation\": \"named-where-possible\",\n\n        \"indentation\": 4,\n        \"function-max-empty-lines\": 2,\n        \"function-comma-space-after\": \"always-single-line\",\n        \"function-parentheses-space-inside\": \"never-single-line\",\n        \"block-closing-brace-newline-after\": [\n            \"always-multi-line\",\n            { \"ignoreAtRules\": [\"if\", \"else\"] }\n        ],\n        \"number-leading-zero\": \"always\",\n        \"number-no-trailing-zeros\": true,\n        \"number-max-precision\": 6,\n        \"block-no-empty\": true,\n        \"comment-no-empty\": true,\n        \"declaration-bang-space-before\": \"always\",\n        \"declaration-block-no-duplicate-properties\": [\n            true,\n            { \"ignore\": [\"consecutive-duplicates\"] }\n        ],\n        \"string-quotes\": \"single\",\n        \"max-line-length\": 100,\n        \"max-empty-lines\": 2,\n        \"max-nesting-depth\": [3,\n            { \"ignoreAtRules\": [\"if\", \"else\", \"include\"] }\n        ],\n        \"order/declaration-block-order\": [\n            \"custom-properties\",\n            \"dollar-variables\",\n            {\n                \"type\": \"at-rule\",\n                \"name\": \"include\",\n                \"hasBlock\": false\n            },\n            \"declarations\",\n            {\n                \"type\": \"at-rule\",\n                \"name\": \"include\",\n                \"parameter\": \"to-screen\",\n                \"hasBlock\": true\n            },{\n                \"type\": \"at-rule\",\n                \"name\": \"include\",\n                \"parameter\": \"from-screen\",\n                \"hasBlock\": true\n            },{\n                \"type\": \"at-rule\",\n                \"name\": \"include\",\n                \"parameter\": \"from-to-screen\",\n                \"hasBlock\": true\n            },{\n                \"type\": \"at-rule\",\n                \"name\": \"include\",\n                \"parameter\": \"at-screen\",\n                \"hasBlock\": true\n            },\n            \"rules\"\n        ],\n        \"order/declaration-block-properties-specified-order\" : [\n            [\n                \"box-sizing\",\n                \"display\",\n                \"float\",\n                \"flex\",\n                \"flex-flow\",\n                \"flex-basis\",\n                \"align-self\",\n                \"align-items\",\n                \"order\",\n                \"position\",\n                \"top\",\n                \"right\",\n                \"bottom\",\n                \"left\",\n                \"min-width\",\n                \"z-index\",\n                \"width\",\n                \"max-width\",\n                \"min-height\",\n                \"height\",\n                \"max-height\",\n                \"overflow\",\n                \"overflow-y\",\n                \"overflow-x\",\n                \"padding\",\n                \"padding-top\",\n                \"padding-right\",\n                \"padding-bottom\",\n                \"padding-left\",\n                \"margin\",\n                \"margin-top\",\n                \"margin-right\",\n                \"margin-bottom\",\n                \"margin-left\"\n            ],\n            {\n                \"unspecified\": \"bottom\"\n            }\n        ]\n    }\n}\n```\n\nPour lancer ceci dans nos CI, nous avons utilisé le plugin pour gulp et donc ajouté une tâche gulp.\n\n```js\ngulp.task('scss:lint', () => {\n    const lintPlugins = [\n        stylelint(),\n        reporter({\n            clearReportedMessages: true,\n        }),\n    ];\n\n    return gulp.src(path.resolve(src.scss, '**/*.scss'))\n        .pipe(postcss(lintPlugins, { syntax }).on('error', onError));\n});\n```\n\nEt comme à chaque fois, il nous faut ajouter la commande dans le fichier `.travis.yml`.\n\n```yml\nscript:\n  - gulp scss:lint\n```\n\nLa seconde façon de vérifier la qualité du CSS est de faire des tests de non régression visuelle. Pour cela [BackstopJs](https://github.com/garris/BackstopJS){:rel=\"nofollow noreferrer\"} est une solution complète, qui permet de tester deux versions de votre code html/css.\n\nL'idée est de générer une version statique des pages de votre site avec votre code actuel et de stocker le résultat. Ensuite, vous pouvez faire des modifications de votre code et lancer les tests de régression visuelle, cela génère un site qui vous montre les différences entre les deux versions. À vous de décider si la différence est normale ou non.\n\nNous n'avons pas ajouté cette vérification dans la partie automatique de la CI, parce que souvent les tests montrent des différences normales et non des erreurs. Mais pour rendre ceci plus simple, nous avions généré le site statique de BackstopJs lors d'un merge dans master. Pour cela, nous utilisions la variable d'environnement de travis qui permet de connaître la branche, si celle-ci était un tag, nous déployions le site dans un bucket lisible par tout le monde et qui permettait de faire les vérifications manuelles.\n\nVoici l'exemple de configuration Travis.\n\n```yml\nlanguage: node_js\nnode_js:\n  - 6.7.0\nsudo: false\ncache:\n  directories:\n    - node_modules\n\nscript:\n  - make lint\n\ninstall:\n  - make install\n  - mkdir -p \"deploy/${TRAVIS_TAG}\"\n  - cp -R public/assets \"deploy/${TRAVIS_TAG}\"\n\ndeploy:\n  provider: gcs\n  access_key_id: GOOGLE_ID\n  secret_access_key:\n    secure: SECURE\n  bucket: BUCKET_NAME\n  acl: public-read\n  local-dir: deploy\n  skip_cleanup: true\n  on:\n    repo: lemonde/pattern-guides\n    branch: master\n    tags: true\n    condition: $TRAVIS_TAG =~ [0-9]+\\.[0-9]+\\.[0-9]+\n```\n\nNous avions avec cela gagné en qualité CSS et avons eu beaucoup moins de régression visuelle.\n\n### Partie WebPerformance\n\nParce que la WebPerformance, c'est aussi de la qualité, nous avons ajouté un outil dans notre CI pour suivre cette dernière.\n\nNous avons choisi [Speedcurve](https://speedcurve.com/){:rel=\"nofollow noreferrer\"}, un outil de monitoring simple d'utilisation et surtout qui permet de suivre les concurrents.\n\nSpeedcurve permet beaucoup de choses, nous avons essayé d'utiliser l'ensemble des fonctionnalités disponibles.\n\nLa première chose est de suivre la WebPerformance de votre site en production. Speedcurve va, selon votre configuration, se connecter plusieurs fois dans la journée sur votre site et faire des calculs de WebPerformance.\n\nSpeedcurve vous renvoie plusieurs indicateurs très sympas :\n\n - Start Render\n - Speed Index\n - Visually Complete\n - Page Load Time\n - css size\n - Image Size\n - etc ...\n\nCe qui est intéressant avec cette fonctionnalité, c'est de pouvoir suivre jour après jour votre WebPerformance.\n\nLa seconde chose est que vous pouvez mettre d'autres sites que le votre et donc vérifier votre WebPerformance par rapport aux autres.\n\nLa dernière fonctionnalité importante permet de lancer une demande de vérification via une API. Nous avions alors, après chaque mise en production lancée, un check sur Speedcurve en le nommant avec le numéro de la release mise en prod. Ceci permet ensuite de voir sur l'ensemble des dashboards disponible sur Speedcurve le moment de la mise en production, mais aussi de faire des comparaisons entre les releases.\n\n### Conclusion\n\nL'utilisation de l'ensemble des outils nous a permis de suivre la qualité de notre site dans le temps. Ceci permet d'éviter la dette technique qui peut très vite s'accumuler. Effectivement, cela prend du temps de mettre tous les outils en place, mais il faut savoir le prendre pour en gagner après. Nous avons mis plus de deux ans pour avoir l'ensemble des outils, allez y pas à pas et vous y arriverez.\n"}