{"date":"2015-10-26T00:00:00.000Z","title":"De qui je me mock !","excerpt":"Phpunit est un outil de test puissant. Il permet de tester de manière unitaire l'ensemble de son projet. Dans cet article, je vais me concentrer sur les mock et les stub d'objet.","readingTime":"7mn","authors":["tthuon"],"categories":["php"],"content":"\n[PHPUnit](https://phpunit.de/){:rel=\"nofollow noreferrer\"} est un outil de test puissant. Il permet de tester de manière unitaire l'ensemble de son projet.\n\nDans cet article, je vais me concentrer sur les mock et les stub d'objet.\n\n## Mock, stub, what else ?\n\nLorsque l'on teste unitairement une classe, très souvent, cette classe a des dépendances avec d'autres classes (qui elles-mêmes ont des dépendances avec d'autres classes.). L'objectif du test unitaire est de tester la classe cible, et uniquement cette classe. En admettant que les classes dépendantes soient fiables et retournent ce qui est attendu, il ne reste plus que la classe cible à tester.\n\nUn \"**stub**\" est un objet qui va simuler les différentes classes utilisées par la classe cible. Cet objet va toujours retourner la même valeur, quels que soient ses paramètres.\n\nUn \"**mock**\" est un \"**stub**\" dans lequel on va vérifier des attentes à des appels de méthodes. Par exemple, je vérifie qu'une méthode est appelée une fois.\n\n## Stub, un simple bouchon\n\nJe vais rentrer directement dans le cœur du sujet avec un exemple simple.\n\nJ'ai les classes suivantes:\n\n```php\n<?php\n\nclass Bouteille\n{\n    private $bouchon;\n\n    public function __construct(Bouchon $bouchon)\n   {\n         $this->bouchon = $bouchon;\n    }\n\n    public function getBouchon()\n    {\n         return $this->bouchon;\n    }\n\n    public function open()\n    {\n        $this->bouchon->popIt();\n    }\n}\n\nclass Bouchon\n{\n     private $type;\n\n     public function __construct($type)\n     {\n         $this->type = $type;\n     }\n\n     public function popIt()\n     {\n         return true;\n     }\n}\n```\n\nLa classe Bouteille a besoin de la classe Bouchon (une bouteille sans bouchon, c'est inutile).\n\nJe vais tester ma classe Bouteille et bouchonner la méthode getBouchon()\n\n```php\n<?php\n\nclass BouteilleTest extends \\PHPUnit_Framework_TestCase\n{\n    public function testGetBouchon()\n    {\n        $bouteille = $this->getMockBuilder(\"Bouteille\")->disableOriginalConstructor()->getMock();\n        $bouteille->method(\"getBouchon\")->will($this->returnValue(new Bouchon));\n\n        $this->assertInstanceOf(\"Bouchon\", $bouteille->getBouchon());\n    }\n}\n```\n\nTout d'abord, je crée le stub avec la méthode `getMockBuilder()`. Il prend en paramètre le nom de la classe. J'ai chaîné un appel à la méthode `disableOriginalConstructor()`  car je ne veux pas que le stub utilise le constructeur de la classe `Bouteille()` pour se construire. Enfin, la méthode `getMock()` me retourne le bouchon.\n\nA la ligne 8, je configure le bouchon. -&gt;method() . Il prend en paramètre le nom de la méthode à bouchonner. Ici, c'est getBouchon() . -&gt;will() indique la valeur qui va être retournée. Je place en paramètre une instance de `Bouchon()` : `$this->returnValue(new Bouchon())`.\n\nEnfin, ligne 10, je vérifie que getBouchon()  est bien une instance de `Bouchon()`.\n\nCe test démontre l'utilisation d'un bouchon. Le bouchon va toujours retourner la même valeur. Ici, je bouchonne la méthode `getBouchon()` pour toujours retourner une instance de `Bouchon()`.\n\nMaintenant, je vais tester que ma fonction `open()` ouvre bien la bouteille et fait appel à la méthode `popIt()`  de la classe `Bouchon()`.\n\n## Mock, le bouchon intelligent\n\nMon test va s’intéresser à la classe `Bouchon()`. Je veux vérifier que la méthode `popIt()`  est appelée une fois lorsque j'appelle la méthode `open()`  de la classe `Bouteille()`.\n\n```php\n<?php\n\nclass BouteilleTest extends \\PHPUnit_Framework_TestCase\n{\n    public function testOpen()\n    {\n        $bouchon = $this->getMock(\"Bouchon\");\n        $bouchon->expect($this->once())->method(\"popIt\");\n\n        $bouteille = new Bouteille($bouchon);\n        $bouteille->open();\n    }\n}\n```\n\nLa différence avec le test précédent est l'**assertion** dans la configuration du mock.\n\nA la ligne 7, la méthode `->expect()`  est l'assertion. Le paramètre prend en valeur le nombre de fois que la méthode sera appelée. Ici, c'est une fois `$this->once()`.\n\n### Et avec Symfony ?\n\nNous avons vu des exemples très théoriques sur l'utilisation des stub et des mock. Qu'en est-il avec Symfony ?\n\nJe vais prendre un exemple concret où un service fait appel au repository pour avoir des données depuis la base de données. Le service `UserService()` a une méthode `generateReport()` qui génère un rapport au format JSON. Pour avoir les statistiques de l'utilisateur, je vais créer une méthode `getStatsForUser()` qui va me retourner un array. Le contenu de la méthode ne m’intéresse pas car je vais le bouchonner. Par contre, je sais que cette méthode doit retourner un array.\n\nMon repository:\n\n```php\n<?php\n\nnamespace App\\AppBundle\\Repository;\n\nclass UserRepository extends DocumentRepository\n{\n    /**\n     * @param string $userId\n     *\n     * @return array\n     */\n    public function getStatsForUser($userId)\n    {\n        // a complicated aggration to get stats of user\n    }\n}\n```\n\nMon service:\n\n```php\n<?php\n\nnamespace App\\AppBundle\\Service;\n\nuse Doctrine\\ODM\\MongoDB\\DocumentManager;\n\nclass UserService\n{\n    private $manager;\n\n    public function __construct(DocumentManager $manager)\n    {\n        $this->manager = $manager;\n    }\n\n    public function generateReport($userId)\n    {\n        if (!$stats = $this->manager->getRepository(\"User\")->getStatsForUser($userId)){\n             return;\n        }\n\n        return json_encode($stats);\n    }\n}\n```\n\nMon test:\n\n```php\n<?php\n\nnamespace App\\AppBundle\\Tests;\n\nclass UserServiceTest extends \\PHPUnit_Framework_TestCase\n{\n  public function testGenerateReport()\n  {\n    $values = [\n        \"userId\" => \"dummy-user-id\",\n        \"nbArticle\" => 5,\n        \"lastPublication\" => \"2015-10-04T11:11:00+0200\"\n    ];\n\n    $expectedString = '{\"userId\":\"dummy-user-id\", \"nbArticle\":5, \"lastPublication\":\"2015-10-04T11:11:00+0200\"}';\n\n    $repository = $this->getMockBuilder('App\\AppBundle\\Repository\\UserRepository')\n      ->disableOriginalConstructor()\n      ->getMock();\n    $repository\n      ->expect($this->once())\n      ->method('getStatsForUser')\n      ->with(\"dummy-user-id\")\n      ->will($this->returnValue($values));\n\n    $manager = $this->getMockBuilder('Doctrine\\ODM\\MongoDB\\DocumentManager')\n        ->disableOriginalConstructor()\n        ->getMock();\n    $manager->expect($this->any())->method(\"getRepository\")->will($this->returnValue($repository));\n\n    $service = new UserService($manager);\n\n    $this->assertEquals($expectedString, $service->generateReport(\"dummy-user-id\"))\n  }\n}\n```\n\nDans ce test, j'ai décomposé bloc par bloc.\n\n-   ligne 9: c'est l'array qui sera retourné par la méthode `getStatsForUser()`\n-   ligne 15: la valeur finale de la méthode generateReport()\n-   lignes 17-24: je mock le repository et bouchonne la méthode getStatsForUser()` . J'utilise la variable $values  pour indiquer la valeur de retour de la méthode bouchonnée.\n-   lignes 26-29: je mock le document manager. Il va retourner le repository que j'ai précédemment configuré.\n-   ligne 31: j'injecte le mock dans mon service `UserService()`\n-   ligne 33: j'appelle la méthode `generateReport()` et je vérifie que j'ai bien la valeur de $expectedString .\n\nLe test permet de bien comprendre comment fonctionnent les différents objets et les différentes interactions.\n\nVoilà !\n\nN.B. : Injecter le document manager est totalement \"overkill\", mais c'était pour les besoins de l'exemple ^^.\n\nRéférence : <https://phpunit.de/manual/current/en/test-doubles.html>\n"}