{"date":"2015-11-12T00:00:00.000Z","title":"Pattern State","excerpt":"Explication du design pattern State et exemple d'implémentation dans une application Symfony via winzou/state-machine-bundle","readingTime":"7mn","authors":["nkania"],"categories":["php","architecture"],"content":"\n> **- Qu'est-ce que c'est ?**\n\nLe design pattern State, ou patron de conception Etat, permet la modification d'un objet en fonction de son statut. Pour faire simple, il vous permet d'exécuter des actions en fonction d'un contexte.\n\nPrenons un exemple. Imaginons que nous voulions mettre en place un système de traitement et de publication de vidéo avec le workflow suivant :\n\n- Demande de création\n- Récupération de la vidéo\n- Encodage + traitements\n- Envoi sur une plateforme de diffusion\n- Publication\n\nNous pourrions donc décider de traiter chaque demande unitairement de bout en bout, mais cela nous forcerait à rendre interdépendants les différents traitements et rendrait le code difficile à faire évoluer et à maintenir par la suite.\n\nOu alors, nous pouvons décider d'utiliser le pattern State afin de gérer ces différentes étapes indépendamment.\n\n> **- Comment ça marche ?**\n\nSi nous reprenons l'exemple de notre vidéo ci-dessus, nous pouvons donc dégager plusieurs étapes utiles à notre workflow :\n\n- *create*\n- *download*\n- *encode*\n- *upload*\n- *publish*\n\nCependant, ces étapes ne sont que des transitions, rien ne nous permet d'identifier qu'une étape est terminée, ce qui est gênant. Comment savoir que le téléchargement de la vidéo s'est bien déroulé et est terminé pour pouvoir passer à la suite ?\n\nNous avons donc besoin d'ajouter des statuts :\n\n- *new*\n- *creating*\n- *created*\n- *downloading*\n- *downloaded*\n- *encoding*\n- *encoded*\n- *uploading*\n- *uploaded*\n- *publishing*\n- *published*\n\nDe cette manière, nous pouvons facilement savoir dans quel état se trouve notre objet à l'instant T.\n\nDans le pattern State, les étapes n'ont pas conscience des autres. Elles n'ont qu'un but : faire passer notre objet d'un statut à un autre. Il faut donc définir le contexte de chaque étape. Celui-ci va permettre d'indiquer à quel moment une étape doit se déclencher sur l'objet en cours.\n\nImaginons le cas suivant :\n\n- On reçoit une demande de création de vidéo :\n\n * L'étape *create* est lancée\n * Notre objet passe en status *creating*\n * Une série de traitements s'effectue\n * Notre objet passe en statut *created*\n\nA partir de ce moment, nous avons donc un objet en état *created*.\n\n- La prochaine étape logique de notre workflow est donc l'étape de *download*:\n\n * L'étape *download* détecte que nous avons un objet en état *created* :\n * L'étape *download* est lancée\n * Notre objet passe en statut *downloading*\n * Une série de traitements s'effectue\n * Notre objet passe en statut *downloaded*\n\nEt ainsi de suite jusqu'à arriver à l'état published qui indique la fin de notre workflow (en effet, aucune étape n'est configurée pour débuter sur ce statut).\n\n> **- Dans quel cas l'utiliser ?**\n\nDe mon opinion, ce pattern est très pratique dans des cas assez complexes où beaucoup d'étapes sont nécessaires à l'élaboration d'un objet.\n\nIl est très souple et permet très facilement d'ajouter/modifier ou supprimer des étapes sans pour autant mettre en péril notre workflow.\n\nCependant, il reste des cas où il est inutile de l'utiliser, par exemple, sur un workflow assez simple. En effet, ce pattern est assez lourd à installer, donc il ne présenterait pas de gros gains. Il impose en effet une certaine manière de penser et de fonctionner qui n'est pas forcément courante.\n\n> **- Cas concret avec le bundle Symfony winzou/state-machine-bundle**\n\nCe bundle permet la mise en place d'une state machine assez facilement. En effet, il se base en grande partie sur de la config pour la gérer automatiquement. Vous pouvez trouver son dépôt ici : [https://github.com/winzou/StateMachineBundle](https://github.com/winzou/StateMachineBundle){:rel=\"nofollow noreferrer\"}\n\nDans notre cas, la configuration du bundle pourrait ressembler à ça :\n\n```yaml\n# app/config/config.yml\n\nwinzou_state_machine:\n    my_bundle_video:\n        class: My\\Bundle\\Entity\\Video\n        property_path: state\n        graph: simple\n        # list of all possible states:\n        states:\n            - creating\n            - created\n            - downloading\n            - downloaded\n            - encoding\n            - encoded\n            - uploading\n            - uploaded\n            - publishing\n            - published\n        # list of all possible transitions:\n        transitions:\n            create:\n                from: [new]\n                to: created\n            download\n                from: [created]\n                to: downloaded\n            encode\n                from: [downloaded]\n                to: encoded\n            upload\n                from: [encoded]\n                to: uploaded\n            publish\n                from: [uploaded]\n                to: published\n        # list of all callbacks\n        callbacks:\n            # will be called before applying a transition\n            before:\n                set_transitional_state:\n                    on:   ['create', 'download', 'encode', 'upload', 'publish']\n                    do:   [@my.awesome.service, 'setTransitionalState']\n                    args: ['object']\n```\n\nDe cette manière, chaque étape sait à quel statut elle doit se déclencher, fera appel à une méthode `setTransitionalState` qui se chargera de mettre à jour le statut en début d'étape (*creating*, *downloading*,...), et enfin définira le statut de fin lorsqu'elle aura terminé.\n\nEnsuite, il suffira juste de choisir de quelle manière activer chaque étape. On peut très bien imaginer la réception d'un call POST sur une url afin de déclencher l'étape *create*, puis des crons s'occupant de récupérer les objets vidéos et de les traiter en fonction de leurs statuts.\n\n> **- Conclusion**\n\nPour conclure, je pense que ce pattern est utile dans des workflows assez complexes où vous désirez découpler chaque étape. Il est possible de faire des choses très poussées qui n'ont pas été abordées dans cet article (toute la gestion d'erreur par exemple, car relancer une étape ne nécessite qu'un changement de statut).\n\nSee ya!\n"}