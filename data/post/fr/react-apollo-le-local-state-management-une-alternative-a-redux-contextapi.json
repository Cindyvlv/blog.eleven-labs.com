{"date":"2019-01-31T00:00:00.000Z","title":"React, le local state management d'Apollo, une alternative à Redux / ContextApi?","excerpt":"Si vous suivez notre blog ou nos différents meetups, vous avez sans doute entendu parler de la librairie React Apollo afin de gérer une API GraphQL. Depuis peu, celle-ci offre une autre manière de gérer le state de votre application afin de ne pas avoir à gérer un Redux, il est temps de voir ça d'un peu plus près !","readingTime":"11mn","authors":["rmavillaz"],"categories":["javascript"],"content":"\nSi vous suivez notre blog ou nos différents meetups, vous avez sans doute entendu parler de la librairie React Apollo afin de gérer une API GraphQL. Depuis peu, **celle-ci propose une autre manière de gérer le state de votre application React afin de ne pas avoir à gérer un Redux**, il est temps de voir ça d'un peu plus près !\n\nCela fait quelques années que les développeurs utilisent le duo React/Redux pour leurs applications front-end, ce dernier permettant de centraliser les données dans un store. Je pars du principe que vous êtes déjà familier avec ce concept, sinon je vous invite à en apprendre plus via [nos autres articles sur le blog](https://blog.eleven-labs.com/fr/redux-structurez-vos-applications-front/).\n\nMême si Redux est encore très présent, de nouveaux moyens permettent de gérer les données de son application comme le tout nouveau ContextAPI intégré directement à React. Pour ceux qui utilisent Apollo pour gérer une API GraphQL, sachez qu'il intégre également sa propre gestion du store répondant au nom de Local State Management. Nous allons voir ici comment l'utiliser et pourquoi.\n\n## Du GraphQL pour gérer ses données locales !\n\nHabituellement, pour récupérer/modifier des données sur une API GraphQL avec Apollo, il est assez courant d'utiliser les composants Query et Mutation afin d'effectuer les requêtes sur le serveur. Apollo stocke automatiquement les données récupérées dans un cache afin d'éviter deux fois la même requête en parcourant l'application. L'idée derrière le Local State Management est de **combiner vos données locales avec celles provenant du serveur !** De ce fait, on va écrire des **requêtes GraphQL en direction de son cache** !\n\nCela peut paraître assez étrange, mais il est possible d'écrire un nouveau schéma de données de la même manière que sur votre serveur GraphQL, sauf que celui-ci se destine uniquement à votre application front-end. Une sorte d'extension du schéma GraphQL serveur avec des données locales !\n\n## Un exemple vaut mieux qu'un long discours\n\nUtilisons ce fameux Local State management d'Apollo dans un exemple concret : **un système de notifications**. Dans notre application, il sera possible de faire apparaitre un message de notification pour spécifier qu'une action a bien été effectuée par l'utilisateur. La donnée de notification devra être stockée dans le cache Apollo afin d'être exploitable dans toute l'application.\n\n\n### Initialisation du client Apollo\nIci, notre client Apollo est déjà configuré, nous allons donc ajouter un nouveau module :\n```\nyarn add apollo-link-state\n```\nPuis on l'ajoute au client Apollo dans notre code :\n\n```js\n//client.js\nimport { withClientState } from  'apollo-link-state';\n\nconst stateLink = withClientState({\n  cache, // on injecte le cache de base d'Apollo\n  resolvers,\n  typeDefs,\n  defaults\n});\nconst client =  new ApolloClient({\n  connectToDevTools: true,\n  link: stateLink, // on l'ajoute le link à notre client Apollo\n  cache,\n});\n```\nComme vous pouvez le constater, le stateLink contient 4 paramètres dont resolvers, typeDefs, defaults. Cela ne vous rappelle rien ? Comme je le disais en début d'article, **on va pouvoir définir un schéma, des resolvers, afin d'exploiter les données, comme sur une API GraphQL** !\n\n### Création du schéma\n\nAvant d'injecter notre schéma dans le client, il faut créer notre fichier typeDefs.js :\n\n```json\n// typeDefs.js\nexport  const typeDefs =  `\n  enum NotificationType {\n    success\n    error\n    warning\n  }\n\n  type Notification {\n    header: String\n    content: String\n    type: NotificationType\n }\n\n  type Mutation {\n    newNotification(input: NotificationInput!): Boolean\n    deleteNotification(): Boolean\n  }\n\n  type Query {\n    Notification: Notification\n  }\n\n  input NotificationInput {\n    header: String\n    content: String\n    type: NotificationType\n  }\n`;\n```\nComme sur une API, on retrouve les types de Input, Query, Mutations, notre objet Notification ainsi qu'un enum. En lisant ce schéma, on comprend que l'on va pouvoir lire la notification, en ajouter et la supprimer.\n\n### Les resolvers\n\nAprès avoir défini notre schéma, il faut ajouter nos resolvers :\n\n```js\n//resolvers.js\nexport  const resolvers = {\n  Mutation: {\n    newNotification: (_, { input }, { cache }) => {\n      cache.writeData({\n         data: { Notification: { __typename: 'Notification', ...input } },\n      });\n\n      return  true;\n    },\n    deleteNotification: (_, variables, { cache }) => {\n      cache.writeData({ data: { Notification: null } });\n\n      return  true;\n    },\n  },\n};\n\nexport  default resolvers;\n```\nLe principe est relativement simple, on écrit directement dans le cache avec la méthode writeData. Notre input contient les paramètres envoyés à la mutation qui vont nous permettre de créer et insérer l'objet Notification dans notre cache.\nLa propriété **__typename** est obligatoire et nécessaire pour Apollo, il faut lui spécifier le nom de l'objet dans votre Schéma.\nIl est également possible de lire le cache avec le méthode readQuery si vous avez besoin des données précédentes avant la mutation. Par exemple, pour ajouter une nouvelle entrée à une liste.\n\nVous remarquerez qu'il n'y a pas de resolver pour la query Notification, en effet, Apollo se charge de la retrouver automatiquement.\n\n### Les requêtes\n\nMaintenant que nous avons fait notre schéma et nos resolvers, il ne reste plus qu'à créer les queries/mutations.\n\n```js\n//local/notification.js\nimport gql from  'graphql-tag';\n\nexport  const GET_NOTIFICATION =  gql`\n  query GET_NOTIFICATION {\n    getNotification @client {\n      content\n      header\n      type\n    }\n  }\n`;\n\nexport  const NEW_NOTIFICATION =  gql`\n  mutation NEW_NOTIFICATION ($input: NotificationInput!) {\n    newNotification(input: $input) @client\n  }\n`;\n\nexport  const DELETE_NOTIFICATION =  gql`\n  mutation DELETE_NOTIFICATION {\n    deleteNotification @client\n  }\n`;\n```\n\nPour éviter de les confondre avec les requêtes serveurs, je vous conseille de les mettre dans un dossier séparé nommé \"local\" ou \"client\" car la syntaxe est identique, et la seule chose qui vous permet de les différencier est **la directive @client**. Pensez-y, elle est très importante, sinon Apollo tentera une requête sur le serveur !\n\n### Les composants\n\nIl ne reste plus qu'à créer nos composants ! Le découpage est relativement simple, nous allons avoir un composant Notification qui va s'occuper d'exécuter la Query pour lire la notification dans le cache et l'afficher.\nPuis un HOC **withNotification** qui contiendra la mutation newNotification et qui permettra de l'injecter à n'importe quel composant qui a besoin de créer une notification.\n\n```js\nimport { GET_NOTIFICATION, DELETE_NOTIFICATION } from '../../graphql/local/notification';\nimport Message from './Message';\n\nconst Notification = () => (\n  <Mutation mutation={DELETE_NOTIFICATION}>\n    {deleteNotification => (\n      <Query query={GET_NOTIFICATION}>\n        {({ data: { Notification } = {} }) => {\n\n          return(\n            <Fragment>\n              {Notification && (\n                <Message\n                  header={Notification.header}\n                  content={Notification.content}\n                  onDismiss={deleteNotification}\n                  type={Notification.type}\n                  ttl={7000}\n                />\n              )}\n            </Fragment>\n          );\n        }}\n      </Query>\n    )}\n  </Mutation>\n);\n```\n\nLe composant est très simple avec une Query **GET_NOTIFICATION** qui va récupérer l'objet Notification, si celle-ci existe alors un message apparait. La Query agit comme un watcher, à chaque fois que l'objet Notification est manipulé dans le cache, un nouveau rendu est effectué !\nJ'ai également mis la mutation permettant de supprimer la notification car le composant Message possède une croix ou un TTL (time to live). Il éxecute la mutation lorsque l'utilisateur ferme le message ou au bout d'un certain temps (7000ms dans notre cas).\n\n```js\nimport { NEW_NOTIFICATION } from '../../graphql/local/notification';\n\nconst withNotification = WrappedComponent => class extends Component {\n  newNotification = ({ header, content, type = 'success' }) => {\n    this.mutate({\n      variables: {\n        input: { header, content, type },\n      },\n    });\n  }\n\n  render() {\n    return (\n      <Mutation mutation={NEW_NOTIFICATION}>\n        {(mutate) => {\n          this.mutate = mutate;\n\n          return (\n            <WrappedComponent\n              {...this.props}\n              newNotification={this.newNotification}\n            />\n          );\n        }}\n      </Mutation>\n    );\n  }\n};\n```\n\nVous risquez d'utiliser très souvent la mutation afin de créer des notifications dans votre application, personnellement, je préfère faire un HOC qui va injecter directement la fonction au composant enfant. Maintenant, il suffit d'ajouter ce HOC où bon vous semble afin de créer une notification !\n\n\n```js\nimport withNotification from './withNotification';\n\nconst Button = ({ newNotification }) => (\n  <button\n    onClick={() => newNotification({\n      header: 'Nouvelle notification',\n      content: 'J\\'ai cliqué sur le bouton !',\n    })}\n  >\n    Ajouter une notification\n  </button>\n);\n\nexport default withNotification(Button);\n```\n\nEt voilà, à chaque clic sur le bouton, le composant Notification affichera un nouveau message. Pourtant les 2 composants sont complètement indépendants !\n\n### Apollo DevTools\n\nPour les habitués d'Apollo, sachez qu'il existe une extension nommée Apollo DevTools, uniquement sur le navigateur Chrome. Elle permet d'éxecuter des Queries/Mutations via une interface exactement comme Playground. Etant donné que le Local State Management étend le schéma de votre API,  Apollo DevTools affiche également les requêtes en direction de son cache ! Plutôt pratique pour tester sans forçément manipuler l'interface de votre application.\n\n## Pour conclure\n\nLe Local State Management est un module intéressant de librairie Apollo car il présente plusieurs avantages. Premièrement, il vous évite de gérer et maintenir un Redux qui peut très vite devenir une usine à gaz ou un ContextApi, vous aurez donc juste à comprendre la librairie Apollo. Le code de votre application sera plus simple car vous utiliserez uniquement des composants Mutation/Query, je trouve cela assez fun de gérer son store avec des requêtes GraphQL.\n\nEn revanche, sachez que le Local State Management est encore très jeune et il présente quelques problèmes notamment pour la gestion des erreurs dans vos resolvers, il est assez difficile de debug pour l'instant. Néanmoins, pour une petite application avec une capacité de développement limitée, je vous conseille très fortement de l'utiliser, afin de vous concentrer uniquement sur Apollo ce qui peut vous faire gagner beaucoup de temps.\n\n\nVous pouvez retrouver plus d'informations sur la documentation officielle d'Apollo React :\n- [Local State Management](https://www.apollographql.com/docs/react/essentials/local-state.html)\n\nLe code est également disponible sur mon Github :\n- [Github](https://github.com/KizeRemi/local-state-management-tuto)\n"}