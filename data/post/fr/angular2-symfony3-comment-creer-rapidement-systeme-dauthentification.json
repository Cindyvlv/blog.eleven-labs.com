{"date":"2017-03-03T00:00:00.000Z","title":"Angular2 & Symfony3 : Comment créer rapidement un système d'authentification ?","excerpt":"Après avoir travaillé sur AngularJS, j'ai voulu tester la seconde version du framework : Angular2. Pour me faire la main, j'ai choisi de travailler sur un système d'authentification par token en utilisant Symfony pour la partie back-end, en incluant le bundle Lexik JWT Authentication.","readingTime":"22mn","authors":["glanau"],"categories":["php","javascript"],"content":"\nIntroduction\n============\n\nAprès avoir travaillé sur AngularJS, j'ai voulu tester la seconde version du framework : Angular2. Pour me faire la main, j'ai choisi de travailler sur un système d'authentification par token en utilisant Symfony pour la partie back-end, en incluant le bundle **Lexik JWT Authentication.**\n\nJe vous propose de voir ensemble un exemple très simple et les différentes étapes à suivre pour la mise en place d'une API sécurisée servant une liste de publications (...très privées) à notre application Angular2.\n\nSommaire\n========\n\n1.  **Mise en place de la partie Back-end**\n    1.  Installation d'une application Symfony3\n    2.  Installation des bundles nécessaires\n    3.  Création d'utilisateurs\n    4.  Création d'un jeu de données\n2.  **Mise en place de la partie Front-end**\n    1.  Création d'une application Angular2 via Angular CLI\n    2.  Création des différents composants\n    3.  Mise en place d'un système de routing\n    4.  Authentifier ses requêtes grâce à Angular2-jwt\n    5.  Protéger les routes authentifiées avec AuthGuard\n3.  **Conclusion**\n\n![](/imgs/posts/2017-03-03-angular2-symfony3-comment-creer-rapidement-systeme-dauthentification/sf-blog-2.png)\n\n---\n\n### **1 Mise en place de la partie Back-end**\n\n#### 1.1 Installation d'une application Symfony3\n\nInstallons tout d'abord la dernière version de Symfony3 via l'installeur prévu à cet effet sur le site officiel :\n\n```sh\nsymfony new api-lab\n```\n\nPuis lançons le serveur PHP interne via cette commande à la racine du projet :\n\n```sh\nbin/console server:start\n```\n\n#### 1.2 Installation des bundles nécessaires\n\nViens ensuite l'installation et la configuration de certains bundles incontournables lorsque l'on veut créer une API. Nous sauterons volontairement l'étape du \"composer require\" et de la déclaration des bundles dans le Kernel de Symfony pour passer directement à la configuration.\n\n##### **FOSRestBundle**\n\nCe bundle va nous permettre d'utiliser des routes API automatiques ainsi que de retourner des réponses au format Json à notre client Angular2 avec un minimum de configuration :\n\n```yaml\n# app/config/config.yml\nfos_rest:\n    routing_loader:\n        default_format: json\n    view:\n        view_response_listener: true\n```\n\n```yaml\n# app/config/routing.yml\napp:\n    resource: \"@AppBundle/Controller/\"\n    type: rest\n    prefix: /api\n```\n\n**[+ d'information sur la documentation](http://symfony.com/doc/current/bundles/FOSRestBundle/index.html){:rel=\"nofollow noreferrer\"}**\n\n##### **NelmioCorsBundle**\n\nContinuons ensuite avec le Bundle, qui va nous permettre de faire des requêtes Ajax sur l'API, étant donné que nos deux applications se trouvent sur deux domaines différents :\n\n```yaml\nnelmio_cors:\n    paths:\n        '^/api/':\n            allow_origin: ['http://localhost:4200']\n            allow_headers: ['origin', 'content-type', 'authorization']\n            allow_methods: ['POST', 'PUT', 'GET', 'DELETE']\n            max_age: 3600\n```\n\n*Note : Nous avons ici autorisé notre future application Angular2 ainsi que le header \"authorization\" qui nous servira à nous authentifier. Patience, on y est bientôt :)*\n\n##### **JMSSerializerBundle**\n\nCe bundle va nous permettre de sérialiser les données renvoyées par notre API. Aucune configuration n'est nécessaire dans le cadre de cet article. Nous utiliserons JMSSerializer plus tard, directement dans notre PostController.\n\n##### **LexikJWTAuthenticationBundle**\n\nEnfin,  last but not least, le bundle qui va nous servir à sécuriser l'accès à nos données Symfony via un token d'authentification. Je vous laisse lire la **[documentation](https://github.com/lexik/LexikJWTAuthenticationBundle/blob/master/Resources/doc/index.md#getting-started){:rel=\"nofollow noreferrer\"}** officielle qui est très claire. Il vous suffit vraiment de suivre les étapes point par point.\n\n*Note : J'ai ajouté deux petites lignes sous l'index \"form\\_login\" du security.yml de façon à pouvoir envoyer username & password au lieu de \\_username et \\_password pour nous authentifier auprès de notre API. Je vous invite à en faire de même :*\n\n```yaml\nusername_parameter: username\npassword_parameter: password\n```\n\nNous allons ensuite devoir générer des données de bases pour pouvoir tester notre système.\n\n#### 1.3 Création d'utilisateurs\n\nNous avons besoin d'un utilisateur. Il s'appellera \"gary\" et aura comme password \"pass\" (très original...). Pour ce faire nous n'allons pas mettre en place un système de gestion d'utilisateurs car ce n'est pas le but de cet article. Nous allons utiliser le système \"user in memory\" de Symfony. Je vous propose donc de rajouter un peu de configuration :\n\n```yaml\n# app/config/security.yml\nsecurity:\n    encoders:\n        Symfony\\Component\\Security\\Core\\User\\User: plaintext\n\n    providers:\n        in_memory:\n            memory:\n                users:\n                    gary:\n                        password: pass\n                        roles: 'ROLE_USER'\n```\n\n#### 1.4 Création d'un jeu de données\n\nNous allons avoir besoin de publications à renvoyer à notre client Angular2. Nous devons créer une entity \"Post\" qui sera la représentation de nos données.\n\n*Note : Nous n'ajouterons qu'une seule propriété \"title\" à cette entity pour les besoins de ce tutoriel même s'il serait utile que nos publications aient aussi un auteur, un contenu, une date de création, etc, etc...*\n\n```php\n<?php\n\nnamespace AppBundle\\Entity;\n\nuse Doctrine\\ORM\\Mapping as ORM;\nuse JMS\\Serializer\\Annotation as Serializer;\n\n/**\n * Post\n *\n * @ORM\\Table(name=\"posts\")\n * @ORM\\Entity\n *\n * @Serializer\\ExclusionPolicy(\"all\")\n */\nclass Post\n{\n    /**\n     * @var int\n     *\n     * @ORM\\Column(name=\"id\", type=\"integer\")\n     * @ORM\\Id\n     * @ORM\\GeneratedValue(strategy=\"AUTO\")\n     */\n    private $id;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(type=\"string\", length=255)\n     *\n     * @Serializer\\Expose\n     */\n    private $title;\n\n    /**\n     * Get id\n     *\n     * @return int\n     */\n    public function getId()\n    {\n        return $this->id;\n    }\n\n    /**\n     * Set title\n     *\n     * @param string $title\n     *\n     * @return Post\n     */\n    public function setTitle($title)\n    {\n        $this->title = $title;\n\n        return $this;\n    }\n\n    /**\n     * Get title\n     *\n     * @return string\n     */\n    public function getTitle()\n    {\n        return $this->title;\n    }\n}\n```\n\nUtilisons ensuite le **DoctrineFixturesBundle** (après l'avoir installé bien sûr !) pour générer deux publications en créant une classe LoadPostData :\n\n```php\n<?php\n\nnamespace AppBundle\\DataFixtures\\ORM;\n\nuse Doctrine\\Common\\DataFixtures\\FixtureInterface;\nuse Doctrine\\Common\\Persistence\\ObjectManager;\nuse AppBundle\\Entity\\Post;\n\nclass LoadPostData implements FixtureInterface\n{\n   public function load(ObjectManager $manager)\n   {\n      $post = new Post();\n      $post->setTitle('post1');\n\n      $post2 = new Post();\n      $post2->setTitle('post2');\n\n      $manager->persist($post);\n      $manager->persist($post2);\n      $manager->flush();\n   }\n}\n```\n\nCréons ensuite la base de données, le schéma, et chargeons les données via ces commandes :\n\n```sh\n# Création de la base\nbin/console do:da:cr\n\n# Création du schéma de données\nbin/console do:sc:cr\n\n# Générations des fixtures\nbin/console doctrine:fixtures:load\n```\n\nEnfin créons notre PostController avec la méthode qui sera le endpoint de notre micro API :\n\n```php\n<?php\n\nnamespace AppBundle\\Controller;\n\nuse FOS\\RestBundle\\Controller\\FOSRestController;\nuse FOS\\RestBundle\\Routing\\ClassResourceInterface;\nuse FOS\\RestBundle\\Controller\\Annotations as Rest;\n\nclass PostController extends FOSRestController implements ClassResourceInterface\n{\n    /**\n     * @Rest\\View()\n     */\n    public function cgetAction()\n    {\n        return $this->getDoctrine()->getRepository('AppBundle:Post')->findAll();\n    }\n}\n```\n\nNous voilà parés ! Vous pouvez dès lors tester la partie back-end en faisant une requête POST vers notre endpoint :\n\n```sh\ncurl -X POST http://localhost:8000/api/login_check -d username=gary -d password=pass\n```\n\nSi tout va bien, vous devriez recevoir un token d'authentification.\n\nC'est le cas ? Très bien, nous allons pouvoir commencer la partie front-end :)\n\n![](/imgs/posts/2017-03-03-angular2-symfony3-comment-creer-rapidement-systeme-dauthentification/ng-blog.png)\n\n---\n\n### **2 Mise en place de la partie Front-end**\n\n#### 2.1 Création de l'application Angular2 via Angular CLI\n\nInstallons tout d'abord Angular CLI globalement sur notre machine. Cet outil va nous servir à générer la structure de notre application via une simple commande et à recompiler à la volée nos modifications :\n\n```sh\nnpm install -g @angular/cli\n```\n\nCréons ensuite notre application :\n\n```sh\nng new api-lab\n```\n\nPuis lançons notre serveur interne :\n\n```sh\ncd api-lab && ng serve\n```\n\nMaintenant que notre application est lancée, vous pouvez vous rendre sur l'url indiquée dans votre console pour accéder à votre application :\n\n<http://localhost:4200>\n\nVous devriez alors voir apparaître : **app works!**\n\n#### 2.2 Création des différents composants\n\nNous allons ensuite générer trois composants principaux supplémentaires :\n\n-   homepage\n-   authentication\n-   post\n\nCommençons notre composant \"homepage\" en lançant la commande suivante :\n\n```sh\nng g c homepage\n```\n\n*Note : \"g\" pour generate et \"c\" pour... component :)*\n\n```js\n// homepage/homepage.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-homepage',\n  templateUrl: './homepage.component.html',\n})\nexport class HomepageComponent {}\n```\n\n*Note : vous remarquerez que nous avons enlevé la déclaration du fichier css. En effet, nous inclurons bootstrap pour styliser rapidement notre application.*\n\n```html\n<!-- homepage/homepage.html -->\n<h1>Home</h1>\n```\n\nCréons ensuite le composant \"authentication\" de la même manière :\n\n```sh\nng g c authentication\n```\n\n```js\n// authentication/authentication.component.ts\nimport { Component } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators } from '@angular/forms';\nimport { Router } from '@angular/router';\n\nimport { AuthenticationService } from './authentication.service';\n\n@Component({\n  selector: 'app-authentication',\n  templateUrl: './authentication.component.html',\n})\nexport class AuthenticationComponent {\n    loginForm: FormGroup;\n    error: string = '';\n\n    constructor(\n        private formBuilder: FormBuilder,\n        private authenticationService: AuthenticationService,\n        private router: Router\n    ) {\n        this.loginForm = formBuilder.group({\n            'username': ['', Validators.required],\n            'password': ['', Validators.required]\n        });\n    }\n\n    onSubmit() {\n        this.authenticationService\n            .authenticate(this.loginForm.value)\n            .subscribe(\n                data => {\n                    localStorage.setItem('id_token', data.token);\n                    this.router.navigate(['post']);\n                },\n                error => this.error = error.message\n            );\n    }\n}\n```\n\n```html\n<!-- authentication/authentication.component.html -->\n<h1>Login</h1>\n<div>\n\t<div [hidden]=\"!error\" class=\"alert alert-danger\" role=\"alert\">\n\t  \t<span class=\"glyphicon glyphicon-exclamation-sign\" aria-hidden=\"true\"></span>\n\t  \t<span class=\"sr-only\">Error:</span>\n\t  \t{{ error }}\n\t</div>\n\t<form [formGroup]=\"loginForm\" (ngSubmit)=\"onSubmit()\">\n\t\t<div class=\"form-group\">\n\t\t\t<input type=\"text\" class=\"form-control\" placeholder=\"Username*\" formControlName=\"username\">\n\t\t</div>\n\n\t\t<div class=\"form-group\">\n\t\t\t<input type=\"password\" class=\"form-control\" placeholder=\"Password*\" formControlName=\"password\">\n\t\t</div>\n\n\t\t<button type=\"submit\" class=\"btn btn-success pull-right\" [disabled]=\"!loginForm.valid\">Submit</button>\n\t</form>\n</div>\n```\n\nCe composant sera notre formulaire d'authentification vers notre API. Nous utiliserons le module ReactiveFormsModule de Angular2 pour une mise en place plus simple sans utiliser la directive \\[(ngModel)\\] très gourmande en ressources et pour pouvoir lui attribuer des validateurs.\n\nPassons ensuite à la création du composant \"post\" :\n\n```sh\nng g c post\n```\n\n```js\n// post/post.component.ts\nimport { Component, OnInit } from '@angular/core';\n\nimport { PostRepository } from './post-repository.service';\n\n@Component({\n  selector: 'app-post',\n  templateUrl: './post.component.html'\n})\nexport class PostComponent implements OnInit {\n    posts: any[] = [];\n    error: string = '';\n\n    constructor(private postRepository: PostRepository) {}\n\n    ngOnInit() {\n        this.postRepository\n            .getList()\n            .subscribe(\n                data => this.posts = data,\n                error => this.error = error.message\n            );\n    }\n}\n```\n\n```html\n<!-- post/post.component.html -->\n<h1>Posts</h1>\n<div [hidden]=\"!error\" class=\"alert alert-danger\" role=\"alert\">\n  \t<span class=\"glyphicon glyphicon-exclamation-sign\" aria-hidden=\"true\"></span>\n  \t<span class=\"sr-only\">Error:</span>\n  \t{{ error }}\n</div>\n<ul>\n\t<li *ngFor=\"let post of posts\">\n\t\t<a href=\"#\">{{ post.title }}</a>\n\t</li>\n</ul>\n```\n\nPour finir, nous allons ajouter deux services à notre application.\n\n-   Un service qui nous servira à nous authentifier sur notre API et à gérer le login & logout\n-   Un service qui nous servira à requêter notre endpoint qui nous renverra notre liste de publications\n\nPour se faire, lancez les commandes suivantes :\n\n```\nng g s authentication/authentication --flat\n```\n\n*Note : \"g\" pour generate, \"s\" pour... service (je sais que vous saviez !) et \"--flat\" pour créer des composants sans dossiers :)*\n\n```js\n// authentication/authentication.service.ts\nimport { Injectable } from '@angular/core';\nimport { Http, Response, Headers, RequestOptions, URLSearchParams } from '@angular/http';\nimport { tokenNotExpired } from 'angular2-jwt';\n\nimport 'rxjs/add/operator/map';\n\n@Injectable()\nexport class AuthenticationService {\n\n  constructor(private http: Http) {}\n\n  authenticate(user: any) {\n      let url     = 'http://127.0.0.1:8000/api/login_check';\n        let body     = new URLSearchParams();\n        body.append('username', user.username);\n        body.append('password', user.password);\n      let headers = new Headers({'Content-Type': 'application/x-www-form-urlencoded'});\n        let options = new RequestOptions({headers: headers});\n\n      return this.http\n              .post(url, body.toString(), options)\n          .map((data: Response) => data.json());\n  }\n\n  logout() {\n    localStorage.removeItem('id_token');\n  }\n\n  loggedIn() {\n    return tokenNotExpired();\n  }\n}\n```\n\n```sh\nng g s post/post-repository --flat\n```\n\n```js\n// post/post-repository.service.ts\nimport { Injectable } from '@angular/core';\nimport { Response } from '@angular/http';\nimport { AuthHttp } from 'angular2-jwt';\n\n@Injectable()\nexport class PostRepository {\n\n  constructor(private authHttp: AuthHttp) {}\n\n  getList() {\n      let url = 'http://127.0.0.1:8000/api/posts';\n\n    return this.authHttp\n          .get(url)\n          .map((data: Response) => data.json());\n  }\n}\n```\n\n*Note : Nous remarquerons que nous utilisons Http dans l'authentication service alors que nous utilisons AuthHttp dans le post-repository service. Il y a une très bonne raison à cela. En effet, comme il est écrit dans la documentation de la librairie Angular2-jwt :*\n\n> This library does not have any functionality for (or opinion about) implementing user authentication and retrieving JWTs to begin with. Those details will vary depending on your setup, but in most cases, you will use a regular HTTP request to authenticate your users and then save their JWTs in local storage or in a cookie if successful.\n\nEn d'autres termes, cette librairie n'est pas faite pour s'authentifier et stocker notre token. Pour cette étape, il vaut mieux privilégier l'utilisation du module Http basique livré avec Angular2.\n\n#### 2.3 Mise en place d'un système de routing\n\nNous allons maintenant nous occuper du routing. En effet nous n'avons pour l'instant aucun moyen d'afficher le contenu qui se trouve dans les fichiers html de nos composants. Pour configurer le routing de votre application, c'est très simple. Nous allons créer un fichier app.routing.ts à la racine de notre application et indiquer les trois routes de nos composants principaux ainsi que la route de redirection au cas où nous entrions une url qui ne correspond à aucune route :\n\n```js\n// app.routing.ts\nimport { Routes, RouterModule } from '@angular/router';\n\nimport { HomepageComponent } from './homepage/homepage.component';\nimport { AuthenticationComponent } from './authentication/authentication.component';\nimport { PostComponent } from './post/post.component';\nimport { AuthGuard } from './_guard/index';\n\nconst APP_ROUTES: Routes = [\n    {\n        path: '',\n        component: HomepageComponent\n    },\n    {\n        path: 'login',\n        component: AuthenticationComponent\n    },\n    {\n        path: 'post',\n        component: PostComponent,\n        canActivate: [AuthGuard]\n    },\n    { path: '**', redirectTo: '' }\n];\n\nexport const Routing = RouterModule.forRoot(APP_ROUTES);\n```\n\n#### 2.4 Protéger les routes authentifiées avec AuthGuard\n\nPour finir, nous allons mettre en place un système permettant de protéger nos routes sécurisées via Guard. Créons un dossier \"\\_guard\" dans le dossier \"app\" contenant deux fichiers :\n\n```js\n// _guard/auth.guard.ts\nimport { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { CanActivate } from '@angular/router';\nimport { AuthenticationService } from '../authentication/authentication.service';\n\n@Injectable()\nexport class AuthGuard implements CanActivate {\n\n    constructor(private authentication: AuthenticationService, private router: Router) {}\n\n    canActivate() {\n        if(this.authentication.loggedIn()) {\n            return true;\n        } else {\n            this.router.navigate(['login']);\n\n            return false;\n        }\n    }\n}\n```\n\n```js\n// _guard/index.ts\nexport * from './auth.guard';\n```\n\nNous importerons le fichier index.ts dans notre fichier app.module.ts et nous déclarerons AuthGuard en tant que provider puis nous l'importerons également dans notre fichier app.routing.ts pour protéger notre route \"post\" via la propriété \"canActivate\".\n\n#### 2.5 Authentifier ses requêtes avec Angular2-jwt\n\nPourquoi ai-je choisi d'utiliser cette librairie ? Et bien tout d'abord pour l'essayer. Et puis parce qu'elle va nous simplifier la vie. Enfin du moins l'envoi des requêtes vers notre API dans un premier temps.\n\nEn effet, ce wrapper du module Http natif d'Angular2 permet d'inclure directement l'id\\_token contenu dans le localStorage, dans un header \"authorization\" compatible avec le format utilisé par notre LexikJwtAuthenticationBundle.\n\nLe deuxième avantage de cette librairie est qu'elle va automatiquement vérifier si le token est valide. Ce qui n'est pas du tout négligeable.\n\nInstallons angular2-jwt via npm à la racine du projet en lançant cette commande :\n\n```sh\nnpm install angular2-jwt\n```\n\nMaintenant que nous avons structuré notre application, il nous faut mettre à jour notre composant \"app\" ainsi que notre fichier app.module.ts avec les imports nécessaires :\n\n```js\n// app.component.ts\nimport { Component } from '@angular/core';\nimport { Router } from '@angular/router';\n\nimport { AuthenticationService } from './authentication/authentication.service';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html'\n})\nexport class AppComponent {\n\n    constructor(private authenticationService: AuthenticationService, private router: Router) {}\n\n    hasAuthToken() {\n        return localStorage.getItem('id_token') !== null;\n    }\n\n    logout() {\n         this.authenticationService.logout();\n             this.router.navigate(['home']);\n    }\n}\n```\n\n```html\n<!-- app.component.html -->\n<nav class=\"navbar navbar-inverse navbar-fixed-top\">\n    <div class=\"container\">\n        <div class=\"navbar-header\">\n            <button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\">\n                <span class=\"sr-only\">Toggle navigation</span>\n                <span class=\"icon-bar\"></span>\n                <span class=\"icon-bar\"></span>\n                <span class=\"icon-bar\"></span>\n            </button>\n            <img class=\"pull-left logo\" src=\"../assets/images/ng-xs.png\" alt=\"Angular2\">\n            <a class=\"navbar-brand\" [routerLink]=\"['']\">Api Lab</a>\n        </div>\n        <div id=\"navbar\" class=\"collapse navbar-collapse\">\n            <ul class=\"nav navbar-nav\">\n                <li><a [routerLink]=\"['']\">Home</a></li>\n                <li><a [routerLink]=\"['post']\">Posts</a></li>\n            </ul>\n            <ul class=\"nav navbar-nav pull-right\">\n                <li *ngIf=\"!hasAuthToken()\"><a [routerLink]=\"['login']\">Login</a></li>\n                <li *ngIf=\"hasAuthToken()\"><a (click)=\"logout()\" href=\"#\">Logout</a></li>\n            </ul>\n        </div>\n    </div>\n</nav>\n\n<router-outlet></router-outlet>\n```\n\n```js\n// app.module.ts\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport { Http, HttpModule, RequestOptions } from '@angular/http';\nimport { AuthHttp, AuthConfig } from 'angular2-jwt';\n\nimport { AppComponent } from './app.component';\nimport { Routing } from './app.routing';\nimport { AuthGuard } from './_guard/index';\n\nimport { AuthenticationComponent } from './authentication/authentication.component';\nimport { AuthenticationService } from './authentication/authentication.service';\nimport { HomepageComponent } from './homepage/homepage.component';\nimport { PostComponent } from './post/post.component';\nimport { PostRepository } from './post/post-repository.service';\n\nexport function authHttpServiceFactory(http: Http, options: RequestOptions) {\n    return new AuthHttp( new AuthConfig({}), http, options);\n}\n\n@NgModule({\n     declarations: [\n         AppComponent,\n         AuthenticationComponent,\n         HomepageComponent,\n         PostComponent\n     ],\n     imports: [\n         BrowserModule,\n         ReactiveFormsModule,\n         HttpModule,\n         Routing\n     ],\n     providers: [\n     {\n         provide: AuthHttp,\n         useFactory: authHttpServiceFactory,\n         deps: [ Http, RequestOptions ]\n     },\n         AuthGuard,\n         AuthenticationService,\n         PostRepository\n     ],\n     bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n*Note : J'ai délibérément inclus la factory authHttpServiceFactory directement dans ce fichier contrairement à ce que dit la documentation car il y a un bug connu de la team Angular2-jwt lors de la compilation* *qui peut être résolu de cette manière :)*\n\nEnfin, pour finaliser notre application, il ne reste plus qu'à lui appliquer un peu de style :\n\n```html\n<!-- index.html -->\n\n<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Api Lab</title>\n  <base href=\"/\">\n\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n  <link rel=\"icon\" type=\"image/x-icon\" href=\"../../public/favicon.ico\">\n  <script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"\n    integrity=\"sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=\"\n    crossorigin=\"anonymous\">\n  </script>\n  <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n</head>\n<body>\n  <div class=\"container\">\n  \t<app-root><div class=\"text-center loading\">Loading...</div></app-root>\n  </div>\n\n  <script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\"></script>\n</body>\n</html>\n```\n\n```css\n// style.css\n/* You can add global styles to this file, and also import other style files */\nbody {\n    padding-top: 50px;\n}\n\n.loading {\n    font-weight: bold;\n    margin-top: 150px;\n}\n\n.logo {\n    margin: 5px;\n}\n```\n\nEt voilà le travail !\n\n![](/imgs/posts/2017-03-03-angular2-symfony3-comment-creer-rapidement-systeme-dauthentification/Capture-decran-2017-03-03-a-01.58.49.png)\n\n![](/imgs/posts/2017-03-03-angular2-symfony3-comment-creer-rapidement-systeme-dauthentification/Capture-decran-2017-03-03-a-13.28.40.png)\n\n### 3 Conclusion\n\nPour conclure, je dirais que cette expérience s'est avérée très enrichissante. Angular2 propose une nouvelle perception du framework front-end en comparaison à la première version. Une façon de développer qui se rapproche plus de la programmation orientée objet et rappelle étrangement les frameworks PHP au niveau de la structures des fichiers. Enfin le CLI, bien que toujours en version beta, reste un outil très pratique dans la lignée de la console de Symfony. Une très bonne première expérience. To be continued !\n"}