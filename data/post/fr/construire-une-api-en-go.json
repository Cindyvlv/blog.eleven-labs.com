{"date":"2017-07-26T00:00:00.000Z","title":"Construire une api en Go","excerpt":"Présentation du package http/net et de la librairie Buffalo","readingTime":"9mn","authors":["qneyrat"],"categories":[],"content":"\nLe langage Go est rapidement devenu très populaire mais beaucoup hésitent encore à l'utiliser pour le développement de leurs nouvelles applications. Nous allons ici voir comment construire une api REST rapidement et facilement.\n\n----------\n\n\nIntroduction\n-------------\n\nLa particularité du langage Go est sa simplicité d’écriture. La syntaxe est inspirée du langage C avec un code procédural. Il n’intègre pas de concept de classes mais fournit les mécanismes nécessaires à l’écriture de code dans un style orienté objet. Le code est concis et clair, principe KISS (Keep It Simple, Stupid). Nous allons donc voir comment utiliser ce language pour faire du web. Nous verrons dans un premier temps une implémentation du package \"net/http\" pour la création d'une api REST. Dans un second temps, je vous présenterai un utilitaire pour faciliter le développement d'une application web : **Buffalo**.\n\nPackage \"http/net\"\n-------------\n\nDocumentation du package : https://golang.org/pkg/net/http/.\n\nPour commencer, nous allons créer un serveur http qui va écouter sur le port `8001`.\n\n```go\npackage main\n\nimport \"net/http\"\n\nfunc main() {\n\t//TO DO Implement handler\n\thttp.ListenAndServe(\":8001\", nil)\n}\n```\n\nPour démarrer le serveur, il suffit d’exécuter le fichier `main.go` avec la commande :\n\n```\ngo run main.go\n```\n\nSi vous essayez de faire une requête http sur `127.0.0.1:8001`, le serveur vous retournera une `404` puisque la route `/` n'est pas spécifiée. Pour remédier à ce problème il faut implémenter un handler sur `/`.\n\n```go\n// Handle registers the handler for the given pattern\n// in the DefaultServeMux.\n// The documentation for ServeMux explains how patterns are matched.\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\n```\n\nPour cela, http.Handle a besoin d'un modèle qui va correspondre à la route de la requête et à un handler.\n\n```go\ntype Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}\n```\n\nUn handler a besoin d’un objet de type `ResponseWriter` et de la requête. Nous allons créer une méthode `handler`. Ici, pour une api REST, la réponse doit être au format JSON. Nous allons donc ajouter au header le content-type JSON et retourner du contenu JSON. La méthode `Write` de `ResponseWriter` prend en paramètre un tableau de byte. Donc on ‘caste’ notre string contenant du JSON vers le format bytes avec la méthode `byte[](string)`.\n\n```go\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", \"application/json\")\n\tw.Write([]byte(`{\"message\": \"Hello world !\"}`))\n}\n```\n\nLe code final de notre serveur donne donc :\n\n```go\npackage main\n\nimport \"net/http\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", \"application/json\")\n\tw.Write([]byte(`{\"message\": \"hello world\"}`))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8001\", nil)\n}\n\n```\n\nCette fois-ci, si on lance le serveur et que l’on fait une requête http sur `127.0.0.1:8001`, le serveur répond bien un code 200 avec notre message en JSON.\n\nCe package est très bas niveau et assez pénible à utiliser. La communauté a donc mis à disposition différentes surcouches notamment au niveau du routing pour faciliter le développement.\n\nPrésentation de Buffalo\n-------------\n\nBuffalo est une librairie permettant de faciliter le développement avec Go. Elle utilise principalement les librairies de Gorilla `https://github.com/gorilla`.\n\nPour installer buffalo lancer la commande :\n\n```\ngo get -u -v github.com/gobuffalo/buffalo/buffalo\n```\n\nUne fois buffalo installé,\n\n```\n> $ buffalo help new\nBuffalo version v0.9.0\n\nCreates a new Buffalo application\n\nUsage:\n  buffalo new [name] [flags]\n\nFlags:\n      --api                  skip all front-end code and configure for an API server\n      --ci-provider string   specify the type of ci file you would like buffalo to generate [none, travis, gitlab-ci] (default \\\"none\\\")\n      --db-type string       specify the type of database you want to use [postgres, mysql, sqlite3] (default \\\"postgres\\\")\n      --docker string        specify the type of Docker file to generate [none, multi, standard] (default \\\"multi\\\")\n  -f, --force                delete and remake if the app already exists\n  -h, --help                 help for new\n      --skip-dep             skips adding github.com/golang/dep to your app\n      --skip-pop             skips adding pop/soda to your app\n      --skip-webpack         skips adding Webpack to your app\n  -v, --verbose              verbosely print out the go get/install commands\n      --with-yarn            allows the use of yarn instead of npm as dependency manager\n\n```\n\nLa commande `new` permet de générer un nouveau projet. On va donc créer un projet api sans la base de données qui est gérée par `pop`. Nous allons donc lancer cette commande pour générer la base de notre api REST. Placez-vous dans votre répertoire de travail (`$GOPATH/src/your_user_name` par exemple) et lancez la commande suivante :\n\n```\nbuffalo new api --api --skip-pop\n```\n\nCette commande a créé le dossier `api`. Celui-ci comprend :\n* le fichier `main.go`, il s’agit de l’entrée de l'application ;\n* le dossier `actions/` il s’agit du dossier contenant nos handlers ;\n* le dossier `grifts/` il s’agit du dossier contenant les commandes\n\nLe reste des fichiers ne nous intéresse pas.\n\nLancez le serveur :\n\n```\nbuffalo dev\n```\n\nCeci va compiler votre projet et démarrer le serveur.\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\t\"qneyrat/api/actions\"\n\n\t\"github.com/gobuffalo/envy\"\n)\n\nfunc main() {\n\tport := envy.Get(\"PORT\", \"3000\")\n\tapp := actions.App()\n\tlog.Fatal(app.Start(port))\n}\n\n```\n\nNous allons regarder ce que fait la méthode `app.start()`.\n\n```go\n// ...\nserver := http.Server{\n\t\tAddr:    fmt.Sprintf(\":%s\", addr),\n\t\tHandler: a,\n\t}\n\n// ...\nerr := server.ListenAndServe()\n```\n\nComme dans la première partie, Buffalo démarre le serveur http du package \"http/net\".\n\nLancez une requête sur `127.0.0.1:3000`, celle-ci nous retourne bien une réponse JSON. Allons maintenant voir dans `actions.App()` ce qu’il se passe.\n\n```go\nfunc App() *buffalo.App {\n\tif app == nil {\n\t\t//...\n\n\t\tapp.GET(\"/\", HomeHandler)\n\n\t}\n\n\treturn app\n}\n```\n\nLa function `App()` va attacher à l'instance de `*buffalo.App` les handlers de notre api. Ici, un handler est attaché à la route `/`. Le handler `HomeHandler` est du type `Handler`.\n\n```go\ntype Handler func(Context) error\n```\n\nHandler prend en paramètre un `Context`.\n\n```go\n// Context holds on to information as you\n// pass it down through middleware, Handlers,\n// templates, etc... It strives to make your\n// life a happier one.\ntype Context interface {\n\tcontext.Context\n\tResponse() http.ResponseWriter\n\tRequest() *http.Request\n\tSession() *Session\n\tParams() ParamValues\n\tParam(string) string\n\tSet(string, interface{})\n\tLogField(string, interface{})\n\tLogFields(map[string]interface{})\n\tLogger() Logger\n\tBind(interface{}) error\n\tRender(int, render.Renderer) error\n\tError(int, error) error\n\tWebsocket() (*websocket.Conn, error)\n\tRedirect(int, string, ...interface{}) error\n\tData() map[string]interface{}\n\tFlash() *Flash\n}\n```\n\nL'interface `Context` va contenir le `http.ResponseWriter` et `*http.Request` comme dans l'exemple de la première partie. On peut remarquer que `Context` dispose de plein d'autres interfaces qui permettront de faciliter le développement de notre handler.\n\nPar exemple, pour retourner notre message JSON, on utilise `Render`.\n\n```go\nreturn c.Render(200, r.JSON(map[string]string{\"message\": \"Welcome to Buffalo!\"}))\n```\n\nVous pouvez maintenant construire l'application et lancer le serveur. Buffalo offre un mode `dev` qui va automatiquement recompiler votre application lorsque vous faites une modification dans le code. Pour cela, lancez la commande :\n\n```\nbuffalo dev\n```\n\nMaintenant, si vous essayez de faire une requête sur `127.0.0.1:3000`, vous aurez bien votre message `Welcome to Buffalo!` en JSON.\n\nPour faciliter le développement buffalo intègre le package `grifts` qui permet la création de commandes. Les commandes sont déclarées dans le dossier `grifts`.\n\n```\nbuffalo task list\n```\n\nPar défaut, il existe la commande `routes` qui permet de voir l'ensemble des routes et les handlers. Pour lancer cette commande, on va d'abord construire l'application pour contruire les routes puis jouer la tâche `routes`.\n\n```\nbuffalo build\nbuffalo task routes\n```\nMaintenant que buffalo a été présenté, nous allons créer de nouvelles routes. Vous pouvez retrouver l'ensemble du code sur mon github [https://github.com/qneyrat/api](https://github.com/qneyrat/api){:rel=\"nofollow noreferrer\"}.\n\nNous allons gérer une nouvelle ressource pour notre api, la ressource `user`.\n\nCréez le dossier `models` et dedans le fichier `user.go`. On va déclarer une structure `User` composé d'un `ID`.\n\n```go\npackage models\n\nimport (\n\t\"github.com/satori/go.uuid\"\n)\n\ntype User struct {\n\tID uuid.UUID `json:\"id\"`\n}\n\n```\n\nCréez une nouvelle action dans le dossier `actions` pour gérer la ressource `user`. Créez donc un fichier `users.go`.\nPour s'abstraire d'une base de données, on va créer une map pour stocker nos utilisateurs.\n\n```go\nvar db = make(map[uuid.UUID]models.User)\n```\n\nOn va donc créer une fonction pour retourner dans un JSON l'ensemble des utilisateurs stockés dans \"base de données\" `db`. Pour regrouper l'ensemble des handlers qui vont gérer notre ressource `user`, on va créer une structure vide pour y attacher nos fonctions.\n\n```go\ntype UserResource struct{}\n\nfunc (ur UserResource) List(c buffalo.Context) error {\n\treturn c.Render(200, r.JSON(db))\n}\n```\n\nOn va maintenant attacher ce nouvel handler à une route dans le fichier `app.go`. Avant cela on va faire préfixer nos routes par `/api/v1`.\n\n```go\n// on préfixe nos nouvelles routes par /api/v1\ng := app.Group(\"/api/v1\")\n\n// on déclare notre UserResource\nur := &UserResource{}\n\n// on déclare notre route get qu'on rattache au handler UserResource.List\n// le path est donc /api/v1/users\ng.GET(\"/users\", ur.List)\n```\n\nSi vous faites donc un `GET` sur `/api/v1/users`, l'api vous retourne une collection vide puisqu'il n'y a pas encore d’utilisateur.\nOn va donc créer un nouveau handler qui va en créer un.\n\n```go\n// Create User.\nfunc (ur UserResource) Create(c buffalo.Context) error {\n\t// on crée un nouvel utilisateur\n\tuser := &models.User{\n\t\t// on génère un nouvel id\n\t\tID: uuid.NewV4(),\n\t}\n\t// on l'ajoute à notre base de données\n\tdb[user.ID] = *user\n\n\treturn c.Render(201, r.JSON(user))\n}\n\n```\n\nOn ajoute la route dans `app.go`.\n\n```go\ng.POST(\"/users\", ur.Create)\n```\n\nMaintenant, si vous faites un `POST` sur `/api/v1/users`, l'api vous retournera une 201 et vous informera que l’utilisateur a bien été créé. On va donc vérifier dans notre liste d’utilisateurs. Donc on fait un `GET` sur `/api/v1/users` et on constate qu’on a bien notre utilisateur dans la collection.\n\nPour finir, nous allons maintenant faire un handler pour afficher un utilisateur spécifique. On va donc créer un handler sur la route `/users/{id}`.\n\n```go\nfunc (ur UserResource) Show(c buffalo.Context) error {\n\t// on récupère l'id de la requête qu'on formate en uuid\n\tid, err := uuid.FromString(c.Param(\"id\"))\n\tif err != nil {\n\t\t// si l'id n'est pas un uuid on génère une erreur\n\t\treturn c.Render(500, r.String(\"id is not uuid v4\"))\n\t}\n\n\t// on récupère notre utilisateur dans notre base de données\n\tuser, ok := db[id]\n\tif ok {\n\t\t// si il existe, on le retourne\n\t\treturn c.Render(200, r.JSON(user))\n\t}\n\n\t// si il n'existe pas, on retourne une erreur 404\n\treturn c.Render(404, r.String(\"user not found\"))\n}\n```\n\nOn attache ce nouveau handler à notre `app`.\n\n```go\ng.GET(\"/users/{id}\", ur.Show)\n```\nMaintenant, on crée un utilisateur avec un `POST` sur `/api/v1/users` puis on fait un `GET` sur `/api/v1/users/{id}` en remplaçant `{id}` par l'uuid de l’utilisateur que vous venez de créer. L'api vous retourne un code 200 avec les informations de l’utilisateur.\n\nVous avez maintenant une base d'api performante avec des outils pour développer rapidement et facilement une api en Go. Vous pouvez retrouver l'ensemble de la documentation et découvrir les autres fonctionnalités de buffalo sur [http://gobuffalo.io](http://gobuffalo.io){:rel=\"nofollow noreferrer\"}.\n"}