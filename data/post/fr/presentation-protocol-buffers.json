{"date":"2017-09-20T00:00:00.000Z","title":"Présentation de Protocol Buffers","excerpt":"Une problématique assez récurrente dans nos applications est la manière de rendre notre donnée, qu'elle soit transmise ou stockée. Le format qu'on utilise souvent aujourd'hui est le `JSON`. Cependant certains langages le gèrent très mal tel que Java et Go. Google a donc développé un système pour palier à ce problème : `Protocol Buffers`.","readingTime":"6mn","authors":["qneyrat"],"categories":[],"content":"\nUne problématique assez récurrente dans nos applications est la manière de rendre notre donnée, qu'elle soit transmise ou stockée. Le format qu'on utilise souvent aujourd'hui est le `JSON`. Cependant certains langages le gèrent très mal tel que Java et Go. Google a donc développé un système pour palier à ce problème : `Protocol Buffers`.\n\n## Présentation\n---\n\nProtocol Buffers est un système de sérialisation de données tout comme `JSON` et `XML`. Il est disponible pour la plupart des langages. Une application en Java peut envoyer des objets à une application en Go. Le système repose sur un fichier qui va permettre de structurer notre objet, les fichiers `.proto`. Ce fichier va un peu comme une interface décrire notre objet. Protobuf permet ensuite de générer le code source de l'objet dans plusieurs langages différents.\n\nPour récapituler, on déclare un fichier proto, on génère notre objet dans notre application serveur et dans notre application client. Nos objets auront dans leur déclaration des méthodes de sérialisation et de de-sérialisation et ce quel que soit le langage.\n\nNotre exemple va être le suivant :\n\nNotre API va retourner un objet `Post`. Un client va appeler cette api. Nous allons avoir besoin d'un fichier `proto` qui va générer le code source en Go. Le serveur va sérialiser un objet et le rendre au client. Ce qui nous donne :\n\n```\nGo Struct  ↘                                              ↗ Java Object\n             Serialization -> bytes -> Deserialization\nProto file ↗                                              ↖ Proto file\n```\n\nNous allons maintenant voir étape par étape comment ça fonctionne.\n\n## Fonctionnement\n---\n\nProtobuf est un langage qui va permettre de définir comment l'objet va être sérialisé et comment il va générer le code source.\nVoici un exemple de fichier protobuf :\n\n```Proto\nmessage Person {\n  string name = 1;\n  int32 id = 2;\n  string email = 3;\n\n  enum PhoneType {\n    MOBILE = 0;\n    HOME = 1;\n    WORK = 2;\n  }\n\n  message PhoneNumber {\n    string number = 1;\n    PhoneType type = 2;\n  }\n\n  repeated PhoneNumber phones = 4;\n}\n```\n\nDans cet exemple notre objet `Person` est constitué d'un `name`, d'un `id`, d'un `email` et de `phones`.\nLa déclaration d'une propriété est définie par un type `int32` ou `string` (et bien d'autres), du nom de la propriété puis d'un identifiant unique (la position) de cette propriété.\n\nOn peut aussi faire de la composition en créant de nouveaux types comme ici `PhoneNumber` ou bien des énumérations.\nDes modèles de données sont aussi disponibles comme les `array` avec le mot-clé `repeated` ou bien encore des maps avec `map<Key, Value>`.\n\nVous pouvez retrouver tous les types et déclaration sur [la documentation de Protobuf](https://developers.google.com/protocol-buffers/docs/proto3){:rel=\"nofollow noreferrer\"}.\n\nUne fois notre fichier proto prêt, nous pouvons générer notre fichier Go ou autres avec la commande `protoc`.\n\nPar exemple :\n\n```Bash\nprotoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/person.proto\n```\n\nEn lui donnant le fichier proto en entrée et le dossier de destination en précisant le langage Go `--go_out` ou Java `--java_out`.\n\nMaintenant que notre fichier Go ou Java est généré, nous avons accès à la méthode de sérialisation.\n\n```Go\nbook := &pb.AddressBook{}\nout, err := proto.Marshal(book)\n```\n\nPour comprendre comment Protocol Buffers sérialise un objet en binaire nous allons prendre la définition suivante :\n\n```Proto\nmessage Test1 {\n  int32 a = 1;\n}\n```\n\nNous allons assigner à `a` la valeur 150. Une sérialisation en `json` donnerait :\n\n```JSON\n{\"a\": 150}\n```\n\nDonne `7b 22 61 22 3a 31 35 30 7d` sur 9 octets.\n\nEn sérialisant avec Protobuf on obtient `08 96 01` sur 3 octets. Ce binaire est composé pour chacune des propriétés de notre objet d'un couple clé/valeur.\n\n### Clé :\n\nCodage de la clé : `(POSITION << 3) | TYPE`\n\nLa position ici est 1 et le type 0, soit :\n\n```\n(1 << 3) | 0 = 0000 1000\n             = 08\n\n```\n\n### Valeur :\n\nCodage de la valeur : groupage en 7 bits avec l'ajout d'un msb (most significant bit), soit :\n\n```\n96 01 = 1001 0110  0000 0001\n       → 000 0001  ++  001 0110 (drop the msb and reverse the groups of 7 bits)\n       → 10010110\n       → 2 + 4 + 16 + 128 = 150\n```\n\nUn binaire protobuf sera plus léger qu'un json et donc plus rapidement transmis dans une requête. De plus le parsing est très performant, retrouvez un article sur [les performances de Protobuf](https://medium.com/@fzambia/centrifugo-protobuf-inside-json-outside-21d39bdabd68){:rel=\"nofollow noreferrer\"}.\n\nNous allons maintenant voir tout ça en pratique.\n\n## Exemple d'application\n---\n\nNous allons tout d'abord installer `protoc` qui permet de générer notre code depuis les fichiers protobuf. [Installer la version pour votre système d'exploitation](https://github.com/google/protobuf/releases/latest){:rel=\"nofollow noreferrer\"}. Une fois ceci fait on va déclarer notre fichier protobuf. Nous allons ensuite installer la librairie qui va permettre de gérer la génération des fichiers Go.\n\n```Bash\ngo get -u github.com/golang/protobuf/protoc-gen-go\n```\n\n### Le fichier Proto :\n\n```proto\nsyntax = \"proto3\";\n\npackage main;\n\nmessage Post {\n    int32 id = 1;\n    string title = 2;\n    string author = 3;\n}\n\n```\n\nUn `Post` est donc composé d'un `id`, d'un `title` et d'un `author`.\nNous allons donc générer le fichier `Post` grâce à `protoc`:\n\n```Bash\nprotoc --proto_path=. --go_out=. post.proto\n```\n\nNous devons récupérer la librairie `proto` qui sera utilisée dans le client et dans le serveur.\n\n```Bash\ngo get github.com/golang/protobuf/proto\n```\n### Le serveur :\nNous allons maintenant passer au code du serveur.\n\n```Go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\tproto \"github.com/golang/protobuf/proto\"\n)\n\nvar post = &Post{\n\tId:     1,\n\tTitle:  \"My awesome article\",\n\tAuthor: \"Quentin Neyrat\",\n}\n\nfunc protoHandler(w http.ResponseWriter, r *http.Request) {\n\tout, err := proto.Marshal(post)\n\tif err != nil {\n\t\tlog.Fatalln(\"Failed to serialize post in protobuf:\", err)\n\t}\n\n\tw.Write(out)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/posts/1\", protoHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\n### Le client :\nNous allons maintenant passer au code du client.\n\n```Go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\tproto \"github.com/golang/protobuf/proto\"\n)\n\nfunc main() {\n\tpost := &Post{}\n\tresp, err := http.Get(\"http://127.0.0.1:8080/posts/1\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tsca := bufio.NewScanner(resp.Body)\n\tsca.Split(bufio.ScanRunes)\n\n\tvar buf bytes.Buffer\n\tfor sca.Scan() {\n\t\tbuf.WriteString(sca.Text())\n\t}\n\n\terr = proto.Unmarshal(buf.Bytes(), post)\n\tif err != nil {\n\t\tlog.Fatal(\"unmarshaling error: \", err)\n\t}\n\n\tfmt.Printf(\"Id: %d \\n\", post.GetId())\n\tfmt.Printf(\"Title: %s \\n\", post.GetTitle())\n\tfmt.Printf(\"Author: %s \\n\", post.GetAuthor())\n}\n```\n\n## Conclusion\n---\n\nProtocol Buffers est un système maintenu par Google qui va permettre de jouer plus facilement avec nos données et de pouvoir travailler avec différents langages. Ceci est relativement important dans une architecture micro-services où chaque service doit communiquer avec d'autres quel que soit le langage.\n\nPoints positifs :\n- performance\n- taille du binaire\n- langage-agnostic\n\nPoints négatifs :\n- maintenir les fichiers proto\n- debug (message en binaire)\n\nNous verrons dans un prochain article gRPC, un client RPC qui utilise HTTP2 et protobuf.\n"}