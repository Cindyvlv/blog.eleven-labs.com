{"date":"2017-12-20T00:00:00.000Z","title":"Optimiser vos images avec Imagine","excerpt":"L’optimisation d’images est un enjeu très important dans la conception d’une application web et nécessite une attention particulière. Durant le développement d’un jeu en ligne impliquant une gestion importante d’images, nous avons été amenés à les optimiser pour différents devices (desktop et mobile). La suite de cet article sera dédiée à expliquer de manière assez simple notre démarche.","readingTime":"6mn","authors":["skpotogbey"],"categories":["php"],"content":"\nL’optimisation d’images est un enjeu très important dans la conception d’une application web et nécessite une attention particulière.\nDurant le développement d’un jeu en ligne impliquant une gestion importante d’images, nous avons été amenés à les optimiser pour différents devices (desktop et mobile).\nLa suite de cet article sera dédiée à expliquer notre démarche en créant une version simplifiée que vous retrouverez [ici](https://github.com/shalomaku/resize-with-imagine){:rel=\"nofollow\"}.\n\n## Pré-requis :\n* php7\n* SYMFONY3\n* [GD](http://php.net/manual/fr/book.image.php){:rel=\"nofollow\"}, [Imagick](http://php.net/manual/fr/book.imagick.php){:rel=\"nofollow\"} ou [GMagick](http://php.net/manual/fr/book.gmagick.php){:rel=\"nofollow\"}\n\n## Definition du projet\nNotre projet est un jeu dont le but est de placer des objets (par drag and drop en Javascript) dans une pièce.\nLes données à manipuler essentiellement sont :\n* **la pièce**: Elle est caractérisée principalement par _une image_ et un _coefficient d'agrandissement_ des objets.\n\n![un exemple de pièce]({{site.baseurl}}/assets/2017-12-20-optimize-image-with-imagine/room.png)\n* **les objets**: Ils ont comme informations principales _une image_, et _une taille réelle_ en centimètre.\n\n![une table]({{site.baseurl}}/assets/2017-12-20-optimize-image-with-imagine/table.png)\n![un écran]({{site.baseurl}}/assets/2017-12-20-optimize-image-with-imagine/imac.png).\n\nL'objectif à atteindre :\n* Optimiser les fonds de pièces\n* Optimiser les objets\n\n## Résolution\nCette section sera subdivisée en deux grandes parties :\n* Installation et définition\n* Optimisation\n\n### Installation et définition\n\nDans cette partie, on parlera brièvement de la mise en place de la bibliothèque Imagine, et de nos classes (room et furniture).\n\n#### Imagine\n\nNous utilisons la librairie **Imagine** parce qu'elle permet notamment :\n* d'unifier les méthodes des bibliothèques [GD](http://php.net/manual/fr/book.image.php){:rel=\"nofollow\"}, [Imagick](http://php.net/manual/fr/book.imagick.php){:rel=\"nofollow\"} et [GMagick](http://php.net/manual/fr/book.gmagick.php){:rel=\"nofollow\"},\n* simplifier les tests.\n\n```bash\n$ composer require imagine/imagine\n```\n\n\n#### Room (Nos pièces)\nDéfinissons nos pièces.\n\n```php\n<?php\n\nnamespace AppBundle\\Entity;\n\nclass Room\n{\n   ...\n   /** @var string */\n   private $imageUrl;\n\n   /** @var float */\n   private $scale;\n   ...\n}\n```\n\n#### Furniture (Nos objets)\n\nVoici un preview de nos objets :\n\n```php\n<?php\nnamespace AppBundle\\Entity;\n\nclass Furniture\n{\n  ...\n  /** @var string */\n  private $imageUrl;\n\n  /** @var float */\n  private $height;\n\n  /** @var Room[] */\n  private $rooms;\n  ...\n}\n```\n\n### Optimisation\nOptimiser, dans notre cas, cela implique de :\n* Trouver une ou plusieurs **tailles de destination**.\n* Déterminer la **méthode de calcul** des tailles des pièces et des objets\n\n#### Taille de destination\nA quoi servent les tailles de destination ? Elles permettent de définir les tailles idéales que doivent avoir nos images.\nDans notre projet, nous avons défini deux tailles basées sur la taille maximale de chaque pièce sur mobile, et sur desktop.\n* LD (Low display) : La largeur maximale a été fixée à 600px.\n* HD (High display) : Une largeur maximale de 1200px a été choisie.\n\nNous reflétons nos tailles dans le fichier de configuration **config.yml**.\n\n```yaml\nparameters:\n    format_size:\n        ld:\n            size: 600\n            quality: 90\n        hd:\n            size: 1200\n            quality: 75\n```\n\n#### Méthode de calcul\nPour optimiser, il faut déterminer une méthode qui permettrait de réduire la taille des images (pièces et objets) sans pour autant en perdre la qualité.\n\nPour toutes nos images, nous utiliserons les méthodes ```open```, ```resize``` et ```save``` d'Imagine pour les traitements.\n\n**Les pièces**\n\nElles sont censées recouvrir la quasi totalité de l'écran donc nous leur appliquons les tailles maximales **LD** et **HD** tout en gardant les proportions des images.\n\nEx : Pour une image ```WIDTHxHEIGHT: 3000x1687``` de **14Mo** ca donnera en :\n* LD : ```600x336```, soit à peu près **592 ko**\n* HD : ```1200x672```, soit environ **2 Mo**\n\n```php\n<?php\n...\n/**\n * Execute resize.\n *\n * @param Room $object\n * @param string $fullInputfile\n * @param string $relativeOutputFilePath\n * @param string $fullOutputFilePath\n * @param int $size\n * @param int $quality\n *\n * @return string\n */\nprotected function execute(\n  $object,\n  $fullInputfile,\n  $relativeOutputFilePath,\n  $fullOutputFilePath,\n  $size,\n  $quality\n): string {\n    //On récupère la taille de l'image d'origine\n    list($width, $height) = getimagesize($fullInputfile);\n    //On calcule le ratio pour toujours garder la même proportion\n    $ratio = $height / $width;\n    $newWidth = $size;\n\n    //Ne pas agrandir l'image si elle est déjà assez petite\n    if ($width < $newWidth) {\n        $newWidth = $width;\n    }\n\n    //Calcul de la nouvelle taille de l'image\n    $newHeight = ceil($newWidth * $ratio);\n    $this->createFileDirectory($fullOutputFilePath);\n\n    //Enregistrons tout ça\n    $box = new Box($newWidth, $newHeight);\n    $this->imagine->open($fullInputfile)\n        ->resize($box)\n        ->save($fullOutputFilePath, ['jpeg_quality' => $quality]);\n\n    return $relativeOutputFilePath;\n}\n...\n```\n\n**Les objets**\n\nPour les objets, la méthode de calcul est un peu différente. On ne peut pas leur appliquer une taille par défaut comme pour les pièces. En effet ils n'ont pas tous la même taille (On ne peut pas redimensionner une table et un écran de la même manière)!\n\n![une table](/imgs/posts/2017-12-20-optimize-image-with-imagine/table.png)\n![un écran](/imgs/posts/2017-12-20-optimize-image-with-imagine/imac.png).\n\nNous avons décidé de calculer la taille maximale des images de nos objets lorsqu'elles sont au maximum zoomées dans les pièces.\n\nPour ce faire il fallait se baser sur trois éléments :\n* La longueur maximale de la pièce, on la retrouve en multipliant la largeur par 0,75 _(0,75 parce que la partie jeu est au format quatre tiers.)_. Soite ```LONG_PIECE_EN_PX = LARG_PIECE_EN_PX * 0.75```.\n* La taille réelle de l’objet en mètre (pas de l’image !). Soit ```HAUTEUR_REEL_OBJET_EN_METRE = HAUTEUR_REEL_OBJET_EN_CM * 0.01```.\n* Et la taille de la pièce en mètre (nous l’avons fixée à 2m30).\n\nPar une petite règle de trois, nous obtenons :\n\n```\nLONG_PIECE_EN_PX    -> HAUTEUR_PIECE_EN_METRE\nLONG_OBJET_EN_PX(?) -> HAUTEUR_REEL_OBJET_EN_METRE\nLONG_OBJET_EN_PX = (HAUTEUR_REEL_OBJET_EN_METRE * LONG_PIECE_EN_PX) / HAUTEUR_PIECE_EN_METRE\n```\n\nLe code correspondant est :\n\n```php\n<?php\n...\n/**\n * Execute resize\n *\n * @param Furniture $object\n * @param $fullInputfile\n * @param $relativeOutputFilePath\n * @param $fullOutputFilePath\n * @param $size\n * @param $quality\n *\n * @return string\n */\npublic function execute(\n  $object,\n  $fullInputfile,\n  $relativeOutputFilePath,\n  $fullOutputFilePath,\n  $size,\n  $quality\n): string {\n    list($width, $height) = getimagesize($fullInputfile);\n    $ratio = $width / $height;\n\n    $newHeight = ($object->getHeight() * 0.01) * ($size * 0.75) / 2.30;\n    if ($newHeight > $height) {\n        $newHeight = $height;\n    }\n    $newWidth = floor($newHeight * $ratio);\n\n    $this->createFileDirectory($fullOutputFilePath);\n\n    $box = new Box($newWidth, $newHeight);\n    $this->imagine->open($fullInputfile)\n        ->resize($box)\n        ->save($fullOutputFilePath, [\n            'png_compression_level' => floor($quality * 9 / 100)\n        ]);\n\n    return $relativeOutputFilePath;\n}\n...\n```\n\n## Récapitulons :\n\nPour résoudre notre problème, nous avons :\n\n* utilisé la librairie Imagine\n* défini les différents objectifs (tailles) que nous voulions atteindre\n* mis en place les différentes méthodes de redimensionnement de nos objets.\n"}