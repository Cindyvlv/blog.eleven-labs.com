{"date":"2016-09-27T00:00:00.000Z","title":"Utiliser le composant Workflow de Symfony","excerpt":"Depuis Symfony 3.2, un nouveau composant très utile a vu le jour : [le composant Workflow](http://symfony.com/blog/new-in-symfony-3-2-workflow-component){:rel=\"nofollow noreferrer\"}.","readingTime":"7mn","authors":["vcomposieux"],"categories":["php"],"content":"Depuis Symfony 3.2, un nouveau composant très utile a vu le jour : [le composant Workflow](http://symfony.com/blog/new-in-symfony-3-2-workflow-component){:rel=\"nofollow noreferrer\"}.\nCelui-ci est en effet très pratique et peut très largement simplifier vos développements lorsque vous avez, par exemple, à gérer des workflows de statut dans votre application.\n\n# Installation\n\nDans tous les cas, vous devez installer la dépendance suivante :\n\n```json\n\"symfony/workflow\": \"~3.2@dev\"\n```\n\nSi vous utilisez une version antérieure de Symfony mais >=2.3, c'est aussi possible mais il vous faudra également installer ce bundle non-officiel qui embarque le composant et ajoute la configuration nécessaire sous le namespace du bundle :\n\n```json\n\"fduch/workflow-bundle\": \"~0.2@dev\"\n```\n\nPensez bien à activer le bundle dans votre kernel.\n\n# Configuration\n\nIl va maintenant nous falloir définir la configuration de notre workflow et ainsi définir les statuts (appelés places) et transitions possibles.\nPour cet article, nous sommes partis sur un exemple basé sur les statuts d'une pull request. Celle-ci peut avoir les états suivants : `opened` , `closed` , `needs_review` , `reviewed`  et enfin `merged`.\n\nCependant, elle ne pourra, par exemple, pas être passée en `merged`  sans être passée par le statut `reviewed` . C'est ici que le composant Workflow prend tout son sens.\n\nVoici ce que donne notre configuration complète :\n```yaml\nworkflow:\n    workflows:\n        pull_request:\n            marking_store:\n                type: multiple_state\n                arguments:\n                    - state\n            supports:\n                - AppBundle\\Entity\\PullRequest\n            places:\n                - opened\n                - closed\n                - needs_review\n                - reviewed\n                - merged\n            transitions:\n                feedback:\n                    from: opened\n                    to:   needs_review\n                review:\n                    from: [opened, needs_review]\n                    to:   reviewed\n                merge:\n                    from: reviewed\n                    to:   merged\n                close:\n                    from: [opened, needs_review, reviewed]\n                    to:   closed\n```\n\nNous spécifions ici que nous souhaitons utiliser un workflow de type `multiple_state` . Notez que si vous souhaitez utiliser une transition simple d'un statut vers un autre, vous pouvez utiliser ici `single_state`.\nNous disposons donc également d'une classe `AppBundle\\Entity\\PullRequest`  qui dispose d'une propriété `state`  ainsi que son setter et getter associé (le composant va utiliser les méthodes getter et setter pour changer l'état et/ou obtenir l'état courant) :\n\n```php\n<?php\n\nnamespace AppBundle\\Entity;\n\nuse Doctrine\\ORM\\Mapping as ORM;\n\n/**\n * @ORM\\Table(name=\"pull_request\")\n */\nclass PullRequest\n{\n    /**\n     * @ORM\\Column(type=\"json_array\", nullable=true)\n     */\n    protected $state;\n\n    public function setState($state)\n    {\n        $this->state = $state;\n    }\n\n    public function getState()\n    {\n        return $this->state;\n    }\n}\n```\n\nNous avons terminé, nous pouvons maintenant commencer à utiliser le composant Workflow !\n\n# Utilisation\n\nLa première chose utile à effectuer après avoir écrit votre workflow est de générer une représentation graphique de celui-ci (sous un format [Graphviz](http://www.graphviz.org)){:rel=\"nofollow noreferrer\"}.\n\nPour ce faire, nous utilisons la commande Symfony :\n\n```bash\n$ bin/console workflow:dump pull_request\n```\n\nCelle-ci va vous générer un code Graphviz qui donne le schéma suivant :\n\n![Workflow Graphviz](/imgs/posts/2016-09-29-symfony-workflow-component/workflow.png)\n\nCelui-ci permet vraiment de donner une vision claire de son workflow, à tous les niveaux (développeurs, product owners, clients, ...).\nLe composant Workflow implémente des méthodes permettant d'effectuer une transition, vérifier si une transition peut être effectuée avec l'état actuel et lister les transitions possibles avec l'état actuel.\n\nPour vérifier si vous pouvez effectuer une transition et l'appliquer, rien de plus simple :\n\n```php\n<?php\n\nnamespace AppBundle\\Controller;\n\nuse AppBundle\\Manager\\PullRequestManager;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\nuse Symfony\\Component\\HttpFoundation\\RedirectResponse;\n\nclass PullRequestController extends Controller\n{\n    /**\n     * @param int $identifier A pull request identifier.\n     *\n     * @return RedirectResponse\n     */\n    public function update($identifier)\n    {\n        ...\n\n        // Notre pull request est au statut \"reviewed\"\n        $pullRequest = $this->getPullRequestManager()->find($identifier);\n\n        // Nous obtenons le service \"workflow.<nom du workflow>\"\n        $workflow = $this->get('workflow.pull_request');\n\n        if ($workflow->can($pullRequest, 'merge')) {\n            $workflow->apply($pullRequest, 'merge');\n        }\n\n        ...\n    }\n}\n```\n\nSi vous ne passez pas par la méthode `can()` , la méthode `apply()`  renverra une exception si la transition ne peut pas être effectuée. Vous pouvez donc également catcher cette exception de type `Symfony\\Component\\Workflow\\Exception\\LogicException`.\n\nPour lister les transitions disponibles :\n\n```php\n$workflow->getEnabledTransitions($pullRequest);\n```\n\nGlobalement, l'utilisation du composant se limite à ces 3 méthodes. Comme vous le remarquez, il devient très simple d'utiliser un workflow, même complexe !\n\n# Branchez-vous sur les événements !\n\nLe composant utilise également plusieurs événements, à savoir, dans l'ordre chronologique :\n\n* `workflow.leave`  : lorsque notre pull request va se voir dépourvue de son dernier statut,\n* `workflow.transition`  : lorsque la transition vers le nouvel état est lancée,\n* `workflow.enter`  : lorsque le nouvel état est défini sur notre pull request,\n* `workflow.guard`  : pour vous éviter de rendre la transition possible, vous pouvez utiliser cet événement pour définir votre événement bloqué : `$event->setBlocked(true);`\n\nEnfin, sachez que ces événements existent aussi en version unique pour chaque workflow afin de vous permettre de vous brancher dessus uniquement sur certains workflows. Il vous faut alors utiliser le nom `workflow.pull_request.enter`.\n\nFaisons encore mieux, vous pouvez même vous brancher sur une transition particulière :\n\n* `workflow.pull_request.enter.needs_review`  : permet de se brancher uniquement lorsque nous définissons un nouvel état `needs_review`  à notre pull request, nous pourrons alors envoyer un email à l'auteur pour qu'il corrige certaines choses,\n* `workflow.pull_request.transition.merge`  : interviendra lorsque la transition de merge prendra effet sur notre pull request.\n\n# Conclusion\n\nLe composant Workflow est vraiment très utile dans la gestion d'états ou de statuts sur la plupart des projets.\n\nN'hésitez pas à l'utiliser, sa facilité de configuration et d'utilisation vous aidera grandement sur vos projets.\nAussi, il m'a permis de donner un graphique clair sur un workflow complexe à toutes les personnes avec qui je travaillais.\n"}