{"date":"2020-07-15T00:00:00.000Z","title":"Créer un Web Component","excerpt":"Dans cet article, nous allons apprendre à créer un Web Component","readingTime":"11mn","authors":["aallier"],"categories":["javascript"],"content":"\nLes normes liées au web ont beaucoup évolué depuis une dizaine d’années, le cap de l’HTML5 CSS3 a été difficile mais a ouvert la porte à de plus en plus de fonctionnalités.\nUne de ces fonctionnalités est le Web Compponent, qui permet de créer des composants indépendants et ré-utilisables.\nLe Web Component ressemble aux composants de React ou Angular mais a la particularité de n’être dépendant que du navigateur. Il peut donc fonctionner dans une page web indépendamment du framework utilisé. Nous allons voir comment en créer un simple, permettant de gérer un système de popin.\n\n## Principes\nLe Web Component repose sur 3 principes :\n- [template](https://developer.mozilla.org/fr/docs/Web/HTML/Element/template)\n- [shadowDOM](https://developer.mozilla.org/en-US/docs/Web/API/Element/shadowRoot)\n- [customElements](https://developer.mozilla.org/fr/docs/Web/Web_Components/Using_custom_elements)\n\n### Template\nLe tag **template** permet de définir un bloc HTML ré-utilisable pouvant contenir des sous-blocs `slot` surchargés lors de son utilisation.\nConcrètement ça ressemble à ça :\n\n```html\n<template>\n    <div class=\"block\">\n        <div class=\"close\"><img src=\"icons-close_24.png\"></div>\n        <div class=\"content\">\n            <slot name=\"content\"></slot>\n        </div>\n    </div>\n</template>\n```\n\nLes balises `template` ne sont pas affichées sur la page, elles doivent être copiées puis ajoutées au DOM grâce à `appendChild`.\nLa balise `slot` permet d'insérer du HTML à la place grâce a la propriété `name`\n###customELement\nL'objet [customElements](https://developer.mozilla.org/fr/docs/Web/API/Window/customElements) possède la méthode `define` permettant de créer une nouvelle balise. Elle a besoin de 2 paramètres :\n- le nom de la balise !Attention il est imperatif d'avoir un *-* dans le nom!\n- la classe définissant la nouvelle balise\n\n```javascript\ncustomElements.define('popin-component', class extends HTMLElement {\n    constructor() {\n        super();\n    }\n\n    connectedCallback() {\n        // Le composant est créé\n    }\n\n    adoptedCallback() {\n        // Le composant est déplacé\n    }\n\n    disconnectedCallback() {\n        // Le composant est detruit\n        // Attention si le noeud est déplacé alors cette méthode sera appeler puis connectedCallback\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n        console.log(`L'attribut ${name} à changé de valeur de ${oldValue} à ${newValue}`);\n    }\n}\n```\nComme on peut le voir, la classe étend HTMLElement. Elle va donc non seulement hériter de toutes les méthodes et propriétés d'HTMLElement, et être considérée comme tel.\nCertaines méthodes disponibles vont nous être très utiles : `connectedCallback` à la fin de la création de l'élément lorsqu'il est chargé dans la page, `disconnectedCallback` lorsque l'élément est supprimé et `attributeChangedCallback` lorsqu'une propriété est modifiée.\n\n### Shadow DOM\nLe principe du shadow DOM est la création d'un DOM virtuel à l'intérieur même d'un élément HTML.\nTout le javascript, HTML et css fonctionnent dans ce shadow DOM mais n'ont aucun impact à l'extérieur de cet élément et inversement.\nCe qui veut dire qu'on peut nommer une fonction dans la page et dans le shadow DOM sans qu'elles ne se surchargent, cela vaut aussi pour les id et les styles css.\nPour ajouter un shadow DOM il faut utiliser [attachShadow](https://developer.mozilla.org/fr/docs/Web/API/Element/attachShadow) hérité depuis l'objet [Element](https://developer.mozilla.org/fr/docs/Web/API/Element) avec comme paramètre un objet de configuration avec comme seul clef `mode`. On peut par la suite lui ajouter du HTML. Dans notre cas nous voulons utiliser notre template.\n\n```javascript\nlet popinTemplate = document.createElement('template');\nElement.attachShadow({mode: 'open'}).appendChild(popinTemplate.content.cloneNode(true));\n```\n### Pseudo class CSS\nLe shadow DOM donne accès à de nouvelles Pseudo classes CSS. Elles permettent entre autres de définir un style en fonction de la position du component dans le DOM.\nElles n'ont aucun effet en dehors d'un shadow DOM.\n- :host\n    Pseudo class css faisant référence à la racine du shadow DOM\n- :host(<class>)\n    Permet d'appliquer un style lorsque la class en paramètre est définie sur le component\n- :host-context(<Element>)\n    Permet d'appliquer un style lorsque le component est un descendant d'ElementName\n\n### Implementation\nPour n'avoir notre composant que dans un seul fichier nous allons déclarer le template en javascript. On va en profiter pour ajouter un peu de CSS histoire de faire plus joli.\nLe template n'a pas besoin d'être ajouté au document, nous allons simplement le cloner et l'ajouter au shadowRoot.\n\n```javascript\nlet popinTemplate = document.createElement('template');\npopinTemplate.innerHTML = `\n<style type=\"text/css\">\n    :host {\n        position: fixed;\n        left: 0px;\n        right: 0px;\n        top: 0px;\n        bottom: 0px;\n        overflow: auto;\n        opacity: 0;\n        visibility: hidden;\n\n        display: flex;\n        align-items: center;\n        justify-content: center;\n\n        background-color: rgba(0,0,0,0.5);\n        transition: all 0.4s ease;\n    }\n    .block {\n        box-shadow: 0px 0px 7px 1px grey;\n        background-color: #fff;\n        padding: 20px;\n        min-width: 700px;\n        min-height: 300px;\n    }\n    .close img {\n        cursor: pointer;\n    }\n    .content {\n        padding: 20px;\n    }\n</style>\n<div class=\"block\">\n    <div class=\"close\"><img src=\"icons-close_24.png\"></div>\n    <div class=\"content\">\n        <slot name=\"content\"></slot>\n    </div>\n</div>\n`;\n```\nMaintenant construisons notre class. On va considérer que la variable `popinTemplate` a été précédement créée.\n```javascript\ncustomElements.define('popin-component', class extends HTMLElement {\n    // Obligatoire afin d'écouter les changements sur la propriété modal grace a la méhode attributeChangedCallback\n    static get observedAttributes() {\n        return ['modal'];\n    }\n\n    constructor() {\n        // Ne pas oublier d'appeler le constructeur de l'objet parent HTMLElement\n        super();\n        // Création du shadowRoot puis ajout d'un clone du template\n        this.attachShadow({mode: 'open'}).appendChild(popinTemplate.content.cloneNode(true));\n\n        [this.close] = this.shadowRoot.querySelectorAll('img');\n\n        this.isVisible = false;\n        this.isModal = false;\n    }\n\n    // Après création du tag, ajout des divers événements\n    connectedCallback() {\n        this.close.addEventListener('click', e => !this.isModal && this.hide());\n\n        document.addEventListener('keyup', e => !this.isModal && this.keyUp(e));\n        this.addEventListener('click', e => !this.isModal && this.click(e));\n\n        this.modal = !!this.getAttribute('modal');\n    }\n\n    // Écoute de changement sur la propriété \"modal\"\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (name !== 'modal') {\n            return;\n        }\n\n        this.modal = newValue;\n    }\n\n    // Petite méthode pour détecter sur l'utilisateur a cliqué en dehors de la popin, si oui fermeture de la popin\n    click(e) {\n        const [block] = this.shadowRoot.querySelectorAll('div');\n        let parent = e.originalTarget;\n        while(parent) {\n            if (parent === block) {\n                return;\n            }\n\n            if (parent == this) {\n                this.hide();\n            }\n\n            parent = parent.parentNode;\n        }\n    }\n\n    // Si l'utilisateur appuie sur la touche échap, fermeture de la popin\n    keyUp(e) {\n        if (e.key === 'Escape') {\n            this.hide();\n        }\n    }\n\n    show() {\n        this.visible = true;\n    }\n\n    hide() {\n        this.visible = false;\n    }\n\n    // Le setter de la propriété visible, c'est la réelle méthode qui ouvre et ferme la popin\n    set visible(value) {\n        this.isVisible = !!value;\n        if (!!value) {\n            this.style.visibility = 'visible';\n            this.style.opacity = 1;\n\n            return;\n        }\n\n        this.style.visibility = 'hidden';\n        this.style.opacity = 0;\n    }\n\n    get visible() {\n        return this.isVisible;\n    }\n\n    set modal(value) {\n        this.isModal = !!value;\n        this.close.style.display = !!value ? 'none' : 'block';\n    }\n\n    get modal() {\n        return !!this.getAttribute('modal');\n    }\n});\n```\n## Utilisation\nOn l'utilise exactement de la même manière que les balises standards. On peut utiliser des propriétés communes à tous les éléments comme `id`, `name` ou `style` mais aussi les propriétés que l'on a ajouté `modal`.\nIl y a tout de même une petite différence : l'utilisation de la propriété `slot`. C'est ce qui nous permet de définir un élément qui sera placé dans la balise `slot` du template. Tout ce qui ne sera pas dans un slot géré par le template ne sera pas affiché.\n```html\n<popin-component id=\"popin\" modal=\"true\">\n    <div slot=\"content\" id=\"popin-content\">\n        Ce qui va apparaître dans la popin\n    </div>\n</popin-component>\n```\nPour afficher ou faire disparaitre la popin il suffit d'appeler les méthodes `show` et `hide` que nous avons définies dans sa classe.\n```javascript\n// On affiche la popin\ndocument.getElementById('popin').show();\n// On la fait disparaitre\ndocument.getElementById('popin').hide();\n```\nNous pouvons connaître son état grâce à la propriété `visible`\n```javascript\n// Renverra true si la popin est visible, sinon false\ndocument.getElementById('popin').visible;\n```\nCette propriété a aussi un setter, il nous est donc possible d'afficher ou de faire disparaitre la popin en la modifiant.\n```javascript\n// Aura le même effet que l'appel de la méthode show()\ndocument.getElementById('popin').visible = true;\n```\nVoilà notre composant popin complètement indépendant et facilement installable et utilisable dans un projet en javascript vanilla, React, Angular ou Vue.\nSeul petit problème, certains navigateurs ne le supportent pas  (coucou IE) mais pas de panique, il existe un [polyfill](https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs) qu'on espère comme solution temporaire.\nVous pouvez retrouver un grand nombre de webComponents disponibles sur ce [site](https://www.webcomponents.org/)\n\n## Ressources\n- [Github exemple](https://github.com/Ghau/webcomponent)\n- [MDN WebComponents](https://developer.mozilla.org/fr/docs/Web/Web_Components)\n- [Standard specification](https://html.spec.whatwg.org/multipage/custom-elements.html)\n- [Google developpers](https://developers.google.com/web/fundamentals/web-components/)\n- [Polyfill](https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs)\n- [WebComponent ressources](https://www.webcomponents.org/)\n"}