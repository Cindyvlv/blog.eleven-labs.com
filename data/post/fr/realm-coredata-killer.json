{"date":"2018-05-21T00:00:00.000Z","title":"Realm, CoreData killer","excerpt":"Realm, CoreData killer","readingTime":"28mn","authors":["ibenichou"],"categories":[],"content":"\nRealm Mobile Database est une alternative à SQLite et à Core Data pour iOS.\nÀ travers cet article, vous allez découvrir et apprécier Realm :).\n\n## Realm\n\nPourquoi utiliser une libraire externe pour gérer une base de données alors que CoreData existe (natif) ?\nPourquoi rajouter encore une couche à notre application ?\n\nVoici quelques éléments de réponses :\n\n* Performance\n* Syntaxe moderne, plus simple\n* Possibilité d'encrypter sa base de données (AES-256)\n* Avec la solution Realm Platform, possibilité de synchroniser vos données à tout moment avec votre serveur (Realm).\n* Marche à travers les threads\n* Migrations\n* Cross-platform (Java, Swift, Objective-C, Javascript, .NET)\n* Realm Studio\n* [Open source](https://github.com/realm/realm-cocoa) (Apache 2.0)\n\n> Realm ne devrait ajouter qu'environ 5 à 8 Mo à la taille de téléchargement de votre application\n\n## Benchmark - Performance\n\nComme annoncé plus haut, l'un des avantages de Realm est la performance.\n\n![realmCount](/imgs/posts/2018-02-24-realm-coredata-killer/realm_benchmarks_count.png){:width=\"600px\"}\n![realmInsert](/imgs/posts/2018-02-24-realm-coredata-killer/realm_benchmarks_insert.png){:width=\"600px\"}\n![realmQueries](/imgs/posts/2018-02-24-realm-coredata-killer/realm_benchmarks_queries.png){:width=\"600px\"}\n\nOn voit clairement que Realm en a sous le capot !\nC'est vraiment un point très important car de nos jours nous mettons en place des applications qui traitent de plus en plus de données et de ce fait nous ne pouvons absolument pas nous permettre d'avoir une application lente.\n\n**Comment Realm fait-il pour avoir de telles performances ?**\n\nRealm s'appuie sur les concepts suivants :\n\n* [Data Structure Alignment](https://en.wikipedia.org/wiki/Data_structure_alignment)\n* [Cache](https://en.wikipedia.org/wiki/Cache_(computing)) & [Vectorization](https://en.wikipedia.org/wiki/Vectorization)\n* [Zero copy](https://en.wikipedia.org/wiki/Zero-copy) architecture\n\n## Installation\n\nAprès avoir créé un nouveau projet, vous allez initialiser un Podfile via [Cocoapods](https://cocoapods.org/)\n\n```shell\n$ pod init\n```\n\n```ruby\n# Podfile\ntarget 'realmArtcile' do\n  use_frameworks!\n\n  pod 'RealmSwift'\nend\n```\n\nAprès avoir exécuté `pod install`, vous pouvez ouvrir votre projet `*.xcworkspace`\n\n\n## Configuration\n\nIl est préférable de configurer Realm avant de l'utiliser en créant une instance de `Realm.Configuration`.\nCette configuration permet :\n\n* De donner le chemin sur le disque du fichier de configuration ;\n* Lorsque les schémas ont changé entre les différentes versions, une fonction de migration contrôlant la façon dont les données de Realm doivent être mises à jour vers le schéma le plus récent.\n* Stocker de nombreuses données ou des données fréquemment modifiées, une fonction de compactage contrôlant la façon dont le fichier Realm doit être compactée pour assurer une utilisation efficace de l'espace disque.\n\nLa configuration peut être transmise à `Realm(configuration: config)` chaque fois que vous avez besoin d'une instance Realm où vous pouvez définir la configuration à utiliser pour Realm par défaut avec `Realm.Configuration.defaultConfiguration = config`.\n\nVous pouvez avoir plusieurs objets de configuration. Ainsi vous pouvez contrôler la version, le schéma et l'emplacement de chaque modèle Realm indépendamment.\n\n```swift\nlet config = Realm.Configuration(\n  // Obtenir l'URL du fichier MyBundledData.realm\n  fileURL: Bundle.main.url(forResource: \"MyBundledData\", withExtension: \"realm\"),\n  // Ouvrir le fichier en mode read-only\n  readOnly: true)\n\n// Ouvrir Realm avec la configuration\nlet realm = try! Realm(configuration: config)\n```\n\nVous avez peut-être remarqué jusqu'à présent que nous avons initialisé l'accès à notre variable de domaine en appelant `Realm()`. Cette méthode renvoie un objet Realm qui correspond à un fichier nommé `default.realm` dans le dossier Documents (iOS) ou dans le dossier Application Support (macOS) de votre application.\n\n**Class subsets**\n\nDans certains scénarios, vous pouvez souhaiter limiter les classes pouvant être stockées dans Realm. Par exemple, si vous avez deux équipes travaillant sur différents composants de votre application qui utilisent Realm en interne, vous ne souhaiteriez peut-être pas avoir à coordonner les migrations entre elles. Vous pouvez alors le faire en définissant la propriété `objectTypes` de votre `Realm.Configuration`.\n\n### Exemples de configuration\n\n**Configuration - SchemaVersion - ObjectTypes**\n\n```swift\n// Initialisation de la configuration\nvar config = Realm.Configuration()\n// Utilisez le répertoire par défaut, mais remplacez le nom de fichier par le nom Category\nconfig.fileURL = config.fileURL!.deletingLastPathComponent().appendingPathComponent(\"Category.realm\")\nconfig.readOnly = false\n// Nous verrons cette partie plus tard\nconfig.schemaVersion = 1\nconfig.objectTypes = [Category.self]\n\nRealm.Configuration.defaultConfiguration = config\n```\n\n**Configuration - DeleteRealmIfMigrationNeeded**\n\n```swift\nvar config = Realm.Configuration()\n// Définir ceci changera le comportement de gestion des exceptions de migration. Au lieu de lancer une exception\n// RealmMigrationNeededException, Realm sur disque sera effacé et recréé avec le nouveau schéma.\nconfig.deleteRealmIfMigrationNeeded = true\nconfig.fileURL = config.fileURL!.deletingLastPathComponent().appendingPathComponent(\"PRODUCT.realm\")\nRealm.Configuration.defaultConfiguration = config\n```\n\nVous voyez, ce n'est pas vraiment compliqué de configurer Realm :).\n\n## Model\n\nRealm supporte les propriétés suivantes :\n* Bool\n* Int\n* Int8\n* Int16\n* Int32\n* Int64\n* Double\n* Float\n* String\n* Date\n* Data\n\n### Attribut de propriété\n\nLes propriétés de modèle Realm doivent posséder l'attribut `@objc dynamic var` pour devenir des accesseurs pour les données de base de données sous-jacentes. Notez que si la classe est déclarée comme `@objcMembers` (Swift 4), les propriétés individuelles peuvent simplement être déclarées comme `dynamic var`.\n\nIl y a trois exceptions à cela : `LinkingObjects`, `List` et `RealmOptional`. Ces propriétés doivent toujours être déclarées avec `let`.\n\nCe tableau fournit une référence pratique pour déclarer les propriétés du modèle.\n\n| Type           | Non optional                                                            | Optional  |\n| -------------  |:------------------------------------------------------------------------:| :---------:|\n| Bool           | `@objc dynamic var value = false`                                        | `let value = RealmOptional<Bool>()` |\n| Int            | `@objc dynamic var value = 0`                                            | `let value = RealmOptional<Int>()` |\n| Float          | `@objc dynamic var value: Float = 0.0`                                   | `let value = RealmOptional<Float>()` |\n| Double         | `@objc dynamic var value: Double = 0.0\t`                                 | `let value = RealmOptional<Double>()` |\n| String         | `@objc dynamic var value = \"\"`                                           | `@objc dynamic var value: String? = nil` |\n| Data           | `@objc dynamic var value = Data()`                                       | `@objc dynamic var value: Data? = nil` |\n| Date           | `@objc dynamic var value = Date()`                                       | `@objc dynamic var value: Date? = nil` |\n| Object         | n/a: doit être optional                                                    | `@objc dynamic var value: Class?` |\n| List           | `let value = List<Type>()`                                               | n/a: doit être non optional |\n| LinkingObjects | `let value = LinkingObjects(fromType: Class.self, property: \"property\")` | n/a: doit être non optional |\n\n\n### Clé primaire - Indexation de propriétés\n\nJe pense que vous connaissez tous l’intérêt d'une clé primaire et de l'indexation de propriétés, donc je ne m'attarde pas trop sur ces sujet.\n\nDéclaration d'une clé primaire et d'indexation de propriétés Realm :\n\n```swift\nclass Planet: Object {\n    @objc dynamic var id = 0\n    @objc dynamic var name = \"\"\n\n    override static func primaryKey() -> String? {\n        return \"id\"\n    }\n\n    override static func indexedProperties() -> [String] {\n        return [\"name\"]\n    }\n}\n```\n\n### Héritage\n\nRealm permet de faire de l'héritage entre modèles. Cependant, voici quelques règles impossibles :\n\n* Le casting entre class polymorphic (ex: sous-classe à sous-classe, sous-classe à parent, parent à sous-classe...)\n* Query simultanée sur plusieurs classes\n* Plusieurs class containers (`List` et `Results`)\n\nSinon, je vous recommande d'utiliser le modèle de composition de classes ci-dessous pour créer des sous-classes englobant la logique d'autres classes.\n\n```swift\n// Modèle parent\nclass Car: Object {\n    @objc dynamic var price = 0\n}\n\n// Modèle qui hérite de Car\nclass Audi: Object {\n    @objc dynamic var car: Car? = nil\n    @objc dynamic var sLine = false\n}\n\n// Modèle qui hérite de Car\nclass Bmw: Object {\n    @objc dynamic var car: Car? = nil\n    @objc dynamic var mDesign = false\n}\n\nlet audiTT = Audi(value: [ \"car\": [ \"price\": 60000 ], \"sLine\": true ])\nlet serie1 = Bmw(value: [ \"car\": [ \"price\": 15000 ], \"mDesign\": false])\n```\n\n### Collections\n\nRealm a plusieurs types qui aident à représenter des groupes d'objets. On les appelle `Realm collections`:\n\n* `Results`, une classe représentant des objets récupérés à partir de queries ;\n* `List`, une classe représentant les relations `to-many` des modèles ;\n* `LinkingObjects`, une classe représentant les relations inverses dans les modèles ;\n* `RealmCollection`, un protocole définissant l'interface commune à laquelle toutes les collections de Realm se conforment.\n\n**Many-to-one - One-to-one**\n\nPour définir une relation `many-to-one` ou `one-to-one`, attribuez à un modèle une propriété dont le type est l'une de vos sous-classes `Object`:\n\n```swift\nclass User: Object {\n    // ...\n    @objc dynamic var card: Card? = nil // one\n}\n```\n\nVous pouvez utiliser cette propriété comme les autres :\n\n```swift\nlet amex = Card()\namex.type = \"Black\"\nlet pepito = User()\npepito.card = amex\n```\n\nLorsque vous utilisez des propriétés `Object`, vous pouvez accéder aux propriétés imbriquées à l'aide de la syntaxe de propriété normale. Par exemple `pepito.card?.type`.\n\n**Many-to-many**\n\nVous pouvez créer une relation avec n'importe quel nombre d'objets ou de valeurs primitives prises en charge à l'aide des propriétés de `List`. Les `List` peuvent contenir d'autres `Object` ou valeurs primitives d'un seul type et ont une interface très similaire à un `Array` mutable.\n\n```swift\nclass Book: Object {\n    // ...\n    let authors = List<Author>()\n}\n```\n\nVous pouvez accéder et assigner aux propriétés `List` comme d'habitude :\n\n```swift\nlet someAuthors = realm.objects(Author.self).filter(\"name contains 'De la Vega'\")\nmiserables.authors.append(objectsIn: someAuthors)\nmiserables.authors.append(victorHugo)\n```\n\nLes propriétés `List` sont garanties pour préserver leur ordre d'insertion.\n\n### Relations inverses\n\nRealm fournit des propriétés d'objets de liaison pour représenter les relations inverses :\n\n```swift\nclass Author: Object {\n    @objc dynamic var name = \"\"\n    @objc dynamic var age = 0\n    let books = LinkingObjects(fromType: Book.self, property: \"authors\")\n}\n```\n\nAvec les propriétés des objets de liaison, vous pouvez obtenir tous les objets liés à un objet donné à partir d'une propriété spécifique.\n\n### Création - Mise à jour - Suppression d'objet\n\n**Création**\n\nPour créer un nouvel objet Realm, rien de plus simple. Vous pouvez le faire de plusieurs façons :\n\n```swift\n// (1) Créez un objet User et setter ses propriétes\nvar pepito = User()\npepito.name = \"Pepito\"\npepito.age = 100\n\n// (2) Créez un objet User depuis un dictionary\nlet pepita = User(value: [\"name\" : \"Pepita\", \"age\": 90])\n\n// (3) Créez un object User depuis un array\nlet lecolasonne = User(value: [\"Lecolasonne\", 770])\n```\n\nAprès avoir créé l'objet, vous pouvez ajouter celui-ci à Realm :\n\n```swift\n// Obtenir Realm par défault\nlet realm = try! Realm()\n// Vous avez seulement besoin de le faire une fois (par thread)\n\n// Ajouter l'objet à Realm à l'intérieur d'une transaction\ntry! realm.write {\n    realm.add(pepito)\n}\n```\n\nAprès avoir ajouté l'objet à Realm, vous pouvez continuer à l'utiliser et toutes les modifications que vous y apporterez seront conservées (et doivent être effectuées dans une transaction d'écriture). Toutes les modifications sont mises à la disposition des autres threads qui utilisent le même Realm lorsque la transaction d'écriture est validée.\n\n**Mise à jour**\n\nVous pouvez mettre à jour n'importe quel objet en définissant ses propriétés dans une transaction write.\n\n`Object`, `Result` et `List` sont conformes au principe `key-value coding` (KVC). Ça peut être utile lorsque vous devez déterminer la propriété à mettre à jour lors de l'exécution. Appliquer KVC à une collection est un excellent moyen de mettre à jour les objets en masse sans avoir à gérer l'itération d'une collection tout en créant des accesseurs pour chaque élément.\n\n```swift\nlet users = realm.objects(User.self)\ntry! realm.write {\n    users.first?.setValue(true, forKeyPath: \"isAstronaut\")\n    // set pour chaque user la valeur Donuts (la meilleure btw) dans la propriété planet\n    users.setValue(\"Donuts\", forKeyPath: \"planet\")\n}\n```\n\nSi votre classe de modèle inclut une clé primaire, vous pouvez demander à Realm de mettre à jour ou d'ajouter intelligemment des objets en fonction de leurs valeurs de clé primaire en utilisant `Realm().add(_:update:)` :\n\n```swift\nlet pepito = User()\nuser.name = \"Pepito\"\nuser.age = 29\nuser.id = 1\n\n// Update l'user avec l'id = 1\ntry! realm.write {\n    realm.add(user, update: true)\n}\n```\n\nSi un objet User avec clé primaire == '1' existait déjà dans la base de données, cet objet serait simplement mis à jour. S'il n'existait pas, un objet User entièrement nouveau serait créé et ajouté à la base de données. C'est un peu comme un `INSERT INTO ... ON DUPLICATE KEY UPDATE` en SQL.\n\nVous pouvez également mettre à jour partiellement des objets avec des clés primaires en passant juste un sous-ensemble des valeurs que vous souhaitez mettre à jour, avec la clé primaire :\n\n```swift\n// En supposant qu'un user avec la clé primaire `1` existe déjà.\ntry! realm.write {\n    realm.create(User.self, value: [\"id\": 1, \"age\": 30], update: true)\n    // La propriété `name` restera inchangée.\n}\n```\n\n> Notez que lors de la mise à jour des objets, `nil` est toujours considéré comme une valeur valide pour les propriétés facultatives. Si vous fournissez un dictionnaire avec des valeurs de propriétés `nil`, elles seront appliquées à votre objet et ces propriétés seront donc vidées.\n\n**Suppression d'objet**\n\nPour supprimer un objet, passez celui-ci à la méthode `Realm().Delete(_ :)` dans une transaction d'écriture.\n\n```swift\ntry! realm.write {\n    realm.delete(userPeppito)\n}\n```\n\nVous pouvez également supprimer tous les objets stockés dans Realm. Notez que le fichier Realm conservera sa taille sur le disque pour réutiliser efficacement cet espace pour les futurs objets.\n\n```swift\ntry! realm.write {\n    realm.deleteAll()\n}\n```\n\n### Queries - Filtres - Tries\n\n**Queries**\n\nLes requêtes renvoient une instance `Results`, qui contient une collection d'`Object`. `Results` a une interface très similaire à `Array` et les objets contenus dans un `Results` peuvent être consultés en utilisant un indice indexé. Contrairement aux `Array`, les `Results` contiennent uniquement des objets d'un type de sous-classe unique.\n\nToutes les requêtes (y compris les requêtes et l'accès aux propriétés) sont `lazy` dans Realm. Les données sont uniquement lues lorsque les propriétés sont accessibles.\n\nLes résultats d'une requête ne sont pas des copies de vos données. La modification des résultats d'une requête (dans une transaction d'écriture) modifiera directement les données sur le disque.\n\n```swift\n// Vous savez déjà écrire une query :)\nlet users = realm.objects(User.self)\n```\n\nL'exécution d'une requête est différée jusqu'à ce que les résultats soient utilisés. Cela signifie que l'enchaînement de plusieurs `Results` temporaires pour trier et filtrer vos données n'effectue pas de travail supplémentaire pour traiter l'état intermédiaire.\n\n**Filtres**\n\nSi vous êtes familier avec `NSPredicate`, alors vous savez déjà comment faire pour Realm. `Objects`, `Realm`, `List` et `Results` fournissent tous des méthodes qui vous permettent d'interroger des instances d'`Object` spécifiques en transmettant simplement une instance `NSPredicate`, une chaîne de prédicat ou une chaîne de format de prédicat comme vous le feriez pour un `NSArray`.\n\n```swift\n// Query utilisant un predicat String\nvar pepitos = realm.objects(User.self).filter(\"age = 30 AND name BEGINSWITH 'P'\")\n\n// Query utilisant un NSPredicate\nlet predicate = NSPredicate(format: \"age = %d AND name BEGINSWITH %@\", 30, \"B\")\npepitos = realm.objects(User.self).filter(predicate)\n```\n\nPour plus d'informations sur comment construire des predicats dans [Realm](https://academy.realm.io/posts/nspredicate-cheatsheet/).\n\n**Tries**\n\n`Results` vous permet de spécifier un critère de tri et un ordre basés sur un chemin de clé, une propriété ou sur un ou plusieurs descripteurs de tri. Par exemple, les appels suivants trient par ordre alphabétique les users :\n\n```swift\nlet pepitos = realm.objects(User.self).filter(\"age = 30 AND name BEGINSWITH 'P'\").sorted(byKeyPath: \"name\")\n```\n\nNotez que `sorted(byKeyPath:)` et `sorted(byProperty:)` ne supportent pas plusieurs propriétés comme critères de tri, et ne peuvent pas être chaînés (seul le dernier appel à trier sera utilisé). Pour trier selon plusieurs propriétés, utilisez la méthode `sorted(by:)` avec plusieurs objets `SortDescriptor`.\n\n> Chaînage des requêtes : un des avantages du moteur de requête de Realm est sa capacité à enchaîner des requêtes avec très peu de surcharge transactionnelle par rapport aux bases de données traditionnelles.\n\n> ⚠ Attention !\n\nPlusieurs choses à savoir  sur Realm :\n\n* Realm n'a pas de mécanisme pour les propriétés d'auto-incrémentation thread-safe / process-safe couramment utilisées dans d'autres bases de données lors de la génération de clés primaires. Cependant, dans la plupart des situations où une valeur auto-générée unique est souhaitée, il n'est pas nécessaire d'avoir des identifiants séquentiels, contigus et entiers. Une clé primaire de chaîne unique est généralement suffisante. Un modèle courant consiste à définir la valeur de la propriété par défaut via `NSUUID().UUIDString` pour générer des IDs de chaînes uniques ;\n* Les noms de classe sont limités à un maximum de 57 caractères UTF8 ;\n* Les noms de propriétés sont limités à un maximum de 63 caractères UTF8 ;\n* Les propriétés `Data` et `String` ne peuvent pas contenir de données d'une taille supérieure à 16 Mo. Pour stocker de plus grandes quantités de données, vous pouvez soit les décomposer en blocs de 16 Mo, soit les stocker directement sur le système de fichiers, en stockant les chemins d'accès à ces fichiers dans Realm. Une exception sera levée au moment de l'exécution si votre application tente de stocker plus de 16 Mo dans une seule propriété ;\n* Un seul fichier Realm ne peut pas être plus grand que la quantité de mémoire que votre application serait autorisée à mapper dans iOS. Cela change par périphérique, et dépend de la fragmentation de l'espace mémoire à ce moment-là (il y a un [radar](http://www.openradar.me/17119975) ouvert sur ce problème). Si vous avez besoin de stocker plus de données, vous pouvez le mapper sur plusieurs fichiers Realm.\n\n## Migration\n\nLorsque vous travaillez avec n'importe quelle base de données, il est probable que votre modèle de données change avec le temps. Étant donné que les modèles de données dans Realm sont définis comme des classes Swift standard, il est aussi facile de modifier un modèle que de changer une autre classe Swift.\n\nSupposons que nous ayons le modèle User suivant :\n\n```swift\nclass User: Object {\n    @objc dynamic var firstName = \"\"\n    @objc dynamic var lastName = \"\"\n    @objc dynamic var age = 0\n}\n```\n\nNous voulons mettre à jour le modèle de données pour exiger une propriété `fullName`, plutôt que de séparer les noms et prénoms. Pour ce faire, nous changeons simplement l'interface de l'objet en :\n\n```swift\nclass User: Object {\n    @objc dynamic var fullName = \"\"\n    @objc dynamic var age = 0\n}\n```\n\nÀ ce stade, si vous avez sauvegardé des données avec la version précédente du modèle, il y aura un décalage entre ce que Realm voit défini dans le code et les données que Realm voit sur le disque. Lorsque cela se produit, une exception sera levée lorsque vous essayez d'ouvrir le fichier existant, sauf si vous exécutez une migration ou que vous configurez Realm avec `DeleteRealmIfMigrationNeeded`.\n\nLes migrations sont définies en définissant `Realm.Configuration.schemaVersion` et `Realm.Configuration.migrationBlock`.\nVotre bloc de migration fournit toute la logique de conversion des modèles de données des schémas précédents vers le nouveau schéma.\n\nLors de la création de Realm avec cette configuration, le bloc de migration sera appliqué pour mettre à jour Realm vers la version de schéma donnée si une migration est nécessaire.\n\nSupposons que nous souhaitons migrer le modèle User déclaré plus haut. Le bloc de migration minimal nécessaire serait le suivant :\n\n```swift\nlet config = Realm.Configuration(\n    // Définir la nouvelle version du schéma. Elle doit être supérieure à la version précédemment utilisée\n    // Si vous n'avez jamais défini de version de schéma auparavant, la version est 0\n    schemaVersion: 1,\n\n    // Définir le bloc qui sera appelé automatiquement lors de l'ouverture de Realm\n    // avec une version de schéma inférieure à celle définie ci-dessus\n    migrationBlock: { migration, oldSchemaVersion in\n        // Nous n'avons encore rien migré, alors oldSchemaVersion == 0\n        if (oldSchemaVersion < 1) {\n            // Rien à faire !\n            // Realm détectera automatiquement les nouvelles propriétés et les propriétés supprimées\n            // et mettra à jour le schéma sur le disque\n        }\n    }\n)\n```\n\nAu minimum, nous devons mettre à jour la version avec un bloc vide pour indiquer que le schéma a été mis à jour (automatiquement) par Realm.\n\nBien que ce soit la migration minimale acceptable, nous voulons probablement utiliser ce bloc pour remplir toutes les nouvelles propriétés (dans le cas du `fullName`) avec quelque chose de significatif. Dans le bloc de migration, nous pouvons appeler `Migration().enumerateObjects(ofType: _:_:)` pour énumérer chaque `Object` d'un certain type, et appliquer toute logique de migration nécessaire. Notez comment, pour chaque énumération, on accède à l'instance `Object` existante via une ancienne variable `oldObject` et on accède à l'instance mise à jour via `newObject`:\n\n```swift\nRealm.Configuration.defaultConfiguration = Realm.Configuration(\n    schemaVersion: 1,\n    migrationBlock: { migration, oldSchemaVersion in\n        if (oldSchemaVersion < 1) {\n            // La méthode enumerateObjects(ofType:_:) itère\n            // sur chaque objet User stocké dans le fichier Realm\n            migration.enumerateObjects(ofType: User.className()) { oldObject, newObject in\n                // combiner les champs dans un seul champ\n                let firstName = oldObject![\"firstName\"] as! String\n                let lastName = oldObject![\"lastName\"] as! String\n                newObject![\"fullName\"] = \"\\(firstName) \\(lastName)\"\n            }\n\n            // Renommez la propriété age en yearsSinceBirth\n            migration.renameProperty(onType: User.className(), from: \"age\", to: \"yearsSinceBirth\")\n        }\n    })\n```\n\n## Notification\n\nIl est possible d'enregistrer un listener pour recevoir des notifications de modifications Realm ou ses entités.\n\nPour ce faire, les notifications sont envoyées tant qu'une référence est conservée sur le token de notification renvoyé. Vous devez conserver une référence forte à ce token dans la classe qui enregistre les mises à jour, car les notifications sont automatiquement désinscrites lorsque le token de notification est désalloué. Les notifications sont toujours envoyées sur le thread sur lequel elles étaient initialement enregistrées. Ce thread doit avoir une boucle d'exécution en cours d'exécution. Après la validation de chaque transaction d'écriture pertinente, les gestionnaires de notification sont appelés de manière asynchrone, quel que soit le thread ou le processus sur lequel la transaction d'écriture a eu lieu.\n\nChaque fois qu'une transaction d'écriture impliquant Realm est validée, quel que soit le thread ou le processus sur lequel la transaction d'écriture a eu lieu, le gestionnaire de notification sera déclenché :\n\n```swift\n// Observe Realm Notifications\nlet token = realm.observe { notification, realm in\n    viewController.updateUI()\n}\n\n// Plus tard\ntoken.invalidate()\n```\n\nDans un cas concret, vous pouvez avoir un code comme ceci :\n\n```swift\nclass ViewController: UITableViewController {\n    var notificationToken: NotificationToken? = nil\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        let realm = try! Realm()\n        let results = realm.objects(User.self).filter(\"age > 5\")\n\n        // Observe Results Notifications\n        notificationToken = results.observe { [weak self] (changes: RealmCollectionChange) in\n            guard let tableView = self?.tableView else { return }\n            switch changes {\n            case .initial:\n                // Les résultats sont maintenant populés et peuvent être consultés sans bloquer l'interface utilisateur\n                tableView.reloadData()\n            case .update(_, let deletions, let insertions, let modifications):\n                // Les résultats des requêtes ont changé, alors appliquez-les à UITableView\n                tableView.beginUpdates()\n                tableView.insertRows(at: insertions.map({ IndexPath(row: $0, section: 0) }),\n                                     with: .automatic)\n                tableView.deleteRows(at: deletions.map({ IndexPath(row: $0, section: 0)}),\n                                     with: .automatic)\n                tableView.reloadRows(at: modifications.map({ IndexPath(row: $0, section: 0) }),\n                                     with: .automatic)\n                tableView.endUpdates()\n            case .error(let error):\n                // Une erreur s'est produite lors de l'ouverture du fichier Realm sur le thread en background\n                fatalError(\"\\(error)\")\n            }\n        }\n    }\n\n    deinit {\n        notificationToken?.invalidate()\n    }\n}\n```\n\nCes modifications sont accessibles via le paramètre RealmCollectionChange transmis au bloc de notification. Cet objet contient des informations sur les indices affectés par les suppressions, les insertions et les modifications.\n\n## Encryption\n\nRealm prend en charge le cryptage du fichier de base de données sur disque avec AES-256 + SHA2 en fournissant une clé de cryptage de 64 octets lors de la création de Realm.\n\n```swift\n// Generez une clé de chiffrement random\nvar key = Data(count: 64)\n_ = key.withUnsafeMutableBytes { bytes in\n    SecRandomCopyBytes(kSecRandomDefault, 64, bytes)\n}\n\nlet config = Realm.Configuration(encryptionKey: key)\ndo {\n    let realm = try Realm(configuration: config)\n    let users = realm.objects(User.self).filter(\"name contains 'Pepi'\")\n} catch let error as NSError {\n    fatalError(\"Error opening realm: \\(error)\")\n}\n```\n\nRealm fait en sorte que toutes les données stockées sur le disque soient cryptées et décryptées de manière transparente avec AES-256 selon les besoins, et vérifiées avec un HMAC SHA-2. La même clé de chiffrement doit être fournie chaque fois que vous obtenez une instance Realm.\n\n> Il y a un faible impact sur les performances (généralement moins de 10% plus lent).\n\n## Test Unitaire\n\nLa façon la plus simple d'utiliser et de tester votre application sous Realm est d'utiliser `inMemoryIdentifier` pour chaque test :\n\n```swift\nimport XCTest\n\nclass TestCaseBase: XCTestCase {\n    override func setUp() {\n        super.setUp()\n\n        // Utilisez Realm en mémoire via le nom du test en cours.\n        // Cela garantit que chaque test ne peut pas accidentellement accéder ou modifier les données\n        // d'autres tests ou de l'application elle-même, et parce qu'ils sont en mémoire,\n        // il n'y a rien à nettoyer.\n        Realm.Configuration.defaultConfiguration.inMemoryIdentifier = self.name\n    }\n}\n```\n\nRegardons un simple benchmark sur MacBook Pro 2.8 GHz Intel Core i7, 16 Go 1600 MHz DDR3, stockage Flash, l'exécution de la suite de tests sur un simulateur iOS, nous obtenons ces résultats :\n\n* 100 accès en mémoire ~0.05 secondes vs sur disque ~0.08 secondes\n* 1000 accès en mémoire ~0.20 secondes vs sur disque ~0.41 secondes\n* 10000 accès en mémoire ~1.72 secondes vs sur disque ~4.66 secondes\n\nOù 1 accès = configure, écrire, détruis Realm.\n\n## Realm Studio\n\nRealm met à disposition un petit [outil](https://realm.io/products/realm-studio#download-studio) qui permet de visualiser votre base de donnée et d’interagir avec.\n\n![realmStudo]({{site.baseurl}}/assets/2018-02-24-realm-coredata-killer/realm-studio.png)\n\nPratique, non ?\n\nSi vous avez besoin de trouver votre fichier Realm de votre app, checkez la réponse [StackOverflow](https://stackoverflow.com/questions/28465706/how-to-find-my-realm-file/28465803#28465803) pour avoir le détail des instructions.\n\n## Conclusion\n\nJ'espère que cet article vous aura convaincu d'utiliser Realm. Sa simplicité, ses performances et sa communauté font qu'il s'est imposé dans le monde du mobile.\n"}