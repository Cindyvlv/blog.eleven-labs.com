{"date":"2017-12-14T00:00:00.000Z","title":"Pour Noël, je configure mon noyau GNU/Linux !","excerpt":"Maintenant que nous avons compris de façon générale comment fonctionnait le noyau Linux dans le précédent article, voyons comment le configurer afin, à terme, de le compiler et l'utiliser.","readingTime":"12mn","authors":["aandre"],"categories":[],"content":"\nCette article fait suite à un article intitulé [Je comprends mon noyau GNU/Linux (partie 1)]({{site.baseurl}}/fr/comprendre-kernel-linux/) et en dépend. Si vous ne l'avez pas lu, je vous invite à le faire.\n\nMaintenant que nous avons compris de façon générale comment fonctionnait le noyau Linux dans le précédent article, voyons comment le configurer afin, à terme, de le compiler et l'utiliser.\n\nJe considère dorénavant que votre choix est fait sur comment compiler votre Kernel par l'usage d'une des solutions suivantes :\n - Sur votre machine actuelle ;\n - Sur une ancienne machine ;\n - Sur une VM type VirtualBox ;\n - Sur un container Docker.\n\nÀ noter encore une fois que nous n'écraserons pas votre ancien Kernel, l'exemple est donc beaucoup plus concret en utilisant votre machine ou une ancienne machine.\n\nAfin de correspondre à une majorité de personnes sous Linux, je vais jouer le rôle de l'initrd, et fournir des commandes pour Debian et toutes distributions qui héritent de Debian.\nPar ailleurs, certains faits énoncés ne seront pas toujours vrais selon les distributions ainsi que les versions des distributions.\nJe pars du principe que vous avez la version la plus naïve d'une distribution Debian. Donc il se peut, à votre avantage, que certaines manipulations ne soient pas à réaliser.\n\n## Un peu de théorie\n\nAbordons tout d'abord très rapidement quelques notions théoriques.\n\n### Notions d'architecture\n\nAvant de compiler son noyau soi-même, encore faut-il disposer d'un environnement propice à sa compilation. Mais bien souvent, vous n'avez pas cet environnement de compilation.\nEn effet, lorsque vous téléchargez une image bootable de votre future distribution, vous avez souvent le choix entre les architectures amd64 et x86. Cela correspond aux deux types de processeurs majeurs du marché sur ordinateur standard.\nCependant il en existe d'autres pour des processeurs mais également des microcontrôleurs (les microcontrôleurs étant assimilables à des microprocesseurs de basse consommation énergétique) : arm, sparc, hppa, etc.\n\n### Le cas de la cross-compilation\n\nDans de très rares cas, la distribution que vous souhaiterez utiliser ne proposera pas votre type de microcontrôlleur ou microprocesseur.\nC'est là qu'intervient là cross-compilation. Il s'agit d'utiliser une machine source, pour compiler un exécutable pour un autre type d'architecture cible, et d'aller *pusher* l'exécutable final dans la mémoire de la cible.\nCe n'est cependant pas le sujet de cet article tant cela est rare et destiné à des systèmes embarqués très particuliers.\n\n### Absence des outils de compilation\n\nDans la plupart des cas (sauf distributions isolées telles que Gentoo), le noyau ne sera pas compilé, mais sera copié depuis l'image ISO de la distribution que vous souhaitez utiliser. D'où l'intérêt de bien choisir le type d'architecture. Cela explique aussi pourquoi de base, vous n'avez pas les outils de compilation nécessaires.\n\n## Step 1 : Récupérer le Kernel\n\nComme je souhaite que cet article soit le plus agnostique possible de la distribution utilisée, nous allons récupérer les sources directement depuis kernel.org, mais sachez que chaque distribution fourni en général un package permettant de récupérer les sources de façon automatisée. Les manipulations que vous allez effectuer sont donc l'équivalent de ce que fait votre distribution quand vous lui dites \"je veux installer les sources du kernel pour les compiler\".\nSauf qu'ici nous allons outrepasser les sécurités d'usage de votre gestionnaire de paquet qui peuvent vous interdire d'installer la dernière version du noyau, car il n'a pas été validé par la Core Team de la distribution, ce qui est potentiellement le cas pour Debian.\n\nLorsque j'écris ces lignes, le noyau est en version 4.x, plus précisément en 4.14.5. La liste est donc disponible ici : [](https://www.kernel.org/pub/linux/kernel/v4.x/). Exécutons les commandes suivantes :\n\n```\n# cd /usr/src\n# wget -c --no-check-certificate https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.14.5.tar.gz\n# tar xvzf linux-4.14.5.tar.gz\n```\n\nEn premier lieu, nous nous sommes placés dans le répertoire conventionnel des sources du noyau linux (à priori il ne contient rien sauf pour certaines distributions).\nÀ priori vous mettez les sources où vous le souhaitez (sauf dans /dev/null tant qu'à faire), mais /usr/src pour les puristes reste la zone où stocker les sources des différentes versions du Kernel avec leurs configurations respectives.\nJ'irais même plus loin en vous disant : versionnez vos configuration de kernel avec git par exemple, mais cela fera un très bon sujet d'article de ma part sur la globalité de votre système.\n\n## Step 2 : Outils permettant de configurer & compiler le kernel\n\nAvoir les sources du Kernel c'est bien, pouvoir en tirer quelque chose, c'est mieux.\n\n### Installer les utilitaires nécessaires\n\nNous aurons besoin des programmes suivants :\n\n - make\n - gcc\n - ncurses-dev\n\nSous Debian ces programmes sont installables via l'une des deux méthodes suivantes :\n```\n# apt-get install make gcc libncurses5-dev\n# apt-get install build-essential libncurses5-dev\n```\n\nncurses-dev n'est pas obligatoire mais dans ce cas, vous devrez répondre à autant de question qu'il y a d'options à configurer dans le noyau.\n\nSans ncurses-dev, `make config` :\n\n![Vue make config]({{site.baseurl}}/assets/2017-12-14-configuring-linux-kernel/make_config.png){:class=\"center-image\"}\n\n*Have fun ! On se revoit dans 10 jours quand vous aurez fini de configurer votre kernel :troll:*\n\nAvec ncurses-dev, `make menuconfig` (ou `make nconfig` pour un style plus épuré) :\n\n![Vue make menuconfig]({{site.baseurl}}/assets/2017-12-14-configuring-linux-kernel/make_menuconfig.png){:class=\"center-image\"}\n\n*Bien plus user-friendly*\n\n## Step 3 : Comprendre et apprendre de sa machine\n\nLà vous vous dites sûrement :\n\n> ok `make menuconfig` c'est bien, mais je ne comprends rien.\n\nC'est là que la commande `lspci` va nous être très utile. Elle permet de lister tous les périphériques PCI : cartes graphiques, cartes réseau, cartes son, etc :\nCette commande dispose d'ailleurs d'options très utiles :\n\n - `-k` : permet d'afficher le driver utilisé par le kernel pour piloter ce périphérique ;\n - `-q` : parfois certains périphériques ne sont pas reconnus localement via leur ID, cette option permet d'interroger la base de données centrale des PCI ID pour les reconnaître.\n\nPour tout autres type de périphériques externes vous devriez déjà avoir les références.\n\n### Google is your friend\n\nUne fois que vous avez les informations de votre matériel, Google is your friend.\nPar exemple je dispose d'un pilote graphique intégré Intel HD Graphics 430, ma recherche sera `intel hd graphics 430 linux kernel`, et une rapide recherche me confirmera que le driver à utiliser est le i915. Ce qui était d'ailleurs le résultat de `lspci -k` :\n\n```\n00:02.0 VGA compatible controller: Intel Corporation HD Graphics 530 (rev 06)\n\tSubsystem: Dell HD Graphics 530\n\tKernel driver in use: i915\n\tKernel modules: i915\n```\n\n## Step 4 : Choisir son type de configuration\n\n\"Il y a 10 types de personnes, celles qui configurent leur noyau à partir de la configuration de leur noyau actuel, et celles qui partent de la configuration de base imposée par les sources du Kernel pour la distribution voulue.\"\n\n### A. Depuis une configuration \"vierge\"\n\nJe n'ai jamais configuré de noyau avec la configuration de base de Kernel.org, mais j'imagine sans trop spéculer, que la configuration proposée se doit d'être plutôt neutre par rapport aux distributions qui vont se greffer par dessus et surtout par rapport au hardware.\nIl y a donc potentiellement plus de choses à configurer, le but n'étant pas de vous dégoûter de la compilation de kernel, cet article traîtera uniquement de l'option B.\n\n### B. Depuis une configuration existante\n\nC'est la solution la plus utilisée : partir d'une configuration de Kernel imposée par votre distribution, bien trop lourde, pour retirer l'inutile. Comme je l'expliquais, cet article reprend les concepts de Debian & Ubuntu, on se base sur un noyau assez gourmand.\nAutre avantage, ce choix permet d'itérer, en retirant des pilotes pas à pas (d'où encore, l'intérêt de versionner la configuration de son noyau). Je recommande vivement cette méthode en faisant confiance à la configuration du Kernel proposée par votre distribution, qui est souvent en adéquation avec votre volonté de choisir cette distribution plutôt qu'une autre.\n\n## Step 5 : Configuration\n\nC'est parti, il est temps de commencer :\n```\n# cd linux-4.14.5\n```\n### Récupérer notre configuration actuelle\n\nComme je le disais nous allons récupérer la configuration du noyau actuel. Deux possibilités s'offrent à nous :\n```\n# zcat /proc/config.gz > /usr/src/linux-4.14.5/.config\n# cat /boot/config-$(uname -r) > /usr/src/linux-4.14.5/.config\n```\n\n### menuconfig\n\nNous allons enfin pouvoir configurer notre noyau.\n```\n# make menuconfig\n```\n\n#### Quelques commandes utiles\n\n - Le slash `/` permet de faire une recherche ;\n - Les flèches directionnelles up/down permettent de sélectionner une option ;\n - Les flèches directionnelles left/right permettent de switcher dans le menu du bas : select/exit/help/save/load.\n - La touche espace permet de switcher une option :\n    - `[*]` option activée en dur dans le kernel\n    - `[M]` option activée en tant que module, et qui ne sera pas directement embarquée dans le kernel\n    - `[ ]` option désactivée\n - La touche entrée permet de valider l'une des options du menu du bas.\n\n#### Explication des menus\n\nGeneral setup : comme son nom l'indique il traite de configurations générales, telles que :\n    - Initrd\n    - Type de compression du module\n    - Optimisation de compilation taille vs. performance\n    - etc...\n\nIl y a des options qu'il est préférable de ne pas désactiver par hasard (lisez l'aide associée à l'option, faites des recherches sur le web). Par exemple si vous désactivez le support de la Swap sur une machine avec très peu de RAM, vous voudrez sûrement y penser à deux fois.\n\nLoadable module support : Permet d'activer ou non la possibilité d'utiliser la compilation en tant que module, et de charger des modules autour du noyau. En effet, ce n'est pas parce vous désactivez l'initrd qu'il vous sera impossible de charger des modules. Néanmoins tous les pilotes nécessaires au boot devront être compilés en dur.\n\nBlock layer : cela fait partie des options que je ne m'amuse pas à désactiver, puisque je n'en ai jamais eu l'utilité.\nUne rapide lecture de l'aide m'indique que sans cette option, je risque de me tirer une balle dans le pied, en rendant inutilisables certains systèmes de fichiers.\n\nProcessor type & features : comme son nom l'indique tout ce qui touche au processeur.\nComme pour le general setup il y a des modifications qu'il est préférable de ne pas changer sans maîtriser.\n\nPower management & ACPI : tout ce qui touche à la gestion de la consommation, très utile notamment pour les laptops.\n\nBus options : Tout ce qui gère les différents bus, évitez de désactiver le PCI, mais vous pourriez très bien en activer d'autres tels que PCMCIA.\n\nExecutable file formats : l'intitulé est trompeur. Je vous invite à regarder plus en détails l'aide de chacune des options.\nC'est ici que vous pourriez décider de ne plus supporter les librairies 32bits lorsque vous êtes sur du amd64.\n\nNetworking support : le nom parle de lui-même.\nIl y a beaucoup de choses qui peuvent être désactivées ici.\nPour le sous-menu `networking options` soyez prudent, certaines options ne devraient pas être désactivées tandis que d'autres sont totalement inutiles si vous n'utilisez pas la machine pour faire un routeur comme `IP: advanced router`.\n\nDevice drivers : Ce menu contient tous les drivers pour carte graphique, audio, réseaux, tout ! C'est là que vous désactiverez le plus de choses. Faites-vous plaisir mais n'oubliez pas google et `lspci`.\n\nFirmware drivers : cela permet au kernel de dialoguer avec le firmware (BIOS, EFI, etc.) pour obtenir des informations supplémentaires.\n\nFile systems : de nombreux systèmes de fichiers sont disponibles ici, c'est en connaissant les différents filesystems que vous utilisez que vous saurez lesquels activer ou non.\nRappelez-vous néanmoins que si vous désactivez l'initrd, si votre disque est disons en ext3, il vous faudra impérativement activer l'ext3 en dur dans le noyau et non en tant que module si vous ne voulez pas d'un joli kernel panic.\n\nKernel hacking, security options, cryptographic API, Virtualization, library routines : je n'ai jamais trop joué avec ces menus, mais leurs noms sont assez parlants pour se passer d'explications supplémentaires. Il y a sûrement quelques kilo-octets à grapiller dans certains (notamment la virtualisation).\n\n#### Désactiver initrd\n\nDans notre cas, nous voulions nous passer de l'initrd. Une brève recherche m'indique que je peux trouver cette option dans le menu general setup :\n![Recherche initrd]({{site.baseurl}}/assets/2017-12-14-configuring-linux-kernel/search_initrd.png){:class=\"center-image\"}\n\nIl me suffit de m'y rendre pour le désactiver.\nEn faisant ça je m'assure que l'initrd ne pourra jamais être utilisé, ce qui m'oblige à avoir un noyau très épuré, avec les drivers nécessaires au boot compilés en dur dans le Kernel.\n\n#### Retirer les drivers graphiques inutiles\n\nDans mon cas je sais que mon driver graphique est l'i915, une nouvelle recherche sur `i915` m'indique que plusieurs options sont disponibles :\n```\nSymbol: DRM_I915 [=m]\nType  : tristate\nPrompt: Intel 8xx/9xx/G3x/G4x/HD Graphics\n  Location:\n    -> Device Drivers\n      -> Graphics support\nDefined at drivers/gpu/drm/i915/Kconfig:1\nDepends on: HAS_IOMEM [=y] && DRM [=m] && X86 [=y] && PCI [=y]\nSelects: INTEL_GTT [=y] && INTERVAL_TREE [=y] && SHMEM [=y] && TMPFS [=y] && DRM_KMS_HELPER [=m] && DRM_PANEL [=y] && DRM_MIPI_DSI [=y] && RELAY [=y] && BACKLIGHT_LCD_SUPPORT [=y]\n```\nC'est donc dans le sous-menu graphics support que je vais aller activer l'option si ce n'est pas déjà fait, et désactiver ce qui me semble inutile (c'est à dire d'autres pilotes graphiques).\n\n![Menu graphics]({{site.baseurl}}/assets/2017-12-14-configuring-linux-kernel/graphics.png){:class=\"center-image\"}\n\nComme vous le voyez, tout est compilé en modules, et quasiment toutes les cartes sont supportées ! Faisons un peu de ménage.\n\n![Twelve seconds later]({{site.baseurl}}/assets/2017-12-14-configuring-linux-kernel/12s.jpg){:class=\"center-image\"}\n\n![Menu graphics propre]({{site.baseurl}}/assets/2017-12-14-configuring-linux-kernel/clean_graphics.png){:class=\"center-image\"}\n\nC'est beaucoup plus digeste !\n\n#### Jouez & apprenez !\n\nComme je l'expliquais la plupart des optimisations sont à faire dans le menu \"device drivers\".\nJouez, lisez les différentes aides, utilisez abondamment vos moteurs de recherche pour apprendre ce que vous pouvez ou non enlever en fonction de vos périphériques.\n\n## Conclusion\n\nNous verrons dans le prochain article comment compiler notre noyau.\nEn attendant, jouez avec les différentes options, et essayez d'apprendre de votre matériel et du kernel.\nSi vous avez tenté d'optimiser au maximum votre kernel, votre première compilation sera probablement défectueuse :D\n\nCette article est le second d'une série de trois. Vous pouvez retrouver le précédent et le suivant ci-dessous :\n\n- [Je comprends mon noyau GNU/Linux (partie 1)]({{site.baseurl}}/fr/comprendre-kernel-linux/)\n- [Je compile mon noyau GNU/Linux (partie 3)]({{site.baseurl}}/fr/compiler-kernel-linux/)\n"}