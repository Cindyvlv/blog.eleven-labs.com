{"date":"2018-10-03T00:00:00.000Z","title":"Introduction à Gitlab CI/CD","excerpt":"Cet article présente une partie des possibilités qu’offre GitLab CI/CD. Vous retrouverez aussi sur la plateforme Codelabs deux tutoriels liés à cet article, qui vous montreront deux cas d'utilisation.","readingTime":"18mn","authors":["nicolas"],"categories":["architecture"],"content":"Aujourd’hui si vous voulez mettre en place une CI/CD sur GitHub il vous faut “linker” vos dépôts avec Travis-ci, Circle-ci, Codeship... Mais savez-vous que GitLab intègre une solution de CI/CD ? C'est l'objet de l'article d'aujourd'hui.\n\nDans cet article je vais juste vous présenter les possibilités que vous offre GitLab CI/CD. Mais pour aller plus loin vous pourrez retrouver deux tutos sur le [codelabs d'Eleven Labs](https://codelabs.eleven-labs.com) :\n- [Mettre en place une Ci sur un projet js](https://codelabs.eleven-labs.com/course/fr/gitlab-ci-js/)\n- [Gestion d'environnement avec Google Cloud Storage et GitlabCI](https://codelabs.eleven-labs.com/course/fr/react-env-variable-gcp-gitlabci/)\n\nSinon, si vous cherchez une alternative à GitlabCI, un article sur GithubActions sortira très prochainement !\n\n## CI/CD c'est quoi ?\n\nJe ne vais pas vous refaire une définition mais voici ce que nous dit Wikipédia pour CI et CD :\n\n### CI : Continuous Integration\n> “L'intégration continue est un ensemble de pratiques utilisées en génie logiciel consistant à vérifier à chaque modification de code source que le résultat des modifications ne produit pas de régression dans l'application développée. [...] Le principal but de cette pratique est de détecter les problèmes d'intégration au plus tôt lors du développement. De plus, elle permet d'automatiser l'exécution des suites de tests et de voir l'évolution du développement du logiciel.”\n\n### CD : Continuous Delivery\n> \"La livraison continue est une approche d’ingénierie logicielle dans laquelle les équipes produisent des logiciels dans des cycles courts, ce qui permet de le mettre à disposition à n’importe quel moment. Le but est de construire, tester et diffuser un logiciel plus rapidement.\nL’approche aide à réduire le coût, le temps et les risques associés à la livraison de changement en adoptant une approche plus incrémentale des modifications en production. Un processus simple et répétable de déploiement est un élément clé.\"\n\n## GitLab en quelques mots\nAlors Gitlab c’est :\n- **Gitlab inc** : la compagnie qui gère les développements des produits GitLab\n- **Gitlab** : c’est une version que vous pouvez installer sur votre machine, serveur ou dans le cloud facilement avec le [Market place d’AWS](https://aws.amazon.com/marketplace/pp/B071RFCJZK)\n- **GitLab.com** : c’est une version web comme GitHub ou BitBucket.\n\nGitLab et GitLab.com sont des gestionnaires de repositories git basés sur le web avec des fonctionnalités comme :\n - un wiki,\n - un suivi d’issue,\n - un registry docker,\n - un suivi de code,\n - une review de code\n - une CI/CD,\n - ...\n\nGitLab est beaucoup plus fourni en fonctionnalités que GitHub dans sa version gratuite. Il est aussi possible d'avoir des dépôts privés sans avoir d'abonnement.\n\n## Avant de commencer\nGitLab CI/CD va vous permettre d'automatiser les `builds`, les `tests`, les `déploiements`, etc de vos applications. L’ensemble de vos tâches peut-être divisé en étapes et l’ensemble des vos tâches et étapes constituent une pipeline.\n\nChaque tâche est exécutée grâce à des `runners`, qui fonctionnent grâce à un projet open source nommé [GitLab Runner](https://gitlab.com/gitlab-org/gitlab-runner/) écrit en [GO](https://golang.org).\n\nVous pouvez avoir vos propres `runners` directement sur votre machine ou serveur. Pour plus d'information je vous laisse lire la documentation officielle :\n - [Page du projet GitLab Runner](https://docs.gitlab.com/runner/)\n - [Configuration de GitLab Runner](https://docs.gitlab.com/runner/configuration/)\n - [Configuration avancée de GitLab Runner](https://docs.gitlab.com/runner/configuration/advanced-configuration.html)\n\nGitLab propose aussi des runners publics, qui vous épargnent une installation, mais attention, il y a des quotas suivant le type de compte dont vous diposez. En compte gratuit, vous avez le droit à 2000 minutes de temps de pipeline par mois. Les runners publics de gitlab.com sont exécutés sur AWS.\n\n## Présentation de GitLab CI/CD\nComme je vous l’ai dit je ne vais pas vous montrer comment mettre en place une CI/CD de A à Z dans cet article mais je vais vous présenter les possibilités de la solution de GitLab CI/CD.\n\n### Le manifeste\nPour que la CI/CD sur GitLab fonctionne il vous faut un manifeste `.gitlab-ci.yml` à la racine de votre projet. Dans ce manifeste vous allez pouvoir définir des `stages`, des `jobs`, des `variables`, des `anchors`, etc.\n\nVous pouvez lui donner un autre nom mais il faudra changer le nom du manifeste dans les paramètres de l’interface web :  `Settings > CI/CD > General pipelines > Custom CI config path`\n\n### Les Jobs\nDans le manifeste de GitLab CI/CD vous pouvez définir un nombre illimité de `jobs`, avec des contraintes indiquant quand ils doivent être exécutés ou non.\n\nVoici comment déclarer un `job` le plus simplement possible :\n```yaml\njob:\n  script: echo 'my first job'\n```\nEt si vous voulez déclarer plusieurs `jobs` :\n```yaml\njob:1:\n  script: echo 'my first job'\n\njob:2:\n  script: echo 'my second job'\n```\nles noms des `jobs` doivent être uniques et ne doivent pas faire parti des mots réservés :\n- `image`\n- `services`\n- `stages`\n- `types`\n- `before_script`\n- `after_script`\n- `variables`\n- `cache`\n\nDans la définition d'un `job` seule la déclaration `script` est obligatoire.\n\n### Script\nLa déclaration `script` est donc la seule obligatoire dans un `job`. Cette déclaration est le coeur du `job` car c'est ici que vous indiquerez les actions à effectuer.\n\nIl peut appeler un ou plusieurs script(s) de votre projet, voire exécuter une ou plusieurs ligne(s) de commande.\n\n```yaml\njob:script:\n  script: ./bin/script/my-script.sh ## Appel d'un script de votre projet\n\njob:scripts:\n  script: ## Appel de deux scripts de votre projet\n    - ./bin/script/my-script-1.sh\n    - ./bin/script/my-script-2.sh\n\njob:command:\n  script: printenv # Exécution d'une commande\n\njob:commands:\n  script: # Exécution de deux commandes\n    - printenv\n    - echo $USER\n```\n\n### before_script et after_script\nCes déclarations permettront d'exécuter des actions avant et après votre script principal. Ceci peut être intéressant pour bien diviser les actions à faire lors des `jobs`, ou bien appeler ou exécuter une action avant et après chaque `job`\n\n```yaml\nbefore_script: # Exécution d'une commande avant chaque `job`\n  - echo 'start jobs'\n\nafter_script: # Exécution d'une commande après chaque `job`\n  - echo 'end jobs'\n\njob:no_overwrite: # Ici le job exécutera les action du `before_script` et `after_script` par défaut\n  script:\n    - echo 'script'\n\njob:overwrite:before_script:\n  before_script:\n    - echo 'overwrite' # N'exécutera pas l’action définie dans le `before_script` par défaut\n  script:\n    - echo 'script'\n\njob:overwrite:after_script:\n  script:\n    - echo 'script'\n  after_script:\n    - echo 'overwrite' # N'exécutera pas l’action définie dans le `after_script` par défaut\n\njob:overwrite:all:\n  before_script:\n    - echo 'overwrite' # N'exécutera pas l’action définie dans le`before_script` par défaut\n  script:\n    - echo 'script'\n  after_script:\n    - echo 'overwrite' # N'exécutera pas l’action définie dans le `after_script` par défaut\n```\n\n### Image\nCette déclaration est simplement l'image docker qui sera utilisée lors d'un job ou lors de tous les jobs\n\n```yaml\nimage: alpine # Image utilisée par tous les `jobs`, ce sera l'image par défaut\n\njob:node: # Job utilisant l'image node\n  image: node\n  script: yarn install\n\njob:alpine: # Job utilisant l'image par défaut\n  script: echo $USER\n```\n\n### Stages\nCette déclaration permet de grouper des `jobs` en étapes. Par exemple on peut faire une étape de `build`, de `codestyling`, de `test`, de `code coverage`, de `deployment`, ….\n\n```yaml\nstages: # Ici on déclare toutes nos étapes\n  - build\n  - test\n  - deploy\n\njob:build:\n  stage: build # On déclare que ce `job` fait partie de l'étape build\n  script: make build\n\njob:test:unit:\n  stage: test # On déclare que ce `job` fait partie de l'étape test\n  script: make test-unit\n\njob:test:functional:\n  stage: test # On déclare que ce `job` fait partie de l'étape test\n  script: make test-functional\n\njob:deploy:\n  stage: deploy # On déclare que ce `job` fait partie de l'étape deploy\n  script: make deploy\n```\n![CI Stages]({{site.baseurl}}/assets/2018-09-19-introduction-gitlab-ci/ci-stages.png)\n\n### Only et except\nCes deux directives permettent de mettre en place des contraintes sur l'exécution d’une tâche. Vous pouvez dire qu’une tâche s'exécutera uniquement sur l’événement d’un push sur master ou s'exécutera sur chaque push d’une branche sauf master.\n\nVoici les possibilités :\n - **branches** déclenche le `job` quand un un push est effectué sur la branche spécifiée.\n - **tags** déclenche le `job` quand un tag est créé.\n - **api** déclenche le `job` quand une deuxième pipeline le demande grâce à API pipeline.\n - **external** déclenche le `job` grâce à un service de CI/CD autre que GitLab.\n - **pipelines** déclenche le `job` grâce à une autre pipeline, utile pour les multiprojets grâce à l’API et le token `CI_JOB_TOKEN`.\n - **pushes** déclenche le `job`quand un `push` est effectué par un utilisateur.\n - **schedules** déclenche le `job` par rapport à une planification à paramétrer dans l’interface web.\n - **triggers** déclenche le `job` par rapport à un jeton de déclenchement.\n - **web** déclenche le `job` par rapport au bouton `Run pipeline` dans l'interface utilisateur.\n\n Je vais vous montrer trois exemples d'utilisation :\n\n#### only et except simple\nDans son utilisation la plus simple, le only et le except se déclarent comme ceci :\n```yaml\njob:only:master:\n  script: make deploy\n  only:\n    - master # Le job sera effectué uniquement lors d’un événement sur la branche master\n\njob:except:master:\n  script: make test\n  except:master:\n    - master # Le job sera effectué sur toutes les branches lors d’un événement sauf sur la branche master\n```\n#### only et except complex\n\nDans son utilisation la plus complexe, le only et le except s'utilisent comme ceci :\n```yaml\njob:only:master:\n  script: make deploy\n  only:\n    refs:\n      - master # Ne se fera uniquement sur master\n    kubernetes: active # Kubernetes sera disponible\n    variables:\n      - $RELEASE == \"staging\" # On teste si $RELEASE vaut \"staging\"\n      - $STAGING # On teste si $STAGING est défini\n```\n#### only avec schedules\nPour l'utilisation de `schedules` il faut dans un premier temps définir des règles dans l'interface web.\nOn peut les configurer dans l’interface web de Gitlab :  `CI/CD -> Schedules` et remplir le formulaire.\n\n![CI Schedules]({{site.baseurl}}/assets/2018-09-19-introduction-gitlab-ci/ci-schedules.png)\n\nSi vous souhaitez, vous pouvez définir un intervalle de temps personnalisé. C'est ce que j'ai fait dans mon exemple. La définition se fait comme un [cron](https://en.wikipedia.org/wiki/Cron)\n\n### when\nComme pour les directives `only` et `except`, la directive `when` est une contrainte sur l'exécution de la tâche. Il y a quatre modes possibles :\n - `on_success` : le job sera exécuté uniquement si tous les `jobs` du stage précédent sont passés\n - `on_failure` : le job sera exécuté uniquement si un job est en échec\n - `always` : le job s'exécutera quoi qu'il se passe (même en cas d’échec)\n - `manual` : le job s'exécutera uniquement par une action manuelle\n\n```yaml\nstages:\n  - build\n  - test\n  - report\n  - clean\n\njob:build:\n  stage: build\n  script:\n    - make build\n\njob:test:\n  stage: test\n  script:\n    - make test\n  when: on_success # s'exécutera uniquement si le job `job:build` passe\n\njob:report:\n  stage: report\n  script:\n    - make report\n  when: on_failure # s'exécutera si le job `job:build` ou `job:test` ne passe pas\n\njob:clean:\n  stage: clean\n  script:\n    - make clean # s'exécutera quoi qu'il se passe\n  when: always\n```\n\n### allow_failure\nCette directive permet d'accepter qu'un job échoue sans faire échouer la pipeline.\n\n```yaml\nstages:\n  - build\n  - test\n  - report\n  - clean\n\n...\n\nstage: clean\n  script:\n    - make clean\n    when: always\n    allow_failure: true # Ne fera pas échouer la pipeline\n...\n```\n\n### tags\nComme je vous l'ai dit en début d’article, avec GitLab Runner vous pouvez héberger vos propres runners sur un serveur ce qui peut être utile dans le cas de configuration spécifique.\n\nChaque runner que vous définissez sur votre serveur à un nom, si vous mettez le nom du runner en `tags`, alors ce runner sera exécuté.\n\n```yaml\njob:tag:\n  script: yarn install\n  tags:\n    - shell # Le runner ayant le nom `shell` sera lancé\n```\n\n### services\nCette déclaration permet d'ajouter des services (container docker) de base pour vous aider dans vos `jobs`.\nPar exemple si vous voulez utiliser une base de données pour tester votre application c'est dans `services` que vous le demanderez.\n\n```yaml\ntest:functional:\n  image: registry.gitlab.com/username/project/php:test\n  services:\n    - postgres # On appel le service `postgres` comme base de données\n before_script:\n   - composer install -n\n script:\n   - codecept run functional\n```\n\n### environment\nCette déclaration permet de définir un environnement spécifique au déploiement. Vous pouvez créer un environnement dans l'interface web de GitLab ou tout simplement laisser GitLab CI/CD le créer automatiquement.\n\nIl est possible de spécifier :\n - un `name`,\n - une `url`,\n - une condition `on_stop`,\n - une `action` en réponse de la condition précédente.\n\n```yaml\n...\n\ndeploy:demo:\n  stage: deploy\n  environment: demo # Déclaration simple de l'environnement\n  script:\n    - make deploy\n\ndeploy:production:\n  environment: # Déclaration étendue de l'environnement\n    name: production\n    url: 'https://blog.eleven-labs/fr/gitlab-ci/' # Url de l'application\n  script:\n    - make deploy\n```\n\nEn déclarant des `environments` vous pouvez, depuis l'interface web de GitLab, déployer / redéployer votre application ou directement accéder à votre site si vous avez déclaré une `url`. Ceci se fait dans `Operations > Environment`.\n\n![CI Environment]({{site.baseurl}}/assets/2018-09-19-introduction-gitlab-ci/ci-environment.png)\n\nLe bouton `undo` permet de redéployer, le bouton `external link` permet d'aller sur l'application et le bouton `remove` permet de supprimer l'environnement.\n\n`on_stop` et `action` seront utilisés pour ajouter une action à la fin du déploiement, si vous souhaitez arrêter votre application sur commande. Utile pour les environnements de démonstration.\n\n```yaml\n...\n\ndeploy:demo:\n  script: make deploy\n  environment:\n    name: demo\n    on_stop: stop:demo\n\nstop:demo: # Ce job pourra être visible et exécuté uniquement après le job `deploy:demo`\n  script: make stop\n  environment:\n    name: demo\n    action: stop\n```\n\nVoici le lien officiel de la documentation sur les [environments](https://docs.gitlab.com/ee/ci/environments.html) si vous souhaitez aller plus loin.\n\n\n### variables\nCette déclaration permet de définir des variables pour tous les `jobs` ou pour un `job` précis.\nCeci revient à déclarer des variables d'environnement.\n\n```yaml\n...\nvariables: # Déclaration de variables pour tous les `job`\n  SYMFONY_ENV: prod\n\nbuild:\n  script: echo ${SYMFONY_ENV} # Affichera \"prod\"\n\ntest:\n  variables: # Déclaration et réécriture de variables globales pour ce `job`\n    SYMFONY_ENV: dev\n    DB_URL: '127.0.0.1'\n  script: echo ${SYMFONY_ENV} ${DB_URL} # Affichera \"dev 127.0.0.1\"\n```\n\nComme pour `environment` je vous laisse regarder la documentation officielle sur les [variables](https://docs.gitlab.com/ee/ci/yaml/#variables) si vous souhaitez aller plus loin.\n\nIl est aussi possible de déclarer des variables depuis l'interface web de GitLab `Settings > CI/CD > Variables` et de leur spécifier un environnement.\n\n![CI Variables]({{site.baseurl}}/assets/2018-09-19-introduction-gitlab-ci/ci-variables.png)\n\n### cache\nCette directive permet de jouer avec du cache. Le cache est intéressant pour spécifier une liste de fichiers et de répertoires à mettre en cache tout le long de votre pipeline. Une fois la pipeline terminée le cache sera détruit.\n\nPlusieurs sous-directives sont possibles :\n - paths : obligatoire, elle permet de spécifier la liste de fichiers et/ou répertoires à mettre en cache\n - key : facultative, elle permet de définir une clé pour la liste de fichiers et/ou de répertoires. Personnellement je n’en ai toujours pas vu l’utilité.\n - untracked : facultative, elle permet de spécifier que les fichiers ne doivent pas être suivis par votre dépôt git en cas d'un `push` lors de votre pipeline.\n - policy : facultative, elle permet de dire que le cache doit être récupéré ou sauvegardé lors d’un job (`push` ou `pull`).\n\n```yaml\nstages:\n  - build\n  - deploy\n\njob:build:\n  stage: build\n  image: node:8-alpine\n  script: yarn install && yarn build\n  cache:\n    paths:\n      - build # répertoire mis en cache\n    policy: push # le cache sera juste sauvegardé, pas de récupération d'un cache existant\n\njob:deploy:\n  stage: deploy\n  script: make deploy\n  cache:\n    paths:\n      - build\n    policy: pull # récupération du cache\n```\n\n### artifacts\nLes artefacts sont un peu comme du cache mais ils peuvent être récupérés depuis une autre pipeline.\nComme pour le cache il faut définir une liste de fichiers ou/et répertoires qui seront sauvegardés par GitLab.\nLes fichiers sont sauvegardés uniquement si le `job` réussit.\n\nNous y retrouvons cinq sous-directives possibles :\n - paths : obligatoire, elle permet de spécifier la liste des fichiers et/ou dossiers à mettre en `artifact`\n - name: facultative, elle permet de donner un nom à l'`artifact`. Par défaut elle sera nommée `artifacts.zip`\n - untracked : facultative, elle permet d'ignorer les fichiers définis dans le fichier `.gitignore`\n - when : facultative, elle permet de définir quand l'`artifact` doit être créé. Trois choix possibles `on_success`, `on_failure`, `always`. La valeur `on_success` est la valeur par défaut.\n - expire_in : facultative, elle permet de définir un temps d'expiration\n\n```yaml\njob:\n  script: make build\n  artifacts:\n    paths:\n      - dist\n    name: artifact:build\n    when: on_success\n    expire_in: 1 weeks\n```\n\n### dependencies\nCette déclaration fonctionne avec les `artifacts`, il rend un `job` dépendant d'un `artifact`. Si l'`artifact` a expiré ou a été supprimé / n'existe pas, alors la pipeline échouera.\n\n```yaml\n\nbuild:artifact:\n  stage: build\n  script: echo hello > artifact.txt\n  artifacts: # On ajoute un `artifact`\n    paths:\n      - artifact.txt\n\ndeploy:ko:\n  stage: deploy\n  script: cat artifact.txt\n  dependencies: # On lie le job avec 'build:artifact:fail' qui n'existe pas donc la pipeline échouera\n    - build:artifact:fail\n\ndeploy:ok:\n  stage: deploy\n  script: cat artifact.txt\n  dependencies: # On lie le job avec 'build:artifact' qui existe donc la pipeline n'échouera pas\n    - build:artifact\n```\n\n### coverage\nCette déclaration permet de spécifier une expression régulière pour récupérer le code coverage pour un `job`.\n\n```yaml\n...\n\ntest:unit:\n  script: echo 'Code coverage 13.13'\n  coverage: '/Code coverage \\d+\\.\\d+/'\n```\n\nLe code coverage sera visible dans les informations du `job` dans l'interface web de GitLab :\n\n![CI Coverage]({{site.baseurl}}/assets/2018-09-19-introduction-gitlab-ci/ci-coverage.png)\n\n> Si vous le souhaitez voici un autre article de notre blog écrit par l'astronaute [Pouzor](https://blog.eleven-labs.com/authors/pouzor/) sur le code coverage : [Ajouter le code coverage sur les MR avec avec GitLab-CI](https://blog.eleven-labs.com/fr/ajouter-le-code-coverage-sur-les-pr-avec-gitlab-ci/)\n\n### retry\nCette déclaration permet de ré-exécuter le `job` en cas d'échec. Il faut indiquer le nombre de fois où vous voulez ré-exécuter le `job`\n\n```yaml\njob:retry:\n  script: echo 'retry'\n  retry: 5\n```\n\n### include\nPour cette fonctionnalité il vous faudra un compte premium. Cette fonctionnalité permet d'inclure des \"templates\".\nles \"templates\" peuvent être en local dans votre projet ou à distance.\n\nLes fichiers sont toujours évalués en premier et fusionnés récursivement. Vous pouvez surcharger ou remplacer des déclarations des \"templates\".\n\n - template en local\n\n```yaml\n# template-ci/.lint-template.yml\n\njob:lint:\n  stage: lint\n  script:\n    - yarn lint\n```\n\n - template à distance\n\n```yaml\n# https://gitlab.com/awesome-project/raw/master/template-ci/.test-template.yml\n\njob:test:\n  stage: test\n  script:\n    - yarn test\n```\n\n - manifeste principal\n\n```yaml\n# .gitlab-ci.yml\n\ninclude:\n  - '/template-ci/.lint-template.yml'\n  - 'https://gitlab.com/awesome-project/raw/master/template-ci/.test-template.yml'\n\nstages:\n  - lint\n  - test\n\nimage: node:9-alpine\n\njob:lint:\n  before_script:\n    - yarn install\n\njob:test:\n  script:\n    - yarn install\n    - yarn unit\n```\n\nVoici ce que gitlab CI/CD va interpréter :\n\n```yaml\nstages:\n  - lint\n  - test\n\nimage: node:9-alpine\n\njob:lint:\n  stage: lint\n  before_script: # on surcharge `job:lint` avec `before_script`\n    - yarn install\n  script:\n    - yarn lint\n\njob:test:\n  stage: test\n  script: # on remplace la déclaration `script` du \"template\" https://gitlab.com/awesome-project/raw/master/template-ci/.test-template.yml\n    - yarn install\n    - yarn unit\n```\n\nCeci peut être intéressant dans le cas où votre manifeste est gros, et donc plus difficile à maintenir.\n\n### Anchors\nCette fonctionnalité permet de faire des templates réutilisables plusieurs fois.\n\n```yaml\n.test_template: &test_template\n  stage: test\n  image: registry.gitlab.com/username/project/php:test\n  before_script:\n    - composer install -n\n  when: on_success\n\n.db_template:\n  services:\n    - postgres\n    - mongo\n\ntest:unit:\n  <<: *test_template\n  script:\n    - bin/phpunit --coverage-text --colors=never tests/\n\ntest:functional:\n  <<: *test_template\n  services: *db_template\n  script:\n    - codecept run functional\n```\n\nVoici ce que gitlab CI/CD va interpréter :\n\n```yaml\ntest:unit:\n  stage: test\n  image: registry.gitlab.com/username/project/php:test\n  before_script:\n    - composer install -n\n  script:\n    - bin/phpunit --coverage-text --colors=never tests/\n  when: on_success\n\ntest:functional:\n  stage: test\n  image: registry.gitlab.com/username/project/php:test\n  services:\n    - postgres\n    - mongo\n  before_script:\n    - composer install -n\n  script:\n    - codecept run functional\n  when: on_success\n```\n\n## Ressources\n\n- [GitLab Continuous Integration (GitLab CI/CD)](https://docs.gitlab.com/ee/ci/README.html)\n- [Getting started with GitLab CI/CD](https://docs.gitlab.com/ee/ci/quick_start/README.html)\n- [Configuration of your jobs with .gitlab-ci.yml](https://docs.gitlab.com/ee/ci/yaml/README.html)\n- [GitLab Runner](https://docs.gitlab.com/runner/)\n"}