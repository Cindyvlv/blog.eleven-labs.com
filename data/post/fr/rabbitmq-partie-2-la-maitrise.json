{"date":"2018-04-11T00:00:00.000Z","title":"RabbitMQ des bases à la maîtrise (Partie 2)","excerpt":"Les policies, le retry (dead letter, poison message)... en avant pour l'utilisation avancée de RabbitMQ.","readingTime":"6mn","authors":["amoutte"],"categories":[],"content":"\nLes policies, le retry (dead letter, poison message)... en avant pour l'utilisation avancée de RabbitMQ.\n\n## Introduction\n\nAprès avoir vu les bases dans [RabbitMQ : Les bases (Partie 1)](/fr/rabbitmq-partie-1-les-bases/),\nnous allons pousser un peu plus loin l'utilisation de RabbitMQ.\n\n## Plugins\n\n> 🥕 Les plugins sont comme des engrais pour votre champ de carottes.\n\nJe vous invite à consulter la page des [plugins](https://www.rabbitmq.com/plugins.html) ainsi que le [Github](https://github.com/rabbitmq)\nafin de voir les plugins officiels disponibles.\n\nD'autre part je vous conseille fortement d'activer au minimum les plugins suivants :\n\n* `rabbitmq_management` ce plugin ajoute une interface web très pratique pour configurer RabbitMQ.\n* `rabbitmq_tracing` ce plugin (dans l'onglet Admin > Tracing) vous permet de tracer (debug) les messages.\n\n## Authentification / Autorisation\n\nDans tout système d'informations, l'utilisation de permissions, par utilisateur/groupe, est une notion très importante.\nElle permet d'organiser et maîtriser l'utilisation et l'accès au service.\n\nRabbitMQ embarque un système interne d'authentification/autorisation mais une fois de plus il existe différents [plugins d'auth](https://github.com/rabbitmq?q=rabbitmq-auth).\n\n> ℹ️ Avec le plugin [rabbitmq-auth-backend-http](https://github.com/rabbitmq/rabbitmq-auth-backend-http) vous pouvez même\n> déléguer cette partie à une API HTTP (Les utilisateurs de votre plateforme sont connectés à RabbitMQ ! 😜).\n> Voici une [implémentation en PHP](https://github.com/symftony/rabbitmq-auth-backend-http-php) qui utilise le composant security de Symfony.\n\nVous avez même la possibilité de configurer plusieurs systèmes d'auth en cascade.\n\n```\nauth_backends.my_auth_1 = internal\nauth_backends.my_auth_2 = http\n...\n```\n\n> Ici les valeurs `my_auth_1` et `my_auth_2` sont arbitraires et peuvent prendre n'importe quelle valeur.\n\n### Utilisateur\n\nUn utilisateur (username, password facultatif) est utilisé pour se connecter à RabbitMQ afin de publier et consommer les messages.\n\n> Le plugin `rabbitmq_management` ajoute une notion de tags (administrator, monitoring, policymaker, management, impersonator)\n> afin de limiter l'accès aux différentes parties de l'interface.\n\nUne fois votre utilisateur créé, il faudra lui ajouter des permissions sur chaque `vhost` auxquels il aura accès.\n\nSur le backend d'auth par défaut (`rabbit_auth_backend_internal`), les permissions sont séparées en 3 groupes :\n\n * Configure regexp\n * Write regexp\n * Read regexp\n\n![RabbitMQ Permissions]({{site.baseurl}}/assets/2018-04-11-rabbitmq-partie-2-la-maitrise/rabbitmq-permissions.png)\n\n> 🚀 Pour une utilisation plus simple des regexp je vous conseille d'avoir une vraie stratégie de nommage des `exchanges`/`queues`\n> avec des préfixes/segments/suffixes. D'une part vous pourrez plus facilement identifier qui a créé les ressources mais aussi qui les consomme.\n\nJe vous laisse consulter le [tableau de répartition des actions par ressource](http://www.rabbitmq.com/access-control.html#permissions)\n\n> 🥕 Maintenant vous pouvez facilement identifier vos petits lapins.\n\n## Policies\n\nLes policies sont des règles de configurations qui s'appliquent aux `exchanges` et aux `queues` (dont le nom matche une regexp) afin de diminuer la redondance de configuration mais aussi et surtout de pouvoir changer une `policy` sans avoir à détruire et recréer la ressource (`exchange`/`queue`).\nCertaines options de configuration d'une `policy` sont spécifiques aux `exchanges` et d'autres aux `queues`.\n\n![RabbitMQ Policies]({{site.baseurl}}/assets/2018-04-11-rabbitmq-partie-2-la-maitrise/rabbitmq-policies.png)\n\nLes `Policies` peuvent être utilisées pour configurer :\n\n- [federation plugin](https://www.rabbitmq.com/federation.html)\n- [mirrored queues](https://www.rabbitmq.com/ha.html)\n- [alternate exchanges](https://www.rabbitmq.com/ae.html)\n- [dead lettering](https://www.rabbitmq.com/dlx.html)\n- [per-queue TTLs](https://www.rabbitmq.com/ttl.html)\n- [maximum queue length](https://www.rabbitmq.com/maxlength.html).\n\n> ⚠️  Attention, l'utilisation de policies peut devenir rapidement complexe.\n\n## Retry (Dead letter)\n\nLes retries sont un autre sujet **très important** de RabbitMQ ! Quand le message consumer rencontre une erreur durant le traitement d'un message il peut être intéressant dans certains cas de réessayer le traitement du message.\nLes différentes solutions sont :\n\n- Ne pas ACK ou NACK le message (Retry infini instantané bloquant)\n\n> Le message va garder sa place dans la queue et le consumer va de nouveau récupérer ce message au prochain get.\n> ⚠️ Je déconseille *très fortement* cette approche ! Car le consumer va toujours récupérer le même message jusqu'au succès du traitement,\n> qui pourrait ne jamais se produire et créer une boucle infinie. De plus le message en erreur bloque le dépilement des messages suivants.\n\n- NACK le message avec une queue configurée avec DLX = \"\" (default exchange amq.default) et DLK = {QUEUENAME}  (Retry infini instantané non bloquant)\n\n> Le message va être remis en début de queue.\n> ⚠️ Je déconseille également cette approche ! Cette fois-ci, le message ne va pas bloquer le dépilement des autres messages de la queue,\n> mais il peut quand même créer une boucle infinie si il n'y a qu'un message dans la queue.\n\n- ACK le message après avoir publié un clone du message depuis le consumer. (Solution la plus dynamique -> retry retardé *variable* non bloquant)\n\n> ℹ️ Avec cette solution on peut facilement gérer des \"délais avant retry\" variables. Premier retry à 5 secondes, deuxième à 10 secondes, etc...\n> ⚠️ Je garde une réserve sur cette pratique car elle fonctionne mais positionne la responsabilité du retry du côté applicatif.\n\n- NACK le message avec un délai avant de retry le message (Le \"délai avant retry\" est fixe -> retry retardé *fix* non bloquant)\n\n> 👍 Le message va être remis en début de queue après avoir été mis en attente pendant un temps défini.\n\nC'est cette dernière solution que nous allons détailler.\n\nPour mettre en place cette solution nous allons devoir créer un exchange et une queue d'attente.\n\nCréer un exchange qui va router les messages dans la queue d'attente `waiting_5` type `fanout`.\nCréer une queue d'attente `waiting_5` avec `x-dead-letter-exchange: \"\"` et `x-message-ttl: 5000`.\nPuis binder cette queue sur l'exchange `waiting_5`.\n\n> ⚠️ le x-dead-letter-exchange doit être configuré avec une chaîne vide (amq.default).\n\nConfigurez ensuite votre queue `queue1` avec `x-dead-letter-exchange: \"waiting_5\"` `x-dead-letter-routing-key: queue1`.\n\n> ⚠️ le x-dead-letter-routing-key doit être configuré avec le nom de la queue.\n\n![RabbitMQ Retry]({{site.baseurl}}/assets/2018-04-11-rabbitmq-partie-2-la-maitrise/rabbitmq-retry.jpg)\n\nAvec cette configuration, quand le consumer NACK le message, RabbitMQ redirige le message dans l'exchange `waiting_5` (fanout)\nqui va donc router ce message dans la queue `waiting_5`. La queue `waiting_5` va attendre 5 secondes avant d'`expired` le message,\nil va donc arriver dans l'exchange `amq.default` avec comme routing key `queue1` et donc être routé dans la queue `queue1`.\n\n> ℹ️ À noter que le retry est infini. Ce qui peu également créer des `poison messages`.\n\n## Poison message\n\nUn `poison message` c'est un message que le consumer rejettera (NACK) à chaque fois qu'il va le consommer.\nAfin de traiter les poisons messages il faut que le consumer regarde dans les properties du message afin de vérifier\nque le nombre de tentatives n'a pas été atteint.\n\n![RabbitMQ Retry]({{site.baseurl}}/assets/2018-04-11-rabbitmq-partie-2-la-maitrise/rabbitmq-x-death-header.jpg)\n\n> Si le nombre de retry a été atteint il faudra loguer une erreur et ACK le message.\n\n## Production\n\nConsultez la documentation sur les [recommandations pour les serveurs de **production**](https://www.rabbitmq.com/production-checklist.html).\n\n> 🐇 Vous voici maintenant fin prêt à déguster un bon pâté de lapin !\n\n## Liens utiles\nhttps://www.rabbitmq.com/admin-guide.html\n"}