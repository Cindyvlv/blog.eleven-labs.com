{"date":"2019-06-12T00:00:00.000Z","title":"Débuter le code splitting avec React.lazy","excerpt":"Lorsque votre projet React est bien avancé, charger l'application pour un utilisateur peut devenir de plus en plus long. Pour pallier ce problème, React permet depuis ses dernières mises à jour de faire du Code Splitting.","readingTime":"6mn","authors":["rmavillaz"],"categories":["javascript"],"content":"\nLorsque votre projet React est bien avancé, charger l'application pour un utilisateur peut devenir de plus en plus long. Pour pallier ce problème, React permet depuis ses dernières mises à jour, de faire du **Code Splitting**.\n\n## Définition du Code Splitting\n\nAvant toute chose, il est bon de rappeler ce qu'est le code splitting. Comme vous le savez sans doute, **il est aujourd'hui très commun d'utiliser Webpack pour build notre application JS**. C'est lui qui va regrouper le JS en un seul fichier et gérer les différents assets.\nMais **Webpack peut également découper le code en plusieurs fichiers de manière intelligente**, permettant ainsi de charger la ressource uniquement si nécessaire ou en parallèle.\n\nL'intérêt est limité dans un petit projet en React mais peut être nécessaire lorsque celui-ci devient bien avancé. Charger toute l'application peut être fastidieux si l'utilisateur a une très faible connexion, et même carrément inutile si celui-ci souhaite juste naviguer sur une partie du site.\n\n## Fonctionnement avec React\n\nAvant de débuter, petite parenthèse, la librairie [loadable-components](https://github.com/smooth-code/loadable-components) permet déjà de faire du code splitting. Mais la team React a commencé à développer son propre module nommé **lazy**.\nSi vous avez initialisé votre projet avec **create-react-app**, vous n'avez rien à faire, sinon, à vous de mettre à jour votre webpack pour le [code splitting](https://webpack.js.org/guides/code-splitting).\n\nUn composant React est arrivé en même temps, nommé **Suspense**, qui va de pair avec le `lazy`. Il va permettre de créer un loadeur pendant le chargement d'une ressource avec **lazy**.\n\n## Utilisation du lazy\n\nPour débuter dans le code splitting, il faut d'abord se poser la question suivante:\n- Quelles sont les parties de mon site, ou plus précisément les composants, que je souhaite splitter ?\nJe pars donc du principe que vous avez déjà un projet React qui tourne et nous allons intégrer l'import de composants en mode lazy. Le plus simple et le plus pertinent est souvent de l’intégrer dans le système de routing de votre application.\n\n```js\n//routing.js\nimport React from 'react';\nimport { Switch, Route } from 'react-router-dom';\n\nimport NotFound from '../NotFound';\nimport Home from '../Home';\nimport Projects from '../Projects';\n\nconst Router = () => (\n    <Switch>\n      <Route path=\"/\" component={Home} exact />\n      <Route path=\"/projets\" component={Projects} />\n      <Route component={NotFound} />\n    </Switch>\n);\n\nexport default Router;\n```\n\nVoici un système de routing classique. Tous les composants sont chargés au moment où on arrive sur l'application. On peut même voir que le fichier JS fait 2,49Mo !\n\n![size_js_app-without_code_splitting]({{site.baseurl}}/assets/2019-05-22-react-code-splitting/js-size-without-code-splitting.png \"javascript code size without code splitting\")\n\n\n### Intégration du lazy\n\n```js\n// on importe la méthode lazy\nimport React, { lazy } from 'react';\nimport { Switch, Route } from 'react-router-dom';\n\nimport { NotFound } from '../NotFound';\n// on utilise lazy pour importer les autres composants\nconst Home = lazy(() => import('../Home'));\nconst Projects = lazy(() => import('../Projects'));\n\nconst Router = () => (\n  <Switch>\n    <Route path=\"/\" component={Home} exact />\n    <Route path=\"/projets\" component={Projects} />\n    <Route component={NotFound} />\n  </Switch>\n);\n\nexport default Router;\n```\n\nNous avons donc importé directement la méthode `lazy` depuis React puis nous avons modifié la façon d'importer les composants nécessaires au routing. La méthode `import()` permet de l'import dynamique. Couplé au lazy, celui-ci va se faire uniquement si la ressource est demandée par l'utilisateur.\n\nDans ce cas précis, le code du composant `Home` et `Projects` ne sera chargé que si l'utilisateur va sur l'url `/` ou `/projects`.\n![size_js_app-with_code_splitting_1]({{site.baseurl}}/assets/2019-05-22-react-code-splitting/js-size-code-splitting-1.png \"javascript code size with code splitting 1\")\n\nLorsque Webpack split le code, il utilise toujours le fichier `bundle.js` contenant le coeur de l'application. Le reste sera contenu dans des fichiers à part, nommé des **chunk**. On voit sur l'image qu'il existe un fichier `0.chunk.js` qui correspond au code du composant `Home` dans notre cas.\n\n![size_js_app-with_code_splitting_2]({{site.baseurl}}/assets/2019-05-22-react-code-splitting/js-size-code-splitting-2.png \"javascript code size with code splitting 2\")\n\nEn naviguant sur la page `/projets`, on voit bien qu'un nouveau fichier a été chargé `1.chunk.js`, le code splitting est donc fonctionnel.\nSi l'ont additionne tous les fichiers, on retrouve bien les 2,49Mo de base. Bien sûr, dans notre exemple le gain est faible. Mais il peut être énorme dans une réelle application avec des images et des dizaines de pages.\n\nAu passage, **notez bien que vous n'êtes pas obligé de TOUT importer en mode lazy**, nous ne l'avons pas fait pour la page `Not Found`.\n\n## Et le composant Suspense\n\nEn début d'article, je vous ai parlé du composant **Suspense** de React, implémentons-le.\n\n```js\n// on importe le composant Suspense\nimport React, { lazy, Suspense } from 'react';\nimport { Switch, Route } from 'react-router-dom';\n\nimport { NotFound } from '../NotFound';\nconst Home = lazy(() => import('../Home'));\nconst Projects = lazy(() => import('../Projects'));\n\nconst Router = () => (\n  <Suspense fallback={<Loading />}>\n    <Switch>\n      <Route path=\"/\" component={Home} exact />\n      <Route path=\"/projets\" component={Projects} />\n      <Route component={NotFound} />\n    </Switch>\n  </Suspense>\n);\n```\n\nLa props fallback doit être un composant (ici, un loading), **il va s'afficher si un des composants enfants de `<Suspense>` est en train de charger et s'il n'a pas fait au moins un rendu**. Si vous mettez un délai ou une alerte dans le constructeur d'un enfant, vous verrez obligatoirement le loading s'afficher.\n\nLe composant `<Suspense>` n'est pas indispensable lors du code splitting, mais il reste important afin d'éviter une page blanche temporaire. Celle-ci peut être totalement invisible si vous avez bonne machine et une bonne connexion, mais ce n'est pas le cas de tous vos utilisateurs !\n\n## Pour conclure\n\nGrace au lazy, React permet enfin de faire du code splitting de manière extrêmement simple tout en intégrant divers modules à coté comme le **Suspense** pour rendre votre application vraiment fluide pour l'utilisateur.\nFaire du code splitting nécessite un peu de réflexion pour déterminer ce que vous allez charger en mode lazy, ne le faites pas pour tous vos composants, il faut que ce soit pertinent !\n\nGardez en tête qu'il s'agit d'un premier pas, et la team React souhaite développer énormément de choses autour de ces sujets en 2019. Par exemple, il n'est pas encore possible en ServerSide Rendering (contrairement à [loadable-components](https://www.smooth-code.com/open-source/loadable-components/docs/loadable-vs-react-lazy/)) et le Suspense est conseillé uniquement pour du loading de composants en lazy.\nUn autres module nommé `react-cache`, actuellement en Alpha, va bientôt voir le jour. Il permettra d'aller fetch une donnée sur une API, ou de charger des images et d'utiliser le composant Suspense pour du loading automatique.\n\n\nLiens utiles :\n- [Code Splitting React](https://reactjs.org/docs/code-splitting.html)\n- [Comparaison React.lazy](https://www.smooth-code.com/open-source/loadable-components/docs/loadable-vs-react-lazy/)\n- [Configuration Webpack](https://webpack.js.org/guides/code-splitting)\n\n\n"}