{"date":"2020-10-13T00:00:00.000Z","title":"Anémie du domaine","excerpt":"Souffrez-vous d'anémie métier ? Regardons ce qu'est une anémie du domaine et comment les choses peuvent changer.","readingTime":"9mn","authors":["rpierlot"],"categories":["php"],"content":"\nAujourd'hui j'aimerais parler de quelque chose que l'on voit souvent dans les applications : l'anémie du domaine.\n\nQu'est-ce donc? C'est simplement le fait que les objects responsables de la modélisation de votre logique métier... n'en contiennent pas. Cela paraît étrange n'est-ce pas ? Prenons un exemple pour mieux comprendre ce que j'entends par là.\n\nImaginons que vous souhaitiez ajouter un nouvel article à votre blog. Dans une application classique, vous utiliseriez votre ORM favori pour insérer votre toute nouvelle entité dans votre base de données. Vous avez un controller gérant votre requête HTTP, et enfin un service qui crééra votre nouvelle entité Article, avec toutes les propriétés qui vont bien.\n\n```php\nClass Article\n{\n    public const STATUS_DRAFT = 'draft';\n    public const STATUS_PUBLISHED = 'published';\n\n    private string $title;\n    private string $content;\n    private string $status;\n    private \\DateTime $createdAt;\n    private \\DateTime $updatedAt;\n\n    public function __construct()\n    {\n        $this->createdAt = new \\DateTime();\n    }\n\n    public function getTitle(): string\n    {\n        return $this->title;\n    }\n\n    public function setTitle(string $title): void\n    {\n        $this->title = $title;\n    }\n\n    public function getContent(): string\n    {\n        return $this->content;\n    }\n\n    public function setContent(string $content): void\n    {\n        $this->content = $content;\n    }\n\n    public function getStatus(): string\n    {\n        return $this->status;\n    }\n\n    public function setStatus(string $status): void\n    {\n        $this->status = $status;\n    }\n\n    public function getCreatedAt(): \\DateTime\n    {\n        return $this->createdAt;\n    }\n\n    public function getUpdatedAt(): ?\\DateTime\n    {\n        return $this->updatedAt;\n    }\n\n    public function setUpdatedAt(\\DateTime $updatedAt): void\n    {\n        $this->updatedAt = $updatedAt;\n    }\n}\n```\nVotre couche service ressemble à cela :\n\n```php\n\nclass ArticleService\n{\n    public function create(string $title, $string $content): Article\n    {\n        $article = new Article();\n        $article->setTitle($title);\n        $article->setContent($content);\n        $article->setStatus(Article::STATUS_DRAFT);\n\n        $this->orm->save($article);\n\n        return $article;\n    }\n\n    public function publish(Article $article): void\n    {\n        $article->setStatus(Article::STATUS_PUBLISHED);\n        $article->setUpdatedAt(new \\DateTime());\n\n        $this->orm->save($article);\n    }\n}\n```\n\nEn regardant ce que nous venons d'écrire, on pourrait se dire « cela m'a l'air assez classique, quel est le problème ? ». Si nous observons d'un point de vue plus conceptuel, est-ce que cela a du sens ? Est-ce que c'est logique de créer cet objet vide `new Article()` avec aucune propriété définie en premier lieu ? Puis de définir un titre, puis un contenu ? Je doute que vous soyez confortable avec l'idée de regarder une page d'article vide, sans contenu.\n\n### Le temps passe\n\nAjoutons une règle métier : vous ne pouvez pas publier d'article sans avoir au moins un titre et un contenu.\n\nLa méthode `publish` de notre service serait changée par :\n\n```php\n// class ArticleService\n    public function publish(Article $a)\n    {\n        if (strlen($article->getTitle()) === 0 || strlen($article->getContent())) {\n            throw new CannotPublishException();\n        }\n\n        //...\n    }\n```\n\nL'objet Article est juste un conteneur de propriétés, pas très utile. La couche service est celle qui s'assure que notre entité est valide.\nC'est quelque chose d'assez étrange de transposer la responsabilité d'un objet à quelque chose d'extérieur à lui-même. Un article devrait être en mesure de protéger ses propriétés, pour être sûr de finir dans un état valide.\n\nAvoir ces responsabilités vont, dans le futur, permettre à vos collègues ou vous-même d'écrire quelque chose comme :\n\n```php\n$article = new Article();\n$article->setStatus(Article::STATUS_PUBLISHED);\n$article->setContent(‘Today we are going to...’);\n$this->orm->save($article);\n```\n\nCe qui veut dire que l'on peut publier un article sans titre. Dans le monde réel, cela parait étrange... Alors pourquoi ne pas traduire ce vrai besoin dans quelque chose d'explicite ? N'est-ce pas ce qu'est la programmation, traduire des vrais process en code ?\n\nDe plus, comment testeriez-vous cela ? En définissant toutes les propriétés à la main, et assertant que toutes soient bien égales à celles définies. Mais est-ce pertinent ? Et quid de l'évolution dans le temps, de l'ajout de nouvelles règles métier ?\n\nC'est ce qu'on appelle un domaine anémique. Une classe avec plein de getters et setters, mais aucun comportement. Elle ne fait rien par elle-même.\n\nUn objet métier devrait être reponsable de son propre état, en contradiction totale avec cet Article anémique.\n\n### Changer d'état d'esprit\n\nTransformer un modèle anémique en un modèle riche n'a pas à être un effort incroyable et douloureux. C'est principalement un changement de la façon dont nous percevons le métier de notre application : comme étant le coeur du logiciel.\n\nPar rapport à notre exemple précédent, nous pouvons simplement faire les changements suivants :\n\n```php\nclass Article\n{\n    //...\n    private function __construct(string $title, string $content): void\n    {\n        $this->title = $title;\n        $this->content = $content;\n        $this->status = self::STATUS_DRAFT;\n        $this->createdAt = new \\DateTime();\n    }\n\n    static public function createDraft(string $title, string $content): Article\n    {\n        return new self($title, $content);\n    }\n\n    public function publish(): void\n    {\n        if (strlen($title) === 0 || strlen($content) === 0) {\n            throw new CannotPublishException();\n        }\n\n        $this->status = self::STATUS_PUBLISHED;\n        $this->updatedAt = new \\DateTime();\n    }\n\n    public function getTitle(): string;\n    public function getContent(): string;\n    public function getCreatedAt(): string;\n    public function getUpdatedAt(): string;\n}\n```\n\nAvec un modèle du domaine riche, notre service ressemblerait à cela :\n\n```php\n//class ArticleService\n    public function create(string $title, string $content)\n    {\n        $article = Article::createDraft($title, $content);\n        $this->orm->save($article);\n    }\n\n    public function publish(Article $article)\n    {\n        $article->publish();\n        $this->orm->save($article);\n    }\n```\n\nBien que cet exemple soit très basique, nous pouvons observer une transformation dans la responsabilité de la couche service et des objets métiers. Et cela est bien plus compréhensible visuellement.\nLes tests peuvent maintenant se concentrer uniquement sur la logique métier, sans avoir à gérer la couche service, qui reste simple et petite.\n\nDes objets du domaine riches permettent d'avoir des états valides, et garantir que ces états le restent, à travers le constructeur de la classe ou en utilisant des constructeurs statiques.\n\nVous remarquerez aussi que Article a des noms de méthodes bien plus explicites. `createDraft` et `publish` sont des concepts métiers, liés à des règles business définies et partagées entre tous les acteurs du logiciel. Le langage utilisé dans le code est maintenant aligné avec le métier.\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Interestingly too, with an Explicit Model there are generally far less lines of code than with an Anemic Model (think client+model). The Explicit Model can be easily tested with confidence. The Anemic Model can have 10,000 tests with doubt.</p>&mdash; Vaughn Vernon (@VaughnVernon) <a href=\"https://twitter.com/VaughnVernon/status/1009183261866639360?ref_src=twsrc%5Etfw\">June 19, 2018</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nJe pense que la plupart de cette anémie vient des différents ORMs/frameworks expliquant comment gérer les objets et bases de donneés, et nous perdons le fil principal de ce qu'est l'architecture orientée objects : transposer des besoins dans le code ; combiner le comportement et les données.\n\nPartir d'un domaine anémique vers une modelisation riche ne convient pas à tous les cas de figure, mais si vous possédez suffisament de logique métier, vous en sortirez gagnant.\n\nIl y a évidemment des incovénients à définir des objets de la sorte. Par exemple, vous devrez adapter comment vos objets sont récupérés ou persistés  par votre ORM (si vous en utilisez un). Mais cette complexité additionnelle sera vite oubliée quand vous découvrirez la joie de manipuler des objets métiers avec des comportements riches, la façon dont vous testez et pensez votre modélisation métier.\n\nPar ailleurs, voici un article de Matthias Noback concernant une solution intéressante pour gérer l'interaction entre vos objets métiers et la base de données : [https://matthiasnoback.nl/2018/03/ormless-a-memento-like-pattern-for-object-persistence/](https://matthiasnoback.nl/2018/03/ormless-a-memento-like-pattern-for-object-persistence/)\n\nMerci à [Guillem](https://twitter.com/buraitopengin) pour la relecture et les retours!\n\n## Ressources\n\n- [Anemic Domain Model - Fowler](https://martinfowler.com/bliki/AnemicDomainModel.html)\n- [A blog engine using rich domain objects](https://github.com/dddinphp/blog-cqrs)\n"}