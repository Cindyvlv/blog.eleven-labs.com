{"date":"2017-08-09T00:00:00.000Z","title":"Android et les Design Patterns","excerpt":"Nous allons voir à travers cet article jusqu'à quel point on peut appliquer les principaux Design Patterns dans un projet Android","readingTime":"12mn","authors":["obennouna"],"categories":[],"content":"Aujourd'hui nous allons voir jusqu'à quel point on peut implémenter le plus rigoureusement possible certains Design Patterns. En effet nous allons les séparer en deux catégories :\n - Design Patterns structurants\n - Design Patterns non structurants\n\nConcernant les Design Patterns structurants, nous allons voir en détail les trois plus connus, à savoir :\n - MVC\n - MVP\n - MVVM\n\nEnfin concernant les non structurants, nous n'allons en survoler que quelques-uns car nous allons surtout nous intéresser à la première catégorie.\n\n> **Petit rappel :**\n> Android est l'OS mobile développé par Google utilisant le langage JAVA (et Kotlin récemment mais nous en parlerons une autre fois) pour la partie développement. Pour en savoir plus il n'y a pas mieux que la [documentation officielle](https://developer.android.com/index.html){:rel=\"nofollow noreferrer\"}.\n\nNéanmoins Android a une particularité par rapport au JAVA : le SDK est déjà structurant.\n\nAvant de commencer à rentrer dans le vif du sujet, il est important de noter certaines différences cruciales avec une application en JAVA (Desktop par exemple) afin de comprendre jusqu'à quel point on peut suivre les différents Design Patterns.\n\nEn effet, un nouveau projet en JAVA ne contient que la méthode main qui sert de point de départ ce qui nous laisse une totale liberté de l'architecture du projet :\n```Java\npublic static void main(String[] args) {\n    System.out.println(\"Hello World\");\n}\n```\nMaintenant si on regarde de plus près un nouveau projet Android on se retrouve avec ceci :\n```Java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n}\n\n```\nPlusieurs choses ont changé :\n- On est obligé d'hériter une classe type **Activity** (AppCompatActivity / Activity / etc...)\n- La méthode main a disparu pour laisser place à une méthode **surchargée** : **onCreate**\n- Cette méthode **onCreate** devient notre nouveau point d'entrée\n- Enfin la méthode setContentView qui permet d'assigner une **vue** à notre Activity\n\n > **Note:**\n > Si vous avez remarqué on commence déjà à \"subir\" une implémentation en parlant d'héritage ou de vue alors que le projet est à peine créé, car le SDK impose un certain MVC\n\n# MVC\n\n\nRien de mieux qu'un schéma pour illustrer une implémentation MVC\n\n![MVC Android](/imgs/posts/2017-08-02-android-design-pattern/mvc.png)\n\nMaintenant essayons d'attribuer chaque partie constituant un projet Android à un élément de ce pattern, on se retrouve avec :\n- **Modèle** : Une classe qui contiendra notre modèle (jusque-là rien de particulier)\n- **Contrôleur** : Il s'agit de l'Activity (ou fragment), vu qu'elle va remonter les interactions utilisateurs et mettre à jour nos vues.\n- **Vue** : Cela correspond aux fichiers layout en .XML\n\nEn creusant un peu on peut se rendre compte de quelques détails.\n\nTout d'abord, on peut définir l'action à faire lors d'un clic sur un bouton, par exemple via l'Activity, mais aussi depuis le layout .XML. La vue reprend une partie de la gestion de l'interaction avec l'utilisateur et donc une partie des responsabilités du contrôleur.\n\n```JAVA\n<!-- XML -->\n<Button android:id=\"@+id/decollage\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"On décolle !\"\n    android:onClick=\"goIntoSpace\" />\n\n<!-- JAVA -->\npublic void goIntoSpace(View view) {\n    // C'est parti !\n}\n```\nOu alors :\n```JAVA\nButton btn = (Button) findViewById(R.id.decollage);\n\nbtn.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        // On décolle !\n    }\n});\n```\n\nMaintenant intéressons-nous à l'interaction entre la vue et son modèle. D'abord, on note que le modèle est complètement indépendant car il ne possède aucun lien avec une vue ou un contrôleur.\nEnsuite, et c'est le point le plus important, la vue devrait avoir connaissance de son modèle afin de pouvoir lire les informations dont elle a besoin, sauf que sur Android **il est impossible d'indiquer à la vue quel modèle elle utilise.**\n\nEffectivement, le SDK Android nous propose déjà une panoplie de vues (Champ texte, checkbox etc...) qui ne prennent pas un modèle en paramètre mais directement des données brutes (Chaîne de caractère, entier etc...).\n\n**Exemple :**\nPrenons un formulaire de contact avec les champs suivants :\n - Nom\n - Prénom\n - Mail\n - Message\n\nLe modèle correspondant sera une classe avec quatre champs `String` pour chaque attribut. Seulement notre layout n'aura jamais connaissance d'un objet de ce type, mais uniquement des quatre champs qui lui auront été fournis (Grâce à une Activity / Fragment ou autre **contrôleur**).\n\n> Et les ViewModels ?\n\nEn effet la première contradiction est le DataBinding, car on lie explicitement un modèle à la vue. Seulement notre modèle se transforme en ViewModel, ce qui nous amène plus à du \"MVMC\" (Model - ViewModel - Controller) et non plus à du MVC \"classique\".\n\nLa seconde méthode, beaucoup moins jolie, consiste à se fabriquer des vues personnalisées permettant de leur attacher un modèle tel que c'est prévu dans le MVC.\n\nAu final, si l'on veut respecter scrupuleusement cette implémentation, on se retrouve obligé de tordre le code pour créer le lien entre la vue et son modèle, sinon on se retrouve avec quelque chose qui ressemble étrangement à du MVP (voir MVVM)\n\n![MVC / MVP Android](/imgs/posts/2017-08-02-android-design-pattern/mvp-mvc-android.jpg)\n\n<span style=\"color:green\">+</span>\n----------\n - Le SDK nous fournit déjà un projet tout prêt pour du MVC\n - Il s'agit d'un des Patterns les plus connus et donc très bien documenté, utilisé etc...\n - Il empêche la création de \"god\" application, voire de \"god\" classe\n\n<span style=\"color:red\">-</span>\n----------\n - Comme on a vu plus haut, son respect le plus strict peut s'avérer compliqué.\n - Il centralise énormément l'aspect \"fonctionnel\" de l'application (seul le contrôleur sait ce qui doit être fait)\n - Un code respectant scrupuleusement le MVC n'est pas forcément très lisible car si l'on prend un layout .XML tout seul (ou un modèle) on ne peut pas voir ce qui est affiché, ni comment.\n\n\n# MVP\n\n\nEncore une fois, un schéma pour expliquer l'implémentation d'un MVP\n\n![MVP Android](/imgs/posts/2017-08-02-android-design-pattern/mvp.png)\n\nLa différence la plus marquante avec le MVC est la disparition de l'interaction entre la vue et le modèle. Cette absence d'interaction tombe à pic pour Android, car on se retrouve avec l'intégration suivante :\n- **Modèle** : Une classe qui contiendra notre modèle\n- **Présenteur** : Il s'agit de l'Activity (ou fragment)\n- **Vue** : Cela correspond aux fichiers layout en .XML\n\nVoici un exemple d'implémentation (très basique) d'un MVP :\n\n```JAVA\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n   super.onCreate(savedInstanceState);\n   setContentView(R.layout.activity_main);\n\n   // Model\n   Post post = new Post();\n\n   // Presenter\n   TextView textView = findViewById(R.id.title);\n   textView.setText(post.getTitle());\n}\n```\n\nNotre vue n'a pas changé et est toujours portée par le layout .XML.\nLe modèle non plus, il peut s'agir d'une simple classe JAVA avec X attributs / accesseurs.\nLa présentation, c'est-à-dire celle qui va indiquer quel contenu mettre dans quel champ, est faite exclusivement par l'Activity (ou fragment) sans autre interaction.\n\n> Sans s'en rendre compte, la plupart des projets respectent plus le MVP que le MVC car il est plus naturel de laisser l'Activity gérer ce qui doit être affiché que d'essayer de lier la vue et son modèle.\n\n<span style=\"color:green\">+</span>\n----------\n - Les mêmes point positifs que le MVC\n - Il supprime une des grosses contraintes du MVC (à savoir le lien entre la vue et le modèle) et épouse beaucoup plus l'architecture de base d'Android\n - Il peut amener à respecter encore plus les principes [SOLID](https://fr.wikipedia.org/wiki/SOLID_(informatique)){:rel=\"nofollow noreferrer\"}\n\n<span style=\"color:red\">-</span>\n----------\n - La logique de l'application est encore plus concentrée dans la présentation\n - La vue et le modèle ne sont plus que des \"squelettes\" et ne contiennent que très peu, voire pas de logique\n\n\n# MVVM\n\nEnfin le dernier Design Pattern structurant parmi les plus utilisés est le MVVM.\n\n![MVVM Android](/imgs/posts/2017-08-02-android-design-pattern/mvvm.png)\n\nIl se distingue grandement des deux précédents car il attribue beaucoup plus d'intelligence à la vue ainsi qu'au ViewModel.\n\nEn effet chaque vue d'un layout est liée à un ViewModel qui lui fournit les données spécifiques à afficher. Ces données peuvent être un texte, une couleur, une liste d'éléments etc...\n\n```JAVA\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <data>\n\n        <variable\n            name=\"model\"\n            type=\"com.elevenlabs.viewmodel.MainViewModel\" />\n    </data>\n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\"\n        android:padding=\"@dimen/material_spacing\">\n\n        <TextView\n            android:id=\"@+id/title\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:textStyle=\"bold\"\n            android:text=\"@{model.title}\"/>\n    </LinearLayout>\n</layout>\n```\n```JAVA\npublic class MainViewModel extends BaseObservable {\n\n    private Post mPost;\n\n    MainViewModel(Post post) {\n        this.mPost = post;\n    }\n\n    public String getTitle() {\n        return mPost.getTitle();\n    }\n}\n```\n\nLa TextView ne contient plus de données statiques (par exemple `@string/app_title` ou autre chaîne de caractères statique) mais devient dynamique : son contenu dépend maintenant du champ `title` de son ViewModel.\n\n\n > **Note:**\n > Une subtilité s'est glissée dans cet exemple : le champ `title` n'existe pas. En effet notre seul attribut s'appelle `mTitle` , en private, mais possède une méthode `getTitle` qui est publique.\n > Le DataBinding Android permet d'appeler le getter comme s'il correspondait à un attribut (si ce getter respecte une certaine nomenclature).\n > Dans notre cas puisque le getter s'appelle `getTitle`, le DataBinding va pouvoir nous permettre de l'appeler comme si on avait un attribut `title` qui existait.\n > Bien sûr rien ne nous empêche de l'appeler directement : `android:text=\"@{model.getTitle()}\"`\n\nMaintenant reste une étape très importante : générer nos ViewModels. On peut le faire directement dans une Activity ou un Fragment par exemple :\n\n```JAVA\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n   super.onCreate(savedInstanceState);\n   MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity);\n\n   // Création du modèle\n   Post post = new Post(\"Eleven Labs !\");\n\n   // Création du ViewModel\n   MainViewModel viewModel = new MainViewModel (post);\n   binding.setUser(viewModel);\n}\n```\nSeul le MVVM permet d'apporter une indépendance certaine qu'il serait dommage de ne pas utiliser.\nOn peut, par exemple, envisager de déléguer cette tâche à un BusinessService qui pourra générer les ViewModels en fonction de la source de données (locales, via appel REST etc...) et leur appliquer une logique, un traitement etc...\n\n```JAVA\nprivate MainActivityBinding mBinding;\nprivate MainActivityBusinessService mService;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n   super.onCreate(savedInstanceState);\n   mBinding = DataBindingUtil.setContentView(this, R.layout.main_activity);\n   mService = new MainActivityBusinessService();\n\n   MainViewModel viewModel = mService.generateViewModel();\n   binding.setUser(viewModel);\n}\n```\nL'un des avantages de cette approche est de proposer du code plus clair et lisible en définissant le rôle de chaque partie très clairement et ce jusqu'au XML.\n\n<span style=\"color:green\">+</span>\n----------\n - Notre .XML est bien plus intelligent et clair\n - Moins de code Boiler Plate avec l'absence des `findViewById`.\n - Il permet l'utilisation des [Binding Adapter](https://developer.android.com/reference/android/databinding/BindingAdapter.html){:rel=\"nofollow noreferrer\"}\n - Grâce à l'utilisation de `BaseObservable`, on peut rafraîchir la vue dès que le ViewModel subit un changement, ce qui évite toute gestion manuelle du rafraîchissement.\n\n<span style=\"color:red\">-</span>\n----------\n - Approche complètement différente des Design Patterns qui peut perturber.\n - Sur un projet existant, une migration s'impose voir une refonte, ce qui peut prendre du temps.\n\n\n# Design Patterns non structurants\n\nLes Design Pattern qui ne sont pas structurants, c'est-à-dire qui ne façonnent pas entièrement l'architecture d'une application, n'ont pas de particularité d'implémentation sur Android.\n\nPar exemple, le Singleton est implémenté exactement de la même manière que sur une autre plateforme. Il en va de même pour la Factory.\n\nConcernant le Design Pattern Observer, il est très répandu grâce à la profusion des listeners (Cf. [Android : Pourquoi j'aime les Listeners](https://blog.eleven-labs.com/fr/android-listeners/)), mais aussi et surtout aux librairies tels qu'[Otto](http://square.github.io/otto/) de Square, [EventBus](https://github.com/greenrobot/EventBus) de GreenRobot ou même encore [Guava](https://github.com/google/guava/wiki/EventBusExplained){:rel=\"nofollow noreferrer\"} de Google.\n\n# Conclusion\n\nAndroid nous offre énormément de possibilités quant aux moyens de bien structurer notre code et de bien l'organiser. Je suis, à titre personnel, un fan du Databinding qui permet enfin de donner un peu plus d'intelligence à mes layouts et pouvoir explicitement lui indiquer comment et avec quoi se remplir.\n\nEnsuite il est tout à fait possible de faire cohabiter plusieurs Design Pattern, je pense notamment au MVC/MVP et MVVM. Si l'on rajoute un élément extérieur à notre trio qui va s'occuper, par exemple, de générer des ViewModels, il peut être considéré comme un pseudo-Presenter ou pseudo-Controller, car il va se charger d'ajouter ou de modifier des données à afficher (en interagissant avec les ViewModels).\n\nPour terminer, je n'ai pas souhaité parler de librairies d'injection tel que [Dagger 2](https://github.com/google/dagger) (car ça s'assimile à de la Factory) ou encore de librairies très structurantes tel que [RxJava](https://github.com/ReactiveX/RxJava) (qui apporte la notion de React Programming certes, mais qui dans certains cas essaye aussi de contourner certains comportements de base d'Android){:rel=\"nofollow noreferrer\"}.\n\n> Embrace Android do not fight it\n\nEt vous, quel Design Pattern vous plaît le plus ?\n"}