{"date":"2016-12-06T00:00:00.000Z","title":"WebRTC : La révolution de la communication","excerpt":"Historiquement, le Web était un outil qui permettait le chargement, l'interprétation et l'exploitation d'interfaces distribuées. Un serveur héberge un contenu (dynamique ou non), l'expose sur le Web via une URL (Uniform Resources Location), puis un navigateur se connecte à cette URL pour télécharger et afficher le contenu en question à l'utilisateur.","readingTime":"8mn","authors":["rascarlito"],"categories":["javascript"],"content":"\n Le **WebRTC** (aka **Web** **R**eal-**T**ime **C**ommunication) apporte la communication en temps réel au Web.\n\nHistoriquement, le Web était un outil qui permettait le chargement, l'interprétation et l'exploitation d'interfaces distribuées. Un serveur héberge un contenu (dynamique ou non), l'expose sur le Web via une URL (Uniform Resources Location), puis un navigateur se connecte à cette URL pour télécharger et afficher le contenu en question à l'utilisateur.\n\nDans le navigateur, seuls trois langages de programmation permettent de décrire le contenu desservi à l'utilisateur :\n\n-   le **HTML** pour la structure du contenu\n-   le **CSS** pour la forme du contenu\n-   le **JavaScript** pour les interactions possibles par l'utilisateur sur le contenu\n\nCes langages avaient beaucoup de limitations pour fournir des interfaces avancées (riches en interactions). Pour remédier à cela, il existait beaucoup de plugins navigateurs capables d'actions plus *\"modernes\"*. Ceux que tout le monde connait : Java, Flash. Et ceux qui sont moins connus : NaCL, PNaCL, XUL (langages pour éditer des plugins navigateur).\n\nCes différents plugins permettaient notamment d'avoir accès à des couches basses du réseau et de manipuler les communications entre machines (client/serveur) plus finement que via le JavaScript (limitation de sécurité forçant le navigateur à initier la demande d'information). Le plus intéressant dans tout cela, outre de faire des interfaces graphiques *bling bling*, était de pouvoir implémenter des communications **RTC** (Real-Time Communication).\n\nLe **RTC**, comme son petit nom l'indique, est le fait de distribuer *instantanément* une information entre plusieurs machines : dès qu'une action est faite, elle se retrouve distribuée aux clients connectés. Ce domaine a longtemps été réservé au monde des télécommunications où l'effet *instantané* était obligatoire. On s'imagine mal devoir entendre le début d'une phrase prononcée une minute plus tôt. La conversation en deviendrait difficile.\n\nLe **WebRTC** permet enfin aux applications Web (HTML, CSS, JavaScript) de fournir cette *instantanéité* à ses utilisateurs.\n\nBon OK, je vois bien que je suis en train de vous saouler avec *l'histoire du Web* en mode édulcoré alors que vous êtes forcément un public averti qui en vaut deux.\n\nMais rassurez-vous, ça va rapidement devenir intéressant !\n\nComment ça marche ?\n===================\n\nLe **WebRTC** est exploitable dans le navigateur au travers de plusieurs nouvelles API JavaScript :\n\n-   navigator.getUserMedia()\n-   RTCPeerConnection()\n-   RTCIceCandidate()\n\nLe *WebRTC* ne se limite pas à ces trois API mais nous allons nous concentrer sur celles-ci pour commencer.\n\nUne liste plus exhaustive peut être trouvée [sur MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API){:rel=\"nofollow noreferrer\"}.\n\n### [navigator.getUserMedia()](https://developer.mozilla.org/en/docs/Web/API/Navigator/getUserMedia){:rel=\"nofollow noreferrer\"}\n\nL'API navigator.getUserMedia() sert à prendre le contrôle sur les équipements médias de l'utilisateur, c.à.d. la webcam et le micro. On pourra alors manipuler ou transférer les flux émis par ces différents médias sous la forme d'une instance de [MediaStream()](https://developer.mozilla.org/en-US/docs/Web/API/MediaStream){:rel=\"nofollow noreferrer\"}. Le navigateur s'occupera de normaliser les protocoles audio/vidéo utilisés pour encoder ces flux. L'utilisateur devra néanmoins autoriser l'application à accéder à ses équipements.\n\n```js\n// Ask for permission to access user webcam and microphone\nnavigator.getUserMedia({ audio: true, video: true }, success, failure);\n\n// Success callback that gets a `MediaStream` instance\nfunction success (stream) {\n  var video = document.querySelector('.video');\n  video.src = URL.createObjectURL(stream);\n}\n\n// Error callback\nfunction failure (err) {\n  console.error('Could not capture user media', err);\n}\n```\n\nLa spécification *WebRTC* n'étant pas finalisée, la façon d'appeler cette API diffère selon le navigateur et sa version. Un [adaptateur](https://github.com/webrtc/adapter) développé et maintenu par le groupe de développement [*WebRTC*](https://webrtc.org){:rel=\"nofollow noreferrer\"} existe pour uniformiser l'exploitation de cette API.\n\nSur la documentation de [MDN](https://developer.mozilla.org/en/docs/Web/API/Navigator/getUserMedia) on peut voir que cette méthode est obsolète, et remplacée par la nouvelle version de la spécification [mediaDevices.getUserMedia()](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia) qui dorénavant renvoie une [Promise()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise){:rel=\"nofollow noreferrer\"} :\n\n```js\nnavigator.mediaDevices.getUserMedia({ audio: true, video: true })\n  .then(function (stream) {\n    /* use the stream */\n  }).catch(function (err) {\n    /* handle the error */\n  });\n```\n\n### [RTCPeerConnection()](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection) / [RTCIceCandidate()](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidate){:rel=\"nofollow noreferrer\"}\n\nL'API RTCPeerConnection() nous sert à établir une connexion réseau *P2P* (tunnel) pour envoyer des données entre deux clients. Pour réussir à l'établir, ce n'est pas aussi simple que d'entrer une *URL* dans un navigateur, la plupart des clients existants n'ayant pas d'adresse publique accessible.\n\nLe **WebRTC** va se reposer sur deux technologies serveur nommées **STUN/ICE** et **TURN** pour que chaque client puisse découvrir le moyen, selon leur configuration réseau, d'exposer de façon sécurisée un tunnel de connexion public et de transférer les données souhaitées.\n\nConcrètement, il faut que chaque client instancie une RTCPeerConnection() en fournissant l'adresse du serveur *STUN/ICE,* ce qui leur donnera une description d'accès à leur réseau (*NAT*) sous la forme d'une instance RTCIceCandidate().\n\nIl faut ensuite partager cette description via un serveur dit de *signaling.* Ce serveur ne fait pas partie de la spécification *WebRTC* et peut être développé dans n'importe quel langage serveur ; en général il s'agira d'un serveur *WebSocket* auquel chaque client est connecté. Une fois ces descriptions partagées, la connexion *P2P* peut être établie.\n\nDans certains cas, la connexion *P2P* n'est tout de même pas possible, par exemple dans le cas d'un réseau trop complexe ou très sécurisé comportant des firewalls et proxies. Mais tout n'est pas perdu ! C'est là qu'intervient le serveur *TURN,* qui sert de pont de transmission pour la connexion. Vous l'aurez deviné, il ne s'agit plus réellement d'une connexion *P2P* dans ce cas-là, mais c'est tout comme.\n\nVoici un exemple qui suppose que vous avez déjà un système de *signaling* accessible via la méthode createSignalingChannel(), ainsi que deux éléments &lt;video&gt; : selfView et remoteView pour afficher les flux vidéos.\n\n```js\nconst signalingChannel = createSignalingChannel();\nconst peer;\nconst configuration = ...;\n\n// run start({ isCaller: true }) to initiate a call\nfunction start({ isCaller }) {\n  peer = new RTCPeerConnection(configuration);\n\n  // send any ice candidates to the other peer\n  peer.onicecandidate = function (evt) {\n    signalingChannel.send(\n      JSON.stringify({ candidate: evt.candidate })\n    );\n  };\n\n  // once remote stream arrives, show it in the remote video element\n  peer.onaddstream = function (evt) {\n    remoteView.src = URL.createObjectURL(evt.stream);\n  };\n\n  // get the local stream, show it in the local video element and send it\n  navigator.mediaDevices.getUserMedia({ audio: true, video: true })\n    .then(function (stream) {\n      selfView.src = URL.createObjectURL(stream);\n      peer.addStream(stream);\n\n      if (isCaller) {\n        peer.createOffer(gotDescription);\n      } else {\n        peer.createAnswer(peer.remoteDescription, gotDescription);\n      }\n\n      function gotDescription(desc) {\n        peer.setLocalDescription(desc);\n        signalingChannel.send(\n          JSON.stringify({ sdp: desc })\n        );\n      }\n    }).catch(function (err) {\n      console.error('Could not capture user media', err);\n    });\n}\n\nsignalingChannel.onmessage = function (evt) {\n  if (!peer) {\n    start({ isCaller: false });\n  }\n\n  const signal = JSON.parse(evt.data);\n  if (signal.sdp) {\n    peer.setRemoteDescription(\n      new RTCSessionDescription(signal.sdp)\n    );\n  }\n  else {\n    peer.addIceCandidate(\n      new RTCIceCandidate(signal.candidate)\n    );\n  }\n};\n```\n\nOn voit que cela devient légèrement plus complexe d'arriver à ses fins, et cela sans compter les polyfills nécessaires pour les différents navigateurs. Heureusement, comme l'adaptateur de l'API navigator.getUserMedia(), il existe de très bonnes librairies open-source qui s'occupent de gérer cette complexité pour vous ([Twilio](https://www.twilio.com/), [EasyRTC](https://www.easyrtc.com/)){:rel=\"nofollow noreferrer\"}.\n\n### STUN/ICE\n\nEn ce qui concerne le serveur de liaison *STUN/ICE*, si on ne passe pas par un service de *signaling* dédié, Google fournit une instance publique à l'adresse [stun.l.google.com:19302](19302). Il existe également une application serveur open-source développée en *C/C++* pour déployer sa propre instance *STUN/ICE* et *TURN* : <https://github.com/coturn/coturn>.\n\nConclusion\n==========\n\nNous n'avons fait que gratter la surface de ce qui est possible avec le **WebRTC**. La technologie pousse à imaginer une nouvelle forme d'application Web et le meilleur dans tout ça c'est qu'elle est exploitable dès aujourd'hui !\n\nSerait-ce enfin ce qu'on pourrait appeler le *Web 3.0* ? Ce qui est sûr c'est que cette technologie ne va pas disparaître de si tôt, bien que sa standardisation par le consortium W3C prenne beaucoup de temps.\n\nBeaucoup d'applications se basent déjà sur cette nouvelle technologie :\n\n-   [Twilio](https://twilio.com){:rel=\"nofollow noreferrer\"}\n-   [Bistri](https://bistri.com/){:rel=\"nofollow noreferrer\"}\n-   [Ottspott](http://ottspott.co/){:rel=\"nofollow noreferrer\"}\n\nLes grands noms de la visio-conférence se basent également dessus :\n\n-   Skype\n-   Facebook\n\nDans une série d'articles, j'entrerai dans le vif du sujet avec des exemples concrets des possibilités que fournit le **WebRTC**. En attendant, renseignez-vous sur le site officiel [webrtc.org](https://webrtc.org), ou sur la très bonne documentation du [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API){:rel=\"nofollow noreferrer\"}\n\nEt surtout, Happy Coding !\n"}