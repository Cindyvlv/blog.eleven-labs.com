{"date":"2014-01-06T00:00:00.000Z","title":"Créer un RPC via RabbitMQ","excerpt":"RabbitMQ est un gestionnaire de queue, il permet donc de conserver des messages et de les lire via une autre tâche. Une présentation plus approfondie sera faite dans un autre article","readingTime":"8mn","authors":["captainjojo"],"categories":["php"],"content":"\nRabbitMQ est un gestionnaire de queue, il permet donc de conserver des messages et de les lire via une autre tâche. Une présentation plus approfondie sera faite dans un autre article. Dans cet article, nous allons nous intéresser à un concept important dans RabbitMQ : le RPC.\nUn RPC (remote procedure call) permet d'envoyer un message à une queue et d'en attendre la réponse, pour mieux comprendre ce concept, partons d'un exemple simple : la génération d'une url de contenu externalisée.\nIl y a donc un client qui envoie un contenu dans une queue RabbitMQ afin de connaitre l'url générée. Le client n'a alors besoin que d'une méthode \"call\".\n\n```php\n<?php\n\nclass generateUrlClient\n{\n  public function call($value)\n  {\n    // TODO\n    return $response;\n  }\n}\n\n$generateUrlClient= new generateUrlClient();\n$response = $generateUrlClient->call('vive le RPC');\necho \"Url généré \".$response;\n```\n\nToujours dans le client, l'initialisation de la queue de \"callback\" permet au message mis dans la queue de savoir où déposer le message de réponse.\n\n```php\n<?php\nlist($queue_name, ,) = $channel->queue_declare(\"\", false, false, true, false);\n\n$msg = new AMQPMessage(\n    $payload,\n    array('reply_to' => $queue_name));\n\n$channel->basic_publish($msg, '', 'rpc_queue');\n\n// Ici le code de lecture le réponse\n```\n\nVous pouvez trouver toutes les options disponibles pour le protocole AMQP dans la library suivante\n[https://github.com/videlalvaro/php-amqplib](https://github.com/videlalvaro/php-amqplib){:rel=\"nofollow noreferrer\"}\n\nLe code ci-dessus fait que tous les messages publiés dans la queue auront une réponse dans la queue de callback. Un problème demeure : comment reconnaître chaque message dans la queue de callback? L'idée est de mettre sur chaque message une clé unique qui permet de le reconnaitre ensuite.\n\nLa clé unique est ce que l'on appelle la 'correlation_id', elle permet d'identifier chaque réponse par rapport à son message. Elle est envoyée sur chaque message envoyé sur le serveur, et renvoyée dans la réponse qui permet alors de reconnaître la demande initiale.\nAvant de faire l'exemple de code, voici un petit résumé:\n\n![RPC description](/imgs/posts/2014-01-06-creer-rpc-rabbitmq/python-six.png)\n\nComme on peut le voir sur le schéma ci-dessus, le client envoie un message dans la queue 'rpc_queue' avec l'option reply_to qui permet d'envoyer la réponse dans une queue de callblack et la clé de 'correlation_id' qui est l'index unique de chaque demande.\nCommençons l'exemple du serveur de génération d'url via un titre. Nous commencerons par le serveur qui s'occupera de créer une url à partir d'un titre. Pour l'exemple, nous prenons simplement un titre et remplaçons les espaces par des underscores.\n\n```php\n<?php\n\nrequire_once __DIR__.'/vendor/autoload.php';\n\nuse PhpAmqpLib\\Connection\\AMQPConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nclass generateUrlClient {\n    private $connection;\n    private $channel;\n    private $callback_queue;\n    private $response;\n    private $correlation_id;\n\n    // On créer la connexion comme sur le serveur\n    public function __construct() {\n        // Création de la connexion RabbitMQ\n        $this->connection = new AMQPConnection(\n            'localhost', 5672, 'guest', 'guest');\n\n        // On récupère ensuite le channel qui nous permet de communiquer avec RabbitMQ\n         $this->channel = $this->connection->channel();\n\n       // Création de la queue\n       list($this->callback_queue, ,) = $this->channel->queue_declare(\n            \"\", false, false, true, false);\n\n       // Consommation de la queue en mode réponse\n        $this->channel->basic_consume(\n            $this->callback_queue, '', false, false, false, false,\n            array($this, 'on_response'));\n    }\n\n    // Varification de la correlation_id\n    public function on_response($rep) {\n        if($rep->get('correlation_id') == $this->correlation_id) {\n            $this->response = $rep->body;\n        }\n    }\n\n    // Publication dans la queue de notre message\n    public function call($n) {\n        $this->response = null;\n        $this->correlation_id = uniqid();\n\n        // Préparation du message avec demande de callback\n        $msg = new AMQPMessage(\n            (string) $n,\n            array('correlation_id' => $this->correlation_id,\n                  'reply_to' => $this->callback_queue)\n            );\n\n        // Publication du message dans la queue rpc\n        $this->channel->basic_publish($msg, '', 'rpc_queue');\n\n        // On attend la réponse\n        while(!$this->response) {\n            $this->channel->wait();\n        }\n\n        // On retourne la reponse\n        return $this->response;\n    }\n};\n\n// On creer un message et on attend la reponse\n$generateUrlClient = new generateUrlClient();\n\n$titles = array('test de ouf', 'numero 1', 'numero 5');\n\nforeach ($titles as $title) {\n    $response = $generateUrlClient->call($title);\n    echo \" Pour le titre \".$title.' url recu '.$response, \"\\n\";\n}\n```\n\nLancer le serveur directement avec:\n\n```sh\nphp generateUrlServer.php\n```\n\nMaintenant créons le  client qui devra envoyer le message au serveur de génération et l'utiliser ensuite.\n\n```php\n<?php\n\nrequire_once __DIR__.'/vendor/autoload.php';\n\nuse PhpAmqpLib\\Connection\\AMQPConnection;\nuse PhpAmqpLib\\Message\\AMQPMessage;\n\nclass generateUrlClient {\n    private $connection;\n    private $channel;\n    private $callback_queue;\n    private $response;\n    private $correlation_id;\n\n    // On créer la connexion comme sur le serveur\n    public function __construct() {\n        // Création de la connexion RabbitMQ\n        $this->connection = new AMQPConnection(\n            'localhost', 5672, 'guest', 'guest');\n\n        // On récupère ensuite le channel qui nous permet de communiquer avec RabbitMQ\n         $this->channel = $this->connection->channel();\n\n       // Création de la queue\n       list($this->callback_queue, ,) = $this->channel->queue_declare(\n            \"\", false, false, true, false);\n\n       // Consommation de la queue en mode réponse\n        $this->channel->basic_consume(\n            $this->callback_queue, '', false, false, false, false,\n            array($this, 'on_response'));\n    }\n\n    // Varification de la correlation_id\n    public function on_response($rep) {\n        if($rep->get('correlation_id') == $this->correlation_id) {\n            $this->response = $rep->body;\n        }\n    }\n\n    // Publication dans la queue de notre message\n    public function call($n) {\n        $this->response = null;\n        $this->correlation_id = uniqid();\n\n        // Préparation du message avec demande de callback\n        $msg = new AMQPMessage(\n            (string) $n,\n            array('correlation_id' => $this->correlation_id,\n                  'reply_to' => $this->callback_queue)\n            );\n\n        // Publication du message dans la queue rpc\n        $this->channel->basic_publish($msg, '', 'rpc_queue');\n\n        // On attend la réponse\n        while(!$this->response) {\n            $this->channel->wait();\n        }\n\n        // On retourne la reponse\n        return $this->response;\n    }\n};\n\n// On creer un message et on attend la reponse\n$generateUrlClient = new generateUrlClient();\n\n$titles = array('test de ouf', 'numero 1', 'numero 5');\n\nforeach ($titles as $title) {\n    $response = $generateUrlClient->call($title);\n    echo \" Pour le titre \".$title.' url recu '.$response, \"\\n\";\n}\n```\n\nMaintenant lançons le client :\n\n```sh\nphp generateUrlClient.php\n```\n\nSi tout se passe bien, le serveur renvoie les bonnes valeurs.\n\nLaissez un commentaire si vous avez des questions.\n"}