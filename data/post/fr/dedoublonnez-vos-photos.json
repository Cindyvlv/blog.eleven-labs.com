{"date":"2023-01-25T00:00:00.000Z","title":"Dédoublonnez vos photos","excerpt":"Comme moi vous avez sur vos disques dur des copies, de copie, de copie de photos et vous souhaiteriez faire un peu de ménage ? C'est par ici.","readingTime":"18mn","authors":["jmoati"],"categories":["php"],"content":"\n![Cover](/imgs/posts/2023-01-25-dedoublonnez-vos-photos/cover.jpg)\n\n## Introduction\n\nLe dédoublonnage de photos est un processus qui vise à détecter et supprimer les images en double d'une collection.\nIl est utilisé pour nettoyer des albums photos ou des bases de données d'images et pour améliorer la qualité des résultats de recherche d'images.\nIl existe différentes méthodes pour le dédoublonnage, comme la comparaison de pixels, des caractéristiques d'image, des métadonnées et des signatures d'image, chacune ayant des avantages et inconvénients.\n\nDans cet article, nous combinerons plusieurs de ces techniques afin d'identifier des doublons.\n\n### 0. Avertissement ###\n\nIl est important de noter que le dédoublonnage de photos peut entraîner la perte de données, il est donc important de sauvegarder les images avant de les supprimer.\nIl est également recommandé de vérifier manuellement les images supprimées afin de s'assurer qu'elles sont en effet des doublons et non des images uniques.\n\n### I. Savoir à coup sûr si un fichier est déjà présent dans ma collection d'image\n\nLa première méthode que nous utiliserons est de générer une somme de contrôle SHA-1 à partir du contenu du fichier puis de vérifier dans un registre si celle-ci s'y trouve déjà.\n\nLa somme SHA-1 (Secure Hash Algorithm 1) est un algorithme de hachage cryptographique qui permet de créer une empreinte numérique (ou \"somme de contrôle\") d'un fichier. Cette empreinte est générée en transformant les données du fichier en un code à 160 bits (40 caractères hexadecimal), qui est unique pour chaque fichier.\nSi un fichier change, même de façon minime, sa somme SHA-1 sera complètement différente.\n\nLes sommes SHA-1 sont souvent utilisées pour vérifier l'intégrité des fichiers téléchargés sur internet, pour s'assurer qu'ils n'ont pas été altérés pendant leur transfert. On peut comparer la somme SHA-1 d'un fichier téléchargé avec la somme SHA-1 d'un fichier original pour vérifier qu'ils sont identiques.\nDe cette manière, on peut être sûr que le fichier téléchargé est le même que celui qui a été diffusé par son auteur ou son éditeur.\n\nIl est important de noter que même si la somme SHA-1 est encore utilisée, il y a des algorithmes de hachage plus récents qui sont considérés plus sécurisés (comme SHA-256, SHA-3, etc).\n\nCalculons ainsi le hash SHA-1 de la photo suivante :\n![Pilou](/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546.jpg)\n\nPour faire cela nous utiliserons le code suivant :\n```php\n<?php\n\necho sha1_file('~/IMG_0546.jpg');\n```\n\nCe qui nous donnera le résultat suivant :\n```\n8ffe297f8e88d5573d375cd12536e33db8d49c54\n```\n\nSi deux fichiers ont le même hash, alors on peut être sûr (ou presque...), que ces derniers sont identiques en tous points et que nous pouvons archiver n'importe lequel des deux. Toutefois, cela ne fonctionne que si notre fichier n'a jamais été importé dans un logiciel (qui ajoutera des métadonnées sur le fichier) ou que nous n'avons pas fait de post traitement dessus.\n\nSi on refait la même opération sur la photo qui s'est affichée, dans votre navigateur (et qui a été redimensionnée pour prendre moins de place) :\n\n```php\n<?php\n\necho sha1_file('/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546.jpg');\n```\n\nLe résultat ne sera pas du tout le même :\n\n```\nfbde9cebfa1522b7489c2e5360bf114f203d7c62'\n```\n\nEn effet, comme dit précédemment, modifier un seul bit de notre fichier aura pour effet de complétement changer la somme de contrôle de celle-ci. Aussi pour trouver les doublons, nous allons devoir avoir recours à d'autres techniques plus permissives.\n\n### II. Savoir si une image a le même aspect visuel qu'une autre\n\nNous ne pouvons donc pas seulement utiliser la somme de contrôle afin de trouver tous les doublons d'une même photo. Nous pouvons toutefois nous reposer sur un deuxième type de hash dans le but d'identifier d'éventuels candidats : le perceptual hash.\n\nLe perceptual hash, ou \"empreinte perceptuelle\", est un algorithme de hachage utilisé pour identifier les images similaires. Il fonctionne en créant un hash (ou une empreinte numérique) unique pour chaque image en comparant les caractéristiques visuelles de l'image plutôt que les données binaires de l'image elle-même.\n\nIl compare les caractéristiques de l'image telles que les niveaux de luminosité, les contours et les textures, pour créer un hash qui est sensible aux différences subtiles entre les images. Cela permet de détecter les images similaires même si elles ont subi des modifications mineures, comme une rotation ou un redimensionnement.\n\nLe perceptual hash est souvent utilisé pour l'analyse d'image, la reconnaissance d'images et la détection de contenu dupliqué, comme dans la vérification de contenu copyright ou, comme dans notre cas, dans la suppression de duplicat d'images. Il est également utilisé dans les systèmes de surveillance vidéo pour détecter des intrusions ou pour des applications de reconnaissance faciale pour identifier les personnes.\n\nAfin de calculer simplement un perceptual hash, on peut utiliser une librairie PHP tel que l'excellente [jenssegers/imagehash](https://github.com/jenssegers/imagehash).\n\nAprès l'avoir installée à l'aide de la commande `composer require jenssegers/imagehash`, on pourra utiliser le morceau de code suivant :\n\n```php\n<?php\n\nrequire(__DIR__.'/vendor/autoload.php');\n\nuse Jenssegers\\ImageHash\\ImageHash;\n\n$hasher = new ImageHash();\n$hash = $hasher->hash('/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546.jpg');\n\necho $hash->toHex();\n```\n\nQui nous donnera comme résultat :\n\n```\na3d7d5f2e22489b3\n```\n\nJe vais maintenant faire quelques ajustements sur ma photo afin de changer les niveaux de couleurs et nous obtenons ainsi la photo suivante (plus pâle, plus jaune) :\n\n![Pilou avec des niveaux modifiés](/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546_leveling.jpg)\n\nEn exécutant le même bout de code que précédemment :\n\n```php\n<?php\n\nrequire(__DIR__.'/vendor/autoload.php');\n\nuse Jenssegers\\ImageHash\\ImageHash;\n\n$hasher = new ImageHash();\n$hash = $hasher->hash('/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546_leveling.jpg');\n\necho $hash->toHex();\n```\n\nNous obtenons le résultat suivant :\n\n```\na3d7d5f2e22489b3\n```\n\nVous avez bien lu : nous avons toujours le même perceptual hash !\nMême si les couleurs de l'image ont été modifiées, la donnée visuelle est toujours la même, et donc le hash de même. Pour avoir un hash différent il va falloir faire des modifications beaucoup plus aggressive. Je vais donc maintenant changer réellement l'aspect d'une zone entière de l'image en mettant un smiley par-dessus la tête de mon chat :\n\n![Pilou avec un emoji à la place de la tête](/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546_emoji.jpg)\n\nEn exécutant le même bout de code que précédemment :\n\n```php\n<?php\n\nuse Jenssegers\\ImageHash\\ImageHash;\n\n$hasher = new ImageHash();\n$hash = $hasher->hash('/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546_emoji.jpg');\n\necho $hash->toHex();\n```\n\nNous obtenons cette fois-ci un résultat bien différent :\n```\na3d7d5f2c26449b3\n```\n\nSi on compare les deux hashes :\n\na3d7d5f2**e**2**2**4**8**9b3\n\na3d7d5f2**c**2**6**4**4**9b3\n\nOn peut maintenant constater que le hash a évolué sur quelques caractères et on peut presque même deviner la zone qui a été modifiée en regardant la position des caractères du hash qui ont changés !\n\nIl existe plusieurs méthodes de hachage pour le perceptual hash mais voici comment fonctionne la forme la plus simple :\n\n_Dans le cas des images, les hautes fréquences donnent des détails, tandis que les basses fréquences montrent la structure._\n\n_Une grande image détaillée comporte beaucoup de hautes fréquences. Une très petite image manque de détails, elle est donc composée uniquement de basses fréquences._\n\n#### 1. Réduire la taille ####\n\nLe moyen le plus rapide de supprimer les hautes fréquences et les détails est de réduire la taille de l'image. Dans ce cas, réduisez-la à 8x8 de façon à ce qu'il y ait 64 pixels au total. Ne prenez pas la peine de conserver le rapport hauteur/largeur, réduisez simplement l'image pour qu'elle tienne dans un carré de 8x8.\n\nDe cette façon, le hachage correspondra à toute variation de l'image, indépendamment de l'échelle ou du rapport d'aspect.\n\n![Pilou en 8x8](/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546_8x8.jpg) <-- résultat en taille réelle\n\n<img height=\"512\" src=\"/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546_8x8.jpg\" width=\"512\"/>\n\n#### 2. Réduire la couleur ####\n\nLa petite image 8x8 est convertie en niveaux de gris. Cela fait passer le hachage de 64 pixels (64 rouges, 64 verts et 64 bleus) à 64 couleurs au total.\n\n![Pilou en 8x8 et greyscale](/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546_8x8_greyscale.jpg) <-- résultat en taille réelle\n\n<img height=\"512\" src=\"/imgs/posts/2023-01-25-dedoublonnez-vos-photos/IMG_0546_8x8_greyscale.jpg\" width=\"512\"/>\n\n#### 3. Moyenne des couleurs ####\n\nCalculer la valeur moyenne des 64 couleurs.\n\n#### 4. Calculer les bits ####\n\nC'est la partie la plus amusante. Chaque bit est simplement défini selon que la valeur de la couleur est supérieure ou inférieure à la moyenne.\n\n#### 5. Construire le hachage ####\n\nPlacez les 64 bits dans un entier de 64 bits. L'ordre n'a pas d'importance, du moment que vous êtes cohérent.\n\n#### 6. Résultat ####\n\n0xa3d7d5f2e22489b3\n\n#### 7. Conclusion ####\n\nLe hachage résultant ne changera pas si l'image est mise à l'échelle ou si le rapport d'aspect change. L'augmentation ou la diminution de la luminosité ou du contraste, ou même l'altération des couleurs, ne modifieront pas de façon spectaculaire la valeur de hachage.\n\nSi nous voulons comparer deux images, nous construirons le hachage de chaque image et on comptera le nombre de positions de bits qui sont différentes : il s'agit de la distance de Hamming. Une distance de zéro indique qu'il s'agit probablement d'une image très similaire (ou d'une variation de la même image).\n\nCette méthode nous permet donc d'identifier des images très proches visuellement, mais attention, elle ne sont pas pour autant identiques aussi il faudra nous baser sur d'autres critères avant de prendre une décision.\n\n### III. Identifier les metadata d'une photo ###\n\nAfin de trouver des doublons, nous pouvons aussi utiliser Exiftool. Exiftool est un outil en ligne de commande qui permet de lire, écrire et éditer les métadonnées dans les fichiers images. Il peut également être utilisé pour détecter les images en double en comparant les métadonnées de ces images.\n\nL'un des avantages d'utiliser Exiftool pour le dédoublonnage de photos est qu'il peut lire les métadonnées de nombreux formats d'images différents, y compris JPEG, TIFF, PNG, et RAW. Il peut également être utilisé pour lire les métadonnées des images stockées sur des appareils photo numériques, comme les informations de prise de vue, les réglages d'exposition, etc.\n\nPour utiliser Exiftool pour détecter les images en double, il suffit de lancer la commande suivante :\n\n```shell\nexiftool -duplicates -r ~/photos > result.txt\n```\n\nCette commande va parcourir tous les fichiers dans le répertoire spécifié (et ses sous-répertoires) et va écrire les images en double dans un fichier texte appelé `result.txt`.\n\nVous pouvez également utiliser des options pour spécifier les métadonnées à utiliser pour la comparaison, comme la date de prise de vue, la résolution, etc.\n\nIl est important de noter qu'Exiftool ne peut pas identifier les images en double basé sur le contenu de l'image, comme le fait le perceptual hash, il utilise uniquement les métadonnées pour identifier les images en double.\n\nIl peut donc y avoir des faux positifs ou des images manquantes si les métadonnées ont été modifiées ou sont absentes. Il est donc important de vérifier manuellement les résultats pour s'assurer de la précision. Dans mon cas, je préfère ainsi utiliser Exiftool uniquement afin d'extraire les métadonnées d'un fichier.\n\nC'est dans ce but que j'ai écrit la librairie PHP suivante : [jmoati/exiftool](https://packagist.org/packages/jmoati/exiftool).\n\nAprès un rapide `composer require jmoati/exiftool` et avoir installé `exiftool` dans un conteneur Docker ou sur votre système, vous pourrez utiliser le code suivant :\n\n```php\n<?php\n\nrequire 'vendor/autoload.php';\n\nuse Jmoati\\ExifTool\\ExifTool;\n\n$media = ExifTool::openFile('~/IMG_0546.JPEG');\n\necho json_encode($media->data());\n```\n\nCe qui nous donnera le résultat suivant :\n\n```json\n{\n    \"File\":{\n        \"FileSize\":808104,\n        \"FileType\":\"JPEG\",\n        \"FileTypeExtension\":\"jpg\",\n        \"MIMEType\":\"image/jpeg\",\n        \"ExifByteOrder\":\"Big-endian (Motorola, MM)\",\n        \"ImageWidth\":2048,\n        \"ImageHeight\":1536,\n        \"EncodingProcess\":\"Baseline DCT, Huffman coding\",\n        \"BitsPerSample\":8,\n        \"ColorComponents\":3,\n        \"YCbCrSubSampling\":\"YCbCr4:2:0 (2 2)\"\n    },\n    \"JFIF\":{\n        \"JFIFVersion\":1.01,\n        \"ResolutionUnit\":\"inches\",\n        \"XResolution\":300,\n        \"YResolution\":300\n    },\n    \"EXIF\":{\n        \"Make\":\"Apple\",\n        \"Model\":\"iPhone 13 Pro\",\n        \"Orientation\":\"Horizontal (normal)\",\n        \"XResolution\":72,\n        \"YResolution\":72,\n        \"ResolutionUnit\":\"inches\",\n        \"Software\":\"15.4.1\",\n        \"ModifyDate\":\"2022:05:14 14:01:09\",\n        \"HostComputer\":\"iPhone 13 Pro\",\n        \"TileWidth\":512,\n        \"TileLength\":512,\n        \"YCbCrPositioning\":\"Centered\",\n        \"ExposureTime\":\"1/81\",\n        \"FNumber\":2.7999999999999998,\n        \"ExposureProgram\":\"Program AE\",\n        \"ISO\":200,\n        \"ExifVersion\":\"0232\",\n        \"DateTimeOriginal\":\"2022:05:14 14:01:09\",\n        \"CreateDate\":\"2022:05:14 14:01:09\",\n        \"OffsetTime\":\"+02:00\",\n        \"OffsetTimeOriginal\":\"+02:00\",\n        \"OffsetTimeDigitized\":\"+02:00\",\n        \"ComponentsConfiguration\":\"Y, Cb, Cr, -\",\n        \"ShutterSpeedValue\":\"1/81\",\n        \"ApertureValue\":2.7999999999999998,\n        \"BrightnessValue\":3.137087712,\n        \"ExposureCompensation\":0,\n        \"MeteringMode\":\"Multi-segment\",\n        \"Flash\":\"Off, Did not fire\",\n        \"FocalLength\":\"9.0 mm\",\n        \"SubjectArea\":\"2013 1500 2310 1327\",\n        \"SubSecTimeOriginal\":305,\n        \"SubSecTimeDigitized\":305,\n        \"FlashpixVersion\":\"0100\",\n        \"ColorSpace\":\"Uncalibrated\",\n        \"ExifImageWidth\":4032,\n        \"ExifImageHeight\":3024,\n        \"SensingMethod\":\"One-chip color area\",\n        \"SceneType\":\"Directly photographed\",\n        \"ExposureMode\":\"Auto\",\n        \"WhiteBalance\":\"Auto\",\n        \"FocalLengthIn35mmFormat\":\"77 mm\",\n        \"SceneCaptureType\":\"Standard\",\n        \"LensInfo\":\"1.570000052-9mm f/1.5-2.8\",\n        \"LensMake\":\"Apple\",\n        \"LensModel\":\"iPhone 13 Pro back triple camera 9mm f/2.8\",\n        \"CompositeImage\":\"General Composite Image\",\n        \"GPSLatitudeRef\":\"North\",\n        \"GPSLatitude\":\"<redacted>\",\n        \"GPSLongitudeRef\":\"East\",\n        \"GPSLongitude\":\"<redacted>\",\n        \"GPSAltitudeRef\":\"Above Sea Level\",\n        \"GPSAltitude\":\"88.93688587 m\",\n        \"GPSSpeedRef\":\"km/h\",\n        \"GPSSpeed\":0,\n        \"GPSImgDirectionRef\":\"Magnetic North\",\n        \"GPSImgDirection\":286.21852100000001,\n        \"GPSDestBearingRef\":\"Magnetic North\",\n        \"GPSDestBearing\":286.21852100000001,\n        \"GPSHPositioningError\":\"35 m\"\n    },\n    \"MakerNotes\":{\n        \"RunTimeFlags\":\"Valid\",\n        \"RunTimeValue\":42659336558125,\n        \"RunTimeScale\":1000000000,\n        \"RunTimeEpoch\":0,\n        \"AccelerationVector\":\"-0.9578987955 0.0249360241 -0.2511245309\",\n        \"ContentIdentifier\":\"ABDDE637-8EF6-4C67-B0FD-E7DB4BC0526E\"\n    },\n    \"MPF\":{\n        \"MPFVersion\":\"0100\",\n        \"NumberOfImages\":2,\n        \"MPImageFlags\":\"(none)\",\n        \"MPImageFormat\":\"JPEG\",\n        \"MPImageType\":\"Undefined\",\n        \"MPImageLength\":106047,\n        \"MPImageStart\":702057,\n        \"DependentImage1EntryNumber\":0,\n        \"DependentImage2EntryNumber\":0,\n        \"MPImage2\":\"(Binary data 106047 bytes, use -b option to extract)\"\n    },\n    \"ICC_Profile\":{\n        \"ProfileCMMType\":\"Apple Computer Inc.\",\n        \"ProfileVersion\":\"4.0.0\",\n        \"ProfileClass\":\"Display Device Profile\",\n        \"ColorSpaceData\":\"RGB \",\n        \"ProfileConnectionSpace\":\"XYZ \",\n        \"ProfileDateTime\":\"2017:07:07 13:22:32\",\n        \"ProfileFileSignature\":\"acsp\",\n        \"PrimaryPlatform\":\"Apple Computer Inc.\",\n        \"CMMFlags\":\"Not Embedded, Independent\",\n        \"DeviceManufacturer\":\"Apple Computer Inc.\",\n        \"DeviceModel\":\"\",\n        \"DeviceAttributes\":\"Reflective, Glossy, Positive, Color\",\n        \"RenderingIntent\":\"Perceptual\",\n        \"ConnectionSpaceIlluminant\":\"0.9642 1 0.82491\",\n        \"ProfileCreator\":\"Apple Computer Inc.\",\n        \"ProfileID\":\"ca1a9582257f104d389913d5d1ea1582\",\n        \"ProfileDescription\":\"Display P3\",\n        \"ProfileCopyright\":\"Copyright Apple Inc., 2017\",\n        \"MediaWhitePoint\":\"0.95045 1 1.08905\",\n        \"RedMatrixColumn\":\"0.51512 0.2412 -0.00105\",\n        \"GreenMatrixColumn\":\"0.29198 0.69225 0.04189\",\n        \"BlueMatrixColumn\":\"0.1571 0.06657 0.78407\",\n        \"RedTRC\":\"(Binary data 32 bytes, use -b option to extract)\",\n        \"ChromaticAdaptation\":\"1.04788 0.02292 -0.0502 0.02959 0.99048 -0.01706 -0.00923 0.01508 0.75168\",\n        \"BlueTRC\":\"(Binary data 32 bytes, use -b option to extract)\",\n        \"GreenTRC\":\"(Binary data 32 bytes, use -b option to extract)\"\n    },\n    \"Composite\":{\n        \"RunTimeSincePowerUp\":\"11:50:59\",\n        \"Aperture\":2.7999999999999998,\n        \"ImageSize\":\"2048x1536\",\n        \"LensID\":\"iPhone 13 Pro back triple camera 9mm f/2.8\",\n        \"Megapixels\":3.1000000000000001,\n        \"ScaleFactor35efl\":8.5999999999999996,\n        \"ShutterSpeed\":\"1/81\",\n        \"SubSecCreateDate\":\"2022:05:14 14:01:09.305+02:00\",\n        \"SubSecDateTimeOriginal\":\"2022:05:14 14:01:09.305+02:00\",\n        \"SubSecModifyDate\":\"2022:05:14 14:01:09+02:00\",\n        \"GPSAltitude\":\"88.9 m Above Sea Level\",\n        \"GPSLatitude\":\"<redacted>\",\n        \"GPSLongitude\":\"<redacted>\",\n        \"CircleOfConfusion\":\"0.004 mm\",\n        \"FOV\":\"26.3 deg\",\n        \"FocalLength35efl\":\"9.0 mm (35 mm equivalent: 77.0 mm)\",\n        \"GPSPosition\":\"<redacted>\",\n        \"HyperfocalDistance\":\"8.24 m\",\n        \"LightValue\":8.3000000000000007\n    }\n}\n```\n\nVoici une quantité monstre d'informations plus intéressantes les unes que les autres. Ne les utilisez pas pour trouver des doublons ! Utilisez-les plutôt comme discriminant afin d'identifier les \"doubles légitimes\".\n\nMême si une image a le même perceptual hash, si la date de prise de vue n'est pas exactement la même (Exif.DateTimeOriginal) ou que l'identifiant de média (Exif.MakerNotes.ContentIdentifier) est différent ou que le temps écoulé depuis lequel l'appareil est allumé (Exif.Composite.RunTimeSincePowerUp) n'est pas identique alors, ce n'est pas un doublon !\n\nCette méthode est donc à coupler avec la précédente.\n\n## Conclusion ##\n\nUn fichier qui a la même somme de contrôle (MD5, SHA-1, etc.) peut-être considéré comme un doublon, car la chance que deux photos partagent le même hash est relativement faible. Dans le cas où deux photos ont le même perceptual hash, cela ne veux pas forcément dire que nous avons un doublon.\n\nPour savoir si la suppression de l'un ou de l'autre est légitime, il nous faut confronter les métadonnées de celles-ci.\n\nEnfin, afin de savoir quelle image garder, écrivez-vous un petit algorithme de scoring dans le but de valoriser par exemple les photos en RAW, ayant une position GPS, n'étant pas passé par un logiciel de retouche, etc.\n\nBonne chance, et que la force soit avec vous dans cette dangereuse entreprise !\n"}