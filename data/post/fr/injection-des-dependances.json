{"date":"2021-09-29T00:00:00.000Z","title":"L'injection des dépendances dans Symfony","excerpt":"Vous travaillez avec Symfony, mais l'injection de dépendances reste un peu floue pour vous ? Découvrez son fonctionnement et apprenez comment en tirer profit au maximum.","readingTime":"10mn","authors":["marishka"],"categories":["php"],"content":"\n## Injection de dépendances\nL'injection de dépendances est un mécanisme qui permet d'implémenter le principe de l'inversion de contrôle.\nL'idée est de créer dynamiquement (_injecter_) les dépendances d'une classe en utilisant une description (un fichier de configuration par exemple).\nCette méthode va nous permettre de ne plus exprimer les dépendances entre les composants dans le code de manière statique, mais de les déterminer dynamiquement à l'exécution.\n\nPrenons un exemple pour illustrer. Imaginons que nous avons une classe _A_, qui dépend des classes _B_ et _C_.\nDans mon code, j'aurai besoin de faire ceci :\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass B implements InterfaceB {\n    // ...\n}\n```\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass C implements InterfaceC {\n    // ...\n}\n```\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass A {\n    private B $b;\n    private C $c;\n\n    public function __construct()\n    {\n        $this->b = new B();\n        $this->c = new C();\n    }\n\n    // ...\n}\n```\n\nAvec l'injection des dépendances, je ne vais plus avoir besoin de créer les instances des classes _B_ et _C_ manuellement, mais je vais les injecter :\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass A {\n    private InterfaceB $b;\n    private InterfaceC $c;\n\n    public function __construct(InterfaceB $b, InterfaceC $c)\n    {\n        $this->b = $b;\n        $this->c = $c;\n    }\n\n    // ...\n}\n```\n\nEncore mieux, depuis PHP 8, je peux faire simplement ceci :\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass A {\n    public function __construct(\n        private InterfaceB $b,\n        private InterfaceC $c,\n    ) {\n    }\n\n    // ...\n}\n```\n\nLes instances des classes _B_ et _C_ seront créées par une classe dont la responsabilité est de lire les fichiers de configuration et de créer des objets.\n\nL'intérêt principal de l'injection de dépendances est de séparer la création des objects de leur utilisation.\nDe plus, en injectant nos dépendances, nous pouvons utiliser des interfaces au lieu des classes et ainsi éviter un couplage fort entre nos classes.\n\n## Dans Symfony\nDans le framework Symfony, l'injection de dépendances est réalisée via le _Container_ de services, qui est construit par le _ContainerBuilder_. Celui-ci est initialisé par le _Kernel_.\n\n### Service Container\nEn environnement de production, le kernel va d'abord chercher une version cachée du _Container_ par souci de performances.\nSi elle existe, c'est la version cachée qui est utilisée. Sinon, le kernel va en construire une en se basant sur la configuration de l'application.\n\nComme vous le savez, la configuration d'une application Symfony est faite dans le dossier _config_.\nLe _ContainerBuilder_ va donc parser tous les fichiers de configuration pour les traiter et récupérer tous les paramètres et services de notre application, et aussi de nos dépendances.\nIl va prendre en compte, entre autres, les services tagués et les _Compiler pass_ (cf. plus bas).\nUne fois la compilation faite, une version cachée du _Container_ va être _dump_ pour être utilisée par les requêtes suivantes.\n\nPour en savoir plus sur ce process, vous pouvez [lire cette documentation](https://symfony.com/doc/current/components/dependency_injection/workflow.html).\n\n### Déclaration de services\nRevenons sur notre exemple précédent et voyons comment déclarer nos classes en tant que services :\n\n```yaml\n# config/services.yaml\nservices:\n    App\\Services\\B:\n\n    App\\Services\\C:\n\n    App\\Services\\A:\n        arguments:\n            - '@App\\Services\\B'\n            - '@App\\Services\\C'\n```\n\nJe configure chacun de mes services séparément.\nPour injecter un service dans un autre, je le passe en arguments du second service, en le préfixant par un '@'.\n\n### Autowiring\nDepuis la version 3.4 de Symfony, nous avons la possibilité d'utiliser l'_autowiring_, ce qui va m'éviter de déclarer tous les services à la main :\n\n```yaml\n# config/services.yaml\nservices:\n    # la configuration par défaut de services dane *ce* fichier\n    _defaults:\n        autowire: true      # Injecte automatiquement les dependances dans nos services\n        autoconfigure: true # Déclare automatiquement nos services en tant que commandes, event subscribers, etc.\n\n    # rendre les classes dans src/ disponibles pour être utilisées en tant que services\n    # ceci va créer un service par classe donc l'id sera son nom complet\n    App\\:\n        resource: '../src/*'\n        exclude: '../src/{DependencyInjection,Entity,Tests,Kernel.php}'\n\n    # ...\n```\n\nDans nos services, on peut injecter non seulement d'autres services, mais aussi les paramètres configurés dans l'application.\nVoici un exemple :\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass AdminMailer {\n    private string $recipient;\n\n    public function __construct(string $adminEmail)\n    {\n        $this->recipient = $adminEmail;\n    }\n\n    // ...\n}\n```\n\n```yaml\n# config/services.yaml\nservices:\n    _defaults:\n        bind:\n            # tout argument $adminEmail dans un constructeur aura cette valeur\n            $adminEmail: 'admin@example.com'\n```\n\nCe sont des exemples basiques pour vous donner un aperçu de l'injection de dépendances.\nJe vous invite à lire la [documentation Symfony sur l'injection de dépendances](https://symfony.com/doc/current/service_container.html) pour une vision complète de ce qu'il est possible de faire avec ce composant, qui est très puissant !\n\n## Services tagués\nCeux qui utilisent Symfony depuis quelque temps ont déjà probablement eu affaire aux services tagués.\nLes services tagués sont un moyen de dire à Symfony que votre service doit être chargé d'une certaine façon.\nPrenons l'exemple suivant : je souhaite formatter les exceptions de mon application, pour cela je vais intercepter un évènement précis.\n\n```yaml\n# config/services.yaml\nservices:\n    App\\EventListener\\ExceptionListener:\n        tags:\n            - { name: kernel.event_listener, event: kernel.exception }\n```\n\nTous les services tagués `kernel.event_listener` sont chargés par le `FrameworkBundle` et sont appelés en fonction de l'évènement auquel ils sont liés.\nIl existe une [multitude de tags disponibles dans Symfony](https://symfony.com/doc/current/reference/dic_tags.html), et chacun a une fonction bien précise.\nAinsi, vous pouvez agir sur des évènements comme ci-dessus, mais aussi ajouter une extension Twig, intervenir au moment de la sérialisation d'une entité, etc.\n\n## Tags personnalisés et Compiler pass\nImaginons maintenant que dans mon application j'ai un système de génération de documents.\nJe voudrais implementer une solution propre et facilement maintenable, avec un service central qui, en fonction du type de document souhaité, va déléguer la génération du document au bon service.\n\nPour ceci, je vais créer un générateur par type de document souhaité, les taguer avec un tag personnalisé, et ensuite les injecter à mon service principal de génération de documents.\n\nAu départ, je crée une interface pour mes générateurs, pour m'assurer qu'ils ont tous le même comportement :\n\n```php\n<?php\n\nnamespace App\\Services;\n\ninterface DocumentGeneratorInterface {\n    public function supports(string $type): bool;\n    public function generate(array $data): mixed;\n}\n```\n\nEnsuite, je prépare mon service principal de génération de documents, qui sera uniquement injecté dans les endroits de mon application où j'aurai besoin de générer un document :\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass DocumentGenerator {\n    private array $documentGenerators;\n\n    public function addGenerator(DocumentGeneratorInterface $generator): void\n    {\n        $this->documentGenerators[] = $generator;\n    }\n\n    public function generate(array $data, string $type): mixed\n    {\n        /** @var GeneratorInterface $generator */\n        foreach ($this->documentGenerators as $generator) {\n            if (!$generator->supports($type)) {\n                continue;\n            }\n\n            return $generator->generate($data);\n        }\n\n        throw new \\LogicException(sprintf('Document of type %s cannot be handled', $type));\n    }\n}\n```\n\nEnfin, j'implémente mes générateurs par type de document :\n```php\n<?php\n\nnamespace App\\Services;\n\nclass PDFDocumentGenerator {\n    public function supports(string $type): bool\n    {\n        return $type === 'pdf';\n    }\n\n    public function generate(array $data): mixed\n    {\n        // generation du document\n    }\n}\n```\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass CSVDocumentGenerator {\n    public function supports(string $type): bool\n    {\n        return $type === 'csv';\n    }\n\n    public function generate(array $data): mixed\n    {\n        // generation du document\n    }\n}\n```\n\nPour dire à l'injection de dépendances que mes générateurs doivent avoir un tag spécifique, je peux le déclarer de cette façon :\n```yaml\n# config/services.yaml\nservices:\n    _instanceof:\n        # toutes les instances de DocumentGeneratorInterface seront automatiquement tagués\n        App\\Services\\DocumentGeneratorInterface:\n            tags: ['app.document_generator']\n```\n\nMaintenant, il ne me reste plus qu'à indiquer à l'injection de dépendances que tous les services tagués `app.document_generator` doivent être injectés dans ma classe `DocumentGenerator`.\nPour cela, je vais créer un _Compiler pass_ personnalisé :\n\n```php\nnamespace App\\DependencyInjection\\Compiler;\n\nuse App\\Services\\DocumentGenerator;\nuse Symfony\\Component\\DependencyInjection\\Compiler\\CompilerPassInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\DependencyInjection\\Reference;\n\nclass DocumentGeneratorPass implements CompilerPassInterface\n{\n    public function process(ContainerBuilder $container): void\n    {\n        if (!$container->has(DocumentGenerator::class)) {\n            return;\n        }\n\n        $definition = $container->findDefinition(DocumentGenerator::class);\n\n        $taggedServices = $container->findTaggedServiceIds('app.document_generator');\n\n        foreach ($taggedServices as $id => $tags) {\n            $definition->addMethodCall('addGenerator', [new Reference($id)]);\n        }\n    }\n}\n```\n\nEnfin, dernière étape, ajouter mon _Compiler pass_ dans le Kernel :\n\n```php\n// src/Kernel.php\nnamespace App;\n\nuse App\\DependencyInjection\\Compiler\\DocumentGeneratorPass;\nuse Symfony\\Component\\HttpKernel\\Kernel as BaseKernel;\n// ...\n\nclass Kernel extends BaseKernel\n{\n    // ...\n\n    protected function build(ContainerBuilder $container): void\n    {\n        $container->addCompilerPass(new DocumentGeneratorPass());\n    }\n}\n```\n\nGrâce à mon tag personnalisé, je peux très facilement ajouter un nouveau type de document à générer dans l'application, sans devoir modifier le reste de l'application.\n\n### Pour aller plus loin\nNous venons de parcourir ensemble en grandes lignes l'injection de dépendances dans Symfony.\nC'est un composant très puissant et central au framework.\nSi vous voulez en savoir plus, n'hésitez pas à parcourir la [documentation très bien faite](https://symfony.com/doc/current/service_container.html#learn-more).\n\nÀ bientôt !\n"}