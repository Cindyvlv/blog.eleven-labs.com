{"date":"2013-12-08T00:00:00.000Z","title":"Symfony 2 : Cache HTTP  et ESI","excerpt":"Voici un petit tuto orienté performance avec l'utilisation du cache dans Symfony. On y abordera aussi l'utilisation des ESI pour mettre en cache une partie de la page.","readingTime":"7mn","authors":["cmoncade"],"categories":["php"],"content":"Lorsque l’on développe un site, en particulier un site à fort trafic, on est forcément amené à se poser la question des ressources consommées par ce dernier afin d’optimiser son temps de réponse. En effet, une page qui met plus de 3-4 secondes à s’afficher rend vite désagréable la navigation et découragera plus d’une personne à venir sur votre site.\n\n# 1) Principe du cache HTTP\n\nLe système de cache de Symfony vous permettra de diminuer les temps de réponses de vos pages en utilisant la puissance du cache HTTP tel qu'il est défini dans la <a href=\"https://fr.wikipedia.org/wiki/Hypertext_Transfer_Protocol\" rel=\"nofollow noreferrer\" style=\"color:#0000ff;\">spécification HTTP</a>. Sachez cependant que ce n’est qu’une des solutions possibles.\n\nPour augmenter la vitesse d'une application, on peut par exemple:\n- optimiser l’utilisation de la base de données. Gérer l’espace alloué à la mémoire tampon pour accélérer l’accès aux données les plus souvent demandées, développer des vues et des procédures pour alléger votre serveur par exemple.\n- Utiliser la mise en cache des <a href=\"http://php.net/manual/fr/book.opcache.php\" rel=\"nofollow noreferrer\" style=\"color:#0000ff;\">OPCodes</a> si vous êtes admin de votre serveur. Pour résumer grossièrement, l’OPCode est le code intermédiaire lors de la transformation de votre code (HTML, PHP …) en code binaire compréhensible par la machine. On trouvera parmi les plus connus APC, XCache ou encore EAccelerator.\n\nPour revenir au cache http, expliquons en un peu le principe. Le rôle de la mémoire cache (ou reverse proxy) est d’accepter les requêtes coté client et de les transmettre au serveur. Il va ensuite recevoir les réponses et les transmettre au client. Lors de ces deux étapes, il va mémoriser les requêtes et les réponses associées. Ceci lui permettra lorsque qu’une même requête est demandée, de vous retourner la réponse sans la redemander au serveur. On économise donc du temps et des ressources.\n\n\n<br/>\n[![mémoire cache](/assets/2013-12-08-symfony-2-cache-http-esi/reverse_proxy.png)](/assets/2013-12-08-symfony-2-cache-http-esi/reverse_proxy.png){: .center-image .no-link-style}\n\n\n# 2) Le Cache dans Symfony\n\nRentrons maintenant dans le vif du sujet. Symfony est équipé d’un reverse proxy défini par la classe AppCache.php qui se situe dans app/AppCache.php de votre projet.\n\nSa mise en place dans Symfony est relativement simple.\n\nIl vous faut dans un premier temps modifier votre app_dev.php afin qu’il ressemble à ceci :\n\n```php\n<?php\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Debug\\Debug;\n\n// If you don't want to setup permissions the proper way, just uncomment the following PHP line\n\n// read http://symfony.com/doc/current/book/installation.html#configuration-and-setup for more information\n\n//umask(0000);\n// This check prevents access to debug front controllers that are deployed by accident to production servers.\n\n// Feel free to remove this, extend it, or make something more sophisticated.\n\nif (isset($_SERVER['HTTP_CLIENT_IP'])\n    || isset($_SERVER['HTTP_X_FORWARDED_FOR'])\n    || !in_array(@$_SERVER['REMOTE_ADDR'], array('127.0.0.1', 'fe80::1', '::1'))\n) {\n    header('HTTP/1.0 403 Forbidden');\n    exit('You are not allowed to access this file. Check '.basename(__FILE__).' for more information.');\n}\n\n$loader = require_once __DIR__.'/../app/bootstrap.php.cache';\n\nDebug::enable();\n\nrequire_once __DIR__.'/../app/AppKernel.php';\nrequire_once __DIR__.'/../app/AppCache.php';\n\n$kernel = new AppKernel('dev', true);\n$kernel->loadClassCache();\n$kernel = new AppCache($kernel);\nRequest::enableHttpMethodParameterOverride();\n$request = Request::createFromGlobals();\n$response = $kernel->handle($request);\n$response->send();\n$kernel->terminate($request, $response);\n```\n\nEt c’est tout? Eh ben oui, c’est pas plus compliqué que ça. Rajoutez votre dépendance à AppCache et instanciez là avec en paramètre votre kernel.\n\n## Exemple 1 : Utilisation simple\n\nMaintenant, on va dans un premier temps créer un exemple sans activer le cache.\n\nPour le routing:\n```yaml\n#app/config/routing.yml\ncache:\n    resource: \"@MyBundle/Resources/config/routing.yml\"\n    prefix:   /\n```\n\nMyBundle/Ressources/config/routing.yml:\n```yaml\nexample:\n    pattern:  /example\n    defaults: { _controller: MyBundle:Example:cache}\n```\n\nVoici pour le Controller:\n```php\n<?php\n\nnamespace MyBundle\\Controller;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\nclass ExampleController extends Controller {\n    public function cacheAction() {\n        return $this->renderView('MyBundle:Cache:cache.html.twig', array('hello' => 'Hello World!!!'));\n    }\n}\n```\n\nEnfin, votre template cache.html.twig situé dans MyBundle/Resources/views/Cache/cache.html.twig:\n\n```\n{% extends \"@MyBundle/layout.html.twig\" %}\n\n{% block body %}\n\n    <h1>{{ hello }}</h1>\n\n{% endblock %}\n```\n\n\nEt voilà le résultat:\n\n<br/>\n[![mémoire cache](/assets/2013-12-08-symfony-2-cache-http-esi/hello1.png)](/assets/2013-12-08-symfony-2-cache-http-esi/hello1.png){: .center-image .no-link-style}\n\nMaintenant pour s’assurer que le cache est bien inactif, ouvrez firebug.\n\nAllez dans l’onglet Réseau (ou Network pour ceux qu’ils l’ont en anglais),\n\n<br/>\n[![mémoire cache](/assets/2013-12-08-symfony-2-cache-http-esi/firebug1.png)](/assets/2013-12-08-symfony-2-cache-http-esi/firebug1.png){: .center-image .no-link-style}\n\nEt dépliez le get correspondant à votre route:\n\n<br/>\n[![mémoire cache](/assets/2013-12-08-symfony-2-cache-http-esi/response1.png)](/assets/2013-12-08-symfony-2-cache-http-esi/response1.png){: .center-image .no-link-style}\n\nOn voit donc bien ici la valeur du Cache-Control qui est à no-cache.\n\nMaintenant pour activer le cache, on va légèrement modifier notre Controller.\nCommencez par rajouter votre dépendance à l’objet Response dans votre controller:\n```php\nuse Symfony\\Component\\HttpFoundation\\Response;\n```\n\nModifiez maintenant votre action:\n```php\npublic function cacheAction() {\n    $response = new Response();\n    $response->setMaxAge(300);\n\n    // Check that the Response is not modified for the given Request\n    if (!$response->isNotModified($this->getRequest())) {\n        $date = new \\DateTime();\n        $response->setLastModified($date);\n        $response->setContent($this->renderView('MyBundle:Cache:cache.html.twig', array('hello' => 'Hello World!!!')));\n        }\n\n        return $response;\n    }\n}\n```\n\nVoici une utilisation très simpliste du système de cache.\n\nL’objet Response va nous permettre de manipuler les différents éléments d’information de l’en-tête Cache-Control. Ici, je me suis contenté de définir le temps de validité de la réponse mise en cache (ici 300 secondes). Au-delà de cette durée, la réponse va être régénérée par le serveur et sera de nouveau valide durant 300 secondes. Si la réponse est encore valide, on la retourne directement sinon on régénère la réponse et on modifie sa date de modification.\n\nMaintenant, si on jette à nouveau un œil à notre firebug:\n\n<br/>\n[![mémoire cache](/assets/2013-12-08-symfony-2-cache-http-esi/response2.png)](/assets/2013-12-08-symfony-2-cache-http-esi/response2.png){: .center-image .no-link-style}\n\nOn constate que le système de cache est bien activé. Pour aller plus loin avec les différentes options possibles de l’en-tête, je vous invite fortement, si ce n’est pas déjà fait, à lire la doc sur le site officiel de <a href=\"http://symfony.com/doc/master/http_cache.html\" rel=\"nofollow noreferrer\" style=\"color:#0000ff;\">Symfony</a>.\n\nOk, tout ça c’est bien, mais cela met en cache une page entière. Mais votre besoin sera peut-être de ne mettre en page qu’une partie de la page.\nHeureusement pour nous, Symfony a pensé à tout et nous fournit une solution, les «Edge Side Includes» (ESI).\n\n## Exemple 2 : ESI\n\nPour activer le mode ESI dans Symfony, ouvrez votre app/config/config.yml et ajoutez ces deux lignes dans la partie framework :\n```yaml\nframework:\n    esi: { enabled: true }\n```\n\nMaintenant créez un deuxième template. Moi je l’appellerai esi.html.twig et il contiendra simplement:\n```html\n<h2>Partie en Cache</h2>\n```\n\nModifiez le premier template:\n\n```\n{% extends \"@ MyBundle/layout.html.twig\" %}\n\n{% block body %}\n\n    <h1>{{ hello }}</h1>\n\n    {{ render_esi(controller(' MyBundle:Example:getEsiCache')) }}\n\n{% endblock %}\n```\n\n\nEt enfin votre controlleur:\n```php\n<?php\n\nnamespace My\\Bundle\\TrainingBundle\\Controller;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass ExampleController extends Controller {\n\n    public function cacheAction() {\n        return $this->render('MyBundle:Cache:cache.html.twig',\n            array('hello' => 'Hello World!!!'));\n    }\n\n    public function getEsiCacheAction(Request $request) {\n        $response = new Response();\n        $response->setSharedMaxAge(10);\n        $response->setPublic();\n        $response->setMaxAge(10);\n\n        // Check that the Response is not modified for the given Request\n        if (!$response->isNotModified($request)) {\n            $date = new \\DateTime();\n            $response->setLastModified($date);\n            $response->setContent($this->renderView('MyBundle:Cache:esi.html.twig'));\n        }\n        return $response;\n    }\n}\n```\n\nJ’ai ici simplifié l’action cacheAction() pour n’activer le cache que pour le fragment ESI.\n\nActualiser votre page et vous devez obtenir ceci:\n\n<br/>\n[![mémoire cache](/assets/2013-12-08-symfony-2-cache-http-esi/hello2.png)](/assets/2013-12-08-symfony-2-cache-http-esi/hello2.png){: .center-image .no-link-style}\n\nMaintenant, si on repart voir ce que nous dit notre bon vieil ami firebug, on voit:\n\n<br/>\n[![mémoire cache](/assets/2013-12-08-symfony-2-cache-http-esi/response3.png)](/assets/2013-12-08-symfony-2-cache-http-esi/response3.png){: .center-image .no-link-style}\n\nUne ligne X-Symfony-Cache est apparu. Si on se concentre sur la fin de la ligne, on lit: «…EsiCache: stale, invalid, store». En gros, le cache de ce fragment n’était pas valide (normal vu qu’on vient de le créer :) ). Mais si vous faite un petit F5, vous aurez le message suivant:\n\n<br/>\n[![mémoire cache](/assets/2013-12-08-symfony-2-cache-http-esi/response4.png)](/assets/2013-12-08-symfony-2-cache-http-esi/response4.png){: .center-image .no-link-style}\n\nAahhhh, ça a l’air d’être «fresh» :)\n\nJe vous passe les explications mais vous aurez compris que le fragment en cache était valide et qu’il a pu être retourné directement.\n\nVous avez maintenant les bases pour voler de vos propres ailes et optimiser votre application.\n"}