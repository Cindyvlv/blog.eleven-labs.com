{"date":"2019-06-19T00:00:00.000Z","title":"Protégez du brute force votre application Symfony avec Maba Gentle Force","excerpt":"Je vous propose de découvrir un bundle très simple à configurer afin de protéger votre application Sympony contre les attaques de brute force","readingTime":"12mn","authors":["dim"],"categories":["php"],"content":"\n\n## Protégez du brute force votre application Symfony avec Maba Gentle Force\n\nLa sécurité est l'affaire de tous, vous avez certainement déjà tous entendu cela au moins une fois.\nAvec l'arrivée de la RGPD, les fuites de données sont de plus en plus médiatisées et si vous souhaitez éviter d'avoir à faire aux institutions comme la CNIL ou tout simplement si vous souhaitez un outil simple pour protéger contre le brute force votre application Symfony, je vous présente Maba Gentle Force.\n\n## Maba Gentle Force, késaco ?\n\nC'est un bundle basé sur la librairie PHP [Gentle Force](https://github.com/mariusbalcytis/gentle-force).\n\n## Introduction de Gentle Force\n\nLa librairie utilise l’algorithme [Token Bucket](https://en.wikipedia.org/wiki/Token_bucket) :\nL'utilisateur possède des jetons qu'il va pouvoir utiliser pour effectuer ses actions. À chaque tentative, un jeton sera consommé jusqu’à ce qu'il n'y en ait plus. Il va ensuite pouvoir regagner d'autres jetons au bout d'un certain temps (configurable) pour faire une nouvelle tentative.\nCette librairie fonctionne avec [Predis](https://github.com/nrk/predis) pour le stockage des jetons.\n\nVoici une liste de fonctionnalités que propose Gentle Force :\n- Vérification des jetons disponible pré-tentatives d'authentification pour empêcher la [Race_condition](https://en.wikipedia.org/wiki/Race_condition).\n- Possibilité de définir différentes limitations selon les créneaux temporels.\n- Différents moyens sur lesquels baser sa vérification d'identité : ID, token d'api, adresse IP, etc...\n\n\n## Initialisation\n\n```sh\ncomposer require maba/gentle-force-bundle\n```\n\nAjouter le bundle dans votre AppKernel si vous n'utilisez pas flex :\n\n```php\nnew \\Maba\\Bundle\\GentleForceBundle\\MabaGentleForceBundle(),\n```\n\nImportez ensuite les routes dans votre routing.yml.\n\n```yaml\ngentle_force:\n    resource: '@MabaGentleForceBundle/Resources/config/routing.xml'\n```\n\nVous trouverez dans l'arborescence `App/config/packages/` un fichier de configuration `maba_gentle_force.yml`.\nDans ce fichier vous allez tout d'abord devoir déclarer votre Predis :\n\n```yaml\nmaba_gentle_force:\n    redis:\n        service_id: votre service client redis\n```\n\n## Utilisation\n\n### Cas simple\n\nDans le cas où dans votre application vous permettez à vos utilisateurs l'upload de documents, et afin d'éviter que ceux ci ne saturent vos espaces de stockage, vous pouvez par exemple ajouter cette portion dans votre fichier de configuration `maba_gentle_force.yml`.\n\n```yaml\n    limits:\n        documents_upload:\n            # Autorise uniquement 50 uploads par jour\n            -   max_usages: 50\n                period: 1d\n```\n\nPour les cas simples où vous n'avez pas le besoin de faire de vérification spécifique, vous devez y ajouter également la configuration du listener comprenant :\n- la route concernée.\n- la clé d'identifiant de la configuration.\n- le type de donnée d'entrée servant à la vérification (ici l'IP).\n- la stratégie de réponse (headers signifiant une réponse pré-configurée pour retourner un statut HTTP 429 Too Many Requests).\n```yaml\n    listeners:\n        -   path: ^/votre-route\n            limits_key: documents_upload\n            identifiers: [ip]\n            strategy: headers\n```\n\nSi votre vérification porte sur une route peu critique, il est également possible de définir une `strategy: log` à la place, afin de ne pas bloquer vos utilisateurs tout en assurant une surveillance à travers les logs disponibles.\nDans ce cas, il vous faudra également ajouter la configuration sur la stratégie de log :\n\n```yaml\n      strategies:\n        default:    headers\n        log:\n            level:  error\n```\n\n### Cas avancé 1 : Réinitialisation de mot de passe\n\nLimiter l'accès à une route est plutôt simple, nous allons voir maintenant comment limiter l'accès à une portion de votre application. L'exemple ici portera sur la fonctionnalité de récupération de mot de passe.\n\n#### Première étape : configuration\n\nDans notre `maba_gentle_force.yml` vous allez devoir déclarer votre configuration :\n\n```yaml\n    limits:\n        reset_password:\n            # Autorise uniquement 3 erreurs par heure\n            # 3 tokens d'erreurs seront récupérés pendant 1 heure suivant la dernière erreur\n            -   max_usages: 3\n                period: 1h\n                bucketed_usages: 3\n\n                # Autorise uniquement 20 erreurs par jour\n            -   max_usages: 20\n                period: 1d\n```\n\nContrairement au cas précédent, nous n'avons pas de listener de route à définir, nous allons directement utiliser le `Throttler` de l'outil.\n\n#### Deuxième étape : utilisation\n\nDu côté de notre code PHP, nous allons dans un premier temps récupérer le `Throttler` puis utiliser la méthode `checkAndIncrease` avant d'appeler notre service de récupération de mot de passe en passant en paramètre :\n- l'identifiant de configuration : `reset_password`\n- l'identifiant d'identité de l'utilisateur : l'adresse IP\n\n```php\nif ($form->isSubmitted() && $form->isValid()) {\n    // Augmenter le compteur de tentatives avant de vérifier la légitimité de l'utilisateur\n    // Cela permet entre autres d'éviter la \"race condition\" provenant d'un grand nombre de requêtes\n    try {\n        $bucket = $this->get('maba_gentle_force.throttler')->checkAndIncrease('reset_password', $request->getClientIp());\n    } catch (RateLimitReachedException $exception) {\n        // Vous pouvez logger ici votre erreur puis retourner une réponse avec le code HTTP 429\n    }\n    // Tout va bien, vous pouvez exécuter votre code permettant de réinitialiser son mot de passe\n    // Vous pouvez ensuite réduire le compteur pour éviter de bloquer inutilement votre utilisateur\n    $bucket->decrease();\n}\n```\n\n### Cas avancé 2 : authentification\n\nCertaines fonctionnalités sont plus soumises aux attaques que d'autres. Il est donc nécessaire d'augmenter d'un cran la sécurité de celles-ci. On parle par exemple de l'authentification de votre application.\n\nCette fois-ci nous allons nous baser sur plusieurs identifiants de vérification : l'email de l'utilisateur et son IP.\n\n#### Première étape : configuration\n\nLa différence ici sera uniquement dans l'ajout d'une configuration par identifiant de vérification.\nLa configuration est similaire à celle du cas précédent, on retrouve nos limitations par durée de créneau de temps :\n\n```yaml\n    limits:\n        authentication_email:\n            # Autorise uniquement 10 erreurs par heure\n            # 5 jetons d'erreurs supplémentaires seront récupérés pendant 1 heure\n            -   max_usages: 10\n                period: 1h\n                bucketed_usages: 5\n\n                # Autorise uniquement 30 erreurs par jour\n            -   max_usages: 30\n                period: 1d\n\n        authentication_ip:\n            # Autorise uniquement 120 erreurs par heure par IP\n            -   max_usages: 60\n                period: 1h\n```\n\n#### Deuxième étape : utilisation\n\nSi vous utilisez [Guard](https://symfony.com/doc/current/security/guard_authentication.html) de Symfony, dans votre implémentation de la méthode `checkCredentials`, vous allez pouvoir ajouter cette portion de code qui agit comme dans le cas précédent en vérifiant cette fois une par une les conditions ayant chacune leur propre configuration.\n\n```php\n$identifier = $user->getEmail();\n$rule = 'authentication_email';\n$throttler = $this->get('maba_gentle_force.throttler');\ntry {\n    // Première vérification avec la configuration sur l'email\n    $bucket = $throller->checkAndIncrease($rule, $identifier);\n    // Deuxième vérification avec la configuration sur l'IP\n    if (isset($credentials['ip'])) {\n        $identifier = $credentials['ip'];\n        $rule = 'authentication_ip';\n        $credentialsResultIp = $throttler->checkAndIncrease($rule, $identifier);\n    }\n} catch (RateLimitReachedException $exception) {\n    throw new RateLimitedBadCredentialsException($exception, $rule, $identifier);\n}\n// L'authentificaion s'est bien passée, vous pouvez décrémenter le seau de jetons\n$bucket->decrease();\n```\n\n## Bonus : google recaptcha\n\nle bundle propose une configuration compatible avec l'utilisation de [google recaptcha](https://www.google.com/recaptcha/intro/v3.html)\n\nIl vous faudra taper cette ligne de commande en plus :\n\n```sh\ncomposer require google/recaptcha\n```\n\nPuis dans votre fichier de configuration `maba_gentle_force.yml` vous pourrez y ajouter vos credentials :\n\n```yaml\nmaba_gentle_force:\n    recaptcha:\n        site_key: my_recaptcha_site_key # get this at google.com/recaptcha\n        secret: my_recaptcha_secret     # this also\n```\n\nVous pourrez enfin définir deux stratégies propres à recaptcha :\n- `recaptcha_headers` aura le même résultat que headers en renvoyant les credentials recaptcha en vue d'activer le widget (pour une API par exemple)\n- `recaptcha_template` permettra d'envoyer une réponse sous forme de template HTML (nécessite l'installation de TWIG) contenant le widget\n\n```yaml\n    strategies:\n        recaptcha_headers:\n            site_key_header:      your-site-key-header-to-enable-widget\n            unlock_url_header:    your-url-to-unlock\n        recaptcha_template:\n            template:             your-template-including-google-widget\n```\n\n## Aperçu du fichier final\n\n\n```yaml\nmaba_gentle_force:\n    redis:\n        service_id: votre service client redis\n\n    limits:\n        authentication_email:\n            -   max_usages: 10\n                period: 1h\n                bucketed_usages: 5\n\n            -   max_usages: 30\n                period: 1d\n\n        authentication_ip:\n            -   max_usages: 60\n                period: 1h\n\n        reset_password:\n            -   max_usages: 3\n                period: 1h\n                bucketed_usages: 3\n\n            -   max_usages: 20\n                period: 1d\n\n        documents_upload:\n            -   max_usages: 50\n                period: 1d\n\n    listeners:\n        -   path: ^/votre-route\n            limits_key: documents_upload\n            identifiers: [ip]\n            strategy: headers\n\n    strategies:\n        default:    headers\n        log:\n            level:  error\n        recaptcha_headers:\n            site_key_header:      your-site-key-header-to-enable-widget\n            unlock_url_header:    your-url-to-unlock\n        recaptcha_template:\n            template:             your-template-including-google-widget\n\n    recaptcha:\n        site_key: votre-recaptcha-site-key\n        secret: votre-recaptcha-secret\n```\n\n## Le mot de la fin\n\nLa sécurité est un domaine très vaste et cet outil n'en est qu'un parmi tant d'autres.\nPAr exemple, ce bundle ne protègera pas votre application contre de la vérification de combinaison mot de passe / email de manière unitaire comme utilisé récemment dans certaines [attaques](https://www.numerama.com/tech/458514-dailymotion-reinitialise-des-mots-de-passe-apres-une-attaque-informatique-a-grande-echelle.html).\nPeu importe quels outils vous allez sélectionner dans votre environnement technique, il convient de rappeler l'importance de prendre en compte l'aspect de la sécurité dans chacun de vos développements.\n"}