{"date":"2014-08-04T00:00:00.000Z","title":"Isolation des tests fonctionnels avec Symfony 2 et Doctrine","excerpt":"Quand on exécute une suite de tests fonctionnels ou unitaires sur une application, le mieux est de ne pas changer l'état de la base de données. Cela permet ainsi d'exécuter ces tests plusieurs fois sur un état stable des données. Chaque test est ainsi isolé des autres.","readingTime":"13mn","authors":["charles-eric"],"categories":["php"],"content":"\nQuand on exécute une suite de tests fonctionnels ou unitaires sur une application, le mieux est de ne pas changer l'état de la base de données. Cela permet ainsi d'exécuter ces tests plusieurs fois sur un état stable des données. Chaque test est ainsi isolé des autres.\n\n**Contexte : isolation grâce à un rollback de la base de données :**\n\nComme indiqué dans un [article précédent](https://blog.eleven-labs.com/fr/test-unitaire-dun-bundle-symfony2/ \"Test unitaire d’un bundle Symfony 2\") et [décrit par Alexandre Salomé](http://alexandre-salome.fr/blog/Symfony2-Isolation-Of-Tests \"Isolation of tests in Symfony2\"){:rel=\"nofollow noreferrer\"}, il est possible de mettre en place un système de rollback pour rétablir l'état initial des données après l’exécution de chaque test.\n\nCela repose sur cette classe que vos tests fonctionnels PHPUnit devront étendre et qui déclenche le système d'isolation, avant et après chaque cas de tests grâce aux méthodes *setUp* et *tearDown* :\n\n```php\n<?php\n\nnamespace Cheric\\ExampleBundle\\Test;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase as BaseWebTestCase;\n\nclass IsolatedWebTestCase extends BaseWebTestCase\n{\n    protected $client;\n\n    public function setUp()\n    {\n        parent::setUp();\n\n        $this->client = self::createClient();\n\n        $this->client->startIsolation();\n    }\n\n    public function tearDown()\n    {\n        if (null !== $this->client) {\n            $this->client->stopIsolation();\n        }\n\n        parent::tearDown();\n    }\n}\n```\n\nCe *Test Case* utilise le *Test Client* suivant, il est capable de déclencher un rollback en base de données :\n\n```php\n<?php\n\nnamespace Cheric\\ExampleBundle\\Test;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Client as BaseClient;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * Test client.\n */\nclass Client extends BaseClient\n{\n    /**\n     * The current DBAL connection.\n     */\n    protected $connection;\n\n    /**\n     * Was this client already requested?\n     */\n    protected $requested = false;\n\n    /**\n     * @param Request $request\n     *\n     * @return Request\n     */\n    protected function doRequest($request)\n    {\n        if (true === $this->requested) {\n            $this->kernel->shutdown();\n            $this->kernel->boot();\n        }\n\n        $this->startIsolation();\n        $this->requested = true;\n\n        return $this->kernel->handle($request);\n    }\n\n    /**\n     * Starts the isolation process of the client.\n     */\n    public function startIsolation()\n    {\n        if (null === $this->connection) {\n            $this->connection = $this->getContainer()\n                ->get('doctrine.dbal.default_connection');\n        } else {\n            $this->getContainer()\n                ->set('doctrine.dbal.default_connection', $this->connection);\n        }\n\n        if (false === $this->requested) {\n            $this->connection->beginTransaction();\n        }\n    }\n\n    /**\n     * Stops the isolation process of the client.\n     */\n    public function stopIsolation()\n    {\n        if (null !== $this->connection) {\n            if ($this->connection->isTransactionActive()) {\n                $this->connection->rollback();\n            }\n\n            $this->connection->close();\n        }\n\n        $this->connection = null;\n    }\n\n    /**\n     * Connect a user\n     *\n     * @param string  $username    The username\n     * @param string  $password The password\n     *\n     * @return Crawler\n     */\n    public function connect($username, $password = '11labs')\n    {\n        $this->followRedirects(true);\n\n        $crawler = $this->request('GET', '/logout');\n        $crawler = $this->request(\n            'POST',\n            '/login_check',\n            array(\n                '_username' => $username,\n                '_password' => $password\n            )\n        );\n\n        $this->followRedirects(false);\n\n        return $this->crawler;\n    }\n}\n```\n\nCela fonctionne très bien sauf dans les cas où vous souhaitez tester des *Events Listeners Doctrine* dans vos tests fonctionnels, dans lesquels vous effectuez plusieurs requêtes (pour connecter l'utilisateur avant votre action par exemple). Nous allons donc d'abord constater l'erreur dans ce cas là avant de voir comment l'éviter.\n\n**Problème : quand on utilise des *Listeners* Doctrine :**\n\nImaginons par exemple que vous ayez besoin d'exécuter une stratégie particulière pour changer un attribut de votre entité Doctrine juste après sa création, i.e. lors de l'event postPersit et/ou postUpdate. Vous mettriez alors en place ce [listener](http://symfony.com/doc/current/cookbook/doctrine/event_listeners_subscribers.html \"How to Register Event Listeners and Subscribers\"){:rel=\"nofollow noreferrer\"} :\n\n```php\n<?php\n\nnamespace Cheric\\ExampleBundle\\Doctrine\\Listener;\n\nuse Doctrine\\ORM\\Event\\LifecycleEventArgs;\nuse Cheric\\ExampleBundle\\Entity\\Article;\nuse Cheric\\ExampleBundle\\Strategy\\PriceStrategy;\n\nclass ArticleListener\n{\n    private $priceStrategy;\n\n    public function __construct(PriceStrategy $priceStrategy)\n    {\n        $this->priceStrategy = $priceStrategy;\n    }\n\n    public function postPersist(LifecycleEventArgs $args)\n    {\n        $article = $args->getEntity();\n\n        if (!$article instanceof Article) {\n            return;\n        }\n\n        $this->execute($article);\n    }\n\n    private function execute(Article $article)\n    {\n        $this->priceStrategy->execute($article);\n    }\n\n    public function postUpdate(LifecycleEventArgs $args)\n    {\n        $article = $args->getEntity();\n\n        if (!$article instanceof Article) {\n            return;\n        }\n\n        $this->execute($article);\n    }\n}\n```\n\nqui fait appel à la *Strategy* suivante (sans intérêt fonctionnel je vous l'accorde, mais je vous laisse imaginer le service qui répondra à vos besoins et fera appel à différents Web Services ou base de données pour trouver le prix unitaire de notre article) :\n\n```php\n<?php\n\nnamespace Cheric\\ExampleBundle\\Strategy;\n\nuse Doctrine\\Bundle\\DoctrineBundle\\Registry;\nuse Cheric\\ExampleBundle\\Entity\\Article;\n\n/**\n * Useless strategy that sets the price to 42.\n * We can easily imagine another strategy\n * that gets this price from the database.\n */\nclass PriceStrategy\n{\n    private $doctrine;\n\n    public function __construct(Registry $doctrine)\n    {\n        $this->doctrine = $doctrine;\n    }\n\n    public function execute(Article $article)\n    {\n        $article->setPrice(42);\n\n        $this->doctrine->getManager()->flush($article);\n    }\n}\n```\n\nEt vous voudriez ensuite tester cela fonctionnellement :\n\n```php\n<?php\n\nnamespace Cheric\\ExampleBundle\\Tests\\Controller;\n\nuse Cheric\\ExampleBundle\\Test\\IsolatedWebTestCase;\n\nclass ArticleControllerTest extends IsolatedWebTestCase\n{\n    public function testCreate()\n    {\n        $this->client->connect('admin');\n        $this->client->request('POST', '/secured/article', array('quantity' => 42));\n\n        $responseContent = $this->client->getResponse()->getContent();\n        $this->assertEquals(200, $this->client->getResponse()->getStatusCode());\n        $this->assertNotEmpty($responseContent);\n\n        $em = $this->client->getContainer()->get('doctrine')->getManager();\n\n        $article = $em->getRepository('ChericExampleBundle:Article')->find($responseContent);\n        $this->assertEquals(42, $article->getQuantity());\n        $this->assertEquals(42, $article->getPrice());\n    }\n\n    public function testUpdate()\n    {\n        $em = $this->client->getContainer()->get('doctrine')->getManager();\n\n        $article = $em->getRepository('ChericExampleBundle:Article')->find(1);\n        $this->assertEquals(1, $article->getQuantity());\n        $this->assertEquals(1, $article->getPrice());\n\n        $this->client->connect('admin');\n        $this->client->request('PUT', '/secured/article/1', array('quantity' => 42));\n        $this->assertEquals(200, $this->client->getResponse()->getStatusCode());\n\n        $em->refresh($article);\n        $this->assertEquals(42, $article->getQuantity());\n        $this->assertEquals(42, $article->getPrice());\n    }\n}\n```\n\nCe test fonctionnel vérifie simplement que les données postées (quantity = 42) sont bien settées dans l'entité par le [controller](https://github.com/ch3ric/BlogTestsIsolation/blob/master/src/Cheric/ExampleBundle/Controller/ArticleController.php \"ArticleController\"){:rel=\"nofollow noreferrer\"}, et que le prix est ensuite renseigné lors du passage dans notre *ArticleListener* avant la sauvegarde en base de données.\n\nEt là, surprise lors de l’exécution de PHPUnit :\n\n```sh\nFailed asserting that 500 matches expected 200.\n```\n\nassociée à l'erreur `InvalidArgumentException: Entity has to be managed or scheduled for removal for single computation` visible dans les logs...\n\nEt pourtant si l'on exécute ce code, sans utiliser nos tests fonctionnels, via de simples appels curl par exemple (1 premier pour se logguer et un deuxième en POST ou PUT pour mettre à jour notre entité, en utilisant le token d'authentification retourné lors du login), on constate que cela fonctionne très bien : l'entité est bien modifiée ou créée en base de données.\n\nLe problème vient donc de notre façon de tester, et très probablement de la façon d'isoler les tests.\n\n**La solution :**\n\nEn analysant notre *IsolatedWebTestCase* et notre *Test Client*, on constate que la *DBAL Connection* initialisée lors de la première requête de login est ensuite réutilisée dans la requête de l'action suivante, dans la méthode *startIsolation*. Ce premier indice permet de dire que la *Connection* initialisée lors de la première requête ne sait pas gérer correctement ce qui lui est demandé lors de la deuxième requête.\n\nDeuxième indice : la stack trace de l'exception dit que l'erreur est levée lors de l'appel `$this->doctrine->getManager()->flush($article);` dans notre *PriceStrategy*, déclenché par notre *ArticleListener*. Autrement dit, l'instance du *Doctrine Registry* injectée dans la *PriceStrategy* et l'*Entity Manager* lié n'ont pas connaissance de l'état de l'entité Article qu'ils doivent flusher : \"*Entity has to be managed*\".\n\nDe plus, en regardant d'un peu plus près la [DBAL Connection de Doctrine](Doctrine\\DBAL\\Connection \"https://github.com/doctrine/dbal/blob/master/lib/Doctrine/DBAL/Connection.php#L107\"), on remarque une propriété [EventManager](https://github.com/doctrine/common/blob/master/lib/Doctrine/Common/EventManager.php \"Doctrine\\Common\\EventManager\"){:rel=\"nofollow noreferrer\"} qui gère les *Events* et *Listeners* Doctrine, dont notre *ArticleListener*.\n\nFinalement, on en déduit que l'*Event Manager* de la *DBAL Connection* de notre deuxième requête doit être conservé tel quel, pour gérer correctement l'enregistrement de l'entité après passage dans le listener. Pour permettre le rollback et l'isolation de nos tests, on ne souhaite conserver que l'état de la *Connection*, qui a lancé la requête SQL \"*START TRANSACTION\"*, sans pour autant conserver l'*Event Manager* de la première requête, qui semble poser problème.\n\nLa [solution](https://github.com/ch3ric/BlogTestsIsolation/commit/2038a61e723f3091b7dd935cf3da9f3cc57651e1 \"Commit Solution\"){:rel=\"nofollow noreferrer\"} consiste donc simplement à setter le bon *Event Manager* dans la *Connection* conservée entre chaque requête de test, lors de l'appel à la méthode *startIsolation*. Cela passe par une extension de la classe *DBAL Connection* dans laquelle on ajoute un setter *setEventManager* :\n\n```php\n<?php\n\nnamespace Cheric\\ExampleBundle\\Doctrine\\DBAL;\n\nuse Doctrine\\DBAL\\Connection as BaseConnection;\nuse Doctrine\\Common\\EventManager;\n\n/**\n * Extends Doctrine DBAL connection\n * to add the ability to change the event manager.\n * Used for tests only.\n */\nclass Connection extends BaseConnection\n{\n    /**\n     * @param EventManager $eventManager\n     */\n    public function setEventManager(EventManager $eventManager)\n    {\n        $this->_eventManager = $eventManager;\n        $this->_platform->setEventManager($eventManager);\n    }\n}\n```\n\nEt dans notre *Test Client*, on set le bon *EventManager* dans la *Connection* conservée entre chaque test :\n\n```php\n<?php\n\nnamespace Cheric\\ExampleBundle\\Test;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Client as BaseClient;\n\nclass Client extends BaseClient\n{\n    // ...\n\n    public function startIsolation()\n    {\n        if (null === $this->connection) {\n            $this->connection = $this->getContainer()->get('doctrine.dbal.default_connection');\n        } else {\n            $this->connection->setEventManager(\n                $this->getContainer()->get('doctrine.dbal.default_connection')->getEventManager()\n            );\n            $this->getContainer()->set('doctrine.dbal.default_connection', $this->connection);\n        }\n\n        if (false === $this->requested) {\n            $this->connection->beginTransaction();\n        }\n    }\n\n    // ...\n}\n```\n\nVoir commit complet [ici : sur github](https://github.com/ch3ric/BlogTestsIsolation/commit/2038a61e723f3091b7dd935cf3da9f3cc57651e1#diff-d618fa2c315d1d7b933528805e889d00R55 \"Commit Solution\"){:rel=\"nofollow noreferrer\"}.\n\nLe code complet permettant l'analyse de ce problème d'isolation et la solution sont disponibles ici : [github.com/ch3ric/BlogTestsIsolation](https://github.com/ch3ric/BlogTestsIsolation \"github.com/ch3ric/BlogTestsIsolation\"){:rel=\"nofollow noreferrer\"}\n\nJe ne pense pas être le seul à avoir rencontré ce problème avec les tests de listeners Doctrine et j'espère donc que cette astuce pourra vous permettre de tester fonctionnellement vos listeners plus proprement.\n\nIntergalactiquement vôtre et à bientôt !!\n\nNB : je me suis concentré ici sur la recherche d'une solution à mon problème d'isolation bien précis, sans pour autant pousser l'analyse du comportement de Doctrine et plus spécifiquement de son *Event Manager*. Si certains ont fait cette analyse, je suis intéressé :) !\n"}