{"date":"2017-12-21T00:00:00.000Z","title":"Pour Noël, je remplace mon ERP par un Slack bot implémenté avec DialogFlow et Symfony","excerpt":"Le but de cet article est de montrer la puissance d'un Slack bot pour simplifier la vie en entreprise, et comment le mettre en place avec DialogFlow et Symfony","readingTime":"23mn","authors":["charles-eric"],"categories":["php"],"content":"\nJe suis sûr que vous rencontrez tous cette problématique : vous êtes obligés d'utiliser les outils ERP de votre entreprise pour faire vos demandes de congés, faire vos comptes-rendus d'activité, vos notes de frais, etc... Et avouez le, ça vous emm$#de ! Pourquoi ? Car ces outils ne sont pas ergonomiques, pas compatibles sur mobile...\n\nNous avons pourtant une infinité de possibilités de simplifications, si on fait preuve d'un peu d'imagination :) !\n\nJe vais vous présenter dans cet article une de ces idées qui me permet de simplifier le process de demande de congés.\n\n\n## Notre Contexte\n\nVoilà plus d'éléments sur notre process.\n\n### Le process existant à améliorer\n\n1. L'astronaute envoie une demande par email à son manager Eleven Labs en indiquant les dates de début et fin des congés.\n2. Si cette demande est validée, il faut également faire une demande par email au client.\n3. Puis une fois validée également, il faut créer un event dans le Google calendar partagé pour donner de la visibilité à toute l'équipe.\n4. Puis, il faut faire apparaître cette période de congés dans l'ERP interne pour la comptabilité.\n\n### Comment simplifier ce process ?\n\nSi on prend un peu de recul sur le process existant, on se rend compte que l'objectif est d'une part d'obtenir une validation, puis communiquer à tous les dates d'absences à venir. Mais en réalité, l'étape de validation n'est pas très utile car les congés sont quasiment systématiquement validés.\n\nIl suffirait donc d'envoyer les dates de congés dans un outils qui communiquerait ensuite à tous, en considérant que la demande est validée par défaut.\nOn pourrait gérer les cas de refus de congés manuellement en parallèle, si ça arrivait.\n\n> Quel est l'outil de communication interne le plus ergonomique ? Slack bien sûr !\n\nL'idée serait donc de mettre en place un **bot Slack** qui :\n\n1. Permettrait à chacun de faire ces demandes de congés.\n2. Puis ce bot serait responsable d'envoyer les notifications à tout le monde dans Slack ou par email : manager, équipe et client.\n3. Il pourrait également faire appel à l'API Google Calendar pour ajouter un event dans l'agenda.\n4. Et idéalement, faire un appel à l'API de l'ERP utilisé pour la comptabilité.\n\nSi une validation est vraiment nécessaire, on pourrait aussi imaginer que ce bot enverrait des demandes de validation, soit par Slack en utilisant les [interactive message buttons](https://api.slack.com/docs/message-buttons), soit par email avec un lien de validation.\n\n### Ce que nous allons implémenter\n\nVous l'avez compris, les possibilités sont multiples, mais concentrons nous ici sur le point *1.* ci-dessus uniquement, le plus intéressant.\n\nPour mettre en place cette première étape du process, nous avons allons donc :\n\n- Créer un **bot Slack** et le rendre accessible sur notre Workspace pour que tous les utilisateurs puissent lui envoyer des messages privés.\n- Mettre en place un agent **DialogFlow** : outil Google, anciennement appelé API.AI, déjà décrit sur notre [blog ici](/fr/dialogflow-votre-chatbot-facile/). Celui-ci va nous permettre de comprendre, grâce au *machine learning*, les messages envoyés au bot par les utilisateurs, ce qui est loin d'être simple sans ce type d'outils !\n- Mettre en place une application **Symfony** exposant un **webhook** qui sera appelé par le serveur Slack à chaque fois qu'un message privé est envoyé à notre bot. C'est depuis cette application que nous allons ensuite appeler DialogFlow pour interpréter le message Slack reçu, puis répondre à l'astronaute, et enfin enregistrer la demande de congés.\n\n\n## Notre bot Slack\n\nCommençons par la mise en place du bot Slack.\n\n### Créer une application Slack\n\nIl faut tout d'abord créer une app Slack.\n\nConnectez vous donc à votre compte Slack relié à votre Workspace d'entreprise. Puis allez sur [https://api.slack.com/apps](https://api.slack.com/apps) et cliquez sur \"Create New App\".\n\n[![Create Slack App]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_create_app.png)]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_create_app.png){: .center-image .no-link-style}\n\nPuis à vous de compléter les informations de votre app comme bon vous semble : nom, description, couleur et icône.\n\nVous pourrez ensuite accéder aux configurations suivantes depuis cet écran de \"Basic Information\" :\n\n[![Slack App Basic Information]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_basic_info.png)]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_basic_info.png){: .center-image .no-link-style}\n\n### Créer un bot\n\nIl faut maintenant créer un utilisateur bot relié à cette app. Pour cela, rendez vous dans le menu de gauche \"Bot Users\" ou depuis les \"Basic Information\" > \"Add features and functionality\" > \"Bots\".\n\n[![Slack Bot]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_bot.png)]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_bot.png){: .center-image .no-link-style}\n\nIl suffit ici de nommer le bot et de le rendre visible \"online\".\n\n### Activer les events\n\nEnsuite allez dans le menu \"Event Subscriptions\", saisissez l'**URL de votre futur webhook** Symfony que nous implémenterons dans la dernière partie. Notez que tant que le webhook n'est pas créé et accessible par Slack, ce dernier ne pourra pas le vérifier et l'enregistrer, il faudra donc revenir plus tard à cette étape quand le webhook sera prêt.\n\nIl faut également sélectionner l'event \"**message.im**\" pour signifier à Slack d'appeler le webhook précédent à chaque fois qu'un message privé est envoyé à notre bot.\n\n[![Slack Event Subscriptions]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_event_subscription.png)]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_event_subscription.png){: .center-image .no-link-style}\n\nLes appels faits vers ce webhook devront être sécurisés à l'aide d'un token qui sera utilisé dans la dernière partie : veuillez donc noter la valeur du \"**Verification Token**\" affichée sur la page \"Basic Information\".\n\n### Configurer les permissions OAuth\n\nVous vous en doutez, les accès aux données Slack sont protégés. Il faut donc configurer notre bot pour que celui-ci ait accès à certains **scopes** de données avec son **access token**.\n\nCela se passe dans la partie \"**OAuth & Permissions**\".\n\nTout d'abord, vous pouvez noter la valeur d'\"**OAuth Access Token**\" qui apparaît sur cette page et que nous utiliserons plus tard.\n\nEnsuite, voilà les scopes dont vous aurez forcément besoin, et donc à ajouter sur cette même page :\n- \"**chat:write:bot**\" (ou \"chat:write:user\" suivant le token que vous utilisez) qui permettra d'envoyer un message privé sur Slack, pour répondre à l'astronaute.\n- \"**users:read**\" et \"**users:read.email**\" pour accéder aux informations de profil de l'utilisateur qui nous envoie un message.\n\nPas forcément besoin d'ajouter plus de scopes pour le moment, et vous verrez avec l'expérience que Slack vous indique bien les scopes à autoriser si nécessaire quand vous appelez une méthode de l'API non autorisée.\n\n## Notre agent DialogFlow\n\nMaintenant que notre bot Slack est prêt, nous avons besoin de configurer un agent DialogFlow pour qu'il nous aide à comprendre les messages envoyés par les utilisateurs.\n\n### Créer un agent\n\nCréez donc un compte, si vous n'en avez pas déjà un, et connectez vous sur la [console DialogFlow](https://console.dialogflow.com).\nPuis créez un nouvel **agent** (bouton \"Create New Agent\") et sélectionnez la langue par défaut **fr**.\n\n### Configurer les intents\n\nLes \"intents\" correspondent aux types de messages de l'utilisateur que nous avons envie de comprendre. Nous allons en configurer trois dans le cadre de cet article :\n\n[![DialogFlow intents]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/dialogflow_intents.png)]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/dialogflow_intents.png){: .center-image .no-link-style}\n\n#### 1. Premier intent, le plus intéressant que nous appelons \"**Demande de congés avec dates de début et de fin**\" :\n\nNous allons lister dans la partie \"**User says**\" un maximum d'inputs utilisateurs qui pourraient être envoyés par les astronautes qui font leur demande de congés.\n\n[![DialogFlow intent dates input]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/dialogflow_intent_dates_input.png)]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/dialogflow_intent_dates_input.png){: .center-image .no-link-style}\n\nPour chacun de ces inputs, nous sélectionnons les passages les plus intéressants, en jaune et orange sur l'image ci-dessus. Ces passages correspondent aux dates de congés qu'on doit reconnaître puis enregistrer.\n\nCes sélections sont associées à des paramètres que nous nommerons \"**startDate**\" et \"**endDate**\" et que nous typons en tant que \"**@sys.date**\" pour que Google reconnaisse automatiquement ces dates.\n\nEnfin, nous pouvons configurer les réponses qui seront renvoyées par DialogFlow quand on lui enverra un message de ce type, s'il le reconnaît :\n\n[![DialogFlow intent dates output]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/dialogflow_intent_dates_output.png)]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/dialogflow_intent_dates_output.png){: .center-image .no-link-style}\n\nNous avons deux types de réponses :\n- les textes que nous utiliserons pour répondre à l'astronaute sur Slack.\n- le \"**Custom Payload**\" qui nous permettra de retourner les valeurs des paramètres \"startDate\" et \"endDate\" qui seront reconnus par Google.\n\n#### 2. L'intent \"**Bonjour**\"\n\nQuant à lui, il nous permettra de répondre poliment à l'astronaute qui nous dit bonjour. Mais pas de paramètre à configurer pour celui-ci.\n\n#### 3. Et enfin, l'intent \"**Fallback**\"\n\nIl nous permet de configurer des messages par défaut, quand le message de l'utilisateur n'est pas reconnu par les précédent intents.\n\n\n## Notre application Symfony\n\nTout le code de l'application Symfony qui permet de communiquer avec Slack et DialogFlow est sur [mon Github ici](https://github.com/ch3ric/WilsonPlanning/tree/master/src/AppBundle). Je vais détailler ici uniquement les parties les plus importantes.\n\n> Je vous recommande d'utiliser les options \"autoconfigure\" et \"autowiring\" pour gérer vos injections de dépendances en toute simplicité : voir [app/config/services.yml](https://github.com/ch3ric/WilsonPlanning/blob/master/app/config/services.yml).\n\n### Créer le Controller pour le webhook Slack\n\nTout d'abord, il faut créer l'action avec une route qui doit correspondre à ce qui a été configuré dans la partie \"Event Subscriptions\" de l'app Slack.\n\nPour que Slack vérifie ce webhook, il faut non seulement vérifier le \"**Verification Token**\" envoyé dans la requête de Slack mais également retourner le \"challenge\" envoyé par Slack en cas de requête de type \"**url_verification**\".\n\nVoilà donc le code à utiliser :\n\n```php\n<?php\n// src/AppBundle/Action/Webhook/SlackAction.php\n\nnamespace AppBundle\\Action\\Webhook;\n\n// use statements...\n\nfinal class SlackAction\n{\n    // private properties and __construct...\n\n    /**\n     * @Route(\"/api/webhook/slack\", defaults={\"_format\": \"json\"})\n     * @Method(\"POST\")\n     */\n    public function __invoke(Request $request): Response\n    {\n        $content = json_decode($request->getContent(), true);\n\n        // check \"Verification Token\"\n        if (!isset($content['token']) || $content['token'] !== $this->slackWebhookToken) {\n            throw new AccessDeniedHttpException('No token given or token is wrong.');\n        }\n\n        // return \"challenge\" to allow Slack to verify this route\n        if (isset($content['type']) && $content['type'] === 'url_verification') {\n            return new JsonResponse(['challenge' => $content['challenge']]);\n        }\n\n        // $content -> valid content\n        // call other services from here.\n\n        return new Response('', 204);\n    }\n}\n```\n\n### Parser le contenu de la requête Slack\n\nEnsuite, nous récupérons le \"content\" de la requête qui a cette forme :\n\n```json\n{\n    ...\n    \"event\": {\n        \"type\": \"message\",\n        \"text\": \"Je veux poser des congés entre le 5 décembre et le 6 janvier\",\n        \"user\": \"XXXXXX\",\n        \"channel\": \"ZZZZZZ\"\n    },\n    ...\n}\n```\n\nNous pouvons donc utiliser un service pour extraire les données qui nous intéressent :\n- le texte du message, à condition que ce message soit de type \"message\"\n- l'ID de l'utilisateur: \"user\"\n- l'ID de la conversation privée entre l'utilisateur et le bot: \"channel\"\n\nVoir [src/AppBundle/Slack/WebhookParser.php](https://github.com/ch3ric/WilsonPlanning/blob/master/src/AppBundle/Slack/WebhookParser.php) pour plus de détails.\n\n### Appeler l'API Slack pour récupérer les informations de l'utilisateur\n\nNous avons besoin des informations de l'astronaute qui a envoyé le message Slack pour être capable de créer un `Member` dans notre application Symfony, qui sera relié à notre demande de congés.\n\nPour cela, nous allons appeler la méthode \"**users.info**\" de l'API Slack. Pour plus de détails, voir la [doc de cette API ici](https://api.slack.com/methods).\n\nIl nous faut donc un client **Guzzle** pour appeler l'API Slack :\n\n```php\n// src/AppBundle/Slack/Client.php\n\nnamespace AppBundle\\Slack;\n\n// use statements...\n\nclass Client\n{\n    private $client; // GuzzleHttp\\ClientInterface\n    private $baseUri; // https://slack.com/api/\n    private $token; // 'OAuth Access Token' from 'OAuth & Permissions' > 'Tokens for Your Workspace' on https://api.slack.com/apps\n\n    // __construct...\n\n    public function getUser(string $userId): array\n    {\n        $options = [\n            'user' => $userId,\n        ];\n        return $this->get('users.info', $options);\n    }\n\n    private function get(string $uri, array $options): array\n    {\n        $options['query'] = array_merge(\n            ['token' => $this->token],\n            $options\n        );\n\n        return $this->handleResponse(\n            $this->client->get($this->baseUri . $uri, $options)\n        );\n    }\n\n    private function handleResponse(ResponseInterface $response): array\n    {\n        $data = json_decode($response->getBody()->getContents(), true);\n\n        if (JSON_ERROR_NONE !== json_last_error()) {\n            throw new \\RuntimeException(\"Can't get Slack response\");\n        }\n        if (!isset($data['ok']) || true !== $data['ok']) {\n            throw new \\RuntimeException('Got error from Slack');\n        }\n\n        return $data;\n    }\n}\n```\n\nNous pouvons ainsi utiliser la méthode `get` de ce service en lui passant le user ID récupéré dans le \"content\" précédent. En retour, nous obtenons :\n\n```json\n{\n    \"user\": {\n        \"name\": \"Charles-Eric Gorron\",\n        ...\n        \"profile\": {\n            ...\n            \"email\": \"cgorron@eleven-labs.com\"\n        }\n    }\n}\n```\n\nEnsuite nous utilisons un autre service [src/AppBundle/Service/MemberHandler.php](https://github.com/ch3ric/WilsonPlanning/blob/master/src/AppBundle/Service/MemberHandler.php) pour créer une instance de `Member` avec ce nom et cet email, si elle n'existe pas déjà dans notre base de données.\n\n### Appeler l'API DialogFlow\n\nMaintenant que nous avons le texte du message Slack ainsi que les données de l'utilisateur qui nous l'a envoyé, nous devons appeler DialogFlow via l'API \"**query**\" pour que celle-ci nous retourne la réponse à renvoyer à l'astronaute, ainsi que les valeurs de \"startDate\" et \"endDate\" qui nous intéressent.\n\nLà encore nous utilisons un client Guzzle pour appeler cette API :\n\n```php\n// src/AppBundle/DialogFlow/Client.php\n<?php\n\nnamespace AppBundle\\DialogFlow;\n\n// use statements...\n\nclass Client\n{\n    private $client; // GuzzleHttp\\ClientInterface\n    private $baseUri; // https://api.dialogflow.com/v1/\n    private $token; // 'Client access token' from agent settings > 'General' tab > 'API KEYS (V1)' on https://console.dialogflow.com\n\n    // __construct...\n\n    public function query(string $message, string $sessionId): array\n    {\n        $options = [\n            'query' => [\n                'query' => $message,\n                'sessionId' => $sessionId,\n                'lang' => 'fr',\n                'v' => '20170712',\n            ],\n        ];\n\n        return $this->handleResponse(\n            $this->call('query', $options)\n        );\n    }\n\n    private function call(string $method, array $options): ResponseInterface\n    {\n        $options = array_merge(\n            ['headers' => ['Authorization' => 'Bearer ' . $this->token]],\n            $options\n        );\n\n        return $this->client->get($this->baseUri . $method, $options);\n    }\n\n    private function handleResponse(ResponseInterface $response): array\n    {\n        $data = json_decode($response->getBody()->getContents(), true);\n\n        if (JSON_ERROR_NONE !== json_last_error()) {\n            throw new \\RuntimeException(\"Can't get DialogFlow response\");\n        }\n\n        return $data;\n    }\n}\n```\n\n- Le paramètre \"query\" doit être le texte du message envoyé par l'utilisateur.\n- Le paramètre \"sessionId\" correspond à une session d'utilisation de DialogFlow. Pour simplifier, j'envoie l'ID de l'utilisateur pour ce paramètre : chaque utilisateur a donc une seule session d'utilisation de DialogFlow.\n- Les paramètres \"lang\" et \"v\" sont également obligatoires. Plus de détails dans la [doc ici](https://dialogflow.com/docs/reference/agent/query).\n\n### Parser la réponse de DialogFlow\n\nCette réponse est sous cette forme :\n\n```json\n\"result\": {\n    ...\n    \"fulfillment\": {\n        ...\n        \"speech\": \"OK, c'est noté !\",\n        \"messages\": [\n            {\n                \"type\": 4,\n                \"payload\": {\n                    \"startDate\": \"2018-01-06\",\n                    \"endDate\": \"2018-03-10\"\n                }\n            },\n            ...\n        ]\n    }\n}\n```\n\nAinsi nous utilisons un service [src/AppBundle/DialogFlow/Parser.php](https://github.com/ch3ric/WilsonPlanning/blob/master/src/AppBundle/DialogFlow/Parser.php) pour extraire les informations intéressantes de cette réponse :\n\n- \"**speech**\" qui est une des réponses textes, configurées sur DialogFlow, qu'on va pouvoir renvoyer à l'utilisateur.\n- les \"startDate\" et \"endDate\" de notre \"**payload**\".\n\n### Envoyer une réponse privée à l'utilisateur via Slack\n\nPour cela, on peut ajouter une méthode dans notre service Client Slack pour appeler \"**chat.postMessage**\" :\n\n```php\n// src/AppBundle/Slack/Client.php\n\n...\n\n    public function postMessage(string $message, string $channel)\n    {\n        $payload = [\n            'text' => $message,\n            'channel' => $channel,\n            'username' => 'wilson-planning',\n        ];\n\n        $response = $this->client->post(\n            $this->baseUri . 'chat.postMessage',\n            [\n                'headers' => [\n                    'Authorization' => 'Bearer ' . $this->token,\n                    'Content-Type' => 'application/json',\n                ],\n                'body' => json_encode($payload, JSON_UNESCAPED_UNICODE),\n            ]\n        );\n\n        return $this->handleResponse($response);\n    }\n\n...\n\n```\n\nOn donne en entrée ces arguments :\n\n- \"message\" : réponse \"speech\" de DialogFlow.\n- \"channel\" : ID de la conversation privée Slack entre l'utilisateur et le bot, tel que retourné dans la première requête Slack.\n\nLe \"token\" à utiliser est le même que celui qu'on a envoyé lors de la requête `GET` qui récupère les informations de l'utilisateur.\n\n### Enregistrer la période de congés en base de données\n\nOn a bien récupéré précédemment les informations de l'utilisateur qui nous ont permis de créer un `Member`, et on a aussi les \"startDate\" et \"endDate\" retournées par DialogFlow. Il ne nous reste donc qu'à créer une instance de `Vacation` et l'enregistrer en base de données.\n\nVoir [src/AppBundle/Service/VacationHandler.php](https://github.com/ch3ric/WilsonPlanning/blob/master/src/AppBundle/Service/VacationHandler.php) pour plus de détails.\n\n### Appeler tous les services précédents\n\nIl faut maintenant brancher tous ces services ensemble, ce qui est très simple puisque nous avons configuré nos services en \"autowiring\" : il suffit donc d'injecter les services au bon endroit dans le constructeur. Finalement voilà à quoi ressemble notre action de controller :\n\n```php\n<?php\n// src/AppBundle/Action/Webhook/SlackAction.php\n\nnamespace AppBundle\\Action\\Webhook;\n\n// use statements...\n\nfinal class SlackAction\n{\n    // private properties and __construct...\n\n    /**\n     * @Route(\"/api/webhook/slack\", defaults={\"_format\": \"json\"})\n     * @Method(\"POST\")\n     */\n    public function __invoke(Request $request): Response\n    {\n        // get $content from request, check 'token', verify 'challenge'...\n\n        try {\n            $userSlackId = $this->slackWebhookParser->getSenderId($content);\n            $member = $this->memberHandler->getOrCreateFromSlackId($userSlackId);\n\n            $dialogFlowResponse = $this->dialogFlowClient->query(\n                $this->slackWebhookParser->getMessage($content),\n                $userSlackId\n            );\n\n            $slackResponse = $this->slackClient->postMessage(\n                $this->dialogFlowParser->getSpeech($dialogFlowResponse),\n                $this->slackWebhookParser->getChannel($content)\n            );\n\n            $vacationDates = $this->dialogFlowParser->getMessageCustomPayload($dialogFlowResponse);\n            $this->vacationHandler->create($vacationDates['startDate'], $vacationDates['endDate'], $member);\n\n        } catch (\\InvalidArgumentException $e) {\n            $this->logger->warning(\n                'Response not supported from Slack or DialogFlow: {exception}',\n                ['exception' => $e]\n            );\n        }\n\n        return new Response('', 204);\n    }\n}\n```\n\n**Point d'attention** : il faut bien prévoir tous les types de messages qu'on peut possiblement recevoir de Slack ou DialogFlow et éviter à tout prix les erreurs.\nVoilà pourquoi je catch ici les `\\InvalidArgumentException` retournées par mes parsers.\nSi votre webhook retourne un code d'**erreur HTTP**, Slack **rappellera plusieurs fois votre webhook**, jusqu'à obtenir une réponse avec un code 20X. Cela peut avoir des conséquences surprenantes : si l'erreur intervient à la dernière étape de votre controller, après le POST vers Slack, vous pourriez spammer la conversation privée de l'utilisateur en lui renvoyant un nouveau message à chaque fois que Slack rappelle le webhook en erreur !\n\n> Bien sûr, pour respecter les bonnes pratiques, il faudrait aussi déplacer toute la logique métier de ce controller vers un service dédié.\n\n## Notre résultat final\n\n**Démonstration** : voici un extrait d'une conversation Slack avec notre bot :\n\n[![Démonstration]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_demo1.png)]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_demo1.png){: .center-image .no-link-style}\n\nEt voilà le résultat enregistré en base de données :\n\n[![Résultats en base de données]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_demo2.png)]({{site.baseurl}}/assets/2017-12-21-remplacer-erp-par-slack-bot-avec-dialogflow-et-symfony/slack_demo2.png){: .center-image .no-link-style}\n\nOn remarque notre ami Google a bien su reconnaître les dates écrites en français et nous a permis d'enregistrer des dates au format \"datetime\" en base de données, merci à lui !\n\n\n## Conclusion\n\nJe m'arrête ici pour cette fois, même si comme mentionné en première partie de cet article, il y aurait encore beaucoup à faire pour automatiser totalement ce process et ne plus jamais avoir besoin d'utiliser nos vieux ERPs : appels vers les API des calendars, utilisation des boutons Slack pour la validation, envoi de notifications Slack à tous les membres de la même équipe, ou même calcul automatique de la capacité du Sprint de l'équipe impactée par cette nouvelle demande de congés !\n\nVous noterez que j'ai utilisé [API Platform](/fr/creer-une-api-avec-api-platform/) sur mon [projet Github](https://github.com/ch3ric/WilsonPlanning), alors qu'il n'a aucun intérêt pour cet article en particulier : car j'ai encore beaucoup d'idées en tête à implémenter pour interagir avec d'autres systèmes qui pourraient appeler cette API.\n\nJe vous tiendrai au courant des prochaines évolutions de cet outil si ça vous intéresse :P !\nFaites moi savoir en commentaire si vous avez d'autres idées d'optimisations !\n"}