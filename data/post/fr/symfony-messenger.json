{"date":"2018-09-18T00:00:00.000Z","title":"Symfony Messenger","excerpt":"Nous allons voir comment utiliser le nouveau composant Messenger de Symfony","readingTime":"6mn","authors":["amoutte"],"categories":["php"],"content":"\n## Présentation générale\n\nLe composant messenger nous apporte un message bus. Un message bus est un composant très simple qui permet de dispatcher un objet (message). Le bus a pour rôle d'exécuter le handler approprié au message. Durant ce processus le message va passer dans une pile ordonnée de middleware.\n\nLes middlewares sont encapsulés les uns sur les autres autours du handler.\n\nExemple simplifier\n```php\n<?php\n$handler = function ($value) {\n    // Le code métier à exécuter\n    return $value;\n};\n\n// ce middleware va encapsuler la réponse du middleware suivant avec du texte\n$wrappingMiddleware = function (callable $handler) {\n    return function ($string) use ($handler) {\n        return 'before > ' . $handler('-' . $string . '-') . ' < after';\n    };\n};\n\n// ce middleware va logguer dans un fichier les différentes exécutions de la stack d'exécution\n$loggingMiddleware = function (callable $handler) {\n    return function ($string) use ($handler) {\n        $result = $handler($string);\n        file_put_contents('dev.log', sprintf('Info: Input \"%s\" with output \"%s\".', $string, $result));\n\n        return $result;\n    };\n};\n\n// on encapsule les middlewares les uns sur les autres autour du handler\n$middlewareStack = $loggingMiddleware(\n        $wrappingMiddleware(\n            $handler\n        )\n    );\n\n// on exécute la stack de middleware ainsi que le handler\necho $middlewareStack('example string');\n// will show \"before > -example string- < after\"\n// le middleware logging aura quand à lui écrit \"Info: Input \"example string\" with output \"before > -example string- < after\"\" dans le fichier dev.log.\n```\n\nLes middlewares permettent d'ajouter un traitement avant ou après l'exécution du handler (ou du middleware suivant), c'est pourquoi l'ordre des middlewares est très important.\n\nDans le composant Messenger de symfony il existe 2 cas d'utilisation standard :\n- Envoi de message (sender)\n- Réception de message (receiver)\n\n## Envoi de message\n\nUn message est envoyé depuis le système vers une destination. Par exemple cette destination peut être un message broker ou un endpoint API.\n\nVous pourriez creer un Handler qui envoie le message à votre destination mais symfony met à disposition un `SendMessageMiddleware`.\n\nVous n'aurez donc qu'à configurer le routage des objets vers le transport souhaité :\n\n```yaml\nframework:\n    messenger:\n        transports:\n            amqp: '%env(MESSENGER_TRANSPORT_DSN)%'\n\n        routing:\n             'App\\MyModel': amqp\n```\n\nReportez-vous à la [documentation](https://symfony.com/doc/current/messenger.html#routing) pour les différentes syntaxes possibles.\n\n## Réception de message\n\nUn message entre dans le système de manière synchrone (endpoint API/controlleur) ou asynchrone (via worker/queue).\nLe message reçu est donc encapsulé avec une enveloppe `ReceivedMessage` avant d'être dispatché dans le message bus.\n\n> L'enveloppe `ReceivedMessage` permet d'éviter au bus de renvoyer le message au sender (boucle infinie).\n\nPour traiter un message il faudra créer un handler avec une méthode `__invoke` (si vous avez déjà une méthode, utilisez l'attribut `handles` dans le tag de définition du service. Voir plus bas).\n\nPar exemple :\n\n```php\n<?php\n// src/MessageHandler/MyMessageHandler.php\nnamespace App\\MessageHandler;\n\nuse App\\MyModel;\n\nclass MyModelHandler\n{\n    public function __invoke(MyModel $message)\n    {\n        // do something with it.\n    }\n}\n```\n\net ensuite l'enregistrer dans symfony\n\n```yaml\n# config/services.yaml\nservices:\n    App\\MessageHandler\\MyModelHandler:\n        tags: [messenger.message_handler]\n```\n\nSi symfony n'arrive pas à deviner le type de message, vous pouvez utiliser la syntaxe complète afin de spécifier la méthode à appeler et ou le modèle supporté.\n```yaml\n# config/services.yaml\nservices:\n    App\\MessageHandler\\MyModelHandler:\n        tags:\n             - {name: 'messenger.message_handler', method: 'process', handles: 'App\\MyModel'}\n```\n\n## Consommer des messages\n\nLe composant met également à disposition une commande `bin/console messenger:consume-messages {TRANSPORT_NAME}` afin de lancer un worker qui va écouter/consulter le transport et dispatcher un message dans le bus.\nDans le cas du transport `amqp` le worker dispatchera chaque message de la queue du broker.\nMais il est tout à fait possible de récupérer les changements d'un résultat d'API.\n\n\nPar exemple :\n```php\n<?php\n\nnamespace App\\Receiver;\n\nuse Symfony\\Component\\Messenger\\Transport\\ReceiverInterface;\nuse Symfony\\Component\\Messenger\\Envelope;\n\nclass APIMeteoReceiver implements ReceiverInterface\n{\n    /**\n     * Last API result\n     */\n    private $result;\n    private $shouldStop;\n\n    public function receive(callable $handler): void\n    {\n        while (!$this->shouldStop) {\n            $result = file_get_contents(\"{URL d'une API de meteo}\");\n\n            // si le résultat est le même que le précédent on attend une seconde avant de recommencer\n            if ($this->result === $result) {\n                sleep(1);\n                continue;\n            }\n\n            $this->result = $result;\n\n            // Si la météo a changé on dispatche la nouvelle météo dans le bus\n            $handler(new Envelope($this->result));\n        }\n    }\n\n    public function stop(): void\n    {\n        $this->shouldStop = true;\n    }\n}\n```\n\nDans l'exemple précédent on ne dispatche que lorsque la météo change\n\n## Conclusion\n\nVoila un premier tour d'horizon du composant Messenger.\nBien que le concept du message bus soit assez simple, l'implémentation du composant ne l'est pas autant.\nEt étant donné que le composant est encore expérimental et que la documentation s'étoffe petit à petit c'est donc encore un composant mal connu et peu utilisé pour le moment.\nPar ailleurs le composant Messenger nous apporte plein d'outils et nous laisse un grand niveau de personnalisation.\nC'est pourquoi une bonne compréhension du concept et une bonne prise en main sont préférables pour une exploitation maximum du potentiel.\n\nSachez qu'il est également possible d'implémenter vos propres `Transport` `Middleware` `Sender` `Receiver`.\nVous avez en plus de cela la possibilité de créer plusieurs bus dans l'application afin de bien compartimenter votre logique.\n\n### Liens utiles\n\n- [Command Bus](https://matthiasnoback.nl/tags/command%20bus/)\n- [Simple Bus](http://simplebus.io/)\n- [Composant Messenger](https://symfony.com/doc/current/components/messenger.html)\n- [how to use messenger](https://symfony.com/doc/current/messenger.html)\n"}