{"date":"2016-10-19T00:00:00.000Z","title":"Mutation Testing – Vérifiez la qualité de vos tests unitaires","excerpt":"Vos tests unitaires sont-ils fiables ? Dans cet article nous allons voir comment s’en assurer","readingTime":"7mn","authors":["rgraillon"],"categories":["php"],"content":"\n## Les Tests Unitaires et la confiance\n\nCe n’est plus à démontrer : les tests unitaires sont incontournables dans le développement d’une application. Ils permettent de mettre en évidence d’éventuelles régressions apportées lors de modifications du code, et donc au développeur d’acquérir une certaine confiance à mettre le code en production : si les tests passent, c’est que tout fonctionne correctement.\n\nPour mesurer cette confiance, on utilise principalement comme métrique la couverture de code. Plus la couverture est grande (proche de 100%), moins il y a de chances qu’une régression passe entre les mailles du filet.\nMais attention ! Cette affirmation n’est que purement théorique !\n\n## Couverture vs Protection\n\nNous allons voir que dans certains cas la couverture de code n’est qu’un faux indicateur de protection.\nVoici un exemple simple :\n\n```php\n<?php\n\nclass Astronaut {}\n\nclass SpaceShip\n{\n    private $capacity;\n    public $astronauts = [];\n\n    public function __construct($capacity)\n    {\n        $this->capacity = $capacity;\n    }\n\n    public function addAstronaut(Astronaut $astronaut)\n    {\n        if (count($this->astronauts) < $this->capacity) {\n            $this->astronauts[] = $astronaut;\n        }\n    }\n}\n```\n\nIci notre classe `SpaceShip` a une méthode publique `addAstronaut` qui ajoute une instance de `Astronaut` uniquement si la capacité maximale n’est pas atteinte.\nVoyons un exemple de test unitaire associé :\n\n```php\n<?php\n\nclass SpaceShipTest extends \\PHPUnit_Framework_TestCase\n{\n    public function testAddAstronaut()\n    {\n        $spaceShip = new SpaceShip(1);\n\n        $spaceShip->addAstronaut(new Astronaut());\n\n        $this->assertCount(1, $spaceShip->astronauts);\n    }\n}\n```\n\nLe test vérifie ici que la méthode ajoute bien une entrée au tableau d’astronautes. En lançant les tests nous avons une couverture de 100% (même sans assertion nous aurions eu ce résultat).\nMais nous ne sommes pas protégés pour autant : que se passerait-il si la méthode `addAstronaut` changeait ?\nNotre test suffira-t-il à détecter une régression ?\n\n## Tests de Mutation\n\nPour détecter les failles dans vos tests unitaires, il existe une solution : **les tests de mutation**.\n\nLe principe est simple : altérer le code source pour vérifier que les tests associés échouent en conséquence.\nAfin d’y parvenir, voici les étapes nécessaires :\n\n- Lancer la suite de tests une première fois pour vérifier que tous les tests passent (il est inutile d’essayer de faire échouer un test qui échoue déjà !)\n- Relancer la suite en modifiant certaines parties du code testé.\n- Vérifier que les tests échouent lorsque le code testé a subi une mutation.\n- Recommencer autant de fois qu’il y a de mutations possibles.\nÉvidemment, pas la peine de faire tout ça à la main, il existe des frameworks qui vont s’en occuper pour nous.\n\nMais avant de voir ça de plus près, voici un peu de vocabulaire :\n\n- **Mutant** : Altération unitaire du code (ex: un `!==` remplacé par un `===`)\n- **Killed/Captured** : On dit qu’un mutant est tué si le test unitaire échoue (résultat positif)\n- **Escaped** : Un mutant s’échappe si le test unitaire n’échoue pas (résultat négatif)\n- **Uncovered** : Un mutant n’est pas couvert si aucun test ne couvre le code qui porte le mutant.\n\n## Mise en pratique avec Humbug\n\nIci nous utiliserons [Humbug](https://github.com/padraic/humbug){:rel=\"nofollow noreferrer\"}, un framework parmi d’autres qui permet de faire des tests de mutation en PHP.\n\nLorsque nous lançons Humbug avec notre exemple de tout à l’heure, nous obtenons :\n\n```bash\nhumbug\n...\nMutation Testing is commencing on 1 files...\n(.: killed, M: escaped, S: uncovered, E: fatal error, T: timed out)\n\nM.\n\n2 mutations were generated:\n       1 mutants were killed\n       0 mutants were not covered by tests\n       1 covered mutants were not detected\n       0 fatal errors were encountered\n       0 time outs were encountered\n\nMetrics:\n    Mutation Score Indicator (MSI): 50%\n    Mutation Code Coverage: 100%\n    Covered Code MSI: 50%\n```\n\nDiantre ! Un mutant nous a échappé ! Voyons dans le fichier de de log :\n\n```diff\n1) \\Humbug\\Mutator\\ConditionalBoundary\\LessThan\nDiff on \\SpaceShip::addAstronaut() in src/SpaceShip.php:\n--- Original\n+++ New\n@@ @@\n     {\n-        if (count($this->astronauts) < $this->capacity) {\n+        if (count($this->astronauts) <= $this->capacity) {\n             $this->astronauts[] = $astronaut;\n         }\n     }\n }\n```\n\nNos tests n’ont pas détecté le changement d’opérateur de comparaison. En effet, nous n’avons pas testé le cas où notre vaisseau spatial est plein. À présent, ajoutons un test pour couvrir ce use-case :\n\n```php\n<?php\n\nclass SpaceShipTest extends \\PHPUnit_Framework_TestCase\n{\n    public function testAddsAstronautWhenShipNotFull()\n    {\n        $spaceShip = new SpaceShip(1);\n\n        $spaceShip->addAstronaut(new Astronaut());\n\n        $this->assertCount(1, $spaceShip->astronauts);\n    }\n\n    public function testDoesNotAddAstronautWhenShipFull()\n    {\n        $spaceShip = new SpaceShip(0);\n\n        $spaceShip->addAstronaut(new Astronaut());\n\n        $this->assertCount(0, $spaceShip->astronauts);\n    }\n}\n```\n\nMaintenant relançons Humbug :\n\n```bash\nhumbug\n...\nMutation Testing is commencing on 1 files...\n(.: killed, M: escaped, S: uncovered, E: fatal error, T: timed out)\n\n..\n\n2 mutations were generated:\n       2 mutants were killed\n       0 mutants were not covered by tests\n       0 covered mutants were not detected\n       0 fatal errors were encountered\n       0 time outs were encountered\n\nMetrics:\n    Mutation Score Indicator (MSI): 100%\n    Mutation Code Coverage: 100%\n    Covered Code MSI: 100%\n```\n\nEt voilà, cette fois aucun mutant ne s’est échappé, notre suite de tests est vraiment efficace, ce bug éventuel n’arrivera jamais jusqu’à la production !\nEvidemment, l’exemple choisi ici est volontairement simple et n’est pas très évocateur, mais dans le code métier au cœur de votre application, vous avez certainement des use-case beaucoup plus sensibles.\n\nPour parvenir à ses fins, Humbug est capable de générer tout un éventail de mutations :\n\n- Remplacement d’opérateurs de comparaison (`>` par `>=`, `!==` par `===`, etc…)\n- Remplacement de constantes (`0` par `1`, `true` par `false`, etc…)\n- Remplacement des opérateurs logiques (`&&`, `||`, etc…)\n- Remplacement des opérateurs binaires (`&`, `|`, `%`, etc…)\n- Remplacement des valeurs de retour d’une fonction\nJe ne vais pas tout détailler ici, si vous voulez en savoir plus je vous invite à consulter la [page GitHub du projet](https://github.com/padraic/humbug){:rel=\"nofollow noreferrer\"}.\n\n## Conclusion\n\nLes tests de mutation sont un moyen simple et efficace de détecter la fiabilité des tests unitaires. La couverture de code n’est pas une métrique très fiable, un code peut être couvert à 100% sans une seule assertion !\nNous avons vu avec Humbug que nous pouvons automatiser ces tests, il devient alors possible de les greffer dans notre workflow d’intégration continue. Attention toutefois au temps d’exécution qui grandit de manière exponentielle lorsque la base de code grandit, on utilisera en priorité les tests de mutation là où il y a un véritable enjeu : le code métier.\n"}