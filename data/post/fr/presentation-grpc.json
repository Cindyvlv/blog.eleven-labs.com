{"date":"2017-09-28T00:00:00.000Z","title":"Présentation de gRPC","excerpt":"gRPC a été développé initialement par Google puis rendu open source. Il permet de réaliser des clients et serveurs rpc via HTTP/2 et donc de profiter de ses nouveautés.","readingTime":"5mn","authors":["qneyrat"],"categories":[],"content":"\nAvant toute chose je vous invite à lire [la première partie](https://blog.eleven-labs.com/fr/presentation-protocol-buffers/){:rel=\"nofollow noreferrer\"} si ce n'est pas déjà fait. L'article présente protobuf qui va être utilisé avec gRPC. Aujourd'hui nos projets sont quasiment tous en architecture microservices et communiquent via HTTP.\n\n> Et si maintenant on utilisait HTTP/2 pour faire communiquer nos services ?\n\nParce qu'un client HTTP/1 c'est bien mais un client HTTP/2 c'est mieux.\n\n> HTTP/2 c'est quoi ?\n\nJe vous invite à lire [cet article de Vincent](https://blog.eleven-labs.com/fr/http2-nest-pas-le-futur-cest-le-present/){:rel=\"nofollow noreferrer\"} pour y voir plus clair.\n\n> gRPC c'est quoi ?\n\ngRPC a été développé initialement par Google puis rendu open source. Il permet de réaliser des clients et serveurs rpc via HTTP/2 et donc de profiter de ses nouveautés. Les données sont sérialisées et désérialisées grâce à Protocol Buffers. Le framework gRPC permet aussi d'avoir un client et un serveur dans différents langages. En effet il est disponible pour la plupart des langages. Chaque service rpc est déclaré dans un fichier protobuf. La RFC est [disponible ici](https://tools.ietf.org/html/draft-kumar-rtgwg-grpc-protocol-00){:rel=\"nofollow noreferrer\"} si ça vous intéresse.\n\ngRPC permet quatre modes de communication.\n\nLe one-to-one classique :\n\n```\nClient Request -> Server\nClient <- Response Server\n\nservice CustomService {\n    rpc Endpoint(Request) returns (Response) {}\n}\n```\n\nLa streaming côté client :\n\n```\nStreaming Request -> Server\nClient <- Response Server\n\nservice CustomService {\n    rpc Endpoint(stream Request) returns (Response) {}\n}\n```\n\nLe streaming côté serveur :\n\n```\nRequest -> Server\nClient <- Streaming Response\n\nservice CustomService {\n    rpc Endpoint(Request) returns (stream Response) {}\n}\n```\n\nLe streaming bidirectionnel :\n\n```\nStreaming Request -> Server\nClient -> Streaming Response\n\nservice CustomService {\n    rpc Endpoint(stream Request) returns (stream Response) {}\n}\n```\n\nNous allons voir pour cet article uniquement le troisième mode `streaming côté serveur` mais les quatre sont très semblables.\n\nVous pouvez retrouver l'ensemble du code de [l'exemple sur mon github](https://github.com/qneyrat/go-grpc-example){:rel=\"nofollow noreferrer\"}.\n\n## Installation\n\nAssurez-vous avant de commencer l'installation d'avoir bien installé Go en version supérieure à 1.5 et Protocol Buffers en version 3.\n\nRécupérez gRPC pour Go :\n\n```bash\ngo get google.golang.org/grpc\n```\n\n## Protobuf\n\nNous allons commencer par récupérer le fichier proto du [précédent article](https://blog.eleven-labs.com/fr/presentation-protocol-buffers/){:rel=\"nofollow noreferrer\"}.\n\nNous allons ajouter un service pour récupérer en streaming la liste des Posts.\n\nUn service rpc est composé de la structure suivante :\n\n```\nrpc function(request) returns (response)\n```\n\nIci on a une request vide et un streaming de Post.\n\n```proto\nservice PostService {\n    rpc ListPosts(google.protobuf.Empty) returns (stream Post) {}\n}\n```\n\nCe qui nous donne :\n\n```proto\nsyntax = \"proto3\";\n\nimport \"google/protobuf/empty.proto\";\n\npackage main;\n\nmessage Post {\n    int32 id = 1;\n    string title = 2;\n    string author = 3;\n}\n\nservice PostService {\n    rpc ListPosts(google.protobuf.Empty) returns (stream Post) {}\n}\n\n```\n\n## Serveur\n\nOn va commencer par générer le code source depuis le fichier protobuf.\n\n```bash\nprotoc --proto_path=. --go_out=plugins=grpc:. post.proto\n```\n\nOn commence par déclarer une pseudo base de données :\n\n```go\nvar posts = []Post{\n\t{\n\t\tId:     1,\n\t\tTitle:  \"My awesome article 1\",\n\t\tAuthor: \"Quentin Neyrat\",\n\t},\n\t{\n\t\tId:     2,\n\t\tTitle:  \"My awesome article 2\",\n\t\tAuthor: \"Quentin Neyrat\",\n\t},\n\t{\n\t\tId:     3,\n\t\tTitle:  \"My awesome article 3\",\n\t\tAuthor: \"Quentin Neyrat\",\n\t},\n}\n```\n\nPuis on crée un serveur TCP sur le port 4000 pour notre serveur gRPC et on attache notre service déclaré dans le protobuf :\n\n```go\n\tlis, _ := net.Listen(\"tcp\", \"localhost:4000\")\n\tg := grpc.NewServer()\n\tRegisterPostServiceServer(g, NewServer())\n\tg.Serve(lis)\n}\n```\n\nOn a plus qu'à créer notre endpoint qui va parcourir notre pseudo base de données et envoyer les posts un par un :\n\n```go\nfunc (s *Server) ListPosts(empty *google_protobuf.Empty, stream PostService_ListPostsServer) error {\n\tfor _, post := range posts {\n\t\tfmt.Printf(\"Send post #%d \\n\", post.GetId())\n\t\tif err := stream.Send(&post); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n```\n\nLe code final :\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\tgoogle_protobuf \"github.com/golang/protobuf/ptypes/empty\"\n\tgrpc \"google.golang.org/grpc\"\n)\n\ntype Server struct{}\n\nfunc NewServer() *Server {\n\treturn &Server{}\n}\n\nvar posts = []Post{\n\t{\n\t\tId:     1,\n\t\tTitle:  \"My awesome article 1\",\n\t\tAuthor: \"Quentin Neyrat\",\n\t},\n\t{\n\t\tId:     2,\n\t\tTitle:  \"My awesome article 2\",\n\t\tAuthor: \"Quentin Neyrat\",\n\t},\n\t{\n\t\tId:     3,\n\t\tTitle:  \"My awesome article 3\",\n\t\tAuthor: \"Quentin Neyrat\",\n\t},\n}\n\nfunc (s *Server) ListPosts(empty *google_protobuf.Empty, stream PostService_ListPostsServer) error {\n\tfor _, post := range posts {\n\t\tfmt.Printf(\"Send post #%d \\n\", post.GetId())\n\t\tif err := stream.Send(&post); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", \"localhost:4000\")\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\n\tg := grpc.NewServer()\n\tRegisterPostServiceServer(g, NewServer())\n\tg.Serve(lis)\n}\n```\n\n> **Astuce :**\n> Vous pouvez exécuter `go run *` pour compiler entièrement le projet.\n\n### Client\n\nDans un nouveau projet, on déclare un client gRPC pour notre service.\n\n```go\nconn, _ := grpc.Dial(\"localhost:4000\", grpc.WithInsecure())\nclient := NewPostServiceClient(conn)\n```\n\nPuis une méthode pour récupérer les Posts :\n\n```go\nfunc printPosts(client PostServiceClient) {\n\tstream, err := client.ListPosts(context.Background(), &google_protobuf.Empty{})\n\tif err != nil {\n\t\tlog.Fatalf(\"%v.ListPosts(_) = _, %v\", client, err)\n\t}\n\tfor {\n\t\tpost, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"%v.ListPosts(_) = _, %v\", client, err)\n\t\t}\n\n\t\tfmt.Printf(\"Id: %d \\n\", post.GetId())\n\t\tfmt.Printf(\"Title: %s \\n\", post.GetTitle())\n\t\tfmt.Printf(\"Author: %s \\n\", post.GetAuthor())\n\t}\n}\n```\n\nLe code final donne :\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\n\tgoogle_protobuf \"github.com/golang/protobuf/ptypes/empty\"\n\tcontext \"golang.org/x/net/context\"\n\tgrpc \"google.golang.org/grpc\"\n)\n\nfunc printPosts(client PostServiceClient) {\n\tstream, err := client.ListPosts(context.Background(), &google_protobuf.Empty{})\n\tif err != nil {\n\t\tlog.Fatalf(\"%v.ListPosts(_) = _, %v\", client, err)\n\t}\n\tfor {\n\t\tpost, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"%v.ListPosts(_) = _, %v\", client, err)\n\t\t}\n\n\t\tfmt.Printf(\"Id: %d \\n\", post.GetId())\n\t\tfmt.Printf(\"Title: %s \\n\", post.GetTitle())\n\t\tfmt.Printf(\"Author: %s \\n\", post.GetAuthor())\n\t}\n}\n\nfunc main() {\n\tconn, err := grpc.Dial(\"localhost:4000\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start gRPC connection: %v\", err)\n\t}\n\tdefer conn.Close()\n\n\tclient := NewPostServiceClient(conn)\n\n\tprintPosts(client)\n}\n```\n\n## Conclusion\n---\n\ngRPC permet de profiter de toutes les nouveautés de HTTP/2 et la puissance de Protocol Buffers. Indispensable pour la communication entre micro-services.\n"}