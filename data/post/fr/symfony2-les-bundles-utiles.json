{"date":"2014-01-05T00:00:00.000Z","title":"Symfony2 et les Bundles utiles","excerpt":"Cela fait maintenant plus de 2 ans que Symfony2 est sorti et, comme vous le savez, il fonctionne avec des bundles. Voici une liste non-exhaustive de bundles sympathiques qui s'avèrent très utiles au quotidien.","readingTime":"6mn","authors":["marishka"],"categories":["php"],"content":"\nCela fait maintenant plus de 2 ans que Symfony2 est sorti et, comme vous le savez, il fonctionne avec des bundles. Voici une liste non-exhaustive de bundles sympathiques qui s'avèrent très utiles au quotidien.\n\n**JMSSerializerBundle** utilise la librairie Serializer du même auteur, et vous permet de sérialiser vos données dans un format de sortie demandé, tel que JSON, XML ou YAML, et inversement. En twig cela donne ça :\n\n\n```twig\n{{ data | serialize }} {# serializes to JSON #}\n{{ data | serialize('json') }}\n{{ data | serialize('xml') }}\n```\n\n\nLes possibilités sont illimitées, plus d'informations [ici](http://jmsyst.com/bundles/JMSSerializerBundle){:rel=\"nofollow noreferrer\"}.\n\nVous devez développer une API REST ? Utilisez **FOSRESTBundle** ! Il vous aide à respecter les conventions RESTful, fournit un controller et un système de routing adaptés au REST, et est très simple à utiliser. FOSRESTBundle va de paire avec JMSSerializerBundle ci-dessus. Avec le serializer vous pouvez paramétrer la politique d'exclusion et exposer uniquement certains attributs de vos entités en utilisant les annotations, le format xml ou yml, ou encore définir le format de sortie pour les dates.\n\n```php\n<?php\n\nnamespace Demo\\Bundle\\ApiBundle\\Controller;\n\nuse FOS\\RestBundle\\Controller\\FOSRestController;\nuse JMS\\Serializer\\SerializationContext;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\nclass DefaultController extends FOSRestController\n{\n    public function getAction($id)\n    {\n        $context = new SerializationContext();\n        $context->setSerializeNull(true);\n\n        // retreive the entity\n        $entity = $this->getDoctrine()->getManager()->find('MyBundle:Entity', $id);\n        $view = $this->view($entity, 200)->setSerializationContext($context);\n\n        return $this->handleView($view);\n    }\n    // ...\n}\n```\n\nLe détail est sur [la page github du projet](https://github.com/FriendsOfSymfony/FOSRestBundle){:rel=\"nofollow noreferrer\"}.\n\nVous appelez des web services REST ? [**Guzzle**](https://github.com/guzzle/guzzle) et [**Buzz**](https://github.com/kriswallsmith/Buzz){:rel=\"nofollow noreferrer\"} sont deux librairies PHP basées sur cURL, qui permettent de faire des requêtes HTTP. Ils ont chacun leur bundle respectif, ils sont rapides à prendre en main, même si Guzzle est plus intuitif. Rien de plus simple qu'un appel de web service :\n\n```php\n// use Guzzle\\Http\\Client;\n$client = new Client($googleMapsApiUrl);\n$request = $client->get($address);\n$response = $request->send()->json();\n```\n\nSi votre application permet la gestion des utilisateurs, **FOSUserBundle** le fait pour vous . Il est compatible avec Doctrine, Propel et MongoDB. Et si vous avez un backoffice d'administration, utilisez un de ces 2 bundles pour vous simplifier la vie : **SonataAdminBundle** ou **AdminGeneratorBundle.** Ils supportent aussi tous les deux Doctrine, MongoDB et Propel. Je ne vous en parle pas plus car il y a beaucoup d'informations sur ces bundles bien connus sur internet.\n\nDans un projet on a aussi souvent du JavaScript et de l'AJAX. Et quand on a besoin de faire un appel AJAX, **FOSJsRoutingBundle** nous vient en aide. Il permet d'accéder au routing du projet dans le code JavaScript. Il suffit d'indiquer que vous souhaitez exposer la route comme ceci :\n\n```yaml\n# routing.yml\ngetCoordinates:\n    pattern: /getCoordinates/{address}\n    defaults: { _controller: \"MyBundle:Address:getCoordinates\"}\n    options:\n        expose: true\n```\n\nEt de l'appeler dans un code JavaScript :\n\n```js\nvar input = $('#address').val();\n$.ajax({\n    url: Routing.generate('getCoordinates', { 'address': input }),\n    data: { address: input },\n    type: 'post',\n    dataType: 'json',\n    success: function( result ) {\n        // do something\n    }\n});\n```\n\nN'oubliez pas d'inclure les fichiers JS du bundle dans votre layout :\n\n\n```twig\n<script src=\"{{ asset('bundles/fosjsrouting/js/router.js') }}\"></script>\n<script src=\"{{ path('fos_js_routing_js', {\"callback\": \"fos.Router.setData\"}) }}\"></script>\n```\n\n\nPlus d'informations sur le [site du projet](https://github.com/FriendsOfSymfony/FOSJsRoutingBundle/blob/master/Resources/doc/README.markdown){:rel=\"nofollow noreferrer\"}.\n\nEn ce qui concerne la navigation sur votre site, prenez **KNPMenuBundle**. Vous définissez notre navigation dans une classe :\n\n```php\n<?php\n// src/MyBundle/Menu/Builder.php\nnamespace Demo\\MyBundle\\Menu;\n\nuse Knp\\Menu\\FactoryInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerAware;\n\nclass Builder extends ContainerAware\n{\n    public function mainMenu(FactoryInterface $factory, array $options)\n    {\n        $menu = $factory->createItem('root');\n\n        $menu->addChild('Home', array('route' => 'homepage'));\n        $menu->addChild('Articles', array('route' => 'posts'))\n\n        return $menu;\n    }\n}\n```\n\nEt vous l'appelez dans votre layout :\n\n\n```twig\n{{ knp_menu_render('DemoMyBundle:Builder:mainMenu') }}\n```\n\n\nFaites un tour [ici](https://github.com/KnpLabs/KnpMenuBundle/blob/master/Resources/doc/index.md#first-menu){:rel=\"nofollow noreferrer\"} pour lire toutes les informations.\n\nMaintenant que l'on peut accéder à la liste d'articles via le menu, on voudrait améliorer l'affichage et ajouter une pagination. Pour cela existe **KNPPaginatorBundle**. Il gère la pagination et le tri des résultats pour les requêtes Doctrine, MongoDB et Propel. Dans votre action, vous créez une requête et la passez au service paginator :\n\n```php\npublic function listAction()\n{\n    $em    = $this->get('doctrine.orm.entity_manager');\n    $dql   = \"SELECT a FROM DemoMyBundle:Article a\";\n    $query = $em->createQuery($dql);\n\n    $paginator  = $this->get('knp_paginator');\n    $pagination = $paginator->paginate(\n        $query,\n        $this->get('request')->query->get('page', 1), // default page number,\n        10 // limit per page\n    );\n\n    // parameters to template\n    return $this->render('DemoMyBundle:Article:list.html.twig', array('pagination' => $pagination));\n}\n```\n\nEt dans le template twig :\n\n\n```twig\n{# total items count #}\n<div class=\"count\">\n    {{ pagination.getTotalItemCount }}\n</div>\n<table>\n<tr>\n{# sorting of properties based on query components #}\n    <th>Id</th>\n    <th>{{ knp_pagination_sortable(pagination, 'Title', 'a.title') }}</th>\n</tr>\n\n{# table body #}\n{% for article in pagination %}\n<tr>\n    <td>{{ article.id }}</td>\n    <td>{{ article.title }}</td>\n</tr>\n{% endfor %}\n</table>\n{# display navigation #}\n<div class=\"navigation\">\n    {{ knp_pagination_render(pagination) }}\n</div>\n```\n\n\nVisitez la [page du bundle](https://github.com/KnpLabs/KnpPaginatorBundle){:rel=\"nofollow noreferrer\"} pour de plus amples informations.\n\nAdmettons que vous voulez facturez vos clients. Le meilleur outil pour cela est **JMSPayment**. JMSPaymentCoreBundle vous fournit une API unifiée simple qui gère les différents modes de paiement. Vous n'avez plus à vous soucier des protocoles divers. JMSPaymentPaypalBundle est une couche qui implémente PayPal.\n\nLa documentation complète est ici : [JMSPaymentCore](http://jmsyst.com/bundles/JMSPaymentCoreBundle) et [JMSPaypal](http://jmsyst.com/bundles/JMSPaymentPaypalBundle){:rel=\"nofollow noreferrer\"}\n\nOn voudrait pouvoir générer la facture au format PDF pour le client pour confirmer son paiement. Pour cela, il y a **KNPSnappyBundle**. Il est basé sur [wkhtmltopdf](http://code.google.com/p/wkhtmltopdf/){:rel=\"nofollow noreferrer\"} qui génère un PDF à partir d'un fichier HTML comme son nom l'indique. On définit notre HTML dans un template twig par exemple. Et le controller n'a besoin que de très peu de code :\n\n```php\npublic function getPDFAction()\n{\n    $html = $this->renderView('DemoMyBundle:Default:pdf.html.twig');\n\n    return new Response(\n        $this->get('knp_snappy.pdf')->getOutputFromHtml($html, array('footer-center' => 'Page [page]/[topage]')),\n        200,\n        array(\n            'Content-Type'          => 'application/pdf',\n            'Content-Disposition'   => 'attachment; filename=\"file.pdf\"'\n        )\n    );\n}\n```\n\nToutes les options de wkhtmltopdf sont disponibles. Cliquez [ici](https://github.com/KnpLabs/KnpSnappyBundle){:rel=\"nofollow noreferrer\"} pour voir le bundle sur Github.\n\nEt vous, quels sont les bundles que vous utilisez ?\n"}