{"date":"2013-12-17T00:00:00.000Z","title":"Performance et Memcached sous Symfony 2","excerpt":"Dans tout (gros) projet, à un moment avancé de votre développement/exploitation, vous serez amené à rencontrer divers problèmes de performance.","readingTime":"9mn","authors":["pouzor"],"categories":["php"],"content":"\nDans tout (gros) projet, à un moment avancé de votre développement/exploitation, vous serez amené à rencontrer divers problèmes de performance.\n\nCertains peuvent être liés au trop grand nombre de requêtes effectuées ou encore à la quantité d'informations récupérées dans la BDD.\n\nNous allons vous proposer dans cet article de faire un point sur les quelques techniques rapides afin d'optimiser votre solution, ainsi que sur l'installation de memcached sous Sf2.\n\nPART I : \"Less Request For Less Time\"\n=====================================\n\nSi il y a une chose que l'on apprécie tous sous Sf2, c'est son Entity Manager avec son système de Lazy Loading. Le principe ? La donnée n'est réellement chargée depuis la BDD que lorsque que vous en avez réellement besoin, c'est a dire, lorsque que vous tentez d'accéder à l'un de ses attributs (le nom par exemple).\n\nMais cela peut aussi amener à quelques problèmes de performances lorsque l'on ne fait pas attention.\n\nPrenons par exemple un model ou l'on a des Ecoles, des Classes et des Elèves. La problématique de votre projet implique que sur une page vous devez tout charger pour un affichage par liste.\n\nEx : Une liste d'école ou un click sur un bouton déroule des classes qui elles-mêmes peuvent se dérouler sur les éleves.\n\nVotre logique métier étant bien faite, il vous suffit de récupérer votre liste complète juste en récupérant votre liste d'école (Vos classes étant liées aux écoles et les élèves étant liés aux écoles).\n\n```php\nclass EcoleRepository {\n\npublic function getEcoles() {\n  $qBuilder = $this->getEntityManager()\n                   ->createQueryBuilder()\n                   ->select('e')\n                   ->from(\"MyBundle:Ecole\", \"e\");\n\n  return $qBuilder->getQuery()->getResult();\n }\n}\n```\n\nIl ne vous reste plus qu'à parcourir la liste des écoles, puis pour chaque école sa liste de classe.\n\nParfait ! Mais si vous jetez un coup d'oeil sur votre Profiler en bas de page, vous verrez quelque chose comme cela :\n\n\nEt oui, 194 requêtes Doctrine juste pour votre simple page, et pourtant votre jeu d'essai ne contient que 20 lignes en tout. Alors pourquoi ?\n\nTout simplement grâce/à cause de Doctrine qui vous a pré-mâché le boulot, certes, mais qui n'a pas optimisé ses requêtes. Si vous jetez un coup d’œil aux requêtes, vous allez voir qu'un certain nombre d'entre elles chargent une Classe pour un ID particulier, les autres chargeant les Elèves aussi pour un ID particulier. Vous commencez à comprendre ? En effet, cela vient de notre fameux Lazy Loading. Ici Doctrine ne charge que les éléments dont il a besoin mais étant dans une boucle, Doctrine les charge un par un, requête par requête. Et voila comment on transforme une page très simple en un enfer pour votre BDD.\n\nLa solution est très simple : indiquer à Doctrine de tout charger dans notre objet initial car nous allons avoir besoin de tout.\n\n```php\nclass EcoleRepository {\n\npublic function getEcoles() {\n  $qBuilder = $this->getEntityManager()\n                   ->createQueryBuilder()\n                   ->select('e', 'c', 's')\n                   ->from(\"MyBundle:Ecole\", \"e\")\n                   ->leftJoin('e.MyBundle:Classe', 'c')\n                   ->leftJoin('c.MyBundle:Student', 's');\n\n  return $qBuilder->getQuery()->getResult();\n }\n}\n```\n\nEt voila, le boulot est fait. Ici, pas de Lazy Loading, toutes nos données sont chargées en une seule requête. Vous devrez donc gagner un temps proportionnel au nombre d'éléments chargés sur la page.\n\nVous pouvez aussi gérer les jointures par défaut dans les entités avec l'annotation fetch=\"EAGER\"\n\nPART II : \"Object Or Array\"\n===========================\n\nBon maintenant que notre requête est optimisée, il serait temps de s'occuper de notre donnée à proprement parlé.\n\nPremier test, pour voir un peut ce qu'on l'on récupère, on peut toujours faire un var\\_dump() sur notre variable $liste\\_ecoles, mais c'est une mauvaise idée...\n\nPourquoi ? Tout simplement parce que l'objet (enfin la liste d'objet) est tellement gros qu'il fera certainement planter le rendu de votre navigateur.\n\nOk mais pourquoi avoir un objet si gros, alors que je veux juste boucler sur les entités et afficher certains de leurs attributs. D'ailleurs, pourquoi mon objet est il si gros alors que ma base ne contient que quelques champs ?\n\nLa réponse est encore à trouver du coté de l'EM, plus particulièrement de l'Hydratation de notre donnée.\n\nEn effet, lorsqu'elles sont récupérées par votre requête, plus particulièrement par  *$qBuilder->getQuery()->getResult();* vos données sont transformées pour intégrer un certain nombre de choses, principalement pour mapper votre Entity.class\n\nCe qu'il faut comprendre, c'est que cette opération consomme de la ressource, pour chaque objet, et ses objets liés etc... Mais pour de la vue simple, aucun intérêt !\n\nDu coup, on va changer de méthode d'hydratation, pour quelque chose de beaucoup plus simple et donc performant.\n\n```php\nclass EcoleRepository {\n\npublic function getEcoles() {\n  $qBuilder = $this->getEntityManager()\n                   ->createQueryBuilder()\n                   ->select('e', 'c', 's')\n                   ->from(\"MyBundle:Ecole\", \"e\")\n                   ->leftJoin('e.MyBundle:Classe', 'c')\n                   ->leftJoin('c.MyBundle:Student', 's');\n\n  return $qBuilder->getQuery()->getArrayResult();\n }\n}\n```\n\nVoila, simple non !?\n\nMaintenant faites un var\\_dump(), si si vous pouvez promis ;)\n\nSimple, vous n'avez que les données dont vous avez besoin.\n\nPetite chose à vous rappeler dans votre template twig, vos données sont accessibles via des tableaux indéxés et non via des getter.\n\nEx :\n\n\n```twig\n{{ eleve[\"nom\"] }} {# remplace {{ eleve.getNom }} #}\n```\n\n\nPART III : \"Time to Cache\"\n==========================\n\nBon, jusqu'ici c'était la partie facile, celle qui est à mettre en place partout, un réflexe à prendre en quelque sorte.\n\nNous allons maintenant rentrer dans les dernières phases d'optimisation côté code, même si nous allons tricher, puisque nous allons coupler Sf à une autre technologie : Memcached.\n\n**⚠ Cette partie consiste à \"stocker\" nos données dans la RAM, cela est toujours mieux si la donnée à stocker est elle-même déjà optimisée, par exemple avec les conseils ci-dessus ;) ⚠**\n\nAlors, pourquoi stocker notre donnée dans la RAM, si celle-ci est déjà optimisée grâce aux exemples précédents ?\n\n1 / La vitesse\n\nEn effet, la grande différence entre stocker en mémoire (Memcached) et le disque (BDD) est la vitesse. Que ce soit en lecture ou écriture, la RAM est beaucoup, BEAUCOUP plus performant que le DD. Ca, je pense que vous le savez, donc pourquoi ne pas en profiter pour votre projet ? Apres tout la RAM ne sert pas qu'à faire tourner les derniers jeux !\n\n2 / Le temps d'exécution\n\nEt oui, qui dit données stockées, dit aussi stockées intelligemment, c'est a dire prêtes à servir. Une fois la donnée stockée, plus aucun traitement n'est à faire dessus hormis de la lecture, alors qu'en temps normal, on a au moins l'hydratation qui est faire à chaque fois.\n\n**Memcached : Késako ?**\n\nMemcached est un binaire, tournant sur à peu près toutes les plateformes, permettant d'accéder à un espace mémoire assez simplement.\n\nEn fait, memcached va nous permettre d'accéder à la RAM comme un simple tableau PHP, indéx clef => valeur, avec une durée de vie.\n\nPour nous simplifier la vie, nous allons utiliser le Bundle Memcached de Leaseweb, disponible [ici](https://github.com/LeaseWeb/LswMemcacheBundle){:rel=\"nofollow noreferrer\"}.\n\nPour l'installation, référez vous au README, c'est assez simple sous Linux.\n\nMaintenant, allons \"stocker\" notre tableau dans la mémoire : (Note, le plugin permet de cacher directement les requêtes Doctrine, mais c'est aussi bien d'avoir toujours le contrôle sur ce que vous faites, à vous de voir)\n\n```php\nclass EcoleRepository {\n\npublic function getEcoles() {\n\n //Verification de la donnée déja presente dans le cache\n if ($data = $this->memcache->get(\"ecole_list\")) {\n   return $data;\n }\n\n  $qBuilder = $this->getEntityManager()\n                   ->createQueryBuilder()\n                   ->select('e', 'c', 's')\n                   ->from(\"MyBundle:Ecole\", \"e\")\n                   ->leftJoin('e.MyBundle:Classe', 'c')\n                   ->leftJoin('c.MyBundle:Student', 's');\n\n  $data = $qBuilder->getQuery()->getArrayResult();\n  //Sinon on set le resultat de notre requête dans le cache\n  $this->memcache->set(\"ecole_list\", $data, 86400);\n\n  return $data;\n }\n}\n```\n\nIci on considérera que l'on a passé le service memcached dans le repo, sinon on y accède par service : *$this->get('memcache.default')*\n\nOn a défini dans le cache pour la clef  \"ecole\\_list\" notre tableau de résultat, qui sera accessible n'importe où, et pour une durée d'une journée.\n\nEt voila, c'était simple non ?\n\nAttention, une dernière petite chose, la donnée dans cet état n'est pas mise à jour lorsque vous ajoutez une école ou encore un élève par exemple. Il faut donc penser à expirer le namespace du cache (\"ecole\\_list\") lors de l'ajout ou la modification d'une donnée :\n\n```php\n$this->memcache->delete(\"ecole_list\");\n```\n\nVoila vous savez tout. Pour pousser l'exemple plus loin, et surtout pour qu'il soit plus exploitable, vous pouvez créer un service MyMemcache qui gère vos enregistrements et suppressions en fonction du context, des paramètres (utile quand les données sont propres à l'utilisateur courant par exemple) :\n\n```php\n$param = array(\"ecole_list\", \"clientId\", \"ListId\", ...);\n\n//Creer un namespace unique composé des éléments du tableau $param\nif ($data = $this->memcache->get(implode(\"_\", $param), null)) {\n  return $data;\n}\n```\n"}