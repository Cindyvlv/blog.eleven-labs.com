{"date":"2018-01-05T00:00:00.000Z","title":"SSR avec Symfony et Vue.js","excerpt":"Nous travaillons de plus en plus avec à la fois un framework serveur type Symfony et un framework client type Vue.js. D'ailleurs on trouve énormément d'articles sur le sujet. La question que l'on se pose le plus souvent, c'est comment rendre ces choix technologiques performants.","readingTime":"7mn","authors":["captainjojo"],"categories":["javascript"],"content":"\nNous travaillons de plus en plus avec à la fois un framework serveur type Symfony et un framework client type Vue.js. D'ailleurs on trouve énormément d'articles sur le sujet. La question que l'on se pose le plus souvent, c'est comment rendre ces choix technologiques performants.\n\nC'est en lisant un article sur [Medium](https://medium.com/js-dojo/server-side-rendering-with-laravel-vue-js-2-5-6afedd64aa90) qui présente la mise en place de SSR (server side rendering) de vue.js sur un serveur Laravel que je me suis dit \"Et pourquoi ne pas le faire en Symfony ?\".\n\n## Symfony et Vue.js premiere partie\n\nTout d'abord, je vous invite à installer un Symfony 4 en suivant les instructions disponibles [ici](https://symfony.com/doc/current/setup.html).\n\nVous devez alors avoir un projet qui ressemble à ceci :\n\n```\nyour-project/\n├── assets/\n├── bin/\n│   └── console\n├── config/\n│   ├── bundles.php\n│   ├── packages/\n│   ├── routes.yaml\n│   └── services.yaml\n├── public/\n│   └── index.php\n├── src/\n│   ├── ...\n│   └── Kernel.php\n├── templates/\n├── tests/\n├── translations/\n├── var/\n└── vendor/\n```\n\nLa première chose à faire, c'est d'installer twig et les annotations :\n\n    composer require annotations\n    composer require twig\n\nCela va vous permettre de créer votre premier controller dans le ficher `src/Controller/DefaultController.php`\n\n\n```php\n<?php\n\nnamespace App\\Controller;\n\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\nclass DefaultController  extends Controller\n{\n    /**\n     * @Route(\"/\")\n     */\n    public function number()\n    {\n        return $this->render('home.html.twig');\n    }\n}\n```\n\n\nEt d'ajouter votre template twig dans le fichier `templates/home.html.twig`\n\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>{% block title %}Welcome!{% endblock %}</title>\n        {% block stylesheets %}{% endblock %}\n    </head>\n    <body>\n        {% block body %}\n            <div id=\"app\">SALUT</div>\n        {% endblock %}\n        {% block javascripts %}\n        {% endblock %}\n    </body>\n</html>\n```\n\n\nNous allons maintenant ajouter la partie vue.js, en utilisant Webpack-encore de Symfony. Vous trouverez la documentation [ici](http://symfony.com/doc/current/frontend/encore/installation.html).\n\nNous allons faire une configuration très simple pour la mise en place de vue.js. Il faut mettre dans votre fichier `webpack.config.js`\n\n\n```js\nvar Encore = require('@symfony/webpack-encore');\n\nEncore\n    // the project directory where compiled assets will be stored\n    .setOutputPath('public/build/')\n    // the public path used by the web server to access the previous directory\n    .setPublicPath('/build')\n    .addEntry('app', './assets/js/app.js')\n    .cleanupOutputBeforeBuild()\n    .enableSourceMaps(!Encore.isProduction())\n    .enableVueLoader()\n;\n\nmodule.exports = Encore.getWebpackConfig();\n```\n\n\nPuis nous allons ajouter le composant Vue.js.\n\n\nDans le dossier `assets` je vous invite à créer le dossier `js`. À l'intérieur de ce dossier vous pouvez créer le composant vue.js. Dans le fichier `assets/js/components/App.vue`\n\n\n```html\n<template>\n  <div id=\"app\">\n    {{ message }}\n  </div>\n</template>\n<script>\n  export default {\n    data() {\n      return {\n        message: 'Hello World'\n      }\n    }\n  }\n</script>\n```\n\n\nPuis vous pouvez créer `app` vue.js, dans le fichier `assets/js/app.js` qui est le point d'entrée de votre application vue.js.\n\n\n```js\nimport App from './components/App.vue';\nimport Vue from 'vue';\nnew Vue({\n  el: '#app',\n  render: h => h(App)\n});\n```\n\n\nDans votre fichier twig vous devez appeler le fichier généré par webpack en ajoutant ceci dans le block javascript.\n\n\n```html\n<script src=\"{{ asset('build/app.js') }}\"></script>\n```\n\n\nVoilà, vous devez avoir un site symfony 4 qui vous affiche `Hello world` en vue.js. Si vous désactivez le javascript, vous n'aurez que le `salut` qui s'affiche.\n\n![Demo1]({{site.baseurl}}/assets/2018-01-05-SSR-symfony-vue/demo1.png)\n\n## Faire du SSR\n\nL'intérêt du SSR est de ne pas interpréter le javascript sur le client lors du premier appel mais plutôt par votre serveur. Cela permet d'avoir une page directement générée, et de gagner en performance d'affichage ainsi qu'en SEO.\n\nNormalement le SSR se fait directement sur un serveur javascript. Il existe d'ailleurs des librairies directement faites pour cela.  Je vous incite à lire cet article qui parle du [SSR sur React](https://blog.eleven-labs.com/en/react-ssr/).\n\nMais ici, nous voulons garder notre serveur Symfony (pour plein de raison que je n'expliquerai pas).\n\nTout d'abord nous allons créer deux fichiers d'entrée pour vue.js, parce qu'il faut appeler des fonctions différentes pour l'affichage dans le client et dans le serveur.\n\n![App.js]({{site.baseurl}}/assets/2018-01-05-SSR-symfony-vue/appjs.png)\n\nCommençons par créer le fichier `assets/js/entry-client.js` qui permet de \"monter\" l'application sur l'id `#app`\n\n\n```js\nimport { createApp } from './app'\ncreateApp().$mount('#app');\n```\n\n\nPuis il faut créer le fichier `assets/js/entry-server.js` qui, lui, permet de transformer le composant vue.js en un chaîne de caractères que vous pourrez ensuite interpréter dans le php.\n\n\n```js\nimport { createApp } from './app'\nrenderVueComponentToString(createApp(), (err, res) => {\n  print(res);\n});\n```\n\n\nEt nous terminons par mettre à jour le fichier  `assets/js/app.js` qui permet d'exporter l'application pour qu'elle soit lisible par les deux fichiers précédents.\n\n\n```js\nimport App from './components/App.vue';\nimport Vue from 'vue';\n\nexport function createApp() {\n  return new Vue({\n    render: h => h(App)\n  });\n}\n```\n\n\nIl vous faut alors changer la configuration de votre `webpack` pour générer les deux fichiers d'entrée\n\n\n```js\nvar Encore = require('@symfony/webpack-encore');\n\nEncore\n    // the project directory where compiled assets will be stored\n    .setOutputPath('public/build/')\n    // the public path used by the web server to access the previous directory\n    .setPublicPath('/build')\n    .addEntry('entry-client', './assets/js/entry-client.js')\n    .addEntry('entry-server', './assets/js/entry-server.js')\n    .cleanupOutputBeforeBuild()\n    .enableSourceMaps(!Encore.isProduction())\n    .enableVueLoader()\n;\n\nmodule.exports = Encore.getWebpackConfig();\n```\n\n\nSi vous changez le bloc javascript dans votre fichier  `templates/home.html.twig` par ceci.\n\n\n`<script src=\"{{ asset('build/entry-client.js') }}\"></script>`\n\n\nVous devez avoir exactement le même résultat que précédemment.\n\nNous allons maintenant mettre en place le SSR. Pour faire simple nous allons charger la librairie V8js qui permet à PHP d'utiliser le moteur d'interprétation de javascript.\n\nPour cela il vous faut installer l'extension [PHP V8js](http://php.net/manual/fr/book.v8js.php) qui vous permet ensuite d'utiliser le class `V8Js` dans votre code PHP.\n\nCe que l'on va faire, c'est récupérer le retour du fichier `entry-server.js` en format string et le mettre directement dans le template.\n\nAjoutons une fonction privée dans notre contrôleur Symfony qui va permettre de faire cela (pour faire propre il faudrait le faire dans un service).\n\n\n```php\nprivate function renderJs()\n{\n    $renderer_source = file_get_contents(__DIR__ . '/../../node_modules/vue-server-renderer/basic.js');\n    $app_source = file_get_contents(__DIR__ . '/../../public/build/entry-server.js');\n    $v8 = new \\V8Js();\n    ob_start();\n    $v8->executeString('var process = { env: { VUE_ENV: \"server\", NODE_ENV: \"production\" }}; this.global = { process: process };');\n    $v8->executeString($renderer_source);\n    $v8->executeString($app_source);\n    return ob_get_clean();\n}\n```\n\n\nIl ne reste plus qu'à récupérer le résultat dans le contrôleur et à l'envoyer dans le template.\n\n\n```php\n/**\n * @Route(\"/\")\n */\npublic function home()\n{\n    $ssr = $this->renderJs();\n    return $this->render('home.html.twig', ['ssr' => $ssr]);\n}\n```\n\n\nEt dans le twig vous pouvez mettre la valeur `raw` de `ssr`.\n\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>{% block title %}Welcome!{% endblock %}</title>\n        {% block stylesheets %}{% endblock %}\n    </head>\n    <body>\n        {% block body %}\n            {{ ssr|raw }}\n        {% endblock %}\n        {% block javascripts %}\n        {% endblock %}\n    </body>\n</html>\n```\n\n\nSi tout est ok, votre page affichera \"Hello World\" directement dans votre code source.\n\n![CodeSource]({{site.baseurl}}/assets/2018-01-05-SSR-symfony-vue/source.png)\n\n## Conclusion\n\nIl est assez simple de mettre en place le système à plus grande échelle et donc d'avoir à la fois la puissance d'un framework javascript même lors du premier appel.\n\nVous trouverez l'ensemble du code sur mon github [ici](https://github.com/CaptainJojo/symfony-vue).\n"}