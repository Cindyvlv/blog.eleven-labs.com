{"date":"2016-09-14T00:00:00.000Z","title":"Pattern Specification","excerpt":"Au cours de mes différentes expériences professionnelles, j'ai dû mettre en place de nombreuses règles métier dans diverses applications riches fonctionnellement. Un jour, j'ai été confronté à une façon de faire différente : l'utilisation du pattern specification. Cette méthode s’est avérée structurante pour les projets, et si vous ne la connaissez pas encore elle mérite qu’on s’y attarde.","readingTime":"9mn","authors":["rpierlot"],"categories":["php","architecture"],"content":"\nAu cours de mes différentes expériences professionnelles, j'ai dû mettre en place de nombreuses règles métier dans diverses applications riches fonctionnellement. Un jour, j'ai été confronté à une façon de faire différente : l'utilisation du pattern specification. Cette méthode s’est avérée structurante pour les projets, et si vous ne la connaissez pas encore elle mérite qu’on s’y attarde.\n\n### Commençons\n\nImaginez une application bancaire par exemple. Cette dernière comprend des clients et des comptes bancaires. Un client peut avoir un ou plusieurs comptes bancaires. Vous devez mettre en place un système hyper simple de virement bancaire entre comptes d’un même client, comprenant la règle métier suivante :\n\n*   Un client ne peut pas effectuer un virement depuis un compte dont le solde est inférieur à 0\n*   Le client associé au compte bancaire débité doit etre actif.\n\nVous apercevez donc clairement la condition qui empêcherait le virement bancaire de se faire pour deux comptes d’un même client.\n\nDans un cas classique, il vous serait possible d’écrire cela sous cette forme :\n\n```php\n<?php\n\nnamespace ElevenLabs\\Application;\n\nuse ElevenLabs\\Domain\\Payment\\Entity\\Account;\n\nclass TransferMoneyCommand\n{\n    /**\n     * @param Amount $accountToDebit\n     * @param Amount $accountToCredit\n     * @param float  $amount\n     */\n    public function execute(Account $accountToDebit, Account $accountToCredit, $amount)\n    {\n        if ($accountToDebit->getBalance() - $amount > 0 && $accountToDebit->getOwner()->isActive()) {\n            //transfer authorized\n            //...\n        }\n    }\n}\n```\n\nCette règle métier, bien que triviale, doit être implémentée dès que l’on souhaite effectuer un virement.\nIl apparait plusieurs contraintes, suite à cette implémentation.\n\nTout d’abord, si notre règle métier évolue, nous devrons modifier la (ou les) classe(s) qui l’utilise(nt). Ensuite, une telle implémentation dans une condition _if_ n’est pas explicite du tout.\n\nC’est là qu’entre en scène le _pattern_ spécification. L’idée de la spécification est d’isoler une règle métier, en la séparant de son utilisation. Elle est utilisée dans le cas de la validation, de la sélection et dans la construction de logique métier.\n\nIl existe principalement trois types de spécifications :\n\n*   les spécifications _hard coded_\n*   les spécifications paramétrées\n*   les spécifications composites\n\nUne spécification est régie par l'interface suivante :\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain;\n\ninterface Specification\n{\n    /**\n     * @param $candidate\n     *\n     * @return bool\n     */\n    public function isSatisfiedBy($candidate);\n}\n```\n\n    ### Spécifications Hard-coded\n\nCe type de specifications permet de déclarer en dur la connaissance métier sans pouvoir modifier la règle métier de l'extérieur.\n\nUne règle métier peut donc être, par exemple, traduite de la sorte :\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain\\Payment;\n\nuse ElevenLabs\\Domain\\Specification;\n\nclass AccountCanTransferMoney implements Specification\n{\n    /**\n     * @param \\ElevenLabs\\Domain\\Payment\\Entity\\Account $account\n     *\n     * @return boolean\n     */\n    public function isSatisfiedBy($account)\n    {\n         return $account->getBalance() > 0 && $account->getOwner()->isActive();\n    }\n}\n```\n\nEn ayant créé une classe séparée pour appliquer notre règle, nous gagnons en découplage et en clarté. Cependant, il apparait évident que nous sommes cantonnés à l'object $account, et qu'aucune information ne peut être apportée de l'extérieur. Nous ne pouvons toujours pas utiliser ce type de spécification dans notre _TransferMoneyCommand_ car il ne répond pas totalement à notre règle métier (seul le solde actuel du compte est comparé).\n\n### Spécifications paramétrées\n\nLes spécifications paramétrées sont identiques au point précédent, sauf qu'elles résolvent le problème que nous venons d'indiquer en permettant de passer des paramètres extérieurs à notre _candidate_.\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain\\Payment;\n\nuse ElevenLabs\\Domain\\Specification;\n\nclass AccountCanTransferMoney implements Specification\n{\n    /** @var float */\n    private $amount;\n\n    /**\n     * @param float $amount\n     */\n    public function __construct($amount)\n    {\n        $this->amount = $amount;\n    }\n\n    /**\n     * @param \\ElevenLabs\\Domain\\Payment\\Entity\\Account $account\n     *\n     * @return boolean\n     */\n    public function isSatisfiedBy($account)\n    {\n         return $account->getBalance() - $this->amount > 0 && $account->getOwner()->isActive();\n    }\n}\n```\n\nAvec ce type de spécifications, nous gardons les mêmes avantages que précédemment, et nous gagnons en flexibilité.\n\nVoici ce que donnerait notre commande avec l'utilisation de notre spécification paramétrée :\n\n```php\n<?php\n\nnamespace ElevenLabs\\Application;\n\nuse ElevenLabs\\Domain\\Payment\\Entity\\Account;\nuse ElevenLabs\\Domain\\Payment\\Specification\\AccountCanTransferMoney;\n\nclass TransferMoneyCommand\n{\n    /**\n     * @param Account $accountToDebit\n     * @param Account $accountToCredit\n     * @param float   $amount\n     */\n    public function execute(Account $accountToDebit, Account $accountToCredit, $amount)\n    {\n        $accountCanTransferMoney = new AccountCanTransferMoney($amount);\n\n        if (true === $accountCanTransferMoney->isSatisfiedBy($accountToDebit)) {\n            //transfer authorized\n            //...\n        }\n    }\n}\n```\n\nPour simplifier l'explication des spécifications paramétrées, j'ai instancié la class AccountCanTransferMoney en dur. Une amélioration notable de cette utilisation serait d'injecter dans la commande la spécification, au lieu de l'instancier en dur, afin de pouvoir tester unitairement notre commande.\n\n### Spécifications composites\n\nLe dernier type de spécification que nous aborderons aujourd'hui concerne la spécification composite. Cette dernière se base sur ce que nous venons de voir. En effet, ce pattern utilise une composition de spécifications pour exister. Les opérations logiques entre deux (ou plus) spécifications font parties des _composite specifications._\n\nL'exemple suivant vous explique l'implémentation de l'opération logique AND :\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain;\n\nabstract class Composite implements Specification\n{\n    /**\n     * {@inheritdoc}\n     */\n    abstract public function isSatisfiedBy($candidate);\n\n    /**\n     * @param Specification $spec\n     *\n     * @return AndSpecification\n     */\n    public function andIsSatisfiedBy(Specification $spec)\n    {\n        return new AndSpecification($this, $spec);\n    }\n\n    //...\n}\n\nclass AndSpecification extends Composite\n{\n    /** @var Specification */\n    private $a;\n\n    /** @var Specification */\n    private $b;\n\n    /**\n     * @param Specification $a\n     * @param Specification $b\n     */\n    public function __construct(Specification $a, Specification $b)\n    {\n        $this->a = $a;\n        $this->b = $b;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function isSatisfiedBy($candidate)\n    {\n        return $this->a->isSatisfiedBy($candidate) && $this->b->isSatisfiedBy($candidate);\n    }\n}\n```\n\nAinsi, si l'on déclare une spécification composite, on peut la chainer à d'autres spécifications, comme ci-dessous, en modifiant notre spécification précédente _AccountCanTransferMoney_ :\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain\\Payment;\n\nuse ElevenLabs\\Domain\\Composite;\n\nclass AccountCanTransferMoney extends Composite\n{\n    /** @var float */\n    private $amount;\n\n    /**\n     * @param float $amount\n     */\n    public function __construct($amount = 0)\n    {\n        $this->amount = $amount;\n    }\n\n    /**\n     * @param \\ElevenLabs\\Domain\\Payment\\Entity\\Account $account\n     *\n     * @return boolean\n     */\n    public function isSatisfiedBy($account)\n    {\n         return $account->getBalance() - $this->amount > 0;\n    }\n}\n```\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain\\Payment\\Specification;\n\nuse ElevenLabs\\Domain\\Specification;\n\nclass AccountOwnerIsActive implements Specification\n{\n    /**\n     * @param \\ElevenLabs\\Domain\\Payment\\Entity\\Account $account\n     *\n     * @return boolean\n     */\n    public function isSatisfiedBy($account)\n    {\n        return $account->getOwner()->isActive();\n    }\n}\n```\n\nEnfin, voici comment utiliser notre composition :\n\n```php\n<?php\n\nnamespace ElevenLabs\\Application;\n\nuse ElevenLabs\\Domain\\Payment\\Entity\\Account;\nuse ElevenLabs\\Domain\\Payment\\Specification\\AccountCanTransferMoney;\n\nclass TransferMoneyCommand\n{\n    /**\n     * @param Account $accountToDebit\n     * @param Account $accountToCredit\n     * @param float   $amount\n     */\n    public function execute(Account $accountToDebit, Account $accountToCredit, $amount)\n    {\n        $accountCanTransferMoney = new AccountCanTransferMoney($amount);\n        $accountOwnerIsActive = new AccountOwnerIsActive();\n        $compositeSpecification = $accountCanTransferMoney->andIsSatisfiedBy($accountOwnerIsActive);\n\n        if (true === $compositeSpecification->isSatisfiedBy($accountToDebit)) {\n            //transfer authorized\n            //...\n        }\n    }\n}\n```\n\nLes avantages de ce type de spécifications sont bien sûr le support des opérations logiques, et donc la création de règles métier plus complexes. Il est maintenant possible de combiner les spécifications. La flexibilité est encore accrue, mais attention à la complexité générée !\n\n### Recap\n\nLes avantages du pattern spécification sont les suivants :\n\n*   Découplage augmenté car la responsabilité de la validation est maintenant limitée à une classe isolée\n*   Ainsi, il est plus facile de tester unitairement à la fois les spécifications et les classes utilisant ces dernières\n*   L'implicite est rendu explicite avec une définition claire des règles métier\n\n## Références\n\n[Eric Evans & Martin Fowler - Specifications](http://martinfowler.com/apsupp/spec.pdf){:rel=\"nofollow noreferrer\"}\n\n[Specification pattern: C# implementation](http://enterprisecraftsmanship.com/2016/02/08/specification-pattern-c-implementation/){:rel=\"nofollow noreferrer\"}\n"}