{"date":"2016-08-19T00:00:00.000Z","title":"Transformer un tableau en réponse JSON","excerpt":"Dans le contexte d'une API REST, intéressons nous particulièrement à la donnée rendue par le contrôleur. Je vous emmène découvrir le mécanisme qui permet l'affichage de la donnée en format compréhensible par d'autres systèmes, JSON dans cet exemple.","readingTime":"3mn","authors":["tthuon"],"categories":["php"],"content":"## Introduction\n\nDans le contexte d'une API REST, intéressons nous particulièrement à la donnée rendue par le contrôleur. Je vous emmène découvrir le mécanisme qui permet l'affichage de la donnée en format compréhensible par d'autres systèmes, JSON dans cet exemple.\n\nConcrètement, le rôle du contrôleur est de prendre un objet _Request_ en entrée et de renvoyer un objet _Response_ en sortie. Mais comment faire si je veux formater mes données autrement, par exemple en JSON ?\n\n## Le chemin d'une requête\n\nCe qui a été décrit plus haut peut se résumer en une image ci-dessous.\n\n[![Symfony kernel event](/imgs/posts/2016-08-19-transformer-tableau-en-reponse-json/10-kernel-view.png)\n\nLe cœur de Symfony tourne autour d'un composant en particulier : _HttpKernel_. Tout au long de sa vie, la requête va passer par plusieurs étapes successives dans le noyau de Symfony.\n\nNous pouvons avoir cette liste:\n\n* kernel.request\n* kernel.controller\n* kernel.view\n* kernel.response\n* kernel.finish_request\n* kernel.terminate\n* kernel.exception\n\nPour référence, vous pouvez aller lire la description de chacun des événements : [http://symfony.com/doc/current/components/http_kernel.html](http://symfony.com/doc/current/components/http_kernel.html){:rel=\"nofollow noreferrer\"}\n\nPour mon exemple, ma fonctionnalité devra prendre en entrée le retour du contrôleur et renvoyer un objet _JsonResponse._ Pour cela, je vais me brancher sur l'événement **kernel.view**. Cet événement est situé juste après l'exécution du contrôleur, mais juste avant l'envoi de la réponse.\n\n## Création d'un service\n\nAprès avoir récupéré toutes mes données depuis le contrôleur, je retourne un tableau.\n\n```php\n<?php\n\nnamespace AppBundle\\Controller;\n\nclass FooController\n{\n    public function getAction()\n    {\n        (...some logics)\n\n        return [\n            \"id\" => 42\n            \"foo\" => \"bar\",\n        ];\n    }\n}\n```\n\nEn l'état, symfony va lever une exception car il ne saura pas quoi faire du tableau. Je vais donc créer un écouteur pour transformer ce tableau. C'est une simple classe PHP.\n\n```php\n<?php\n\nnamespace AppBundle\\EventListener;\n\nuse Symfony\\Component\\HttpKernel\\Event\\GetResponseForControllerResultEvent;\n\nclass JsonListener\n{\n    public function onKernelView(GetResponseForControllerResultEvent $event)\n    {\n        $data = $event->getControllerResult();\n\n        if (is_array($data)) {\n            $event->setResponse(new JsonResponse($data));\n        }\n    }\n}\n```\n\nL'événement kernel.view passe en argument un objet de type _[Symfony\\Component\\HttpKernel\\Event\\GetResponseForControllerResultEvent](http://api.symfony.com/3.1/Symfony/Component/HttpKernel/Event/GetResponseForControllerResultEvent.html)._ J'ai accès au retour du contrôleur avec _getControllerResult(){:rel=\"nofollow noreferrer\"}._\n\nJe fais une simple vérification sur le type avant de créer la réponse: ici JsonResponse. Une fois la réponse créé, j'affecte l'objet à la méthode _setResponse()_ de l'événement.\n\nAvec cet écouteur, je transforme un tableau en une réponse JSON.\n\n## Branchement à l'événement\n\nUne fois la classe créée, il faut la déclarer en tant que service et taguer le service.\n\n```xml\n<!-- app/config/services.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<container xmlns=\"http://symfony.com/schema/dic/services\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd\">\n\n    <services>\n        <service id=\"app.view.json_listener\" class=\"AppBundle\\EventListener\\JsonListener\">\n            <tag name=\"kernel.event_listener\" event=\"kernel.view\" />\n        </service>\n    </services>\n</container>\n```\n\nJe tague le service avec le nom _kernel.event_listener_ et avec l'événement _kernel.view_.\n\nTout est bien branché. Lorsque je vais aller sur la route pour accéder au contrôleur, je vais avoir une réponse au format json.\n\nCette méthode est pratique lors de la création de webservice. Avec la réponse d'une requête en base de données, le résultat est souvent un tableau. Il suffit juste de faire un _return_ du résultat de la requête sans avoir à créer un objet _JsonResponse_. Autre avantage donc, cette méthode permet d'éclaircir le code et vous évite la création systématique d'un objet _JsonResponse._\n\n## Références :\n\n* [http://symfony.com/doc/current/event_dispatcher.html](http://symfony.com/doc/current/event_dispatcher.html){:rel=\"nofollow noreferrer\"}\n* [http://api.symfony.com/3.1/Symfony/Component/HttpKernel/Event/GetResponseForControllerResultEvent.html](http://api.symfony.com/3.1/Symfony/Component/HttpKernel/Event/GetResponseForControllerResultEvent.html){:rel=\"nofollow noreferrer\"}\n* [http://symfony.com/doc/current/reference/dic_tags.html#kernel-event-listener](http://symfony.com/doc/current/reference/dic_tags.html#kernel-event-listener){:rel=\"nofollow noreferrer\"}\n"}