{"date":"2016-06-29T00:00:00.000Z","title":"Le cache HTTP, votre meilleur ami","excerpt":"e suis actuellement Lead développeur pour un site de presse Français à très fort trafic (lemonde.fr). Au cours de mes expériences précédentes, j'ai pu développer sur plusieurs autres sites à forte volumétrie.","readingTime":"12mn","authors":["captainjojo"],"categories":["php","javascript"],"content":"\nJe suis actuellement Lead développeur pour un site de presse Français à très fort trafic ([lemonde.fr](http://www.lemonde.fr)){:rel=\"nofollow noreferrer\"}. Au cours de mes expériences précédentes, j'ai pu développer sur plusieurs autres sites à forte volumétrie.\n\nQuand avec seulement une dizaine de serveurs vous devez contenir des pics de trafic entre 100 000 et 300 000 visiteurs instantanés, le cache n'est plus optionnel. Il devient une véritable nécessité. Votre application peut avoir les meilleures performances, vous serez toujours limités par vos machines physiques -même si ce n'est plus vrai dans le cloud (avec un budget illimité)- le cache doit donc devenir votre ami.\nAvec l'expérience que j'ai pu accumuler sur le sujet et les nombreux pièges dans lesquels je suis tombé, je vais tenter de vous donner les meilleurs solutions d'utilisation des différents caches.\n\nVous avez souvent dû entendre dire, ou dire vous-même \"vide ton cache\", lors du test des fonctionnalités de votre site web. Vous devez même connaître les touches suivantes par cœur :\n\n<table class=\"wikitable\">\n<tbody>\n<tr>\n<th>Navigateurs</th>\n<th>Raccourcis clavier</th>\n</tr>\n<tr>\n<td><a class=\"mw-redirect\" title=\"Firefox\" href=\"https://fr.wikipedia.org/wiki/Firefox\">Firefox</a></td>\n<td><kbd>Ctrl</kbd> + <kbd>F5</kbd></td>\n</tr>\n<tr>\n<td><a title=\"Chrome\" href=\"https://fr.wikipedia.org/wiki/Chrome\">Chrome</a></td>\n<td><kbd>Ctrl</kbd> + <kbd>F5</kbd> ou <kbd>Maj</kbd> + <kbd>F5</kbd> ou <kbd>Ctrl</kbd> + <kbd>Maj</kbd> + <kbd>N</kbd></td>\n</tr>\n<tr>\n<td><a class=\"mw-redirect\" title=\"Safari (logiciel)\" href=\"https://fr.wikipedia.org/wiki/Safari_(logiciel)\">Safari</a></td>\n<td><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>E</kbd></td>\n</tr>\n<tr>\n<td><a title=\"Internet Explorer\" href=\"https://fr.wikipedia.org/wiki/Internet_Explorer\">Internet Explorer</a></td>\n<td><kbd>Ctrl</kbd> + <kbd>F5</kbd></td>\n</tr>\n<tr>\n<td><a title=\"Opera\" href=\"https://fr.wikipedia.org/wiki/Opera\">Opera</a></td>\n<td><kbd>Ctrl</kbd> + <kbd>F12</kbd></td>\n</tr>\n</tbody>\n</table>\nsource: https://fr.wikipedia.org/wiki/Cache_web\n\nRassurez-vous, il y a une solution : le but de cet article est de vous permettre d'enfin apprivoiser le cache HTTP.\n\n### Le principe du cache HTTP\n\nLe cache HTTP utilise le même principe que n'importe quel cache, il s'agit simplement d'un enregistrement clé/valeur.\n\n> Comment est choisie la clé ? Et quelle est la valeur ?\n\nLa clé est une valeur unique qui permet de reconnaître une page web, vous commencez sans doute à comprendre qu'il s'agit bien évidemment de l'url. La valeur stockée quant à elle, est le contenu de votre page dans tous les formats possibles (text, html, json, etc ...).\nLe cache HTTP permet beaucoup de choses que nous verrons au fur et à mesure de l'article.\n\n> Mais comment utiliser toutes ces fonctionnalités ?\n\nIl vous suffit de regarder ce que contient une requête HTTP. En version simple, une requête contient un header et un contenu. Le contenu est ce que le navigateur affiche, le plus souvent, il s'agit de votre page html. Le header, quant à lui, contient toutes les informations essentielles de la page, la plus connue étant le \"status code\"  permettant de savoir le statut de la page (200 OK, 404 Not Found, 500 Error), mais c'est aussi le lieu de la configuration de votre cache HTTP. De nombreux header peuvent être changés pour améliorer et configurer votre cache.\n\n### Configurer votre cache HTTP\n\nMaintenant que nous savons où nous devons configurer notre cache,\n\n> Que pouvons-nous configurer ?\n\nD'abord, activons le cache pour notre page. Pour cela, nous devons ajouter le header.\n\n```\nCache-Control: public\n```\nIl existe d'autres paramètres pour ce header que je vous invite à retrouver sur  https://fr.wikipedia.org/wiki/Cache-Control, un des plus utilisés est le\n\n```\nCache-Control: no-store\n```\npermettant de désactiver le cache sur la page.\nNous pouvons désormais configurer le temps de cache de la page, c'est ce que l'on appelle le TTL de la page. Pour cela, le header à changer est le suivant :\n\n```\nmax-age: 300\n```\n\n300 étant un temps de cache donné en seconde.\nVous pouvez trouvez dans certaines documentations disponibles un header très ressemblant :\n\n```\ns-max-age: 300\n```\n\nIl a la même utilité que le header max-age mais permet d'être utilisé sur un proxy (varnish par exemple) et donc avec un TTL différent pour le CDN et le proxy.\nVous pouvez aussi choisir une date d'expiration ce qui permet d'être encore plus précis avec le cache, le header est simple :\n\n```\nExpires: Thu, 25 Feb 2016 12:00:00 GMT\n```\n\nAvec ces trois header, vous pouvez déjà utiliser le cache avec une bonne précision, en gérant vos TTL et expirations, vous pouvez faire vivre vos pages et les laisser se décacher toutes seules.\n\n> Mais comment les décacher à volonté ?\n\nLe cache HTTP a une fonctionnalité très intéressante permettant de demander au serveur de calculer s'il doit renvoyer une nouvelle page. Pour l'utiliser, il suffit de remplir un nouveau header lors de la génération de la page.\n\n```\nLast-Modified: Wed, 25 Feb 2015 12:00:00 GMT\n```\n\nLe client (votre navigateur) envoie quant à lui un header dans sa requête au serveur .\nSi le serveur renvoie une date plus récente que celle du client alors le client prend la nouvelle page. Sinon, il garde la page dans le cache.\nCela permet aussi de gérer la réponse 304 qui permet au serveur de n'envoyer que le header de la réponse (soit un contenu vide) qui réduit la bande passante utilisée par le serveur. Pour cela, le serveur doit avoir l'intelligence de lire le header Last-modified et dans le cas ou la nouvelle date générée n'est pas plus récente, il peut renvoyer une requête HTTP 304 permettant au client de garder son cache.\nIl existe un autre header ayant le même principe, il s'agit du header Etag, qui se configure avec un 'string' généré par le serveur qui change selon le contenu de la page.\n\n```\nEtag: home560\n```\n\nAttention, le calcul de l'etag doit être très réfléchi puisqu'il régit le temps de cache de la page, il doit donc être calculé avec les données dynamiques de la page.\nComme expliqué dans le premier chapitre, la clé du cache HTTP est l'url de la page. Cela peut être gênant si votre page est dynamique selon l'utilisateur car l'url sera la même, mais le contenu sera différent. Il faut donc cacher plusieurs contenus pour une url. Heureusement, [Tim Berners-Le](https://fr.wikipedia.org/wiki/Tim_Berners-Lee){:rel=\"nofollow noreferrer\"}, l'inventeur du protocole HTTP a prévu le cas en ajoutant le header :\n\n```\nVary: Cookie User-agent\n```\n\nComme son nom l'indique, il permet de faire varier le cache en utilisant un autre header, par exemple 'User-agent' qui permet de stocker pour une url toutes les pages pour chaque user-agent (exemple page mobile, page desktop). Le Cookie permet de stocker une page par cookie (donc par utilisateur).\nNous venons de faire un tour plutôt complet des configurations possibles pour le cache HTTP, mais il est aussi possible d'ajouter ses propres header. Avant d'avancer sur ce sujet, nous allons réfléchir à l'architecture du cache HTTP.\n\n### L'architecture classique du cache HTTP\n\nVous savez configurer votre cache comme un professionnel.\n\n> Mais où placer votre cache ?\n\nLe cache HTTP peut être utilisé à plusieurs endroits dans votre architecture, chaque endroit a des spécificités et permet une amélioration des performances.\n\n\n#### Le navigateur\n\nC'est le cache HTTP le plus proche de votre utilisateur : ce qui lui permet d'être très rapide. Le seul souci est qu'il est lié avec l'utilisateur, il peut donc être vide assez souvent, exemple lors de la première connexion. Il peut aussi être vidé par l'utilisateur ou même désactivé. La résilience de ce cache ne vous est donc pas imputée, ce dernier doit donc être couplé avec un autre cache HTTP.\n\n#### Le CDN\n\nLe Content Delivery Network est un réseau d'ordinateurs permettant de servir du contenu (https://fr.wikipedia.org/wiki/Content_delivery_network). Il est externe à l'architecture et sa spécialité est la géolocalisation, il permet donc à un utilisateur d'aller sur le CDN le plus proche. Vous en avez surement déjà utilisé un quand vous utilisez un tag js, exemple jquery, angular etc ..., et que vous utilisez l'url fournie plutôt que le fichier téléchargé.\nL'avantage principal du CDN est d'avoir de nombreux serveurs à travers le monde et de vous permettre de ne pas recevoir l'ensemble du trafic du site sur vos serveurs. Si vous avez déjà travaillé pour un site à fort trafic, le CDN est le meilleur moyen de ne pas maintenir 10 000 serveurs pour votre application. Le coût d'un CDN est souvent lié à la bande passante, il est donc important de cacher seulement ce dont vous avez besoin et d'utiliser le plus de 304 possible.\n\n### Le proxy cache, Varnish\n\nIl agit comme le CDN et ce dernier appartient à l'architecture. Il s'agit souvent de serveurs que vous maintenez, il demande beaucoup de RAM (le stockage y est fait). Le varnish ou autre technologie de cache permet des configurations plus fines qu'un CDN et surtout permet d'utiliser ses propres header. Il permet aussi d'utiliser les ESI que nous verrons dans le prochain chapitre. (Akamai l'inventeur des ESI est un CDN)\n\n#### Web serveur\n\nLe web serveur aussi permet d'utiliser le cache HTTP, on l'utilise généralement pour le cache des assets (js, css, images, etc ...). Comme le varnish, son avantage est d'être configurable très finement.\n\n![Architecture Http](/imgs/posts/2016-06-29-le-cache-http-votre-meilleur-ami/untitled.png)\n\n### Personnaliser votre cache HTTP\n\nL'avantage du cache HTTP est que son utilisation est très simple, et que la plupart des frameworks web mettent en place des interfaces simples pour utiliser ce dernier. Malgré un nombre de fonctionnalités très important, nous avons toujours besoin de plus, c'est pour cela que lors d'un projet sur un site à fort trafic, on place deux header varnish personnalisés qui peuvent aider.\n\n#### Le catalogue\n\n```\nX-Varnish-Catalog: |home|345|567|\n```\n\nIl s'agit d'un header qui référence votre page, soit par terme (home, page, etc ...), soit par id d'objet.\n\n> Mais pourquoi faire ?\n\nParce que cela vous permet de facilement trouver toutes les pages stockées dans varnish et qui référencent un objet particulier, si vous pouvez les trouver, vous pouvez les supprimer, et donc générer un cache. Il faut pour cela configurer varnish pour réaliser un ban d'une url. Voici un petit code simple à mettre en place :\n\n\n```javascript\n# Ban - Catalogue decache\n#\n# How to ban all objects referencing <my_tag> in the X-Cache-Varnish-Catalog header\n#       curl -X BAN http://<varnish_hostname>/uncache/<my_tag>\n# Object header ex. : X-Cache-Varnish-Catalog: |1235|9756|546|687|37436543|<my_tag>|region-centre|\nif (req.method == \"BAN\") {\n    if (!client.ip ~ invalidators) {\n        return (synth(405, \"Ban not allowed\"));\n    }\n\n    if (req.url ~ \"^/uncache/\") {\n        ban(\"obj.http.X-Cache-Varnish-Catalog ~ |\" + regsub(req.url, \"^/uncache/([-0-9a-zA-Z]+)$\", \"\") + \"|\");\n        return (synth(200, \"Banned with \" + req.url));\n    }\n\n    return (synth(200, \"Nothing to ban\"));\n}\n```\n\n#### Le grace\n\n``` X-Varnish-Grace: 300```\n\nComme le max-age, vous devez lui donner un temps en seconde. Ce petit header permet de gagner encore plus en performance. Il dit à votre varnish le temps acceptable pour renvoyer un cache même après l'expiration du max-age.\n\nPour mieux comprendre, voici un exemple :\nPrenons la page /home qui à pour header :\n\n```\nCache-control: public\nmax-age: 300\nX-varnish-grace: 600\n```\n\nImaginons que varnish a la page dans son cache, si un utilisateur arrive à la 299ème seconde, varnish renvoie directement le cache.\n\n> Mais que se passe t-il à la 301ème seconde ?\n\nS'il n'y avait pas le Grace, <span class=\"s1\">varnish serait obligé d'appeler directement le serveur pour obtenir la réponse à renvoyer à l'utilisateur.</span> Mais avec le Grace, varnish va renvoyer son cache et demander au serveur un nouveau contenu, ce qui permet de ne pas avoir de temps de latence pour l'utilisateur.\n\n> Et maintenant à la 601ème seconde ?\n\nFacile, votre page est expiré la requête arrive directement sur votre serveur.\nVoici la configuration pour varnish :\n\n```javascript\nsub vcl_backend_response {\n   # Happens after we have read the response headers from the backend.\n   #\n   # Here you clean the response headers, removing silly Set-Cookie headers\n   # and other mistakes your backend does.\n   # Serve stale version only if object is cacheable\n   if (beresp.ttl > 0s) {\n       set beresp.grace = 1h;\n   }\n   # Objects with ttl expired but with keep time left may be used to issue conditional (If-Modified-Since / If-None-Match) requests to the backend to refresh them\n   #set beresp.keep = 10s;\n   # Custom headers to give backends more flexibility to manage varnish cache\n   if (beresp.http.X-Cache-Varnish-Maxage) {\n       set beresp.ttl = std.duration(beresp.http.X-Cache-Varnish-Maxage + \"s\", 3600s);\n   }\n   if (beresp.http.X-Cache-Varnish-Grace &amp;&amp; beresp.ttl > 0s) {\n       set beresp.grace = std.duration(beresp.http.X-Cache-Varnish-Grace + \"s\", 3600s);\n   }\n}\n```\n\n### Les ESI\n\nVous êtes désormais un expert dans l'utilisation du cache HTTP, il ne reste plus qu'une chose à comprendre : les ESI.\nEdge Side Include (ESI) permet d'utiliser toute la puissance de varnish. Comme indiqué plus haut, cette technologie fut inventée par [Akamai](https://www.akamai.com/fr/){:rel=\"nofollow noreferrer\"}, l'un des plus célèbres CDN.\n\n> À quoi ça sert ?\n\nLe problème le plus simple est le suivant.\nSur chacune des pages, vous avez un bloc de pages qui est toujours le même mais vous devez le changer souvent. La solution est de décacher l'ensemble des pages contenant le bloc, cela pourra très vite devenir embarrassant car vos serveurs vont alors être trop souvent sollicités.\nLes ESI servent dans cette situation. Il s'agit seulement d'une page avec son cache propre que l'on peut intégrer dans une autre via une balise HTML.\n\n```html\n//home.html\n<html>\n<body>\n<esi url='block.html'/>\nTest\n</body>\n</html>\n```\n\nVarnish va reconnaître l'utilisation d'un ESI et va donc cacher deux objets, l'un pour la page complète avec les informations de cache de la page et l'un pour ESI avec d'autres informations de cache. Vous pouvez alors décacher seulement l'ESI et varnish va mettre à jour un seul objet (une seule demande au serveur), l'utilisateur a tout de même toutes les pages mises à jour.\n\nPour plus d'informations, je vous invite à aller voir un ancien [article](https://blog.eleven-labs.com/symfony-2-cache-http-esi/){:rel=\"nofollow noreferrer\"} , qui explique une implémentation pour Symfony.\nVous pouvez aussi retrouver une présentation sur le cache HTTP et Symfony [ici](https://docs.google.com/presentation/d/1RVr_JfpFKVRXdg4hy6war3OfiSJtdeYzFsdxhn2t0NY/edit?usp=sharing){:rel=\"nofollow noreferrer\"}.\n"}