{"date":"2018-11-07T00:00:00.000Z","title":"Débutons avec le Serverless","excerpt":"Vous avez un nouveau projet personnel ou professionnel, vous ne voulez pas vous prendre la tête avec l’infrastructure, et vous souhaitez payer seulement pour les ressources utilisées ? Serverless est fait pour vous !","readingTime":"7mn","authors":["flemzord"],"categories":["architecture"],"content":"\nVous avez un nouveau projet personnel ou professionnel, vous ne voulez pas vous prendre la tête avec l’infrastructure, et vous souhaitez payer seulement pour les ressources utilisées ? Serverless est fait pour vous !\n\nAvant de vous lancer directement dans un cas concret sur l’utilisation du framework serverless, nous allons commencer par revenir sur les notions et la définition de serverless.\n\n## Que veut réellement dire serverless ?\n\nDans le monde du cloud et du devops, il n’y a pas une seule et unique définition. Je vais donc vous donner la mienne.\n\nNous pouvons considérer que si nous n’avons pas de gestion de serveur, alors nous sommes dans le monde du Serverless. Cela voudrait dire que des services comme AWS Elastic Beanstalk, Google App Engine, Heroku, Clever Cloud qui sont des services PaaS pourraient être compris dans cette définition.\n\nCependant, nous allons souvent plus loin dans la définition du serverless. Il y a bien le côté de non-gestion des serveurs, mais aussi de pay-as-you-go. Il n’y a plus de frais fixes pour maintenir votre infrastructure disponible, mais seulement des coûts liés à l’utilisation de celle-ci. Des services comme AWS Lambda ou Google Cloud Functions rentrent parfaitement dans cette catégorie.\n\n## Le framework serverless, il sert à quoi ?\n\n[Serverless](https://serverless.com/) est un des outils les plus connus à ce jour, il est compatible avec les solutions Cloud suivantes : AWS, IBM OpenWhisk, Microsoft Azure, GCP, Kubeless, Spotinst, Webtask. Serverless est agnostique du langage dans lequel vous souhaitez développer. Cependant, si votre provider ne supporte pas votre langage, cela pourrait ne pas fonctionner. L’ensemble des providers supporte deux langages : NodeJS et Python.\nMais il est aussi capable d’aller beaucoup plus loin grâce à un système de plugins. Ainsi, vous pouvez démarrer vos fonctions en local sur votre machine en simulant le fonctionnement d’API Gateway et Lambda, ou encore avoir une base DynamoDB locale pour vos développements.\n\n## Comment fonctionne le framework serverless\n\nQuand on cherche à déployer avec serverless, celui-ci va lire notre fichier serverless.yml et le convertir en [CloudFormation](https://aws.amazon.com/fr/cloudformation/). Le code vas être zippé puis uploade sur S3. CloudFormation lors de son lancement va récupérer les fichiers sur S3 pour alimenter les fonctions Lambda, et créer / modifier / supprimer les resources nécessaires (rôles, lambda, dynamodb...).\n\n### Prenons un cas concret\n\nNous allons déployer sur AWS une API GraphQL qui utilise une base de donnée DynamoDB. Nous allons découper le fichier serverless.yml et comprendre le fonctionnement de chacun des blocks.\n```yaml\nservice: factory-api\n\nframeworkVersion: \">=1.21.0 <2.0.0\"\n\nprovider:\n name: aws\n region: eu-west-3\n runtime: nodejs8.10\n environment:\n   DYNAMODB_TABLE_TEMPLATE: ${self:service}-${opt:stage, self:provider.stage}-template\niamRoleStatements:\n   - Effect: Allow\n     Action:\n       - dynamodb:Query\n       - dynamodb:Scan\n       - dynamodb:GetItem\n       - dynamodb:PutItem\n       - dynamodb:UpdateItem\n       - dynamodb:DeleteItem\n     Resource: \"arn:aws:dynamodb:${opt:region, self:provider.region}:*:table/${self:provider.environment.DYNAMODB_TABLE_TEMPLATE}\"\n```\nVotre fichier de description doit commencer par un “service” qui porte le nom de votre projet.\nPuis vous allez configurer votre provider. Dans notre cas, nous souhaitons utiliser AWS sur la région de Paris (eu-west-3). Notre fonction lambda tournera avec un NodeJS 8.10. Nous voulons aussi ajouter une variable d’environnement à nos lambdas (DYNAMODB_TABLE_TEMPLATE).\nNous avons aussi besoin que notre Lambda communique avec DynamoDB de façon automatique et sans devoir stocker des credentials AWS. Pour cela nous allons utiliser un Rôle AWS.\n```yaml\npackage:\n exclude:\n   - docs/**\n   - helpers/**\n   - node_modules/**\n   - test/**\n```\nQuand on demande un déploiement à Serverless, celui-ci va créer un répertoire temporaire, et copier le code ainsi que les dépendances de celui-ci.\nDans son comportement par défaut, il copie l’ensemble du répertoire dans le répertoire temporaire, mais nous pourrions vouloir exclure certains dossiers (comme dans cet exemple).\n```yaml\nplugins:\n - serverless-offline\n - serverless-webpack\n - serverless-domain-manager\n - serverless-dynamodb-local\n - serverless-prune-plugin\n```\nNous pouvons ajouter des plugins pour améliorer et / ou changer le comportement de serverless :\n- serverless-offline : nous permet d’avoir en local un environnement simulant le fonctionnement de Lambda et API Gateway\n- serverless-webpack : nous permet de compiler le code NodeJS\n- serverless-domain-manager : nous permet de gérer nos domaines et certificats pour les rattacher directement à notre API Gateway\n- serverless-dynamodb-local : nous permet d’avoir une base de donnée DynamoDB en local pour nos développements, cela nous permet aussi de faire des développements en offline\n- serverless-prune-plugin : nous permet de nettoyer au fur et à mesure les ressources non utilisées, ainsi nous ne gardons pas tout notre historique sur les lambdas, mais seulement les 3 dernières.\n\n```yaml\ncustom:\n prune:\n   automatic: true\n   number: 3\n domains:\n   preprod: \"preprod-api.aws.eleven-labs.com\"\n   prod: \"api.aws.eleven-labs.com\"\n certificate:\n   preprod: \"*.aws.eleven-labs.com\"\n   prod: \"*.aws.eleven-labs.com\"\n serverless-offline:\n   port: 4000\n webpackIncludeModules: true\n customDomain:\n   domainName: \"${self:custom.domains.${opt:stage}}\"\n   stage: \"${opt:stage}\"\n   certificateName: \"${self:custom.certificate.${opt:stage}}\"\n   createRoute53Record: true\n   endpointType: 'regional'\n dynamodb:\n   start:\n     host: dynamodb\n     migrate: true\n     noStart: true\n   migration:\n     dir: offline/migrations\n```\nQuand on ajoute des plugins, il est souvent nécessaire d’ajouter de la config supplémentaire. Il faut alors l’ajouter dans le block custom, et suivre la documentation de chaque plugin :)\n```yaml\nfunctions:\n graphql:\n   runtime: nodejs8.10\n   handler: index.graphqlHandler\n   events:\n     - http:\n         path: graphql\n         method: get\n         cors: true\n     - http:\n         path: graphql\n         method: post\n         cors: true\n```\nLe block functions nous permet de définir les lambdas que nous souhaitons créer avec leurs spécificités.\n```yaml\nresources:\n Resources:\n   dynamodbTemplate:\n     Type: 'AWS::DynamoDB::Table'\n     DeletionPolicy: Retain\n     Properties:\n       AttributeDefinitions:\n         -\n           AttributeName: id\n           AttributeType: S\n       KeySchema:\n         -\n           AttributeName: id\n           KeyType: HASH\n       ProvisionedThroughput:\n         ReadCapacityUnits: 1\n         WriteCapacityUnits: 1\n       TableName: ${self:provider.environment.DYNAMODB_TABLE_TEMPLATE}\n\n```\nNous pouvons demander à Serverless de créer des ressources supplémentaires sur AWS, dans notre cas, nous allons créer une table DynamoDB.\n\nComme nous avons pu le voir, avec un seul fichier, nous sommes capable de déployer l’infrastructure nécessaire au fonctionnement de notre projet, mais aussi simplifier la vie de nos développeurs.\n\nMaintenant, vous êtes capables de déployer votre projet via le framework serverless, cependant, vous pourriez vouloir aller plus loin. Pourquoi ne pas ajouter une queue SQS ? Voire même des lambdas qui se lancent automatiquement lors d’un nouveau message dans SQS ? (Je vous recommande de regarder du côté des triggers sur SQS et Lambda).\n"}