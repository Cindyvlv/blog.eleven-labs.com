{"date":"2018-03-28T00:00:00.000Z","title":"GraphQL, kesako ?","excerpt":"Dans nos architectures micro-services, l'un des nouveaux défis est de réussir à récupérer les données stockées dans les différents micro-services le plus facilement possible. Pour résoudre ce défi, je vous propose d'utiliser GraphQL. Cette technologie qui est devenu un des buzz word du moment est en vrai très simple à mettre en place. Ne voulant pas faire de jaloux je vous propose de réaliser deux serveurs GraphQL l'un en PHP et l'autre en NodeJs.","readingTime":"6mn","authors":["captainjojo"],"categories":["javascript"],"content":"Dans nos architectures micro-services, l'un des nouveaux défis est de réussir à récupérer les données stockées dans les différents micro-services le plus facilement possible.\n\nPour résoudre ce défi, je vous propose d'utiliser GraphQL. Cette technologie qui est devenu un des buzz word du moment est en vrai très simple à mettre en place. Ne voulant pas faire de jaloux je vous propose de réaliser deux serveurs GraphQL l'un en PHP et l'autre en NodeJs.\n\n## GraphQL c'est quoi ?\n\nGraphQL est un langage de requête initié par Facebook en 2012 et développé en 2015. [Facebook Manifest](http://facebook.github.io/graphql/October2016/). GraphQL permet de se plugguer à n'importe quel type de base de données ou d'API. Le but de GraphQL est de décrire les données et les fonctions disponibles entre les applications client-server.\n\nGraphQL **ne stocke donc pas** de données. Il va seulement décrire la donnée et savoir comment aller la récupérer sur vos différentes applications backend.\n\nLa communication sur un serveur GraphQL se fait en `json` à la fois pour l'entrée et la sortie.\n\nLe principal intérêt de GraphQL est donc d'en faire une API-Gateway qui va devenir votre seul point d'entrée pour récupérer toutes vos données très simplement.\n\nLe serveur GraphQL aura la charge d'aller chercher les données selon la query. Ce qui permet pour une même requête d'aller chercher la donnée dans plusieurs types de bases de données (exemple: dans un PostgreSQL, dans une API, etc ...)\n\nIl est possible de faire un serveur GraphQL dans n'importe quelle technologie, il suffit de suivre le manifest de Facebook.\n\nDans n'importe quelle technologie les étapes de construction d'un serveur GraphQL sont les suivantes.\n\n## GraphiQL\n\nTout d'abord il faut installer l'IDE de GraphQL, GraphiQL. Ce dernier se place devant un serveur GraphQL et permet :\n\n - de tester les requêtes en live\n - de générer une documentation\n - d'utiliser l'ensemble des fonctionnalités d'un serveur GraphQL (exemple : variables)\n\nL'installation est assez simple, il vous suffit de suivre le tutoriel [suivant](https://github.com/graphql/graphiql/tree/master/example).\n\n\n## Serveur\n\nUne fois l'IDE choisi, à vous de choisir le serveur que vous souhaitez utiliser. Il existe de nombreux serveurs différents. Dans cet article j'utilise le serveur de base en nodeJS ([Express GraphQL](http://graphql.org/graphql-js/running-an-express-graphql-server/)), c'est à vous de choisir.\nDans le cadre de projet plus poussé j'utilise soit :\n\n- en Symfony le bundle [Overblog](https://github.com/overblog/GraphQLBundle)\n- en node le framework [apollo](https://www.apollographql.com/)\n\n## Les types\n\nLa première chose à faire est de déclarer les types de données que vous souhaitez requêter.\n\nComme pour une base de données classique vous avez accès à des types `Scalar`:\n\n - `Int` un entier\n - `Float` un double\n - `String` une chaîne de caractères\n - `Boolean` un booléen\n - `ID` représente un identifiant unique\n\nVous pouvez utiliser le type `Enum` qui est considéré comme un `scalar` et permet de valider les valeurs d'un argument.\n\n```json\nenum Status {\n\tONLINE\n\tERROR\n\tREVIEW\n}\n```\n\nIl est aussi possible de gérer des `list` de `scalar` ou d'`type` . Pour cela il suffit de mettre en place des `[]`.\n\nDans l'ensemble des cas, vous pouvez choisir de forcer le `non-null` en ajoutant un `!` à la fin du typage.\n\nLa création d'un nouveau type se fait via le mot clé `type`.\n\n```json\ntype Article {\n  name: String!\n  status: Status!\n}\n```\n\nComme pour des objets dans un langage orienté objet, vous pouvez utiliser des interfaces via le mot clé `interface`.\n\n```json\ninterface Publish {\n  id: ID!\n  name: String!\n  createdAt: Date\n}\n```\n\nEt donc l'utiliser dans vos types :\n\n```json\ntype Article implements Publish {\n  content: String!\n}\n```\n\nUne fois l'ensemble de vos types définis, vous devez définir les types principaux :\n\n - query\n - mutation\n\n### Query\n\nLe type `query` représente l'ensemble des fonctions utilisables pour la récupération des données.\n\nChaque `query` peut prendre des paramètres et renvoie un `type`.\n\nExemple:\n\n```json\ntype Query {\n  article(id: ID!): Article\n  articles(): [Article]\n}\n```\n\n### Mutation\n\nComme dans une API rest la mutation permet d'effectuer des changements dans votre base de données.\n\nElle se configure comme la `query` il faut définir la fonction avec ses paramètres et sa sortie.\nLes paramètres d'une mutation sont de type `input`.\n\nLe type `input` se configure comme un type classique en utilisant le mot clé `input`.\n\n```json\ninput ArticleInput {\n  id: Int!\n  title: String\n}\n```\n\nVous pouvez utiliser vos inputs dans vos mutations.\n\n```json\nsaveArticle(input: ArticleInput!): Article\n```\n\n## Resolver\n\nMaintenant que vos types sont faits, il faut dire à GraphQL comment aller chercher vos données.\nDans chaque librairie, il vous faut configurer ce que l'on appelle un `resolver`.\n\nChaque `resolver` est une fonction qui permet d'aller chercher la donnée au bon endroit.\n\nLa magie des serveurs GraphQL est de savoir que la donnée a déjà été chargée et ne pas la recharger. C'est aussi de permettre via une seule requête GraphQL d'aller chercher dans plusieurs bases.\n\n## Les plus vs les moins\n\nRegardons rapidement les avantages et inconvenients de cette tehcnologie.\n\n### Les moins\n\nLe gros moins de l'utilisation de GraphQL est que l'ensemble des queries se font en POST sur un seul endpoint. Elle ne sont donc *pas cachées*.\n\nComme le cache HTTP utilise l'url comme clé de cache, il n'est pas possible d'utiliser votre cache navigateur.\n\nL'un des biais que propose GraphQL c'est de faire du cache applicatif qui permet d'éviter l'appel vers les bases de données mais pas le call HTTP.\n\nLe second moins est qu'il faut souvent réécrire l'ensemble de vos types que vous avez certainement dû faire pour votre ORM.\n\nLe troisième point faible est la diffuculté de mettre en place une authentification via GraphQL?\n\nLe dernier problème est la difficulté de monitorer le serveur GraphQL, même si maintenant il existe [Apollo Engine](https://www.apollographql.com/engine)\n\n### Les plus\n\nGraphQL permet de mettre en place facilement une API Gateway. Il permet d'avoir un unique point d'entrée pour l'ensemble de vos applications.\n\nPrenons l'exemple de données séparées dans deux API, d'un coté les utilisateurs et de l'autre les articles.  Vous pouvez en *une seule requête* GraphQL récupérer l'ensemble des articles qu'un utilisateur aurait lus.\n\nLe point sympathique est que la documentation se fait automatiquement dans l'IDE tel que GraphIQL qui aura même l'autocomplétion.\n\nLe plus majeur, c'est que c'est le front qui gère ce dont il a besoin, ce qui limite le nombre de calls HTTP. Il arrive assez couramment que pour afficher une page complexe avec une API Rest il faut 7 ou 8 call API, avec GraphQL c'est 1. Le gain de performance est donc assez sympa.\n\n## Conclusion\n\nGraphQL est une technologie ayant de nombreux avantages. GraphQL est très appréciable lors de son utilisation avec des frameworks javascript tel que React et Angular.\n\nJe vous invite desormais à lire les deux Codelabs suivant:\n\n - [Utiliser GraphQL avec apollo](https://codelabs.eleven-labs.com/course/fr/graphql-avec-apollo/)\n - [Utiliser GraphQL avec Symfony](https://codelabs.eleven-labs.com/course/fr/graphql-avec-symfony/)\n"}