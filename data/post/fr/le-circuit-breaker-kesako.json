{"date":"2016-12-14T00:00:00.000Z","title":"Le circuit breaker Késako ?","excerpt":"Aujourd'hui les architectures micro-services sont de plus en plus répandues. Mais quels sont les moyens de contrôler votre nouveau système d'information ?","readingTime":"27mn","authors":["captainjojo"],"categories":["php"],"content":"\nAujourd'hui les architectures micro-services sont de plus en plus répandues. Mais quels sont les moyens de contrôler votre nouveau système d'information ?\n\nMettons fin au mystère dès maintenant, le circuit-breaker, c'est le **disjoncteur** de votre architecture micro-services. Mais comment cela fonctionne et pourquoi en aurions-nous besoin ?\n\n### Pourquoi j'ai besoin d'un disjoncteur ?\n\nPour expliquer l'utilité d'un disjoncteur, un peu d'histoire. C'est Thomas Edison qui apporte l'électricité dans nos foyers en 1879. Peu après la sortie de cette impressionnante invention, de nombreux accidents de surtension, tuent ou blessent de nombreuses personnes. C'est alors que Thomas Edison, et oui toujours lui, invente le disjoncteur : un mécanisme permettant de couper le courant lors d'un surtension avant que celui-ci détruise les éléments du circuit électrique. Aujourd'hui, le disjoncteur est un élément essentiel dans tout circuit électrique, il y a en dans les téléphones, les ordinateurs, les télévisions etc...\n\nMais quel parallèle avec notre architecture micro-services ? Il faut se représenter cette architecture comme un circuit électrique : Tous les services peuvent communiquer entre eux. conséquence, si un des services surchauffe, il risque de contaminer les autres. Il ne faut donc plus faire appel à lui. Et c'est ici que le circuit-breaker rentre en action.\n\n***Exemple:***\n\nUn service A fait appel à un service B.\n\n![](/imgs/posts/2016-12-14-le-circuit-breaker-kesako/untitled-drawing-1.png)\n\nSi le service B tombe ou est ralenti, sans circuit breaker la communication entre le service A et le service B continue.\n\n![](/imgs/posts/2016-12-14-le-circuit-breaker-kesako/untitled-drawing-1-1.png)\n\nLe service A peut alors être ralenti ou même tomber.\n\n![](/imgs/posts/2016-12-14-le-circuit-breaker-kesako/untitled-drawing-2.png)\n\nMais si vous avez un circuit-breaker, quand le service B tombe ou est ralenti, le circuit-breaker s'ouvre et stoppe la communication entre A et B.\n\n![](/imgs/posts/2016-12-14-le-circuit-breaker-kesako/untitled-drawing-3.png)\n\nCe qui permet au service A de prendre en charge la panne, et d'attendre que le service B soit relancé. Dans ce cas là le circuit-breaker se ferme et la communication recommence.\n\n![](/imgs/posts/2016-12-14-le-circuit-breaker-kesako/untitled-drawing-5.png)\n\n***Bonus***: L'intérêt est encore plus présent quand votre architecture est dans le cloud et que vous avez choisi un système d'autoscalling. Quand un service tombe ou est ralenti cela peut entraîner une plus forte demande du service, ce qui par effet de levier peut faire des demandes de création de machine et ne ferrons que sur-alimenter le cloud. Cela peut vite coûter cher !\n\nVous êtes désormais convaincu d'avoir besoin d'avoir un circuit-breaker, mais comment l'implémenter ? Nous allons en faire une en Symfony permettant de gérer un circuit-breaker minimum avec comme base une communication entre service utilisant Guzzle.\n\n### Implémentation en Symfony 3 :\nNous allons suivre le pattern suivant.\n\n![](/imgs/posts/2016-12-14-le-circuit-breaker-kesako/untitled-drawing-6.png)\n\nCe dont nous avons besoin :\n\n - un [event](http://symfony.com/doc/current/event_dispatcher.html){:rel=\"nofollow noreferrer\"} permettant d'envoyer le statut de la communication\n - un [listener](http://symfony.com/doc/current/event_dispatcher.html){:rel=\"nofollow noreferrer\"} permettant de récupérer l'événement précédent\n - un [service](http://symfony.com/doc/current/service_container.html){:rel=\"nofollow noreferrer\"} permettant de connaitre le statut du circuit-breaker\n - un [cache](https://symfony.com/blog/new-in-symfony-3-1-cache-component){:rel=\"nofollow noreferrer\"} permettant de stocker les informations du circuit-breaker\n\nNous allons commencer par l'event, pour cela rien de plus simple : nous devons envoyer le nom du service et le statut de la communication.\n\n```php\n<?php declare(strict_types=1);\n\nnamespace AppBundle\\Event;\n\nuse Symfony\\Component\\EventDispatcher\\Event;\n\nclass CircuitBreakerEvent extends Event\n{\n    /**\n     * @var string\n     */\n    private $key;\n\n    /**\n     * @var bool\n     */\n    private $status;\n\n    /**\n     * @param string $key\n     * @param bool $status\n     */\n    public function __construct(string $key, bool $status)\n    {\n        $this->key = $key;\n        $this->status = $status;\n    }\n\n    /**\n     * @return string\n     */\n    public function getKey() :string\n    {\n        return $this->key;\n    }\n\n    /**\n     * @return bool\n     */\n    public function getStatus() :bool\n    {\n        return $this->status;\n    }\n}\n```\n\nUne fois l'événement envoyé, il faut le récupérer dans un listener, qui servira de passe-plat vers le service du circuit-breaker.\n\n```php\n<?php declare(strict_types=1);\n\nnamespace AppBundle\\EventListener;\n\nuse AppBundle\\Event\\CircuitBreakerEvent;\nuse AppBundle\\Service\\CircuitBreakerService;\n\nclass CircuitBreakerListener\n{\n    /**\n     * @var CircuitBreakerService\n     */\n    private $circuitBreaker;\n\n    /**\n     * @param CircuitBreakerService $circuitBreaker\n     */\n    public function __construct(CircuitBreakerService $circuitBreaker)\n    {\n        $this->circuitBreaker = $circuitBreaker;\n    }\n\n    /**\n     * @param CircuitBreakerEvent $event\n     */\n    public function onCircuitBreaker(CircuitBreakerEvent $event)\n    {\n        $this->circuitBreaker->save($event->getKey(), $event->getStatus());\n    }\n}\n```\nOn n'oublie pas de mettre en place le listener dans la configuration des services.\n\n```yaml\nservices:\n    circuit.breaker.listener:\n        class: AppBundle\\EventListener\\CircuitBreakerListener\n        arguments: ['@circuit.breaker']\n        tags:\n            - { name: kernel.event_listener, event: circuit.breaker, method: onCircuitBreaker, priority: 1  }\n ```\n\nMaintenant nous allons mettre en place le service CircuitBreaker, qui permet de calculer le statut du circuit-breaker pour un service donné.\n\nNous allons d'abord initialiser le service avec les trois statuts possibles, nous allons aussi mettre en configuration le nombre d'essais en erreur possibles et le temps avant de relancer un appel.\n\n```php\n<?php declare(strict_types=1);\n\nnamespace AppBundle\\Service;\n\nuse Symfony\\Component\\Cache\\Adapter\\AbstractAdapter;\n\nclass CircuitBreakerService\n{\n    const OPEN = 'open';\n    const CLOSED = 'closed';\n    const HALFOPEN = 'half-open';\n\n    /**\n     * @var AbstractAdapter\n     */\n    private $cacheApp;\n\n    /**\n     * @var array\n     */\n    private $status;\n\n    /**\n     * @var int\n     */\n    private $threshold;\n\n    /**\n     * @var int\n     */\n    private $timeout;\n\n    /**\n     * @param AbstractAdapter $cacheApp\n     * @param int $threshold\n     * @param int $timeout\n     */\n    public function __construct(AbstractAdapter $cacheApp, int $threshold, int $timeout)\n    {\n        $this->cacheApp = $cacheApp;\n        $this->threshold = $threshold;\n        $this->timeout = $timeout;\n    }\n}\n```\n\nMaintenant nous allons créer la fonction \"save\" qui permet de prendre en compte  le statut de la dernière communication.\n\n```php\n<?php declare(strict_types=1);\n\nnamespace AppBundle\\Service;\n\nuse Symfony\\Component\\Cache\\Adapter\\AbstractAdapter;\n\nclass CircuitBreakerService\n{\n    const OPEN = 'open';\n    const CLOSED = 'closed';\n    const HALFOPEN = 'half-open';\n\n    /**\n     * @var AbstractAdapter\n     */\n    private $cacheApp;\n\n    /**\n     * @var array\n     */\n    private $status;\n\n    /**\n     * @var int\n     */\n    private $threshold;\n\n    /**\n     * @var int\n     */\n    private $timeout;\n\n    /**\n     * @param AbstractAdapter $cacheApp\n     * @param int $threshold\n     * @param int $timeout\n     */\n    public function __construct(AbstractAdapter $cacheApp, int $threshold, int $timeout)\n    {\n        $this->cacheApp = $cacheApp;\n        $this->threshold = $threshold;\n        $this->timeout = $timeout;\n    }\n\n    /**\n     * @param string $key The service key\n     * @param string $status The service status (true: up, false: down)\n     */\n    public function save(string $key, bool $status)\n    {\n        if (!isset($this->status[$key])) {\n            $this->status[$key] = self::CLOSED;\n        }\n\n        if ($this->status[$key] === self::OPEN) {\n            $this->attemptReset($key);\n        }\n\n        if (!$status) {\n            $this->countFailure($key);\n        } else {\n            $this->resetCount($key);\n        }\n    }\n}\n```\n\nComme vous pouvez le constater, nous suivons ce qui est dans le schéma plus haut. Arrivé dans la fonction save, si le circuit-breaker n'a pas encore de statut, nous le mettons à CLOSED et enregistrons le statut de la communication. Si celui-ci est OPEN nous appelons la fonction \"attemptReset\", ce qui permet de retenter ou non un appel.\n\nNous continuons en mettant en place les fonctions \"countFailure\" et \"resetCount\".\n\n```php\n<?php declare(strict_types=1);\n\nnamespace AppBundle\\Service;\n\nuse Symfony\\Component\\Cache\\Adapter\\AbstractAdapter;\n\nclass CircuitBreakerService\n{\n    const OPEN = 'open';\n    const CLOSED = 'closed';\n    const HALFOPEN = 'half-open';\n\n    /**\n     * @var AbstractAdapter\n     */\n    private $cacheApp;\n\n    /**\n     * @var array\n     */\n    private $status;\n\n    /**\n     * @var int\n     */\n    private $threshold;\n\n    /**\n     * @var int\n     */\n    private $timeout;\n\n    /**\n     * @param AbstractAdapter $cacheApp\n     * @param int $threshold\n     * @param int $timeout\n     */\n    public function __construct(AbstractAdapter $cacheApp, int $threshold, int $timeout)\n    {\n        $this->cacheApp = $cacheApp;\n        $this->threshold = $threshold;\n        $this->timeout = $timeout;\n    }\n\n    /**\n     * @param string $key The service key\n     * @param string $status The service status (true: up, false: down)\n     */\n    public function save(string $key, bool $status)\n    {\n        if (!isset($this->status[$key])) {\n            $this->status[$key] = self::CLOSED;\n        }\n\n        if ($this->status[$key] === self::OPEN) {\n            $this->attemptReset($key);\n        }\n\n        if (!$status) {\n            $this->countFailure($key);\n        } else {\n            $this->resetCount($key);\n        }\n    }\n\n    /**\n     * Increment number of fail to one service\n     *\n     * @param string $service\n     */\n    private function countFailure(string $service)\n    {\n        $this->info('[CircuitBreaker] call countFailure to ' . $service);\n        $value = $this->cacheApp->getItem($service);\n        $fail = $value->get() + 1;\n        $value->set($fail);\n\n        if ($this->status[$service] === self::HALFOPEN) {\n            $value->set($this->threshold);\n        }\n\n        $value->expiresAfter($this->timeout);\n\n        if ($fail >= $this->threshold) {\n            $this->tripBreaker($service);\n        }\n\n        $this->cacheApp->save($value);\n    }\n\n    /**\n     * Close circuit breaker, and reset value to fail service\n     *\n     * @param string $service\n     */\n    private function resetCount(string $service)\n    {\n        $this->info('[CircuitBreaker] call resetCount to ' . $service);\n        $value = $this->cacheApp->getItem($service);\n\n        $value->set(0);\n        $this->status[$service] = self::CLOSED;\n        $this->cacheApp->save($value);\n    }\n}\n```\n\"ResetCount\" est super simple, on remet le compteur stoker en cache à 0 et on met le circuit-breaker en CLOSED.\n\"CountFailure\" incrémente le compteur, si celui-ci atteint le \"threshold\" on passe dans le \"tripBreaker\". Si le statut du cricuit-breaker est HALFOPEN on le remet tout de suite au niveau du \"threshold\".\nMaintenant on va développer les fonctions \"attemptReset\" et \"tripBreaker\".\n\n```php\n\n<?php declare(strict_types=1);\n\nnamespace AppBundle\\Service;\n\nuse Symfony\\Component\\Cache\\Adapter\\AbstractAdapter;\n\nclass CircuitBreakerService\n{\n    const OPEN = 'open';\n    const CLOSED = 'closed';\n    const HALFOPEN = 'half-open';\n\n    /**\n     * @var AbstractAdapter\n     */\n    private $cacheApp;\n\n    /**\n     * @var array\n     */\n    private $status;\n\n    /**\n     * @var int\n     */\n    private $threshold;\n\n    /**\n     * @var int\n     */\n    private $timeout;\n\n    /**\n     * @param AbstractAdapter $cacheApp\n     * @param int $threshold\n     * @param int $timeout\n     */\n    public function __construct(AbstractAdapter $cacheApp, int $threshold, int $timeout)\n    {\n        $this->cacheApp = $cacheApp;\n        $this->threshold = $threshold;\n        $this->timeout = $timeout;\n    }\n\n    /**\n     * @param string $key The service key\n     * @param string $status The service status (true: up, false: down)\n     */\n    public function save(string $key, bool $status)\n    {\n        if (!isset($this->status[$key])) {\n            $this->status[$key] = self::CLOSED;\n        }\n\n        if ($this->status[$key] === self::OPEN) {\n            $this->attemptReset($key);\n        }\n\n        if (!$status) {\n            $this->countFailure($key);\n        } else {\n            $this->resetCount($key);\n        }\n    }\n\n    /**\n     * Increment number of fail to one service\n     *\n     * @param string $service\n     */\n    private function countFailure(string $service)\n    {\n        $this->info('[CircuitBreaker] call countFailure to ' . $service);\n        $value = $this->cacheApp->getItem($service);\n        $fail = $value->get() + 1;\n        $value->set($fail);\n\n        if ($this->status[$service] === self::HALFOPEN) {\n            $value->set($this->threshold);\n        }\n\n        $value->expiresAfter($this->timeout);\n\n        if ($fail >= $this->threshold) {\n            $this->tripBreaker($service);\n        }\n\n        $this->cacheApp->save($value);\n    }\n\n    /**\n     * Open circuit breaker\n     *\n     * @param string $service\n     */\n    private function tripBreaker(string $service)\n    {\n        $this->error('[CircuitBreaker] call tripBreaker to ' . $service);\n        $this->status[$service] = self::OPEN;\n    }\n\n    /**\n     * CLose circuit breaker, and reset value to fail service\n     *\n     * @param string $service\n     */\n    private function resetCount(string $service)\n    {\n        $this->info('[CircuitBreaker] call resetCount to ' . $service);\n        $value = $this->cacheApp->getItem($service);\n\n        $value->set(0);\n        $this->status[$service] = self::CLOSED;\n        $this->cacheApp->save($value);\n    }\n\n    /**\n     * HalfOpen circuit breaker\n     *\n     * @param string $service\n     */\n    private function attemptReset(string $service)\n    {\n        $this->warning('[CircuitBreaker] call attemptReset to ' . $service);\n        $this->status[$service] = self::HALFOPEN;\n    }\n}\n```\n\n\"AttemptReset\" change le statut du circuit-breaker en HALFOPEN.\n\"TripBreaker\" change le statut du circuit-breaker en OPEN.\nIl ne nous reste plus qu'à mettre en place la fonction qui permet de connaitre le statut du circuit-breaker.\n\n```php\n<?php declare(strict_types=1);\n\nnamespace AppBundle\\Service;\n\nuse Symfony\\Component\\Cache\\Adapter\\AbstractAdapter;\n\nclass CircuitBreakerService\n{\n    const OPEN = 'open';\n    const CLOSED = 'closed';\n    const HALFOPEN = 'half-open';\n\n    /**\n     * @var AbstractAdapter\n     */\n    private $cacheApp;\n\n    /**\n     * @var array\n     */\n    private $status;\n\n    /**\n     * @var int\n     */\n    private $threshold;\n\n    /**\n     * @var int\n     */\n    private $timeout;\n\n    /**\n     * @param AbstractAdapter $cacheApp\n     * @param int $threshold\n     * @param int $timeout\n     */\n    public function __construct(AbstractAdapter $cacheApp, int $threshold, int $timeout)\n    {\n        $this->cacheApp = $cacheApp;\n        $this->threshold = $threshold;\n        $this->timeout = $timeout;\n    }\n\n    /**\n     * @param string $key The service key\n     * @param string $status The service status (true: up, false: down)\n     */\n    public function save(string $key, bool $status)\n    {\n        if (!isset($this->status[$key])) {\n            $this->status[$key] = self::CLOSED;\n        }\n\n        if ($this->status[$key] === self::OPEN) {\n            $this->attemptReset($key);\n        }\n\n        if (!$status) {\n            $this->countFailure($key);\n        } else {\n            $this->resetCount($key);\n        }\n    }\n\n    /**\n     * Verify if service is open\n     *\n     * @param string $service\n     * @return boolean\n     */\n    public function isOpen(string $service) :bool\n    {\n        if (!isset($this->status[$service]) &amp;&amp;\n            $this->cacheApp->getItem($service)->get() >= $this->threshold\n        ) {\n            $this->status[$service] = self::OPEN;\n        }\n\n        return $this->status[$service] === self::OPEN;\n    }\n\n    /**\n     * Increment number of fail to one service\n     *\n     * @param string $service\n     */\n    private function countFailure(string $service)\n    {\n        $this->info('[CircuitBreaker] call countFailure to ' . $service);\n        $value = $this->cacheApp->getItem($service);\n        $fail = $value->get() + 1;\n        $value->set($fail);\n\n        if ($this->status[$service] === self::HALFOPEN) {\n            $value->set($this->threshold);\n        }\n\n        $value->expiresAfter($this->timeout);\n\n        if ($fail >= $this->threshold) {\n            $this->tripBreaker($service);\n        }\n\n        $this->cacheApp->save($value);\n    }\n\n    /**\n     * Open circuit breaker\n     *\n     * @param string $service\n     */\n    private function tripBreaker(string $service)\n    {\n        $this->error('[CircuitBreaker] call tripBreaker to ' . $service);\n        $this->status[$service] = self::OPEN;\n    }\n\n    /**\n     * CLose circuit breaker, and reset value to fail service\n     *\n     * @param string $service\n     */\n    private function resetCount(string $service)\n    {\n        $this->info('[CircuitBreaker] call resetCount to ' . $service);\n        $value = $this->cacheApp->getItem($service);\n\n        $value->set(0);\n        $this->status[$service] = self::CLOSED;\n        $this->cacheApp->save($value);\n    }\n\n    /**\n     * HalfOpen circuit breaker\n     *\n     * @param string $service\n     */\n    private function attemptReset(string $service)\n    {\n        $this->warning('[CircuitBreaker] call attemptReset to ' . $service);\n        $this->status[$service] = self::HALFOPEN;\n    }\n}\n```\n\n\nVous n'avez plus qu'à utiliser votre circuit-breaker. Voici un exemple avec une communication avec Guzzle 6.\n\n```php\n<?php\n   /**\n     * @param string $method\n     * @param string $uri\n     * @param array  $options\n     *\n     * @return PromiseInterface\n     */\n    private function callApi(string $method, string $uri, array $options = []): PromiseInterface\n    {\n        $queryParams = $options['query'] ?? [];\n\n        $headerOptions = [\n            'headers' => [\n                'x-access-token' => $this->tokenGeneratorService->getToken($uri, $queryParams),\n            ],\n        ];\n\n        $options = array_merge($options, $headerOptions);\n\n        if ($this->circuitBreaker->isOpen('edito-service')) {\n            $promise = new Promise();\n            $promise->resolve([\n                'statusCode' => 503,\n                'reasonPhrase' => 'Circuit breaker is open',\n            ]);\n\n            return $promise;\n        }\n\n        return $this->client\n            ->requestAsync($method, $uri, $options)\n            ->then(\n                function (Response $response): array {\n                    $this->eventDispatcher->dispatch('circuit.breaker', new CircuitBreakerEvent('edito-service', true));\n\n                    $contents = json_decode($response->getBody()->getContents(), true);\n\n                    return [\n                        'headers' => $response->getHeaders(),\n                        'statusCode' => $response->getStatusCode(),\n                        'reasonPhrase' => $response->getReasonPhrase(),\n                        'contents' => $contents['data'] ?? [],\n                    ];\n                }\n            )\n            ->otherwise(\n                function (RequestException $exception): array {\n                    $this->eventDispatcher->dispatch('circuit.breaker', new CircuitBreakerEvent('edito-service', false));\n\n                    $return = [\n                        'message' => $exception->getMessage(),\n                        'contents' => [],\n                    ];\n\n                    if ($exception->hasResponse()) {\n                        $return = array_merge($return, [\n                            'statusCode' => $exception->getResponse()->getStatusCode(),\n                            'reasonPhrase' => $exception->getResponse()->getReasonPhrase(),\n                        ]);\n                    }\n\n                    return $return;\n                }\n            );\n    }\n```\n\nPour aller plus loin, je vous invite à lire [Release-It](https://www.amazon.com/Release-Production-Ready-Software-Pragmatic-Programmers/dp/0978739213){:rel=\"nofollow noreferrer\"}, dans lequel vous pourrez trouver une superbe explication d'un circuit-breaker.\n"}