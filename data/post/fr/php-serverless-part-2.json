{"date":"2020-05-13T00:00:00.000Z","title":"PHP & Serverless avec Bref - part 2","excerpt":"Comment déployer des applications PHP sur AWS Lambda avec Bref","readingTime":"10mn","authors":["marishka"],"categories":["php"],"content":"\nCet article est la suite d'un [premier article](https://blog.eleven-labs.com/fr/php-serverless-part-1/) qui fait l'introduction du Serverless. Dans cette deuxième partie, nous allons d'abord voir ce que sont les *layers* dans AWS Lambda et comment les implémenter. Ensuite, nous verrons l'utilisation du framework Bref.\n\n## AWS Lambda\n\n### Fonctionnement\n\nUn environnement AWS Lambda inclut :\n\n-   L'environnement d'exécution (runtime) du langage choisi (Java, Go, PowerShell, Node.js, C#, Python, Ruby par défaut)\n-   L'implémentation de *Lambda runtime API*, c'est à dire le cycle de vie de l'exécution de l'environnement et l'invocation des fonctions Serverless\n\nLe cycle de vie d'un environnement d'exécution Lambda est composé d'une phase d'initialisation et de plusieurs (autant que nécessaire) phases d'invocation.\n\nLa phase d'initialisation représente le temps entre le moment où l'environnement démarre le runtime et le moment où le code d'une fonction est exécuté. Cette phase n'est exécutée qu'une seule fois durant le cycle de vie de l'environnement.\n\nAprès l'initialisation, l'environnement d'exécution se met dans la phase d'invocation et va sans cesse vérifier et exécuter des tâches, et ce jusqu'à ce que l'environnement s'éteigne.\n\nDepuis novembre 2018, il est possible de déclarer ses propres environnements d'exécution pour des fonctions Lambda, mais aussi d'y incorporer des composants réutilisables sous forme de *Layers*.\n\nOn peut implémenter un runtime dans n'importe quel langage. Un runtime est un programme qui exécute le `handler` d'une fonction Lambda lorsqu'elle est appelée. Un runtime peut être inclus dans le package de déploiement d'une fonction sous forme d'un fichier exécutable nommé `bootstrap` (nous verrons un exemple plus bas dans l'article).\n\n### Layers\n\nUne fonction Lambda peut être configurée pour télécharger du code et du contenu additionnel sous forme d'un layer. Un layer est une archive ZIP qui contient des librairies, un runtime personnalisé ou d'autres dépendances.\n\nSi vous avez déjà écrit des fonctions serverless en Node.js, vous savez qu'il faut packager tout le dossier `node_modules` pour chacune des fonctions (puisqu'elles sont déployées de façon indépendante les unes des autres). Ceci ralentit le process de déploiement et rend les builds lents.\n\nMais désormais il est possible de publier le dossier `node_modules` sous forme d'un Layer partagé et réutilisable pour toutes nos fonctions. Cela veut dire que l'on pourrait avoir un layer pour notre runtime custom, un autre layer qui contient nos dépendances et configurer nos fonctions pour utiliser ces 2 layers. Notez qu'une fonction a une limite de 5 layers.\n\n### Exemple\n\n**Fonction PHP**\n\nPrenons la fonction suivante simple comme exemple :\n\n```php\n// src/profession.php\nfunction occupation()\n{\n    $jobs = [\n        'Fireman',\n        'Astronaut',\n        'Super hero',\n        'Pilot',\n        'Professional cook',\n        'Artist',\n    ];\n\n    return ['occupation' => $jobs[array_rand($jobs)]];\n}\n```\n\n**Layer PHP**\n\nJe vais créer un dossier `layers/php` dans mon application et je vais y placer mon layer.\nPour créer un runtime custom, nous avons besoin d'un fichier `bootstrap` qui contiendra la logique de notre runtime responsable d'appeler nos fonctions.\n\nNous avons également besoin d'un exécutable PHP capable d’interpréter notre code. Je vais créer un dossier `bin` dans le dossier de mon layer pour y placer mon binaire `php`. Pour générer un binaire, je vous recommande de regarder [cet article](https://aws.amazon.com/blogs/compute/scripting-languages-for-aws-lambda-running-php-ruby-and-go/).\n\nLorsqu'on déploie un layer, il est placé dons le dossier `/opt` dans les containers. Ainsi, mon fichier `bootstrap` pourrait ressembler à ceci :\n\n```bash\n#!/bin/sh\n\n#go into the source directory\ncd $LAMBDA_TASK_ROOT\n\n#execute the runtime\n/opt/bin/php /opt/runtime.php\n```\n\nVoici un exemple de `runtime.php`  inspiré de l'[article sur le blog AWS](https://aws.amazon.com/blogs/apn/aws-lambda-custom-runtime-for-php-a-practical-example/).\nNous allons utiliser `Guzzle` pour faire les appels réseau, par conséquent je vais d'abord exécuter la commande suivante :\n\n```\ncomposer require guzzlehttp/guzzle\n```\n\n```php\n<?php\n\n// Invoke Composer's autoloader to use Guzzle\nrequire $_ENV['LAMBDA_TASK_ROOT'] . '/vendor/autoload.php';\n\n// Request processing loop => barring unrecoverable failure, this loop runs until the environment shuts down\ndo {\n    // Ask the runtime API for a request to handle\n    $request = getNextRequest();\n\n    // Obtain the function name from the _HANDLER environment variable and ensure the function's code is available\n    list($handlerFile, $handlerFunction) = explode(\".\", $_ENV['_HANDLER']);\n    require_once $_ENV['LAMBDA_TASK_ROOT'] . '/src/' . $handlerFile . '.php';\n\n    // Execute the desired function and obtain the response\n    $response = $handlerFunction($request['payload']);\n\n    // Submit the response back to the runtime API\n    sendResponse($request['invocationId'], $response);\n} while (true);\n\nfunction getNextRequest()\n{\n    $client = new \\GuzzleHttp\\Client();\n    $response = $client->get(sprintf(\n        'http://%s/2018-06-01/runtime/invocation/next',\n        $_ENV['AWS_LAMBDA_RUNTIME_API']\n    ));\n\n    return [\n        'invocationId' => $response->getHeader('Lambda-Runtime-Aws-Request-Id')[0],\n        'payload' => json_decode((string) $response->getBody(), true),\n    ];\n}\n\nfunction sendResponse($invocationId, $response)\n{\n    $client = new \\GuzzleHttp\\Client();\n    $client->post(\n        sprintf(\n            'http://%s/2018-06-01/runtime/invocation/%s/response',\n            $_ENV['AWS_LAMBDA_RUNTIME_API'],\n            $invocationId\n        ),\n        ['body' => $response]\n    );\n}\n```\n\nPour résumer, nous avons actuellement la structure de fichiers suivante :\n\n```\nlayers/\n    php/\n        bin/\n            php #binary file\n        bootstrap\n        runtime.php\nsrc/\n    profession.php\nvendor/\n    guzzlehttp/\n```\n\n**Déploiement**\n\nJe vais utiliser le framework *serverless* pour le déploiement de mon layer et de ma fonction :\n\n```yaml\n# serverless.yml\nservice: php-serverless\nprovider:\n  name: aws\n  runtime: provided\n  region: eu-west-3\n  memorySize: 512\n\nlayers:\n  php:\n    path: layers/php\n\nfunctions:\n  occupation:\n    handler: profession.occupation\n    layers:\n      - {Ref: PhpLambdaLayer}\n```\n\nComme on peut constater, dans ma fonction `occupation`, le `handler` contient le nom de mon fichier `profession.php` et la méthode `occupation`. C'est comme ça que je l'ai configuré dans le `runtime.php` :\n\n```php\n//...\nlist($handlerFile, $handlerFunction) = explode(\".\", $_ENV['_HANDLER']);\nrequire_once $_ENV['LAMBDA_TASK_ROOT'] . '/src/' . $handlerFile . '.php';\n$response = $handlerFunction($request['payload']);\n```\n\nC'est donc à nous de bien configurer la façon dont on nomme les handlers et la façon de les exécuter dans le runtime.\n\nLe nom de notre layer `PhpLambdaLayer` correspond à sa référence CloudFormation. Vous pouvez lire les détails [ici](https://www.serverless.com/framework/docs/providers/aws/guide/layers/#aws---layers).\n\nPour déployer la fonction et le layer, exécutons la commande suivante :\n\n```bash\n$ sls deploy\n\nServerless: Packaging service...\n#...\nServerless: Stack update finished...\nService Information\nservice: php-serverless\nstage: dev\nregion: eu-west-3\nstack: php-serverless-dev\nresources: 7\napi keys:\n  None\nendpoints:\n  None\nfunctions:\n  occupation: php-serverless-dev-occupation\nlayers:\n  php: arn:aws:lambda:eu-west-3:087017887086:layer:php:1\n```\n\nEnfin, appelons la fonction `occupation` :\n\n```bash\n$ sls invoke -f occupation -l\n{\n  \"occupation\": \"Fireman\"\n}\n--------------------------------------------------------------------\nSTART RequestId: d09f2191-7233-47d3-a4fe-8de2a621a608 Version: $LATEST\nEND RequestId: d09f2191-7233-47d3-a4fe-8de2a621a608\nREPORT RequestId: d09f2191-7233-47d3-a4fe-8de2a621a608  Duration: 38.15 ms  Billed Duration: 300 ms  Memory Size: 512 MB  Max Memory Used: 59 MB  Init Duration: 191.10 ms\n```\n\n**Récapitulatif**\n\nNous venons donc de réaliser un exemple fonctionnel avec un *layer* capable d'exécuter du code PHP.\n\nMaintenant, imaginez que vous avez une grande application, disons une API REST en Symfony, que vous voudriez déployer sur AWS Lambda. Il faudrait développer un runtime beaucoup plus poussé capable de s'intégrer avec le *front controller de Symfony*, et pourquoi pas aussi avec la *console*. Il faudrait également modifier le layer PHP pour ajouter toutes les librairies dont nous aurions besoin et de recompiler le binaire PHP.\n\nHeureusement pour nous, une solution *open source* existe pour gérer tout cela : [Bref](https://bref.sh/).\n\n## Bref\n\nBref est un package Composer open source qui nous permet de déployer des applications PHP sur AWS Lambda. Il est développé par [Matthieu Napoli](https://mnapoli.fr/).\n\nBref fournit :\n\n- la documentation\n- les runtimes PHP pour AWS Lambda\n- des outils de déploiement\n- l'intégration avec des frameworks PHP\n\nJe vous propose de déployer une application Symfony sur AWS Lambda en utilisant Bref.\n\n### Application Symfony\n\nPour créer mon application,\n\n```bash\n$ composer create-project symfony/skeleton sf-serverless-example\n```\n\nEnsuite, modifions le controller par défaut comme ceci (pour reprendre le même exemple que plus haut) :\n\n```php\nnamespace App\\Controller;\n\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\n\nclass DefaultController\n{\n    public function index()\n    {\n        $jobs = [\n            'Fireman',\n            'Astronaut',\n            'Super hero',\n            'Pilot',\n            'Professional cook',\n            'Artist',\n        ];\n\n        return new JsonResponse([\n            'occupation' => $jobs[array_rand($jobs)],\n        ]);\n    }\n}\n```\n\nAjoutons maintenant la librairie Bref :\n\n```bash\n$ composer require bref/bref\n```\n\nEnfin, configurons le déploiement avec *serverless* :\n\n```yaml\n# serverless.yml\nservice: php-serverless-sf-bref\nprovider:\n  name: aws\n  region: eu-west-3\n  runtime: provided\n  environment:\n    # Symfony environment variables\n    APP_ENV: prod\n\nplugins:\n  - ./vendor/bref/bref\n\nfunctions:\n  website:\n    handler: public/index.php\n    timeout: 28 # API Gateway has a timeout of 29 seconds\n    layers:\n      - ${bref:layer.php-74-fpm}\n    events:\n      - http: 'ANY /'\n      - http: 'ANY /{proxy+}'\n  console:\n    handler: bin/console\n    timeout: 120 # in seconds\n    layers:\n      - ${bref:layer.php-74} # PHP\n      - ${bref:layer.console} # The \"console\" layer\n```\n\nLa liste des layers mis à disposition par Bref peut être consultée [ici](https://runtimes.bref.sh/). Je vous recommande également de lire la documentation de Bref, elle est très claire et fournit plein d'exemples dont vous pourriez avoir besoin.\n\nIl ne faut pas oublier qu'avec la plupart des fournisseurs Cloud, le filesystem est disponible de lecture seulement. Ainsi, nous devons changer l'endroit où sont stockés les fichers de `logs` et `cache` :\n\n```php\npublic function getLogDir()\n{\n    // When on the lambda only /tmp is writeable\n    if (getenv('LAMBDA_TASK_ROOT') !== false) {\n        return '/tmp/log/';\n    }\n\n    return parent::getLogDir();\n}\n\npublic function getCacheDir()\n{\n    // When on the lambda only /tmp is writeable\n    if (getenv('LAMBDA_TASK_ROOT') !== false) {\n        return '/tmp/cache/'.$this->environment;\n    }\n\n    return parent::getCacheDir();\n}\n```\n\nDernière étape, le déploiement :\n\n```bash\n$ sls deploy\n\nServerless: Packaging service...\nService Information\nservice: php-serverless-sf-bref\nstage: dev\nregion: eu-west-3\nstack: php-serverless-sf-bref-dev\nresources: 15\napi keys:\n  None\nendpoints:\n  ANY - https://maeck9uwyf.execute-api.eu-west-3.amazonaws.com/dev\n  ANY - https://maeck9uwyf.execute-api.eu-west-3.amazonaws.com/dev/{proxy+}\nfunctions:\n  website: php-serverless-sf-bref-dev-website\n  console: php-serverless-sf-bref-dev-console\nlayers:\n  None\n```\n\nL'URL à laquelle mon application est accessible est indiquée dans les endpoints. Voici donc le résultat :\n\n![](/imgs/posts/2020-05-07-php-serverless-part-2/example.png)\n\nNous avons terminé ! Nous venons de déployer une application Symfony sur AWS Lambda en utilisant Bref.\nComme vous avez vu, c'est assez simple au final...\n\nMaintenant vous pouvez déployer vos applications PHP sur des infrastructures serverless :)\n"}