{"date":"2017-12-15T00:00:00.000Z","title":"Pour Noël, je compile mon noyau GNU/Linux !","excerpt":"Le moment tant attendu est finalement arrivé, il est tant de : compiler, installer, tester (kernel-paniquer, recompiler, réinstaller, retester).","readingTime":"6mn","authors":["aandre"],"categories":[],"content":"\nCette article fait suite à un article intitulé [Je configure mon noyau GNU/Linux (partie 2)]({{site.baseurl}}/fr/configurer-kernel-linux/) et en dépend. Si vous ne l'avez pas lu, je vous invite à le faire.\n\nLe moment tant attendu est finalement arrivé, il est tant de : compiler, installer, tester (kernel-paniquer, recompiler, réinstaller, retester).\n\n## Compilation\n\nIci rien de très compliqué nous allons juste lancer la compilation du noyau et des potentiels modules avec l'option -j4, ce qui correspond à paralléliser sur 4 coeurs de microprocesseur.\nLa règle empirique est de faire 1 core = 1 job, vous pouvez connaître le nombre de coeur de votre microprocesseur via la commande `nproc` ou via `cat /proc/cpuinfo |grep processor` :\n```\n# make -j4 & make -j4 modules_install\n```\n\nJe vous vois venir :\n\n> Et qu'est-ce qu'on fait  pendant que ça compile ? Ça dure longtemps ?\n\nDéjà assurez-vous que votre processeur n'est pas trop utilisé par d'autres tâches, cela accélère grandement la compilation.\nPar exemple évitez de miner de la crypto-monnaie sur votre processeur en même temps.\nEt pour répondre, pendant que ça compile on fait autre chose :\n\n![On attend...]({{site.baseurl}}/assets/2017-12-15-compiling-linux-kernel/wait.gif){:class=\"center-image\"}\n\n### Si ça plante ?\n\nParfois on a pas besoin d'attendre longtemps pour que la compilation s'arrête et affiche une erreur.\nCes erreurs sont au cas par cas, encore une fois un moteur de recherche sur le message d'erreur précédé des mots clés `kernel compile` devrait vous aider.\n\n### Comment sait-on que ça a réussi ?\n\nLorsque qu'il n'y a pas d'erreurs :D\n\nPlus sérieusement, en cherchant un fichier `bzImage` dans `/usr/src` :\n```\n# find ./ -iname \"bzImage\"\n./arch/x86/boot/bzImage\n./arch/x86_64/boot/bzImage\n# ls -lh ./arch/x86_64/boot/bzImage\nlrwxrwxrwx 1 root root 22 déc.  15 02:09 ./arch/x86_64/boot/bzImage -> ../../x86/boot/bzImage\n# ls -lh ./arch/x86/boot/bzImage\n-rw-r--r-- 1 root root 3.7M déc.  15 02:09 ./arch/x86/boot/bzImage\n```\n\nLes date & heure sont bonnes, la taille correcte, tout est bon.\n\n## Installation\n\nPour installer le kernel dans son répertoire, il suffit de lancer la commande suivante :\n```\nmake install\n```\n\nCela effectue plusieurs tâches :\n - copier le binaire du kernel `./arch/x86/bzImage` => `/boot/vmlinuz-4.14.5`.\n - copier la configuration écrite dans le fichier `./.config` => `/boot/config-4.14.5`\n - copier le fichier `./System.map` => `/boot/System.map-4.14.5`\n - créer un `/boot/initrd.img-4.14.5`\n\n Deux choses devraient vous choquer ici.\n Pourquoi diantre a-t-on un fichier initrd, alors que nous n'en voulions pas ? La réponse est simple. C'est comme ça que fait make install, mais rien ne nous oblige à l'utiliser.\n Et quel est ce mystérieux fichier System.map ? Il contient tout simplement l'adresse mémoire d'un bon nombre de fonctions et de variables (83334 dans mon cas) :\n\n```\n# cat System.map\n0000000000000000 D __per_cpu_start\n0000000000000000 D irq_stack_union\n00000000000001cf A kexec_control_code_size\n0000000000004000 d exception_stacks\n0000000000009000 D gdt_page\n000000000000a000 D espfix_waddr\n000000000000a008 D espfix_stack\n000000000000a020 D cpu_llc_id\n000000000000a040 D cpu_llc_shared_map\n000000000000a080 D cpu_core_map\n000000000000a0c0 D cpu_sibling_map\n000000000000a100 D cpu_info\n000000000000a1e8 D cpu_number\n# cat System.map |wc -l\n83334\n```\nCe fichier est essentiellement utilisé par le Kernel. Notez que si vous recompilez votre kernel, le System.map sera différent.\n\n## Bootloader\n\nÉtant donné que la plupart des gens utilisent GRUB 2, nous allons effectuer cette manipulation pour ce bootloader.\nRéférez-vous à la documentation de votre bootloader si vous n'utilisez pas GRUB 2.\n\nnous allons donc ajouter une entrée custom dans /etc/grub.d/40_custom afin qu'il ressemble à ce qui suit :\n```\n#!/bin/sh\nexec tail -n +3 $0\n# This file provides an easy way to add custom menu entries.  Simply type the\n# menu entries you want to add after this comment.  Be careful not to change\n# the 'exec tail' line above.\n\nmenuentry \"deb 4.14.5 no initrd\" {\n  set root=(hd0,1)\n  linux /boot/vmlinuz-4.14.5 root=/dev/sda1 ro quiet\n}\n```\n\nPour savoir qui indiquer pour les `root=`, nous allons afficher notre table de montage des partitions :\n```\n# cat /etc/fstab\n# /etc/fstab: static file system information.\n#\n# Use 'blkid' to print the universally unique identifier for a\n# device; this may be used with UUID= as a more robust way to name devices\n# that works even if disks are added and removed. See fstab(5).\n#\n# <file system> <mount point>   <type>  <options>       <dump>  <pass>\n# / was on /dev/sda1 during installation\nUUID=d3cdbebd-8030-45af-8f53-5910d38f8493 /               ext4    errors=remount-ro 0       1\n# swap was on /dev/sda5 during installation\nUUID=068aa3bb-48b2-4bb8-af83-8d603bc80931 none            swap    sw              0       0\n```\n\n### Cas basique\n\nDans mon cas je n'ai qu'une partition réelle : `sda1` montée à la racine `/` de mon système de fichier.\nDonc je sais que je peux renseigner `root=(hd0,1)` et `root=/dev/sda1`.\n\n### Cas de plusieurs zone de stockage\n\nSi ma partition avait été `/dev/sdb1`, j'aurais renseigné `root=(hd1,1)` et `root=/dev/sdb1`\n\n### Cas de plusieurs partitions dont l'une sur /boot\n\nMaintenant si j'avais deux partitions `/dev/sda1` et `/dev/sda2`, la première sur `/` et l'autre sur `/boot`.\nJ'utiliserais alors `/dev/sda2` parce que le kernel se trouve sur `/boot`, donc c'est une partition qui est bootable (en effet, il existe des partitions non bootables, il faut switcher un flag avec un gestionnaire de partition tel que `fdisk`).\nDonc dans mon fichier grub j'aurais à la première ligne `set root=(hd0,2)` et à la seconde `linux /vmlinuz-4.14.5 root=/dev/sda2 ro quiet` (notez que la nous n'avons pas préfixé le noyau de `/boot`)\n\n### Mapping /dev/sd* / hd*,*\n\n| /dev/sd*  | hd*,* |\n|-----------|-------|\n| /dev/sda1 | hd0,1 |\n| /dev/sda2 | hd0,2 |\n| /dev/sda3 | hd0,3 |\n| /dev/sdb1 | hd1,1 |\n| /dev/sdb2 | hd1,2 |\n\nBref vous aurez compris le fonctionnement.\n\n## Mettre à jour grub\n\nSauvegardez le fichier, et lancez la commande `update-grub`. Cette commande va scanner le dossier /boot et ajouter automatiquement à GRUB tous les noyaux qu'elle trouve.\n\nLà vous vous posez sûrement une question :\n> Pourquoi avoir modifié un fichier et s'être pris la tête sur les partitions, si grub le fait automatiquement ?\n\nLa réponse est simple, l'entrée ajoutée à grub ajoute le initrd avec, sauf que nous ne voulons pas l'utiliser, donc nous avons ajouté une entrée custom.\n\nIl n'y a plus qu'à rebooter et sélectionner notre nouvelle entrée :\n\n![grub]({{site.baseurl}}/assets/2017-12-15-compiling-linux-kernel/grub.png){:class=\"center-image\"}\n\nPuis le moment tant attendu arriva... Le saint Graal de toute personne qui compile son Kernel ! Le Mother Fucking Kernel Panic\n\n![Kernel Panic]({{site.baseurl}}/assets/2017-12-15-compiling-linux-kernel/kernel_panic.png){:class=\"center-image\"}\n\nBon dans mon cas précis j'ai vite fait trouvé l'erreur, je l'ai fait sur une VM (c'est plus simple pour les screenshots) sauf que j'ai désactivé le support des systèmes de fichiers virtuels (VFS). L'erreur est en général beaucoup plus parlante que sur un BSOD Windows !\n\n## Conclusion\n\nC'est dorénavant à vous de jouer, vous savez comment compiler votre Kernel.\nSi vous avez des Kernel Panic encore une fois c'est normal, c'est même mieux, c'est en faisant des erreurs qu'on apprend !\nIl vaut mieux avoir trop de Kernel Panic et savoir comment les résoudre, que ne pas en avoir et dire \"je sais compiler mon Kernel\".\nL'avantage c'est que le Kernel évolue toujours !\nDes drivers & autres options sont ajoutés à chaque nouvelle version, de nouveaux devices/matériels sont créés, et de nouveaux matériels sont donc supportés !\nC'est donc une source intarissable d'apprentissage !\n\nCette article est le dernier d'une série de trois. Vous pouvez retrouver les précédents ci-dessous :\n\n- [Je comprends mon noyau GNU/Linux (partie 1)]({{site.baseurl}}/fr/comprendre-kernel-linux/)\n- [Je configure mon noyau GNU/Linux (partie 2)]({{site.baseurl}}/fr/configurer-kernel-linux/)\n"}