{"date":"2017-01-17T00:00:00.000Z","title":"Redux : Structurez vos applications front","excerpt":"L'écosystème Javascript est très riche, beaucoup de développeurs mais aussi de frameworks et d'outils sont disponibles.","readingTime":"7mn","authors":["vcomposieux"],"categories":["javascript"],"content":"L'écosystème Javascript est très riche, beaucoup de développeurs mais aussi de frameworks et d'outils sont disponibles.\nLorsque vous souhaitez développer une application, quel que soit son framework de rendu, vous allez vite être amené à vouloir architecturer votre projet afin de différencier et d'organiser les données des vues. C'est particulièrement le cas lorsque vous utilisez des frameworks de rendu de composants comme `React` ou `VueJS`.\n\nHistoriquement, le besoin s'est fait sentir sur [React](https://facebook.github.io/react/) et Facebook a donc ouvert les sources de son outil [Flux](http://facebook.github.io/flux/){:rel=\"nofollow noreferrer\"}.\n\nLe principe est le suivant :\n\n![](/imgs/posts/2017-01-17-redux-structurez-vos-applications-front/flux-diagram.png)\n\nVotre application déclare, pour chaque composant, les `actions`  qui lui sont liées. Ces actions permettent de définir l'état de votre composant, stocké dans un `store` , qui permet de maintenir votre `vue`  à jour.\nL'inconvénient est que dans ce cas, vous avez un store par composant. Ce modèle fonctionne pour React mais vous pouvez vous sentir limité sur certaines applications.\nDan Abramov a donc lancé, en juin 2015, [Redux](http://redux.js.org){:rel=\"nofollow noreferrer\"}, qui permet principalement de simplifier la gestion du store car il y a en effet qu'un seul store pour toute votre application dans Redux.\n\nTous vos composants peuvent donc accéder à vos données.\n\nPour plus d'informations sur les différences Redux / Flux, je vous invite à lire cette [réponse de Dan](http://stackoverflow.com/questions/32461229/why-use-redux-over-facebook-flux/32920459#32920459){:rel=\"nofollow noreferrer\"}.\n\n# Installation\n\nNous allons voir dans cet article comment mettre en place et utiliser Redux sur vos projets.\nNotez dès maintenant que la librairie peut être utilisée avec plusieurs librairies de rendu comme React ou VueJS.\nPour installer Redux, il vous faudra installer le package npm (ou yarn) `redux`.\n\nSi vous utilisez Redux sur une application React, il vous faudra également le package `react-redux`  ou encore `vue-redux`  s'il s'agit d'un projet VueJS.\n\n```bash\n$ yarn add redux\n```\n\nRien de plus, vous êtes prêt à utiliser Redux.\n\n# Utilisation classique\n\nComme décrit précédemment, il vous faudra initialiser un `store`  qui va permettre de stocker l'état de votre application.\n\nPour instancier ce store, il vous faudra passer un ou plusieurs `reducers` . Les reducers contiennent les méthodes qui effectuent le changement d'état de votre application.\n\nCes changements d'état sont effectués lorsqu'une `action`  est déclenchée sur votre application.\nVoilà, nous avons là les 3 composantes d'une application structurée par Redux : des `actions`, des `reducers` et un `store`.\nNous allons prendre un cas pratique simple : un compteur que l'on peut incrémenter ou décrémenter d'une certaine valeur.\n\nVoici l'arborescence que nous ciblons :\n\n```\nsrc/\n├── actions\n│   └── counter.js\n├── constants\n│   └── ActionTypes.js\n├── reducers\n│   ├── another.js\n│   ├── counter.js\n│   └── index.js\n└── store\n    └── configureStore.js\n```\n\n## Actions\n\nÉcrivons donc un fichier d'actions qui permet de définir ces deux actions : incrémenter et décrémenter.\nAvant tout, nous allons également stocker ces noms d'actions dans des constantes, ce qui nous permettra d'être clair dans notre code car nous ferons toujours appel à ces constantes.\nCréez donc un fichier `src/constants/ActionTypes.js`  avec le contenu :\n\n```js\nexport const INCREMENT = 'INCREMENT';\nexport const DECREMENT = 'DECREMENT';\n```\n\nNous allons maintenant écrire les définitions des actions. Créez maintenant le fichier `src/actions/counter.js` :\n\n```js\nimport * as types from '../constants/ActionTypes';\n\nexport const increment = (value) => ({ type: types.INCREMENT, value });\nexport const decrement = (value) => ({ type: types.DECREMENT, value });\n```\n\nVous venez de déclarer deux actions (`increment`  et `decrement` ) qui prennent chacune un type (obligatoire) et une valeur à ajouter ou soustraire.\n\n## Reducers\n\nIl nous faut maintenant écrire les méthodes des reducers permettant de mettre à jour l'état de notre application.\nCes reducers seront écrits dans le fichier `src/reducers/counter.js` :\n\n```js\nimport { INCREMENT, DECREMENT } from '../constants/ActionTypes';\n\nconst initialState = {\n  current: 0,\n};\n\nexport default function counter(state = initialState, action) {\n  switch (action.type) {\n    case INCREMENT:\n      return {\n        current: state.current += action.value,\n      };\n\n    case DECREMENT:\n      return {\n        current: state.current -= action.value,\n      };\n\n    default:\n      return state;\n  }\n}\n```\n\nVous avez compris l'idée, nous avons nos actions dans un `switch() { case ... }`  et mettons directement à jour les valeurs de notre store.\nVous remarquerez que nous avons créés un état initial (initialState) afin d'initialiser les valeurs de notre application.\n\n`Note :` Il vous est possible de créer autant de reducers que nécessaire.\n\nSi vous avez déclaré plusieurs reducers dans votre application, vous pouvez les combiner dans un fichier `src/reducers/index.js` comme suit :\n\n```js\nimport { combineReducers } from 'redux';\n\nimport counter from './counter';\nimport another from './another';\n\nconst reducers = combineReducers({\n  counter,\n  another,\n});\n\nexport default reducers;\n```\n\n## Store\n\nMaintenant que nous avons nos actions et reducers, dernière étape indispensable : la création du store !\n\nCréez un fichier `src/store/configureStore.js`  avec le contenu suivant :\n\n```js\nimport { createStore } from 'redux';\nimport reducers from '../reducers';\n\nconst configureStore = () => {\n  return createStore(\n    reducers,\n  );\n};\n\nexport default configureStore;\n```\n\nNous utilisons ici la fonction `createStore()` de l'API Redux permettant de créer notre store.\n\nAfin d'aller un peu plus loin, notez que cette fonction peut prendre jusqu'à 3 arguments :\n\n* un ou des reducers,\n* un état pré-chargé (<em>optionnels</em>), correspondant à un état initial,\n* des \"enhancers\" (<em>optionnels</em>), autrement dit des callbacks comme des middlewares.\n\nUn middleware permet d'exécuter une callback à chaque fois que le `dispatch()`  d'actions est exécuté.\n\nVoici un exemple de middleware permettant de logger chaque action déclenchée :\n\n```js\nimport { createStore, applyMiddleware } from 'redux'\nimport reducers from '../reducers';\n\nfunction logger({ getState }) {\n  return (next) => (action) => {\n    console.log('will dispatch', action)\n    return next(action)\n  }\n}\n\nconst configureStore = () => {\n  return createStore(\n    reducers,\n    applyMiddleware(logger)\n  );\n};\n\nexport default configureStore;\n```\n\nN'oubliez pas d'utiliser la fonction `applyMiddleware()`  lorsque vous passez vos fonctions de middleware au store.\n\n# Utilisation avec React\n\nLe principe reste exactement le même lorsque Redux est utilisé avec React, cependant, la librairie `react-redux`  va vous apporter des petites choses en plus.\nVous allez en effet pouvoir lier l'état de votre application gérée par Redux ainsi que les actions que vous avez définies avec les `props`  de vos composants React.\n\nPrenons un composant `Counter`  reflétant l'architecture Redux mise en place dans notre cas d'exemple :\n\n```js\nimport React, { PropTypes } from 'react';\nimport { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\n\nimport * as CounterActions from '../actions/counter';\n\nconst Counter = ({ children, value, actions }) => (\n  <div>\n    <button>Increment</button>\n    <button>Decrement</button>\n  </div>\n);\n\nCounter.propTypes = {\n  children: PropTypes.object.isRequired,\n  value: PropTypes.number.isRequired,\n  actions: PropTypes.object.isRequired,\n};\n\nconst mapStateToProps = state => ({\n  value: state.counter.current,\n});\n\nconst mapDispatchToProps = dispatch => ({\n  actions: bindActionCreators(CounterActions, dispatch),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(Counter);\n```\n\nDe cette façon, nous récupérons donc les valeurs de nos props provenant de notre store mais également une propriété `actions`  permettant d'appeler nos actions Redux.\nLes principaux éléments à noter ici sont :\n\n* `mapStateToProps`  est une fonction permettant de mapper des `valeurs de notre state` Redux avec des `propriétés React`,\n* `mapDispatchToProps`  est une fonction permettant de mapper des `actions` Redux avec des `propriétés React`.\n\nCes deux fonctions sont ensuite appliquées à l'aide de la fonction `connect()`  fournie par `react-redux`.\n\n`Note :` Nous devons ici utiliser `bindActionCreators()`  sur nos `CounterActions`  car il s'agit d'un objet dont les valeurs sont des actions et cette fonction va permettre d'ajouter un appel à la fonction `dispatch()`  de Redux afin que celles-ci soient correctement déclenchées.\n\n# Conclusion\n\nSi nous mettons en parallèle les `1 303 720 téléchargements sur le mois précédent` `de la librairie Redux` avec les `2 334 221 de téléchargements pour React`, nous remarquons que Redux est aujourd'hui `très utilisé` et semble vraiment très `apprécié` par les développeurs car il s'agit d'une solution `simple` qui permet réellement de structurer une application front.\nRedux apporte, selon moi, une `vraie solution` permettant de structurer des applications au métier complexe aux communautés comme React, VueJS mais également aux autres.\n"}