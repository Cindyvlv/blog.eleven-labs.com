{"date":"2019-09-18T00:00:00.000Z","title":"Les promesses en Javascript","excerpt":"Nous allons voir ensemble ce que sont les promesses et comment les utiliser.","readingTime":"8mn","authors":["mehdidr"],"categories":["javascript"],"content":"\nLes promesses ne sont pas récentes. Elles ont commencé à apparaître dans les années 80 dans des langages tels que MultiLisp.\nLe JS a depuis quelques années une tendance à baser les nouveautés du langage sur des modèles asynchrones, car cela permet au moteur Javascript de gérer plusieurs tâches en même temps (événements, affichage, interrogation de base locale...) et de conserver une interface réactive malgré le fait qu'il soit single thread.\n\nC'est une fonctionnalité qui existe depuis longtemps dans l'écosystème JS, mais qui devient un nouvel objet nommé `Promise` natif grâce à l'ES6.\n\n## Définition\n\nLes promesses sont donc des objets qui retournent la valeur d'une opération asynchrone, autrement dit elles représentent une valeur future. Elles disposent de méthodes permettant de traiter le résultat une fois l'opération accomplie (`then()` et `catch()`). D'une manière générale, les promesses vont nous permettre de nous affranchir des callback des fonctions, qui sont désormais attachés à la promesse. Cela permet de nous libérer de l'inversion de contrôle induit par les callbacks (c'est la fonction appelée qui est chargée de les lancer).\n\nPour rappel, un callback, ou fonction de rappel en français, est une fonction qui est passée en argument à une autre fonction, ce qui permet à cette dernière de faire usage de cette fonction comme n'importe quelle fonction alors qu'elle ne la connaît pas par avance.\n\nIl existe 3 états possibles pour une promesse :\n\n- résolue (fulfilled en anglais) : la valeur de la promesse est arrivée et est utilisable. La fonction `resolve()` est appelée.\n- rejetée (rejected en anglais) : une erreur est survenue et il est possible d'effectuer une action en réaction à cette erreur. La fonction `reject()` est appelée.\n- en cours (pending en anglais) : la valeur contenue dans la promesse n'est pas encore arrivée.\n\nUne fois la promesse résolue ou rejetée, elle ne peut plus changer d'état.\n\n## Comment les utiliser\n\n### then()\n\nPrenons comme exemple une fonction qui retourne une promesse qui sera résolue après un délai déterminé :\n\n```javascript\nconst wait = time => new Promise(resolve => setTimeout(resolve, time));\n\nwait(3000).then(() => console.log('Hello!')); // 'Hello!'\n```\n\nNotre appel de `wait(3000)` va attendre 3000ms (3 secondes) et va ensuite logger `Hello`.\n\nL'utilisation du `then()` est utilisée pour passer un handler qui pourra récupérer la valeur, qu'elle soit résolue ou rejetée, et crée toujours une nouvelle promesse.\n\nLe constructeur de l'objet `Promise` prend une fonction, qui prend elle-même deux paramètres : `resolve()` et `reject()`. Dans l'exemple ci-dessus, seul `resolve()` a été utilisé, d'où l'absence de `reject()` dans les paramètres.\n\nIl existe une liste de règles que les handler `resolve()` et `reject()` suivent :\n\n- Retourne une valeur : cette valeur devient celle de la promesse retournée par le `.then()`.\n\n- Ne retourne rien : la promesse retournée est résolue avec une valeur égale à undefined.\n\n- Jette une erreur : cette erreur devient celle de la promesse qui est désormais rejetée.\n\n- Retourne une promesse déjà résolue : la valeur de cette promesse devient celle de la promesse retournée par le `.then()`\n\n- Retourne une promesse déjà rejetée : même cas que pour une promesse déjà résolue.\n\n- Retourne une promesse en cours : la résolution ou le rejet de la promesse retournée par le `.then` sera la même que celle de la promesse retournée par le handler.\n\n### Chaînage des .then\n\nIl est tout à fait possible de chainer les `.then()` :\n\n```javascript\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000); // a\n\n}).then(function(result) { // b\n\n  console.log(result); // c\n  return result * 2;\n\n}).then(function(result) { // d\n\n  console.log(result); // 2\n  return result * 2;\n\n}).then(function(result) {\n\n  console.log(result); // 4\n  return result * 2;\n});\n```\n\nVoilà ce qui se passe :\n\n- a : la promesse initiale est résolue en 1 seconde,\n- b : le handler `then()` est appelé,\n- c : la valeur qui est retournée est passée au prochain `then()`,\n- d : et ainsi de suite.\n\n![](/imgs/posts/2019-09-18-les-promesses-en-javascript/promises.png)\n\n### .catch()\n\nCette méthode renvoie une promesse et ne traite que les cas où la promesse initiale est rejetée. C'est en réalité un alias pour `then(null, errorCallback)`.\n\nLe chaînage des promesses permet de gérer facilement les erreurs. Quand une promesse est rejetée, le runtime sautera au handler de rejet le plus proche.\n\n```javascript\n// doAsyncOperation1() retourne une promesse.\ndoAsyncOperation1()\n.then(() => {\n  // ...\n  return doAsyncOperation2();\n})\n.then((output) => {\n  // ...\n  return doAsyncOperation3();\n})\n.catch((err) => {\n  // Recupère n'importe quelle erreur qui se produit dans chaque promesse de la chaîne.\n});\n```\n\n### Promise.all()\n\nIl existe par ailleurs d'autres méthodes couramment utilisées, comme `Promise.all()`. Cette méthode prend un tableau de promesses comme input, et est résolue lorsque toutes les promesses sont résolues ou si l'une d'elles est rejetée.\n\n```javascript\n// Une simple promesse qui est résolue après un temps donné\nconst timeOut = t => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`Completed in ${t}`)\n    }, t)\n  })\n}\n\n// Résoudre une promesse.\ntimeOut(1000)\n .then(result => console.log(result)) // Completé in 1000\n\n// Utilisation de Promise.all pour résoudre plusieurs promesses\nPromise.all([timeOut(1000), timeOut(2000)])\n .then(result => console.log(result)) // [\"Completed in 1000\", \"Completed in 2000\"]\n```\n\nDans cet exemple, `Promise.all` est résolue après 2 secondes et renvoie un tableau.\n\nUne autre utilité de cette méthode est que l'ordre des promesses est maintenu : la première promesse du tableau sera aussi le premier élément du tableau renvoyé, et de même pour les suivantes.\n\n### Promise.race()\n\nTout comme `Promise.all`, cette méthode prend un tableau en entrée. La différence se situe dans le résultat. `Promise.race` renverra la promesse la plus rapide à se résoudre, ou à être rejetée.\n\n```javascript\nconst promise1 = new Promise((resolve, reject) => setTimeout(resolve, 500, 'one'));\n\nconst promise2 = new Promise((resolve, reject) => setTimeout(resolve, 100, 'two'));\n\nPromise.race([promise1, promise2]).then(value => {\n  return console.log(value); // Les 2 sont résolues, mais promise2 est plus rapide\n});\n\n// résultat attendu: \"two\"\n```\n\n### Promise.allSettled()\n\nCette méthode renvoie une promesse qui est résolue une fois l'ensemble des promesses du tableau passé en argument réussi ou rejeté. La valeur retournée est un tableau d'objets dont chacun est le résultat de chaque promesse du tableau passé en argument.\n\n```javascript\nconst promise1 = Promise.resolve(3);\nconst promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));\nconst promises = [promise1, promise2];\n\nPromise.allSettled(promises).\n  then((results) => results.forEach((result) => console.log(result.status)));\n\n// résultat attendu:\n// \"fulfilled\"\n// \"rejected\"\n```\n\n⚠️ Cette méthode est actuellement en draft au TC39, plus de détails sur la [doc MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled#Specifications)\n\n## Comment ça marche\n\nAvant d'expliquer comment fonctionnent les promesses dans les coulisses, il est d'abord important d'expliquer comment le runtime JS fonctionne. Le runtime JS est un programme qui exécute du code à la demande. Il est appelé par l'événement `loop` (une boucle infinie de gestion des évènements) du navigateur. Il est appelé en premier lieu pour exécuter le programme contenu dans une balise `<script>`, et en deuxième lieu pour exécuter un callback à l'expiration d'un timer créé par exemple par un `setTimeout()`.\n\nLe runtime utilise un principe nommé \"run-to-completion\", qui lui impose de ne jamais s'interrompre lors de l'exécution d'une task (qui est le code executé à un instant donné).\n\nAvant l'arrivée de l'ES6, il n'existait pas de possibilités de créer une fonction asynchrone en dehors d'appels à des fonctions telles que `setTimeout()` ou `XMLHttpRequest.send()` : ces appels entraînent plus tard la création des événements adéquats pour exécuter une callback.\n\nL'apparition de l'objet `Promise` apporte avec lui un nouveau concept : celui des `job queue`. Un job queue est une task qui doit être exécutée aussitôt que possible par l'event loop, c'est-à-dire avant la task suivante si elle existe. Il existe une différence de nomenclature entre les auteurs de la spécifiation ECMAScript 2015 (qui font abstraction du contexte dans lequel fonctionne le runtime JS) et les développeurs qui appellent ces job queues des `microtask`.\n\nPour résumer, les régles au sein du navigateur sont donc :\n\n- une task n'est exécutée qu'après une autre, à cause du principe de run-to-completion.\n- une microtask crée par une task est exécutée après cette task et avant la task suivante.\n- les microtasks sont exécutées les unes après les autres.\n\n⚠️ Les fonctions comme `setTimeout()`, même avec un délai nul, ne rajoutent pas une microtask mais bien une task.\n\n## Conclusion\n\nComme nous l'avons vu, les promesses sont devenues un outil indispensable en Javascript pour gérer les opérations asynchrones. Elles permettent d'avoir un meilleur contrôle et une meilleure gestion des erreurs, tout en rendant le code bien plus lisible.\n\nVous pouvez aller voir ce [lien](https://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects) si vous aimez l'anglais et la lecture pour voir les specs des promesses par l'ECMAScript.\n\nDeux autres liens utiles [ici](http://latentflip.com/loupe) et [ici](https://bevacqua.github.io/promisees/), qui vous permettront de jouer avec une sandbox et de visualiser ce qui se passe en arrière-plan, ce qui vous aidera peut-être à mieux comprendre l'asynchronisme !\n\nLe prochain article portera sur async / await, qui mérite bien un article à lui tout seul !\n"}