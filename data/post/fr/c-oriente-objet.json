{"date":"2018-09-12T00:00:00.000Z","title":"Faire du C orienté Objet","excerpt":"Faisons du C comme s'il s'agissait d'un langage Objet","readingTime":"13mn","authors":["thuchon"],"categories":[],"content":"\n## Introduction\n\nSalut les Astronautes, content de vous retrouver aujourd'hui après un petit moment sans avoir posté d'article.\n\nL'article que je vous propose aujourd'hui change un peu de ceux que j'ai pu écrire par le passé. La volonté est ici de transmettre mes tips/bonnes pratiques à n'importe quel développeur motivé. C'est pourquoi on va aborder un sujet simple, mais sous un angle différent de d'habitude.\n\nAllons maintenant dans le vif du sujet. Cet article se veut assez spécialisé, on va parler de **C**, oui, oui, j'ai bien dit **C**, vous savez ce langage procédural où l'on doit faire toutes les allocations à la mano et pareil pour la libération de la mémoire.<br/>\nIl est super important ce langage, le Kernel de votre ordinateur est codé en **C**, même si c'est un peu galère on peut tout faire avec, et commencer par ce langage vous permettra d'être capable d'apprendre n'importe quel langage plus facilement.<br/>\nC'est pourquoi mon école (ça ne me rajeunit pas tout ça), nous l'a fait apprendre en premier, et j'ai créé par mal de petits programmes avec. Le seul inconvénient à l'époque était que je n'avais pas encore le recul sur la programmation comme je peux l'avoir aujourd'hui. Je vous avoue que j'aurais bien aimé qu'à l'époque une âme bienveillante me guide pour ne pas faire les erreurs que j'ai pu faire.\n\n\nC'est donc dans ce but que je fais cet article, pour vous donner un autre regard sur la programmation procédurale, on va donc ensemble essayer de pousser le langage et de \"**L'objectiser**\".\n\n\n## Mise en situation\n\nVous êtes étudiant en première année, vous avez un petit programme à faire qui doit être capable de gérer plusieurs utilisateurs et vous vous dites, bah tiens, ce serait bien de ne pas se faire un code hyper compliqué à maintenir, sait-on jamais, peut-être que j'aurais des nouvelles données pour mes utilisateurs dans le futur comme le téléphone fixe ou le code postal (ce sont des exemples).\n\nVous avez la solution 1, qui est de faire du **C** en mode normal, donc besoin de modifier beaucoup de code dès qu'une modification arrive, ou alors vous pouvez vous poser 30 minutes, et vous dire, essayons de faire les choses différemment. C'est là que j'interviens ;)\n\nOn va penser en mode objet pour du code procédural.<br/>\nPour faire ceci, on va utiliser 4 éléments du langage **C** :\n\n- **Les structures**\n- **Les pointeurs**\n- **Les listes chainées**\n- **Les pointeurs sur fonctions**\n\n### Les structures\n\nCe sont un peu les ancêtres des objets que vous connaissez, il n'y pas de notion de privé/publique, tout est en publique ; il n'y a pas de méthodes, elles peuvent juste contenir des **propriétés** qui sont soit des types primitifs soit des pointeurs.\n\n### Les pointeurs\n\nOn utilise beaucoup des références en code maintenant, mais il existe aussi les pointeurs, c'est une variable qui pointe vers un endroit spécifique dans la mémoire. Très utile, et tout notre système va reposer sur ça.\n\n### Les listes chainées\n\nOn va réutiliser les 2 notions vues précédémment. Une liste chainée est ensemble de structures qui sont liées ensemble par des pointeurs.\n\n### Les pointeurs sur fonctions\n\nJe pense que vous vous en doutez vu ce que je vous ai décrit au dessus, ce sont des pointeurs non pas pour accéder à des données, mais à des fonctions qui ont été déclarées en mémoire.\n\nBon, c'est pas mal tout ça, on a vu les grosses notions, vous savez ce que l'on veut réaliser.<br />\nEt si on passait au concret ? :)\n\n## Comment nous allons procéder :\n\nEncore aujourd'hui, je vais vous fournir du Dummy code qui va se lancer, et réaliser une série d'opérations qui sera définie dans le code, donc pas vraiment d'interaction avec l'utilisateur. L'idée est de vous présenter le principe, à vous de l'utiliser dans des cas réels.\n\nIci mon objectif est d'être capable de créer des \"utilisateurs\" et de pouvoir en rajouter/supprimer facilement, au cas où mon code doive partir en run.\n\nPour ce faire, commencons par créer nos \"modèles\" de données.\n\n```C\ntypedef struct list list;\nstruct list\n{\n    list *next;\n    void *obj;\n};\n```\n\nJe créé déjà ma structure de liste chainée, l'idée de reproduire un **Array** comme il existe dans quasiment tous les langages.\nOn a donc un pointeur qui va pointer vers le prochain maillon de ma liste (next) et un pointeur de type void* pour contenir tout type d'objets car je veux être capable de pouvoir utiliser ma liste chainée pour tout type de choses (c'est plutôt pratique en vrai).\n\n```C\ntypedef struct plop plop;\nstruct plop\n{\n    void (*hello)(plop*);\n    char* name;\n};\n```\n\nEnsuite voici le vrai \"modèle\" pour nos objets utilisateurs. Une structure de type plop qui contient deux attributs, **name** pour le nom de mon utilisateur et un pointeur sur fonction **hello** qui prend en paramètre un \"objet\" de type **plop**.\n\nAlors, on a notre structure de données, c'est bien, mais qu'est-ce que l'on fait maintenant?\nEt bien, on va coder nos \"méthodes\" de liste chainée pour reproduire les **new**, **add**, **remove**, **getObjectAtIndex** que l'on utilise tous les jours avec nos langages modernes.\n\nCommençons par **New** :\n\n```C\nlist* make_new_list() {\n    list* ptr = malloc(sizeof(list*));\n    return ptr;\n}\n\nplop* make_new_object(char *name) {\n    plop* obj = malloc(sizeof(plop*));\n    obj->name = name;\n    obj->hello = hello;\n    return obj;\n}\n```\n\n**make_new_list** nous sert à créer une nouvelle liste, et **make_new_object** nous sert à créer un nouvel utilisateur. Pour le moment rien de bien compliqué, à part peut-être dans **make_new_object** qui assigne **hello** avec un **hello** qui n'existe pas dans le scope de la fonction, on y reviendra un peu plus tard.\n\nPassons maintenant aux fonctions utilitaires de la liste chainée :\n\n```C\nvoid add_in_list(list* my_list, void* obj) {\n    if (my_list->obj == NULL) {\n        my_list->obj = obj;\n        return;\n    }\n    list* list_ptr = my_list;\n    while (list_ptr->next != NULL) {\n        list_ptr = list_ptr->next;\n    }\n    list* tmp_list_obj = malloc(sizeof(list*));\n    tmp_list_obj->obj = obj;\n    tmp_list_obj->next = NULL;\n    list_ptr->next = (void*)tmp_list_obj;\n}\n\nvoid remove_in_list(list* my_list, void* obj) {\n    list* tmp = my_list;\n    if (tmp->obj == obj) {\n        my_list = tmp->next;\n        return;\n    }\n    list* prev = NULL;\n    while (tmp) {\n        if (tmp->obj == obj) {\n            prev->next = tmp->next;\n            break;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n}\n\nlist* get_object_at_index(list* my_list, int index) {\n    int i = 0;\n    list* tmp = my_list;\n    while (tmp) {\n        if (i == index)\n            return tmp;\n        i++;\n        tmp = tmp->next;\n    }\n    return NULL;\n}\n```\n\nOn crée la fonction **add_in_list** qui correspond au **Add**, la fonction **remove_in_list** qui correspond au **Remove** et la fonction **get_object_at_index** qui correspond au **GetObjectAtIndex**.<br/>\nVeuillez bien noter que ces 3 méthodes prennent en paramètres des pointeurs qui ne sont pas typés ```C(void*)```, ce qui veut dire que vous pouvez réutiliser ces 3 fonctions dans tous vos projets, donc gardez les bien précieusement :)\n\n- Bon bah, c'est pas mal tout ça, on a nos \"modèles\", nos fonctions pour jouer avec, on est parés non ?\n- Bah euh non...\n- Ah ? J'ai oublié un truc ?\n- Bah t'avais pas parlé de la fonction **hello** au dessus ?\n- Ah mais si bien-sûr, qu'est-ce que je ferais sans vous les astronautes ?\n\n```C\nvoid print_str(char* str) {\n    write(1, str, strlen(str));\n}\n\nvoid hello(plop* obj) {\n    print_str(\"Hello, my name is: \");\n    print_str(obj->name);\n    print_str(\"\\n\");\n}\n\nvoid print_list(list* my_list) {\n    list* tmp = my_list;\n    plop* obj = NULL;\n    while (tmp) {\n        obj = (plop*)(tmp->obj);\n        obj->hello(obj);\n        tmp = tmp->next;\n    }\n}\n```\n\nEn fait, il nous manquait un peu plus que juste la fonction **hello**.<br />\nOn va rajouter ces 3 fonctions qui dans l'ordre font :\n- Afficher une chaine de caractère\n- Prendre un \"objet\" **plop** en paramètre et afficher son nom sur la console.\n- Dérouler notre liste chainée et appeler la fonction **hello** sur chaque \"objet\".\n\nOn revient sur la fonction **hello**, cette fonction est maintenant déclarée dans notre code, et dans la fonction **make_new_object** on assigne le pointeur sur fonction de la structure fraîchement créée sur cette fonction qui a une adresse en mémoire. On doit juste passer \"l'objet\" en paramètre car on est pas capable d'appeler directement la méthode dessus. Cette idée m'est venue quand j'ai fait du **Python**, en effet, le self est automatiquement passé dans chaque méthode et on fait nos appels dessus.\n\n## Le rendu final\n\nComme je vous ai dit, ce code a pour vocation de vous donner des idées et n'interagit pas vraiment avec l'utilisateur. Je vais donc vous dumper tout le code d'un coup, comme ça rien de plus simple pour vous, vous avez juste à le tester (par exemple sur [ideone](https://ideone.com/){:rel=\"nofollow noreferrer\"})\n\n```C\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\ntypedef struct plop plop;\nstruct plop\n{\n    void (*hello)(plop*);\n    char* name;\n};\n\ntypedef struct list list;\nstruct list\n{\n    list *next;\n    void *obj;\n};\n\nplop* make_new_object(char *);\nlist* make_new_list();\nvoid print_str(char* str);\nvoid hello(plop* obj);\nvoid add_in_list(list* my_list, void* obj);\nvoid remove_in_list(list* my_list, void* obj);\nlist* get_object_at_index(list* my_list, int index);\nvoid print_list(list* my_list);\n\nint main(int ac, char **av) {\n    list* my_list = make_new_list();\n    add_in_list(my_list, make_new_object(\"Pierre\"));\n    add_in_list(my_list, make_new_object(\"Paul\"));\n    add_in_list(my_list, make_new_object(\"Jacques\"));\n    print_list(my_list);\n    return 0;\n}\n\nlist* make_new_list() {\n    list* ptr = malloc(sizeof(list*));\n    return ptr;\n}\n\nplop* make_new_object(char *name) {\n    plop* obj = malloc(sizeof(plop*));\n    obj->name = name;\n    obj->hello = hello;\n    return obj;\n}\n\nvoid print_str(char* str) {\n    write(1, str, strlen(str));\n}\n\nvoid hello(plop* obj) {\n    print_str(\"Hello, my name is: \");\n    print_str(obj->name);\n    print_str(\"\\n\");\n}\n\nvoid add_in_list(list* my_list, void* obj) {\n    if (my_list->obj == NULL) {\n        my_list->obj = obj;\n        return;\n    }\n    list* list_ptr = my_list;\n    while (list_ptr->next != NULL) {\n        list_ptr = list_ptr->next;\n    }\n    list* tmp_list_obj = malloc(sizeof(list*));\n    tmp_list_obj->obj = obj;\n    tmp_list_obj->next = NULL;\n    list_ptr->next = (void*)tmp_list_obj;\n}\n\nvoid remove_in_list(list* my_list, void* obj) {\n    list* tmp = my_list;\n    if (tmp->obj == obj) {\n        my_list = tmp->next;\n        return;\n    }\n    list* prev = NULL;\n    while (tmp) {\n        if (tmp->obj == obj) {\n            prev->next = tmp->next;\n            break;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n}\n\nlist* get_object_at_index(list* my_list, int index) {\n    int i = 0;\n    list* tmp = my_list;\n    while (tmp) {\n        if (i == index)\n            return tmp;\n        i++;\n        tmp = tmp->next;\n    }\n    return NULL;\n}\n\nvoid print_list(list* my_list) {\n    list* tmp = my_list;\n    plop* obj = NULL;\n    while (tmp) {\n        obj = (plop*)(tmp->obj);\n        obj->hello(obj);\n        tmp = tmp->next;\n    }\n}\n```\n\n## It's time to run the code\n\nBon, on a enfin tout en place, il suffit juste de runner notre bout de code.\nIci, pas de paillettes et de strass, juste 3 petites sorties console :\n\n```Shell\nHello, my name is: Pierre\nHello, my name is: Paul\nHello, my name is: Jacques\n```\n\nPlutôt cool non ? :)\n\n- Attends, on a pondu toutes ces lignes de code juste pour ça ?\n- Oui\n- Mais hum, elle est où la magie ?\n- La magie n'est pas tout le temps visuelle, parfois c'est juste comment c'est fait derrière. En tant que développeurs vous devez vous challenger pour ne pas faire les choses d'une seule et même manière, varier les plaisirs.\n\n## Mais pourquoi faire tout ça ?\n\nVous devez vous dire, mais pourquoi faire tout ça ?<br/>\nPour différentes raisons.<br/>\nLa première étant que c'est très, très fun. Imaginez montrer ce code à votre binôme de travail, et lui dire, tiens si on faisait le projet comme ça ?<br/>\nAussi, vous arrivez en soutenance avec une telle structure de code, le correcteur va se dire, ah tiens, ça sort de l'ordinaire, est-ce que l'on pourrait pousser encore plus loin et vous donner des vrais conseils pour la suite de vos projets.<br/>\nCela rend le code beaucoup plus lisible à mon goût aussi, on a quelques fonctions complexes et le reste est très facilement compréhensible.\nCela va vous apprendre à mieux découper votre code aussi et architecturer vos projets avec beaucoup moins de dépendance.\n\nVoilà, comme je l'ai dit au début, cet article est différent des autres, il est plus réservé à des gens qui débutent dans la programmation. J'espère que cela vous aura plu. N'hésitez surtout pas à me faire des retours dans les commentaires.\n\nAllez, salut les astronautes :)\n"}