{"date":"2019-07-26T00:00:00.000Z","title":"Une application React plus réactive - L'Optimistic UI","excerpt":"Dans cet article, nous allons vous présenter l'optimistic UI et vous montrer comment l'implémenter dans votre application React facilement grâce à ApolloJS","readingTime":"32mn","authors":["kcordier"],"categories":["javascript"],"content":"\n## Intro\n\nÊtes-vous quelqu’un de patient ? Si oui, alors c’est bien, c’est une vertu. Mais êtes-vous prêt à attendre 3 secondes le retour d’un appel API pour avoir une réaction de la part d’une application front ?\n *\\- Ça va 3 secondes dans la vie d’une personne.*\nOK mais si je vous montre ça :\n![](/imgs/posts/2019-07-23-optimistic-ui/no_reactivity.gif)\nÇa vous fait grincer des dents ?\n *\\- Ouais mais si le serveur met du temps à réagir je peux rien y faire en tant que dev JS ?*\nEt c’est là qu'intervient le sujet de notre article : l’**Optimistic UI**.\nLe but de l’article est de vous présenter cette technique et de vous montrer comment l'implémenter dans votre application React facilement grâce à ApolloJS.\n\n\n## Définition\n\nL’**Optimistic UI** est une technique de développement front permettant d’améliorer la réactivité d’une interface. Elle consiste à simuler l’état le plus optimal lors d’une action utilisateur pouvant prendre du temps.\nDans le cas normal nous attendons la fin de l’appel API pour changer l'état de notre interface :\n![](/imgs/posts/2019-07-23-optimistic-ui/simple_event_call.png)\nSi le serveur prend du temps, l’utilisateur peut penser à un dysfonctionnement de l'application.  Il risque alors de cliquer à nouveau sur le bouton et de multiplier les appels au serveur. Pour régler ce problème nous pouvons faire patienter l'utilisateur avec un état “En chargement” grâce à un loader bien connu des utilisateurs de 3G :\n![](/imgs/posts/2019-07-23-optimistic-ui/loading_event_call.png)\nEt si on donnait l'impression à notre utilisateur qu’il utilise une application totalement optimisée en lui affichant directement le résultat final de son action comme si tout se passait comme dans le meilleur des mondes ?\n![](/imgs/posts/2019-07-23-optimistic-ui/optimistic_event_call.png)\nCette technique est très prisée des outils de communication écrite comme les tchats ou les applications sms de vos téléphones lors de l’envoi de message.\n![](/imgs/posts/2019-07-23-optimistic-ui/phone_exemple.gif)\nIci, le message s’affiche dans la conversation alors que la barre de chargement n’est pas encore complète et que le “Sending... “ est encore présent.\n\n## Mais la réalité est-elle si optimiste ?\n\nDans la vie, j'essaie de voir le verre à moitié plein. Mais malheureusement tout n’est pas rose, et il existe des cas où votre requête serveur vous retournera une erreur. Que la faute soit due au serveur ou au client, comment signaler à votre utilisateur que l’action qu’il vient de réaliser n’est pas tant un succès que ça ?\nLa méthode la plus facile est de rollback à l'état avant l’action tout en informant l’utilisateur de l’erreur via un message d’erreur.\n\n## Mise en place\nMaintenant que vous avez bien compris les tenants et aboutissants de l’**Optimistic UI**, mettons-le en oeuvre dans notre application React.\nÀ partir d’ici je présume que votre application React utilise GraphQL et ApolloJS pour la communication avec vos APIs. Si ce n’est pas le cas et que vous voulez le mettre en place suivez [cet article](https://blog.eleven-labs.com/fr/commencer-avec-apollojs/).\nPour une meilleure compréhension du code suivant, mettons nous en situation :\nImaginons une application permettant de noter des articles via un système de pouce bleu et de pouce rouge. L’idée ici est d'afficher à l’utilisateur la valeur exacte du nombre de pouces vers le haut de l’article précédemment noté.\n\n```jsx\n//article.jsx\nconst ADD_THUMB_UP = gql`\n    mutation AddThumbUp($articleId: ID!) {\n        addThumbUp(articleId: $articleId) {\n            status // OK or KO\n        }\n    }\n`;\n\nconst Article = ({ articleId }) => (\n    <Query query={GET_ARTICLE_BY_ID} variables={{ id: articleId }} >\n        {(data: { article }) => {\n            return (\n                //...\n                <Mutation mutation={SUBMIT_COMMENT_MUTATION}>\n                    {mutate => (\n                        <ThumbUp\n                            nbThumbUp={article.nbThumbUp}\n                            onClick={() =>\n                                mutate({\n                                    variables: { articleId: article },\n                                })\n                            }\n                        />\n                    )}\n                </Mutation>\n                //...\n            );\n        }}\n    </Query>\n);\n```\n\nUne première solution est d’effectuer un **refetch** de la query récupérant les articles afin d’avoir la nouvelle valeur de pouces.\n\n```jsx\n//article.jsx\nconst ADD_THUMB_UP = gql`\n    mutation AddThumbUp($articleId: ID!) {\n        addThumbUp(articleId: $articleId) {\n            status // OK or KO\n        }\n    }\n`;\n\nconst Article = ({ articleId }) => (\n    <Query query={GET_ARTICLE_BY_ID} variables={{ id: articleId }} >\n        {(data: { article }) => {\n            return (\n                //...\n                <Mutation mutation={SUBMIT_COMMENT_MUTATION} refetchQueries={[{ query: GET_ARTICLE_BY_ID, variables: { id: articleId } }]}>\n                    {mutate => (\n                        <ThumbUp\n                            nbThumbUp={article.nbThumbUp}\n                            onClick={() =>\n                                mutate({\n                                    variables: { articleId: article },\n                                })\n                            }\n                        />\n                    )}\n                </Mutation>\n                //...\n            );\n        }}\n    </Query>\n);\n```\n\nLa solution est facile à mettre en place, mais elle nécessite d’attendre la fin de la mutation puis la récupération de tous les articles (même de possibles nouveaux) afin de voir la modification. C’est lent, pas optimisé, et ce n’est pas le sujet de l’article.\nUne deuxième solution serait de manuellement incrémenter la valeur, mais cela nécessite de garder la valeur initiale dans un ‘state’. La difficulté ici est de gérer les erreurs et le rollback de manière propre.\nLa dernière solution (et je pense, la meilleure, sinon je ne ferais pas cet article) est d’utiliser l’option **optimisticResponse** de votre mutation pour simuler une réponse la plus proche de l’état souhaité (sans oublier les **\\_\\_typename**) et d’utiliser l’option **update** pour modifier directement dans le cache apollo avec les valeurs envoyées par notre fake response.\n\n```jsx\n//article.jsx\nconst ADD_THUMB_UP = gql`\n    mutation AddThumbUp($articleId: ID!) {\n        addThumbUp(articleId: $articleId) {\n            nbThumbUp // La dernière valeur du nombre de pouces bleu\n        }\n    }\n`;\n\nconst Article = ({ articleId }) => (\n    <Query query={GET_ARTICLE_BY_ID} variables={{ id: articleId }} >\n        {(data: { article }) => {\n            return (\n                //...\n                <Mutation mutation={SUBMIT_COMMENT_MUTATION} >\n                    {mutate => (\n                        <ThumbUp\n                            nbThumbUp={article.nbThumbUp}\n                            onClick={() => {\n                                try {\n                                    mutate({\n                                        variables: { articleId: article },\n                                        optimisticResponse: {\n                                            __typename: 'Mutation',\n                                            nbThumbUp: article.nbThumbUp + 1, // donnée fake\n                                        },\n                                        update: (proxy, { data: { nbThumbUp } }) => {\n                                            // Récupération des données du cache pour cette query.\n                                            const data = proxy.readQuery({ query: GET_ARTICLE_BY_ID, variables: { id: articleId } });\n                                            // Ajout de la donnée fake\n                                            data.article.nbThumbUp = nbThumbUp;\n                                            // Ecriture de la nouvelle valeur directement dans le cache de la query\n                                            proxy.writeQuery({ query: GET_ARTICLE_BY_ID, variables: { id: articleId }, data });\n                                        },\n                                    })\n                                } catch (e) {\n                                    // Traitement des erreurs\n                                }\n                            }}\n                        />\n                    )}\n                </Mutation>\n                //...\n            );\n        }}\n    </Query>\n);\n\n```\n\nUne fois le cache Apollo mis à jour, c’est toute la query qui va se re render avec les valeurs mises à jour.\nLe plus beau dans tout ça, c’est que dans le cas d’un retour en erreur, Apollo se charge de rollback les modifications réalisées dans la fonction d’update, et le catch se chargera de gérer l’erreur. Encore mieux, à la fin de la mutation le même traitement sera réalisé, mais cette fois-ci avec les vraies données de la réponse et dans notre exemple nous afficherons la valeur de pouces bleus la plus à jour.\n\n## Génial ! Mettez-en moi 2 caisses de 12\nMais calmez vous ! Je sais que l’**optimistic UI** est génial, mais il n’est pas à utiliser dans tous les cas. C’est très utile dans le cas de modifications simples comme ceci.\n\n```jsx\n//comment.jsx\nconst UPDATE_COMMENT = gql`\n    mutation UpdateComment($commentId: ID!, $commentContent: String!) {\n        updateComment(commentId: $commentId, commentContent: $commentContent) {\n            id\n            __typename\n            content\n        }\n    }\n`;\n\nconst ArticleComments = ({ articleId }) => (\n    <Query query={GET_COMMENTS_BY_ARTICLE} variables={{ articleId }} >\n        {(data: { comments }) => {\n            return (\n                //...\n                <Mutation mutation={UPDATE_COMMENT}>\n                    {mutate => {\n                        <Comment\n                            updateComment={({ commentId, commentContent }) => {\n                                try {\n                                    mutate({\n                                        variables: { commentId, commentContent },\n                                        optimisticResponse: {\n                                            __typename: \"Mutation\",\n                                            updateComment: {\n                                                id: commentId,\n                                                __typename: \"Comment\",\n                                                content: commentContent,\n                                            }\n                                        }\n                                    })\n                                } catch (e) {\n                                    // Traitement des erreurs\n                                }\n                            }\n                        />;\n                    }}\n                </Mutation>\n                //...\n            );\n        }}\n    </Query>\n);\n\n```\n\nIci, nous effectuons la modification de l’entièreté d’un objet. Si vous avez bien remarqué, nous n’utilisons pas l’option ‘update’. La raison est que notre mutation nous renvoie un objet complet avec le même ‘__typename’ et ‘id’ que la query a initialement retourné. Grâce à ces deux informations Apollo peut directement retrouver et modifier l’objet dans le cache, car elles forment le ‘dataIdFromObject’ par défaut. Il va sans dire que si vous avez changé votre définition du ‘dataIdFromObject’ dans les paramètres de cache alors vous ne pouvez plus utiliser cette méthode telle quelle.\nTraitons le cas de l’ajout :\n\n```jsx\n//comment.jsx\nconst ADD_COMMENT = gql`\n    mutation AddComment($commentContent: String!) {\n        addComment(commentContent: $commentContent) {\n            id\n            __typename\n            content\n        }\n    }\n`;\n\nconst ArticleComments = ({ articleId }) => (\n    <Query query={GET_COMMENTS_BY_ARTICLE} variables={{ articleId }} >\n        {(data: { comments }) => {\n            return (\n                //...\n                <Mutation mutation={UPDATE_COMMENT}>\n                    {mutate => {\n                        <Comment\n                            updateComment={({ commentId, commentContent }) => {\n                                try {\n                                    const generatedId = _.uniqueId('comment_');\n                                    mutate({\n                                        variables: { commentId, commentContent },\n                                        optimisticResponse: {\n                                            __typename: \"Mutation\",\n                                            submitComment: {\n                                                id: generatedId,\n                                                __typename: \"Comment\",\n                                                postedBy: currentUser,\n                                                createdAt: new Date(),\n                                                content: commentContent,\n                                            }\n                                        },\n                                        update: (proxy, { data: { submitComment } }) => {\n                                            // Récupération des données du cache pour cette query.\n                                            const data = proxy.readQuery({ query: GET_COMMENTS_BY_ARTICLE, variables: { articleId } });\n                                            // On supprime le fake commentaire s'il existe, pour eviter les doublons\n                                            data.comments.filter((comment) => comment.id != generatedId);\n                                            // Ajout du nouveau commentaire\n                                            data.comments.push(submitComment);\n                                            // Ecriture de la nouvelle valeur directement dans le cache de la query\n                                            proxy.writeQuery({ query: GET_COMMENTS_BY_ARTICLE, variables: { articleId }, data});\n                                        }\n                                    })\n                                } catch (e) {\n                                    // Traitement des erreurs\n                                }\n                            }}\n                        />;\n                    }}\n                </Mutation>\n                //...\n            );\n        }}\n    </Query>\n);\n```\n\nLa problématique est que nous ajoutons un objet en cache sans connaître son ‘ID’. L’idée est alors de générer un ID temporaire unique en attendant le retour.\nLa divergence d’ID va poser un problème pour tout appel de mutation nécessitant un identifiant, il faut donc bien vérifier l'intégrité de l’ID avant de donner accès aux autres mutations, comme par exemple la modification.\n\nMais “dans quel cas ne pas l'utiliser ?” vous allez me demander. Il est déconseillé d’utiliser l’**optimistic UI** sur des formulaires nécessitant une validation serveur avec les erreurs bind sur les champs, ici le retour est trop important pour ne pas l’attendre.\nJe vois un second cas où je vous déconseille d’utiliser cette technique. Si l’ajout ou la modification d’un objet a des conséquences sur d’autres objets d’autres queries. La meilleure manière et alors de re-render ces différents queries.\n\n## Conclusion\nL'optimistic UI est une technique qui va grandement améliorer les performances de vos applications front si votre back office peine à répondre. De plus, si vous utilisez Apollo il est très facile de la mettre en place. Mais Attention, car mal utilisé, vous pouvez oublier des erreurs ou générer de grosses différences entre vos données back et front. C'est pour cela qu'il faut l'utiliser en connaissance de cause.\nPour plus d'informations, n'hésitez pas à visiter la documentation d'ApolloJS qui m'a inspiré pour cet article : [https://www.apollographql.com/docs/react/features/optimistic-ui/](https://www.apollographql.com/docs/react/features/optimistic-ui/)\n"}