{"date":"2017-08-25T00:00:00.000Z","title":"JSON Server","excerpt":"Accélérez le prototypage de vos applications, en imitant vos APIs avec JSON Server.","readingTime":"15mn","authors":["kelfarsaoui"],"categories":["javascript"],"content":"\nBonjour, aujourd'hui, je vais parler de `json-server`, de la motivation qui pousse à l'utiliser, et surtout comment l'utiliser ?\n\n`json-server` est un module `npm`, qui fournit un serveur [Express](https://github.com/expressjs/express){:rel=\"nofollow noreferrer\"} qui sert une API JSON.\n\n## Motivation\n\nDisons que vous travaillez sur votre application (Javascript, PHP, IOS, Android, ...) et que vous souhaitez consommer les données d'une certaine API. Sauf qu'il s'avère que cette API est encore en développement. La première étape consiste à travailler avec de fausses données, soit codées en dur dans une certaine constante (à éviter), soit en utilisant un fichier JSON statique, ce qui sera un peu difficile à gérer. Pourquoi ? Vous êtes un bon développeur qui aime faire le bon choix; vous voulez que votre application puisse effectuer des mises à jour de données, en utilisant des requêtes HTTP (comme GET, POST... etc.), et vous souhaitez conserver vos mises à jour. Malheureusement, vous ne pouvez pas faire tout cela en utilisant un fichier statique, vous devez trouver un moyen de le rendre dynamique. Donc, à moins que votre collègue ait fini de développer l'API, vous aurez besoin d'une aide sérieuse.\n\n`json-server` nous permet d'imiter une API et de fournir un accès dynamique aux données. Cela veut dire qu'on peut lire, ajouter, mettre à jour et supprimer des données (`GET`, `POST`, `PUT`, `PATCH`, `DELETE`).\n\nIl fournit des cas d'utilisation d'URL comme :\n\n- [Les routes](#routes) (`/articles/1`)\n- [Les filtres](#filters) (`/articles/1/comments?author.username=rpierlot`)\n- [La pagination](#pagination) (`/articles?_page=2&_limit=10`)\n- [La recherche intégrale de texte](#full-text-search) (`/articles?q=graphql`)\n- [Les relations](#relationships) (`/articles?_embed=comments`)\n\nEt d'autres choses diverses comme :\n\n- `CORS` & `JSONP`\n- La possibilité d'accéder aux schémas à distance\n- [La génération de données aléatoires](#random-data)\n- [Les routes personnalisées](#custom-routes)\n- [Les middlewares](#middlewares)\n- [La possibilité d'utiliser `json-server` comme module dans votre serveur NodeJS](#nodejs-module)\n\n## Comment l'utiliser ?\n\nCela prendra moins de 5 minutes !\n\n### Recommandations\n\n- NodeJS & `npm`\n- Un consommateur de l'API (Votre code, `curl`, `postman` ou simplement votre navigateur)\n\n### Installation\n\nIl est assez simple à mettre en place :\n\n```bash\n$ npm install -g json-server\n\n# ou bien avec yarn\n$ yarn global add json-server\n\n# puis créer un repertoire dans lequel on va mettre notre fichier db.json\n$ mkdir blog && cd $_\n\n# créer le schéma\n$ touch db.json\n```\n\nPour le remplir, on peut le faire à la main, ou utiliser un générateur de json aléatoire (mon préféré est [json-generator](http://json-generator.com)){:rel=\"nofollow noreferrer\"}\n\n```json\n{\n  \"articles\": [\n    {\n      \"id\": 1,\n      \"title\": \"Construire une API en GO\",\n      \"authorId\": 2\n    },\n    {\n      \"id\": 2,\n      \"title\": \"Créer une API avec API Platform\",\n      \"authorId\": 1\n    }\n  ],\n  \"comments\": [\n    {\n      \"id\": 1,\n      \"body\": \"Brillant\",\n      \"articleId\": 1\n    },\n    {\n      \"id\": 2,\n      \"body\": \"Sympa\",\n      \"articleId\": 2\n    }\n  ],\n  \"authors\": [\n    {\n      \"id\": 1,\n      \"username\": \"rpierlot\",\n      \"title\": \"Romain Pierlot\"\n    },\n    {\n      \"id\": 2,\n      \"username\": \"qneyrat\",\n      \"title\": \"Quentin Neyrat\"\n    }\n  ]\n}\n```\n\nMaintenant, on peut exécuter `json-server` afin de pouvoir accéder aux URL que `json-server` a créées.\n\n```bash\n$ json-server db.json\n\n  \\{^_^}/ hi!\n\n  Loading db.json\n  Done\n\n  Resources\n  http://localhost:3000/articles\n  http://localhost:3000/comments\n  http://localhost:3000/authors\n\n  Home\n  http://localhost:3000\n\n  Type s + enter at any time to create a snapshot of the database\n```\n\nBien, on a configuré la simulation d'API. Maintenant, on peut la tester :\n\n```bash\n$ curl http://localhost:3000/articles\n[\n  {\n    \"id\": 1,\n    \"title\": \"Construire une API en GO\",\n    \"authorId\": 2\n  },\n  {\n    \"id\": 2,\n    \"title\": \"Créer une API avec API Platform\",\n    \"authorId\": 1\n  }\n]\n\n$ curl http://localhost:3000/articles/1\n{\n  \"id\": 1,\n  \"title\": \"Construire une API en GO\",\n  \"authorId\": 2\n}\n```\n\n<a name=\"routes\"></a>\n\n### Les routes\n\nOn peut utiliser presque toutes sortes de requêtes : par exemple, pour insérer (créer) un nouvel auteur, on peut utiliser : `POST http://localhost:3000/authors`\n\n```bash\n$ curl --data-urlencode \"title=Vincent Composieux\" --data \"username=vcomposieux\" http://localhost:3000/authors\n{\n  \"title\": \"Vincent Composieux\",\n  \"username\": \"vcomposieux\",\n  \"id\": 3\n}\n```\n\nPour lire un article ayant l'id 2 : `GET http://localhost:3000/articles/2`. Le même URI serait utilisé pour `PUT` et `DELETE` pour mettre à jour et supprimer, respectivement.\n\nMaintenant, en ce qui concerne la création d'un nouveau commentaire dans un article, on peut utiliser l'URI suivant : `POST http://localhost:3000/comments`, et cela pourrait fonctionner pour créer un commentaire, mais il est sans doute en dehors du contexte d'un article.\n\nEn fait, cette URI n'est pas très intuitive. On peut l'améliorer en y ajoutant contexte : `POST http://localhost:3000/articles/1/comments`. Maintenant, on sait qu'on crée un commentaire dans l'article ayant id 1.\n\n```bash\n$ curl --data-urlencode \"body=Cool article ;-)\" http://localhost:3000/articles/1/comments\n{\n  \"body\": \"Cool article ;-)\",\n  \"articleId\": 1,\n  \"id\": 4\n}\n```\n\nIdem avec la création d'un article par l'auteur ayant l'id 3 :\n\n```bash\n$ curl --data-urlencode \"title=GraphQL\" http://localhost:3000/authors/3/articles\n{\n  \"title\": \"GraphQL\",\n  \"authorId\": \"3\",\n  \"id\": 3\n}\n```\n\n<a name=\"filters\"></a>\n\n#### Filtres, tri et opérateurs\n\n**Le filtrage** se fait à l'aide de simples paramètres de requête : `GET http://localhost:3000/articles?title=GraphQL`.\n\n**Le tri** est aussi simple que d'ajouter les paramètres `_sort` et `_order` (`asc` & `desc`) dans la requête :\n\n`GET http://localhost:3000/articles?_sort=likes`\n\n(En supposant qu'on a ajouté le champ `likes` à chaque article). Le tri est ascendant par défaut.\n\nDans le cas où l'on veux trier par plusieurs propriétés, on peut écrire les propriétés séparées par une virgule :\n\n`GET http://localhost:3000/articles?_sort=author,score&_order=desc,asc`\n\n\n**Les opérateurs** sont des suffixes utilisés pour augmenter les paramètres de requête :\n\n* `_gt` (greater than), `_lt` (less than), `_gte` (greater than or equal) et `_lte` (less than or equal) : `GET http://localhost:3000/comments?score_gte=5` (en supposant qu'on a un champ `score` dans les commentaires).\n\n* `_ne` (not equal) négation d'une expression `GET http://localhost:3000/comments?articleId_ne=2`\n* `_like` est un opérateur qui peut être appliqué à des chaînes de caractères, il donne le même résultat que le `LIKE` de `SQL`. `GET http://localhost:3000/articles?title_like=API`\n\n<a name=\"pagination\"></a>\n\n#### La pagination\n\nOn peut utiliser les paramètres de requête intégrés `_page` et `_limit` pour paginer les résultats. `json-server` expose `X-Total-Count` et l'en-tête `Link` qui contient des liens vers la première, la prochaine et la dernière page.\n\n`GET http://localhost:3000/articles?_page=1&_limit=1`\n\n```http\nHTTP/1.1 200 OK\nX-Powered-By: Express\nVary: Origin, Accept-Encoding\nAccess-Control-Allow-Credentials: true\nCache-Control: no-cache\nPragma: no-cache\nExpires: -1\nX-Total-Count: 3\nAccess-Control-Expose-Headers: X-Total-Count, Link\nLink: <http://localhost:3000/articles?_page=1&_limit=1>; rel=\"first\", <http://localhost:3000/articles?_page=2&_limit=1>; rel=\"next\", <http://localhost:3000/articles?_page=3&_limit=1>; rel=\"last\"\nX-Content-Type-Options: nosniff\nContent-Type: application/json; charset=utf-8\nContent-Length: 89\nETag: W/\"59-24+hjZrVFdbtnn+FgcogU6QvujI\"\nDate: Sun, 30 Jul 2017 17:22:34 GMT\nConnection: keep-alive\n```\n\n<a name=\"full-text-search\"></a>\n\n#### La recherche intégrale de texte\n\nOn peut implémenter une fonction de recherche dans notre application, en utilisant la fonctionnalité \"recherche intégrale de texte\" de json-server, avec le paramètre `q`.\n\n```bash\n$ curl http://localhost:3000/articles?q=api\n[\n  {\n    \"id\": 1,\n    \"title\": \"Construire une API en GO\",\n    \"author\": \"qneyrat\"\n  },\n  {\n    \"id\": 2,\n    \"title\": \"Créer une API avec API Platform\",\n    \"author\": \"rpierlot\"\n  }\n]\n```\n\n<a name=\"relationships\"></a>\n\n#### Les relations\n\nOn peut voir les relations à l'aide des paramètres `_embed` et `_expand`.\n\n* `_embed` permet de voir les ressources \"enfants\" comme les commentaires : `GET http://localhost:3000/articles?_embed=comments`\n* `_expand` permet de voir les ressources \"parentes\" comme les articles : `GET http://localhost:3000/comments?_expand=article`\n\n```bash\n$ curl http://localhost:3000/articles?author=vincent&_embed=comments\n[\n  {\n    \"title\": \"GraphQL\",\n    \"author\": \"vincent\",\n    \"id\": 3,\n    \"comments\": [\n      {\n        \"body\": \"nice\",\n        \"articleId\": 3,\n        \"id\": 3\n      },\n      {\n        \"body\": \"great!\",\n        \"articleId\": 3,\n        \"id\": 4\n      }\n    ]\n  }\n]\n\n\n$ curl http://localhost:3000/comments?_expand=article\n[\n  {\n    \"id\": 1,\n    \"body\": \"Brillant\",\n    \"articleId\": 1,\n    \"article\": {\n      \"id\": 1,\n      \"title\": \"Construire une API en GO\",\n      \"author\": \"qneyrat\"\n    }\n  },\n  {\n    \"id\": 2,\n    \"body\": \"Sympa\",\n    \"articleId\": 2,\n    \"article\": {\n      \"id\": 2,\n      \"title\": \"Créer une API avec API Platform\",\n      \"author\": \"rpierlot\"\n    }\n  },\n  ...\n]\n```\n\nJusqu'à présent, on n'a vu que les routes `json-server`, mais il y a encore plein de choses à découvrir.\n\n<a name=\"random-data\"></a>\n\n### La génération de données aléatoire\n\nL'[exemple de base de Typicode](https://github.com/typicode/json-server#generate-random-data) présente un script simple qui génère le point d'accès `users`. Ici, on va écrire des points d'accès qui servent des données générées de manière aléatoire en utilisant un module qui génère de fausses données. Personnellement, j'utilise [faker.js](https://github.com/Marak/faker.js), mais il y en a d'autres que vous pouvez explorer comme [Chance](https://github.com/chancejs/chancejs) et [Casual](https://github.com/boo1ean/casual){:rel=\"nofollow noreferrer\"}.\n\nL'aspect aléatoire de la génération ne se produit qu'une seule fois, et c'est seulement pendant le démarrage du serveur. Cela signifie que `json-server` ne nous donnera pas une réponse différente pour chaque requête. Finalement, on doit installer le générateur de données fausses, puis écrire le script de génération.\n\n```bash\n$ yarn add faker\n$ touch generate.js\n```\n\nGardez à l'esprit que le script doit exporter une fonction qui renvoie exclusivement un objet avec des clés (points d'accès).\n\n```js\n// generate.js\nconst faker = require('faker');\n\nmodule.exports = () => ({\n  messages: [...Array(3)].map((value, index) => ({\n    id: index + 1,\n    name: faker.hacker.noun(),\n    status: faker.hacker.adjective(),\n    description: faker.hacker.phrase(),\n  })),\n});\n```\n\nEnsuite, on exécute `json-server` en lui donnant le script de génération comme argument :\n\n```bash\n$ json-server generate.js\n\n  \\{^_^}/ hi!\n\n  Loading generate.js\n  Done\n\n  Resources\n  http://localhost:3000/messages\n\n  Home\n  http://localhost:3000\n\n  Type s + enter at any time to create a snapshot of the database\n```\n\nEt les résultats ressembleront à quelque chose comme :\n\n```bash\n$ curl http://localhost:3000/messages\n[\n  {\n    \"id\": 1,\n    \"name\": \"driver\",\n    \"status\": \"cross-platform\",\n    \"description\": \"If we connect the system, we can get to the ADP panel through the redundant PCI protocol!\"\n  },\n  {\n    \"id\": 2,\n    \"name\": \"monitor\",\n    \"status\": \"1080p\",\n    \"description\": \"Try to synthesize the CSS driver, maybe it will navigate the bluetooth matrix!\"\n  },\n  {\n    \"id\": 3,\n    \"name\": \"hard drive\",\n    \"status\": \"virtual\",\n    \"description\": \"Use the redundant SMS program, then you can compress the bluetooth port!\"\n  }\n]\n```\n\nEt on peut toujours effectuer des requêtes comme on l'a vu dans la section des [routes](#routes).\n\n<a name=\"custom-routes\"></a>\n\n### Les routes personnalisées\n\nImaginons qu'on est censés effectuer des requêtes sur plusieurs points d'accès différents sur la future API, et que ces paramètres ne contiennent pas les mêmes URI :\n\n```url\n/api/dashboard\n/api/groups/ducks/stats\n/auth/users\n/rpierlot/articles\n```\n\n`json-server` permet de spécifier des routes personnalisées. Elles vont permettre de résoudre ce problème en utilisant un mapping qui résout les routes réelles dans notre schéma json :\n\n```json\n{\n  \"/api/:view\": \"/:view\",\n  \"/api/groups/:planet/stats\": \"/stats?planet=:planet\",\n  \"/:user/articles\": \"/articles?author=:user\",\n  \"/auth/users\": \"/users\"\n}\n```\n\nDonc, lorsque on lance `json-server`, il nous montre les routes personnalisées qu'on peut utiliser :\n\n```bash\n$ json-server --watch db2.json --routes routes.json\n\n  \\{^_^}/ hi!\n\n  Loading db2.json\n  Loading routes.json\n  Done\n\n  Resources\n  http://localhost:3000/users\n  http://localhost:3000/dashboard\n  http://localhost:3000/stats\n  http://localhost:3000/articles\n\n  Other routes\n  /api/:view -> /:view\n  /api/groups/:planet/stats -> /stats?planet=:planet\n  /:user/articles -> /articles?author=:user\n  /auth/users -> /users\n\n  Home\n  http://localhost:3000\n\n  Type s + enter at any time to create a snapshot of the database\n  Watching...\n```\n\nMaintenant, on peut effectuer les requêtes personnalisées pour voir les résultats :\n\n```bash\n$ curl http://localhost:3000/api/dashboard\n{\n  \"visits\": 3881,\n  \"views\": 625128,\n  \"shares\": 7862\n}\n\n$ curl http://localhost:3000/api/groups/ducks/stats\n[\n  {\n    \"planet\": \"ducks\",\n    \"stats\": {\n      \"points\": 5625,\n      \"ships\": 8\n    }\n  }\n]\n```\n\n<a name=\"middlewares\"></a>\n\n### Middlewares\n\nDans le cas où l'on veut ajouter un comportement spécifique à notre instance json-server, on peut utiliser des middlewares personnalisés, qu'on intègre dans le serveur de la même manière que lors du développement d'une application express classique. Dans cette section, on va explorer un exemple utile d'une fonctionnalité qui est habituellement nécessaire.\n\nImaginez qu'on veuille accéder à une ressource sur l'API, mais qu'il s'avère que cette ressource est sécurisée. On peut dire qu'il s'agit simplement de données, et qu'on se satisferait de les utiliser sans se soucier de la sécurité. Mais, on sait que ce n'est le bon choix, on veut que l'application soit prête lorsque la future API est prête, afin de tout tester. Donc, au lieu de contourner la sécurité, on va utiliser les middlewares pour mettre en place une couche d'authentification.\n\n```js\n// auth.js\nconst auth = require('basic-auth');\n\nmodule.exports = (req, res, next) => {\n  var user = auth(req);\n\n  if (typeof user === 'undefined' || user.name !== 'kamal' || user.pass !== 'secret') {\n    // Cette ligne sera expliquée plus tard dans cette section.\n    res.header('WWW-Authenticate', 'Basic realm=\"Access to the API\"');\n    return res.status(401).send({ error: 'Unauthorized' });\n  }\n\n  next();\n};\n```\n\nMaintenant, on exécute `json-server` avec l'option `--middlewares` :\n\n```bash\n$ json-server --watch db2.json --routes routes.json --middlewares auth.js\n```\n\nRemarque: l'option `--middlewares` accepte une liste de fichiers. `--middlewares file1.js file2.js file3.js`.\n\nPuis, on teste la couche d'authentification :\n\n```bash\n$ curl http://localhost:3000/api/groups/ducks/stats\n{\n  \"error\": \"Unauthorized\"\n}\n```\n\nEt on peut voir le log avec le status HTTP `401` :\n\n```bash\nGET /api/groups/ducks/stats 401 12.180 ms - 29\n```\n\nLorsqu'on affiche les en-têtes de la réponse, on reconnaît cet en-tête `WWW-Authenticate: Basic realm=\"Access to the API\"` :\n\n```http\nHTTP/1.1 401 Unauthorized\nX-Powered-By: Express\nVary: Origin, Accept-Encoding\nAccess-Control-Allow-Credentials: true\nCache-Control: no-cache\nPragma: no-cache\nExpires: -1\nWWW-Authenticate: Basic realm=\"Access to the API\"\nContent-Type: application/json; charset=utf-8\nContent-Length: 29\nETag: W/\"1d-t1Z3N2Fd2Yqi/vcyFQaHaMeQEew\"\nDate: Thu, 03 Aug 2017 09:59:57 GMT\nConnection: keep-alive\n```\n\nVoici ce que Mozilla Developer Network en dit :\n\n> Les en-têtes de réponse `WWW-Authenticate` et `Proxy-Authenticate` définissent la méthode d'authentification qui devrait être utilisée pour accéder à une ressource. Ils doivent spécifier quel schéma d'authentification est utilisé afin que le client qui souhaite l'autoriser sache comment fournir les informations d'identification.\n>\n> <cite>[HTTP authentication : `WWW-Authenticate` and `Proxy-Authenticate` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#WWW-Authenticate_and_Proxy-Authenticate_headers){:rel=\"nofollow noreferrer\"}</cite>\n\nEnsuite, on teste à nouveau, et cette fois en ajoutant les informations d'identification à la requête (Remarque: l'option `--user` de `curl` n'est pas limitée à l'authentification de type `Basic`, nous pouvons effectuer d'autres types d'authentification, [voir ici](https://ec.haxx.se/http-auth.html)){:rel=\"nofollow noreferrer\"} :\n\n```bash\n$ curl --user kamal:secret http://localhost:3000/api/groups/ducks/stats\n[\n  {\n    \"planet\": \"ducks\",\n    \"stats\": {\n      \"points\": 5625,\n      \"ships\": 8\n    }\n  }\n]\n```\n\nBien ! Évidemment, c'est un status HTTP `200` :-D.\n\n```bash\nGET /api/groups/ducks/stats 200 4.609 ms - 94\n```\n\n<a name=\"nodejs-module\"></a>\n\n### En tant que module NodeJS\n\n`json-server` est une application Express, ce qui signifie que nous pouvons l'utiliser dans une application NodeJS/Express existante pour réaliser des comportements personnalisés. Voici un exemple simple qui montre comment personnaliser le logger :\n\n`json-server` utilise `morgan` pour les logs, et le format par défaut qu'il utilise est le format [`dev`](https://github.com/expressjs/morgan#dev), qui n'expose pas toutes les informations que l'on veut. Pour avoir un log détaillé on doit utiliser le [format  standard d'Apache](https://github.com/expressjs/morgan#combined){:rel=\"nofollow noreferrer\"} :\n\n```js\n// server.js\nimport express from 'express';\nimport api from './api';\n\nconst port = 9001;\nconst app = express();\nconst API_ROOT = `http://localhost:${port}/api`;\n\napp.use('/api', api);\n\napp.listen(port, error => {\n  if (error) {\n    console.error(error);\n  } else {\n    console.info('==> 🌎  Listening on port %s. Open up %s in your browser.', port, API_ROOT);\n  }\n});\n```\n\n\n```js\n// api.js\nimport { create, defaults, rewriter, router } from 'json-server';\nimport morgan from 'morgan';\nimport rewrites from './routes.json';\n\nconst server = create();\nconst apiEndpoints = router('db2.json');\n\n// Désactiver le logger existant\nconst middlewares = defaults({ logger: false });\n\n// Ici on utilise notre propre logger\nserver.use(morgan('combined', { colors: true }));\n\nserver.use(rewriter(rewrites));\nserver.use(middlewares);\nserver.use(apiEndpoints);\n\nexport default server;\n```\n\nEnsuite, on lance le serveur :\n\n```bash\n$ nodemon --exec babel-node server.js\n==> 🌎  Listening on port 9001. Open up http://localhost:9001/api/ in your browser.\n```\n\nIci, on peut voir les logs personnalisés dans la console :\n\n```bash\n$ curl --user kamal:secret http://localhost:9001/api/groups/ducks/stats\n::1 - kamal [11/Aug/2017:15:04:58 +0000] \"GET /api/groups/ducks/stats HTTP/1.1\" 200 187 \"-\" \"curl/7.51.0\"\n\n# or with Chrome\n::1 - - [10/Aug/2017:08:57:04 +0000] \"GET /api/ HTTP/1.1\" 200 - \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\"\n```\n\n## Conclusion\n\n`json-server` a considérablement réduit le temps de scaffolding d'une API. Parmi les possibilités qu'on a vues, il existe de nombreux cas d'utilisation que vous pouvez explorer pour utiliser `json-server`, comme la personnalisation des logs, les tests, la réconciliation entre micro-services, les applications sans serveur ... etc.\n\nJ'espère que cet article a pu éclairer la façon dont on peut utiliser `json-server`. J'ai essayé d'apporter des cas d'utilisation utiles qu'on rencontre tous les jours. Si vous souhaitez encore en savoir plus sur l'utilisation ou même sur son fonctionnement interne, je recommande d'explorer son [projet Github](https://github.com/typicode/json-server){:rel=\"nofollow noreferrer\"}.\n\nMerci pour la lecture !\n"}