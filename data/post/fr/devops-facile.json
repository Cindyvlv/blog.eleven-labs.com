{"date":"2017-12-18T00:00:00.000Z","title":"Devenir DevOps c'est facile","excerpt":"Deployer dans le Cloud c'est encore plus simple que de faire un Rsync. En voici la preuve avec ce petit tutoriel.","readingTime":"6mn","authors":["captainjojo"],"categories":["architecture","javascript"],"content":"\nCe n'est pas parce que l'on n'est pas DevOps que l'on ne peut pas mettre en production notre code dans le Cloud.\n\nDepuis que deployer n'est plus un Rsync ou un upload FTP (oui je suis #old) la mise en place d'un environnement de production est devenu un métier à part entière. Puis il y a eu l'avènement du Cloud et là je me suis senti encore plus perdu.\n\nSauf que le Cloud c'est justement ce qui ma permis de remettre un pied dans le monde secret du déploiement en production.\n\nLe but de ce petit article est de montrer qu'avec peu d'effort on peut avoir une application scalable dans le Cloud sans une ligne de bash.\n\n## Le besoin\n\nMettre en production une application front en React. L'application n'a pas de serveur, c'est du pur React, nous avons donc besoin d'un serveur web type Nginx. Pour ce qui est des assets, on les veut avec un CDN puissant.\n\n## Mise en place\n\nNotre première idée était de mettre l'ensemble des fichiers générés (Javascript/CSS/HTML) dans un [Bucket Google Cloud](https://cloud.google.com/storage/?hl=fr).\n\nPour cela rien de plus simple, comme le projet est hébergé sur GitHub et que nous avons Travis pour les tests unitaires, nous allons utiliser Travis pour faire le déploiement aussi.\n\n> Oui Travis permet aussi le déploiement !\n\nJe vous invite à regarder la documentation disponible [ici](https://docs.travis-ci.com/user/deployment).\n\nDans notre fichier `.travis.yml` nous avons seulement besoin d'ajouter :\n\n```yml\ndeploy:\n  provider: gcs\n  access_key_id: $GCS_ACCESS_KEY_ID\n  secret_access_key: $GCS_SECRET_ACCESS_KEY\n  bucket: \"tutos\"\n  skip_cleanup: true\n  acl: public-read\n  local-dir: public\n  on:\n    branch: master\n```\n\nEt voilà, vous avez déployé tout ce qui est contenu dans le dossier `public` dans le [bucket](https://cloud.google.com/storage/?hl=fr) `tutos`.\n\nCela fut très pratique, mais la navigation React ne fonctionnait pas. Effectivement, Storage se comporte mal lors d'un changement dynamique d'url (en même temps ce n'est pas fait pour cela). Cloud storage ce n'est pas un serveur web, c'est très bien pour nos assets mais ce n'est pas fait pour gérer l'application.\n\n> Mais alors comment faire ?\n\nLa première idée aurait été de créer une machine dans le cloud avec [Compute Engine](https://cloud.google.com/compute/?hl=fr). Mais là on arrive à ma problèmatique. Il va faloir faire la machine et ensuite ccréer des scripts de déploiement avec un système de rollback etc...\n\n> Mais comment faire ?\n\nC'est la que l'idée de [App Engine](https://cloud.google.com/appengine/?hl=fr) est apparue.  App Engine permet d'avoir une application évolutive, ce dernier scale automatiquement selon le CPU de la machine. De plus il permet de mettre en production plusieurs versions de l'application et donc de garder chacune d'elles et faire du [rolling deployment](http://searchitoperations.techtarget.com/definition/rolling-deployment).\n\nCe qui est super pratique c'est que App Engine prend en compte les Dockerfile, il faut donc simplement lui donner la configuration de votre Docker.\n\nPour notre projet, qui est statique, nous avons suivi le tutoriel Google disponible [ici](https://cloud.google.com/appengine/docs/flexible/custom-runtimes/quickstart).\n\nDonc dans notre projet nous avons ajouté le fichier Dockerfile suivant :\n\n```sh\n# The standard nginx container just runs nginx. The configuration file added\n# below will be used by nginx.\nFROM nginx\n\n# Copy the nginx configuration file. This sets up the behavior of nginx, most\n# importantly, it ensure nginx listens on port 8080. Google App Engine expects\n# the runtime to respond to HTTP requests at port 8080.\nCOPY nginx.conf /etc/nginx/nginx.conf\n\n# create log dir configured in nginx.conf\nRUN mkdir -p /var/log/app_engine\n\n# Create a simple file to handle heath checks. Health checking can be disabled\n# in app.yaml, but is highly recommended. Google App Engine will send an HTTP\n# request to /_ah/health and any 2xx or 404 response is considered healthy.\n# Because 404 responses are considered healthy, this could actually be left\n# out as nginx will return 404 if the file isn't found. However, it is better\n# to be explicit.\nRUN mkdir -p /usr/share/nginx/www/_ah && \\\n    echo \"healthy\" > /usr/share/nginx/www/_ah/health\n\n# Finally, all static assets.\nADD www/ /usr/share/nginx/www/\nRUN chmod -R a+r /usr/share/nginx/www\n```\n\nPuis la configuration de notre serveur nginx :\n\n```sh\n# Copyright 2015 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nevents {\n    worker_connections 768;\n}\n\nhttp {\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    keepalive_timeout 65;\n    types_hash_max_size 2048;\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n\n    # Logs will appear on the Google Developer's Console when logged to this\n    # directory.\n    access_log /var/log/app_engine/app.log;\n    error_log /var/log/app_engine/app.log;\n\n    gzip on;\n    gzip_disable \"msie6\";\n\n    server {\n        # Google App Engine expects the runtime to serve HTTP traffic from\n        # port 8080.\n        listen 8080;\n        root /usr/share/nginx/www;\n        index index.html index.htm;\n\n        location / {\n          try_files $uri $uri/ /index.html;\n        }\n    }\n}\n```\n\nPour terminer il faut ajouter le fichier `app.yml` qui permet de dire à App Engine quel machine utiliser :\n\n```sh\nruntime: custom\nenv: flex\n```\n\nIl ne vous reste plus qu'à dire à Travis que vous voulez déployer dans Google App Engine. Nous avons tout de même gardé le déploiement dans Google Storage pour les assets, ce qui donne la configuration dans le fichier `.travis.yml` suivante :\n\n```yaml\ndeploy:\n  - provider: gcs\n    access_key_id: $GCS_ACCESS_KEY_ID\n    secret_access_key: $GCS_SECRET_ACCESS_KEY\n    bucket: \"tutos\"\n    skip_cleanup: true\n    acl: public-read\n    cache_control: \"public,max-age=60\"\n    local-dir: _posts\n    on:\n      branch: master\n  - provider: gae\n    keyfile: \"codelabs-1ddb09746a38.json\"\n    project: \"codelabs-179614\"\n    local-dir: nginx\n    skip_cleanup: true\n    on:\n      branch: master\n```\n\nAttention, dans les tutoriels que vous allez trouver, il faut récupérer le fichier de `credentials` fourni par Google et l'encoder via les scripts de Travis. Surtout ne versionnez pas le fichier de credentials mais seulement le fichier encodé. Il faut seulement garder le fichier de Google en local à l'abri des regards.\n\n## Conclusion\n\nEn quelques lignes de code et un peu de lecture de tutoriel, vous avez déployé votre application sur des serveurs scalables et dans un service d'asset avec le CDN Google. Ce qui est magique c'est qu'avec l'ensemble des outils Google, vous pouvez monitorer votre application simplement (CPU/Mémoire/Logs).\n\nLe Cloud et l'outillage associés nous aident tous à devenir des DevOps en puissance. Il suffit de s'y mettre.\n\nVous pouvez retrouver le projet [ici](https://github.com/eleven-labs/codelabs).\n"}