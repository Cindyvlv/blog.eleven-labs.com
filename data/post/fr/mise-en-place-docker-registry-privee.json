{"date":"2016-12-07T00:00:00.000Z","title":"Mise en place d'une Docker Registry privée","excerpt":"Dans cet article, nous allons détailler, étape par étape, la mise en place d'une Docker Registry. Une Docker Registry est une application qui permet de distribuer des images Docker au sein de votre organisation.","readingTime":"20mn","authors":["gcanal"],"categories":["architecture"],"content":"\nDans cet article, nous allons détailler, étape par étape, la mise en place d'une Docker Registry.\n\nUne Docker Registry est une application qui permet de distribuer des images Docker au sein de votre organisation.\n\nC'est un composant majeur dans l'écosystème Docker, car il va permettre :\n\n-   À vos développeurs de distribuer des images prêtes à l'emploi de vos applications et de les versionner avec un système de tags.\n-   À de nouveaux arrivants dans votre société de mettre en place rapidement leur environnement de développement à partir de ces images.\n-   À des outils d'intégration en continu de jouer une suite de tests sans avoir besoin d'autre chose que de Docker.\n-   Et à des systèmes automatisés de déployer ces applications sur vos environnement de développement, de tests, de recette et de production.\n\n## Petit rappel\n\nUne image Docker est en quelque sorte une image disque qui contient l'arborescence d'une distribution linux, le code source d'une application et des binaires capables de la faire tourner.\n\nUne image se construit à partir d'un fichier **Dockerfile** que l'on retrouve généralement à la racine des sources d'une application.\n\nDocker met à disposition un registre d’images publiques : [DockerHub](https://hub.docker.com/){:rel=\"nofollow noreferrer\"}.\nDans ce registre, vous allez retrouver des images, telles que :\n\n-   des distributions linux,\n-   des images pré-configurées avec un serveur web et un environnement, exécution pour votre langage préféré,\n-   des bases de données,\n-   et des applications open-source prêtes à l’emploi\n\nDocker propose également le dépôt d’images privées via une offre détaillée [ici](https://hub.docker.com/account/billing-plans/){:rel=\"nofollow noreferrer\"}.\n\n## Mise en place\n\nNous allons déployer notre Docker Registry avec [Docker Swarm Mode](https://docs.docker.com/engine/swarm/) et [Traefik](https://traefik.io/){:rel=\"nofollow noreferrer\"}, un reverse proxy qui va nous permettre d’associer un domaine à notre registre Docker.\n\nNous aurons besoin d’un nom de domaine, d’un serveur et d’un terminal.\n\nPour ce guide, je vais utiliser une instance [OVH Public Cloud](https://www.ovh.com/fr/cloud/){:rel=\"nofollow noreferrer\"} et un nom de domaine géré par OVH. Dans les grandes lignes, toutes les étapes critiques peuvent être reproduite sur n’importe quel environnement.\n\n## Configuration du serveur\n\nPartons d'une distribution récente, une Ubuntu 16.04 qui a le bon goût d'avoir dans ces dépôts une version de Docker à jour :\n\n``` bash\n# Installation de Docker\nsudo apt-get update && sudo apt-get install docker.io curl\n\n# Ajoute l'utilisateur courant au groupe docker (si différent de root)\nsudo usermod -a -G docker $(id -un)\n```\n\nOn se déconnecte du serveur, puis on se reconnecte pour initialiser Docker Swarm mode.\n\n``` bash\n# Initialise Docker Swarm Mode\ndocker swarm init\n```\n\n## Installation de Traefik\n\nTraefik va nous permettre d'associer un domaine au conteneur dans lequel tournera la registry. Le gros avantage, c'est qu'il permet d'obtenir automatiquement un certificat TLS délivré par [Let's Encrypt](https://letsencrypt.org/){:rel=\"nofollow noreferrer\"}.\n\n``` bash\n# Créer un réseau traefik\ndocker network create --driver overlay traefik\n\n# Création d'un répertoire où seront stockés nos certificats\nsudo mkdir -p /opt/traefik\n```\n\nOn va maintenant créer la définition de notre service Traefik.\nCréez un fichier à l'adresse **$HOME/traefik.json** dans lequel vous ajoutez :\n\n``` json\n{\n    \"Name\": \"traefik\",\n    \"TaskTemplate\": {\n        \"ContainerSpec\": {\n            \"Image\": \"traefik:v1.1.0\",\n            \"Args\": [\n                \"--defaultentrypoints=http,https\",\n                \"--entryPoints=Name:http Address::80 Redirect.EntryPoint:https\",\n                \"--entryPoints=Name:https Address::443 TLS\",\n                \"--acme\",\n                \"--acme.entrypoint=https\",\n                \"--acme.email=[email]\",\n                \"--acme.storage=/data/acme.json\",\n                \"--acme.ondemand=true\",\n                \"--docker\",\n                \"--docker.swarmmode\",\n                \"--docker.exposedbydefault=false\",\n                \"--docker.watch\",\n                \"--web\",\n                \"--logLevel=INFO\"\n            ],\n            \"Mounts\": [\n                {\n                    \"Type\": \"bind\",\n                    \"Source\": \"/var/run/docker.sock\",\n                    \"Target\": \"/var/run/docker.sock\"\n                },\n                {\n                    \"Type\": \"bind\",\n                    \"Source\": \"/opt/traefik\",\n                    \"Target\": \"/data\"\n                }\n            ]\n        },\n        \"RestartPolicy\": {\n            \"Condition\": \"any\",\n            \"MaxAttempts\": 0\n        },\n        \"Placement\": {\n            \"Constraints\": [\n                \"node.role==manager\"\n            ]\n        }\n    },\n    \"Mode\": {\n        \"Replicated\": {\n            \"Replicas\": 1\n        }\n    },\n    \"UpdateConfig\": {\n        \"Parallelism\": 1,\n        \"FailureAction\": \"pause\"\n    },\n    \"Networks\": [\n        {\n            \"Target\": \"traefik\"\n        }\n    ],\n    \"EndpointSpec\": {\n        \"Mode\": \"vip\",\n        \"Ports\": [\n            {\n                \"Protocol\": \"tcp\",\n                \"TargetPort\": 80,\n                \"PublishedPort\": 80\n            },\n            {\n                \"Protocol\": \"tcp\",\n                \"TargetPort\": 443,\n                \"PublishedPort\": 443\n            },\n            {\n                \"Protocol\": \"tcp\",\n                \"TargetPort\": 8080,\n                \"PublishedPort\": 8080\n            }\n        ]\n    }\n}\n```\n\n> **Important**: Remplacez **\\[email\\]** par une adresse mail valide sans quoi, Let's Encrypt ne vous délivrera pas de certificat.\n\nIl ne nous reste plus qu'à lancer le service en utilisant l'API Docker :\n\n``` bash\ncurl -XPOST --unix-socket /var/run/docker.sock http:/services/create -d @$HOME/traefik.json\n```\n\nContrôlez que le service tourne en tapant **docker service ls**. Au bout d'un certain temps, vous allez voir **1/1** s'afficher en face du service **traefik**.\n\n> **Astuce **: Utilisez la commande **watch** pour exécuter la commande périodiquement par intervalles de 1 seconde :\n> **watch -n1 docker service ls**. **Ctrl+c** pour quitter.\n\nSur le port **8080** de votre serveur vous devez trouver l'interface de contrôle de Traefik :\n\n![enter image description here](https://lh3.googleusercontent.com/-7OVJ1TQ-U80/WEeRgAfxt_I/AAAAAAAAAaM/-CFecYhSv-AQRsQxuVBAJ-tj0MG5wyTMQCLcB/s0/Capture+d%25E2%2580%2599e%25CC%2581cran+2016-12-07+a%25CC%2580+05.32.37.png \"Traefik Web\"){:rel=\"nofollow noreferrer\"}\n\n## Configuration du domaine\n\nAvant de lancer la registry sur notre environnement, nous allons créer deux sous-domaines pointant vers notre serveur web :\n\n-   l'un pour la registry,\n-   l'autre pour le serveur d'authentification\n\nSur le manager d'OVH, il suffit de se rendre dans **Web/Domaine(s)**, de choisir son domaine, puis de cliquer sur l'onglet **Zone DNS**\n\n![enter image description here](https://lh3.googleusercontent.com/-YW_nkX8qJV8/WEeUfHNWOaI/AAAAAAAAAaY/ljqtytkTCccK3eak8Gu6Ytt15XX28cEyQCLcB/s0/Capture+d%25E2%2580%2599e%25CC%2581cran+2016-12-07+a%25CC%2580+05.44.40.png \"Ajout entrée DNS\"){:rel=\"nofollow noreferrer\"}\n\nPuis nous ajoutons un pointage DNS de type **A** pour les sous-domaines :\n\n-   **registry.domain.tld** pour la registry,\n-   **token.domain.tld** pour le serveur d'authentification\n\n![enter image description here](https://lh3.googleusercontent.com/-MaFb82-SY3c/WEeVhjIumFI/AAAAAAAAAag/a8dyGIA0gfEQ4MvTFwgu89tEBYWE6j9FwCLcB/s0/Capture+d%25E2%2580%2599e%25CC%2581cran+2016-12-07+a%25CC%2580+05.51.24.png \"Ajout pointage DNS\"){:rel=\"nofollow noreferrer\"}\n\n> **Important**: Remplacez **domain.tld** par votre domaine et **xxx.xxx.xxx.xxx** par l'adresse IPv4 de votre serveur.\n\n## Serveur d’authentification\n\nDocker registry permet d'utiliser des services tiers pour gérer l'authentification et les contrôles d'accès des utilisateurs.\n\nNous allons utiliser ici [Docker Registry 2 authentication server](https://github.com/cesanta/docker_auth){:rel=\"nofollow noreferrer\"}.\n\nCette application en GO prend en charge plusieurs backends. Vous avez au choix la possibilité de stocker vos utilisateurs et ACL dans MongoDB, d'utiliser un serveur LDAP, ou dans notre cas, d'utiliser un fichier YAML.\n\nL'authentification des utilisateurs se fait par jeton [JWT](https://jwt.io/){:rel=\"nofollow noreferrer\"}. La registry Docker, de son coté, attend que ces jetons soient signés par un certificat. Commençons par le générer :\n\n``` bash\n# Préparation des répertoires nécessaires à docker auth\nsudo mkdir -p /opt/docker-auth/{logs,config,certs}\n\n# Génération du certificat\ncd /opt/docker-auth/certs\nsudo openssl req -x509 -newkey rsa:2048 -new -nodes -keyout privkey.pem -out fullchain.pem -subj \"/C=FR/ST=Paris/L=Paris/O=ACME/OU=IT Department/CN=[domain.tld]\"\n```\n\n> **Note **: Remplacez **\\[domain.tld\\]** par votre nom de domaine\n\nOn crée un fichier de configuration contenant nos utilisateurs et nos règles d'accès dans **/opt/docker-auth/config/auth\\_config.yml**\n\n```yaml\nserver:\n  addr: \":5001\"\n\ntoken:\n  issuer: \"Acme auth server\"  # Doit correspondre à l'émetteur (issuer) indiqué dans la configuration du registre\n  expiration: 900 # Expiration en secondes du jeton d'accès\n  certificate: \"/certs/fullchain.pem\"\n  key: \"/certs/privkey.pem\"\n\n# Les mots de passe sont hashés avec BCrypt (Utiliser htpasswd -B pour en générer un)\nusers:\n  \"admin\":\n    password: \"$2y$05$LO.vzwpWC5LZGqThvEfznu8qhb5SGqvBSWY1J3yZ4AxtMRZ3kN5jC\"  # badmin\n  \"test\":\n    password: \"$2y$05$WuwBasGDAgr.QCbGIjKJaep4dhxeai9gNZdmBnQXqpKly57oNutya\"  # 123\n  \"\": {}  # Autorise les accès anonymes au registre\n\nacl:\n  - match: {account: \"admin\"}\n    actions: [\"*\"]\n    comment: \"Tout est permit pour l'administrateur\"\n\n  - match: {account: \"/.+/\", name: \"${account}/*\"}\n    actions: [\"*\"]\n    comment: \"Les utilisateurs enregistrés peuvent tirer et contribuer des images dans leur espace de nom\"\n\n  - match: {account: \"/.+/\"}\n    actions: [\"pull\"]\n    comment: \"Les utilisateurs enregistrés peuvent tirer n'importe quelle image\"\n\n  - match: {account: \"\"}\n    actions: [\"pull\"]\n    comment: \"Les utilisateurs anonymes peuvent tirer n'importe quelle image\"\n```\n\nCréons enfin un fichier à l'adresse **$HOME/docker-auth.json**:\n\n```json\n{\n    \"Name\": \"docker-auth\",\n    \"Labels\": {\n        \"traefik.docker.network\": \"traefik\",\n        \"traefik.enable\": \"true\",\n        \"traefik.frontend.rule\": \"Host:[token.domain.tld]\",\n        \"traefik.port\": \"5001\"\n    },\n    \"TaskTemplate\": {\n        \"ContainerSpec\": {\n            \"Image\": \"cesanta/docker_auth:stable\",\n            \"Args\": [\n                \"/config/auth_config.yml\"\n            ],\n            \"Mounts\": [\n                {\n                    \"Type\": \"bind\",\n                    \"Source\": \"/opt/docker-auth/config\",\n                    \"Target\": \"/config\"\n                },\n                {\n                    \"Type\": \"bind\",\n                    \"Source\": \"/opt/docker-auth/logs\",\n                    \"Target\": \"/logs\"\n                },\n                {\n                    \"Type\": \"bind\",\n                    \"Source\": \"/opt/docker-auth/certs\",\n                    \"Target\": \"/certs\"\n                }\n            ]\n        },\n        \"RestartPolicy\": {\n            \"Condition\": \"any\",\n            \"MaxAttempts\": 0\n        },\n        \"Placement\": {\n            \"Constraints\": [\n                \"node.role==manager\"\n            ]\n        }\n    },\n    \"Mode\": {\n        \"Replicated\": {\n            \"Replicas\": 1\n        }\n    },\n    \"UpdateConfig\": {\n        \"Parallelism\": 1,\n        \"FailureAction\": \"pause\"\n    },\n    \"Networks\": [\n        {\n            \"Target\": \"traefik\"\n        }\n    ],\n    \"EndpointSpec\": {\n        \"Mode\": \"vip\"\n    }\n}\n```\n\n> **Important **: Remplacez **\\[token.domain.tld\\]** par le sous-domaine que vous avez créé précédemment pour le serveur d'authentification\n\nOn lance le service :\n\n```bash\ncurl -XPOST --unix-socket /var/run/docker.sock http:/services/create -d @$HOME/docker-auth.json\n```\n\nEt on vérifie que le service **docker-auth** est bien lancé en utilisant la commande **docker service ls**.\n\n### Mise en place de la registry\n\nIl ne nous reste plus qu'à mettre en place la registry.\n\nCréons des répertoires qui contiendront nos images docker :\n\n```bash\nsudo mkdir -p /opt/registry\n```\n\nPuis on finit avec un fichier que l'on crée à l'adresse **$HOME/registry.json **:\n\n```json\n{\n    \"Name\": \"docker-registry\",\n    \"Labels\": {\n        \"traefik.docker.network\": \"traefik\",\n        \"traefik.enable\": \"true\",\n        \"traefik.frontend.rule\": \"Host:[registry.domain.tld]\",\n        \"traefik.port\": \"5000\"\n    },\n    \"TaskTemplate\": {\n        \"ContainerSpec\": {\n            \"Image\": \"registry:2.5.0\",\n            \"Mounts\": [\n                {\n                    \"Type\": \"bind\",\n                    \"Source\": \"/opt/docker-auth/certs\",\n                    \"Target\": \"/certs\"\n                },\n                {\n                    \"Type\": \"bind\",\n                    \"Source\": \"/opt/registry\",\n                    \"Target\": \"/var/lib/registry\"\n                }\n            ],\n            \"Env\": [\n                \"REGISTRY_LOG_LEVEL=warn\",\n                \"REGISTRY_STORAGE_DELETE_ENABLED=true\",\n                \"REGISTRY_AUTH=token\",\n                \"REGISTRY_AUTH_TOKEN_REALM=https://[token.domain.tld]/auth\",\n                \"REGISTRY_AUTH_TOKEN_SERVICE=Docker registry\",\n                \"REGISTRY_AUTH_TOKEN_ISSUER=Acme auth server\",\n                \"REGISTRY_AUTH_TOKEN_ROOTCERTBUNDLE=/certs/fullchain.pem\"\n            ]\n        },\n        \"Placement\": {\n            \"Constraints\": [\n                \"node.role==manager\"\n            ]\n        }\n    },\n    \"Mode\": {\n        \"Replicated\": {\n            \"Replicas\": 1\n        }\n    },\n    \"UpdateConfig\": {\n        \"Parallelism\": 1,\n        \"FailureAction\": \"pause\"\n    },\n    \"Networks\": [\n        {\n            \"Target\": \"traefik\"\n        }\n    ],\n    \"EndpointSpec\": {\n        \"Mode\": \"vip\"\n    }\n}\n```\n\n> **Important **: Remplacez **\\[registry.domain.tld\\]** par le sous-domaine que vous avez créé précédemment pour la registry et **\\[token.domain.tld\\]** par celui dédié au serveur d'authentification.\n\nOn lance la registry :\n\n``` bash\ncurl -XPOST --unix-socket /var/run/docker.sock http:/services/create -d @$HOME/registry.json\n```\n\nEt on vérifie que le service **docker-registry** est bien lancé en utilisant la commande **docker service ls**.\n\n## Tests\n\nSur le port **8080** de votre serveur, vous devez avoir quelque chose d'équivalent à ceci :\n\n![enter image description here](https://lh3.googleusercontent.com/-CHOW4DC6pi4/WEefmOVQGpI/AAAAAAAAAbA/f7W-kRKRLaoUKMXb1BNgQHEyRLxPZHuNgCLcB/s0/Capture+d%25E2%2580%2599e%25CC%2581cran+2016-12-07+a%25CC%2580+06.34.33.png \"Traefik Services\"){:rel=\"nofollow noreferrer\"}\n\nSi c'est le cas, c'est que Traefik à fait correctement son boulot, vous avez maintenant un registre docker et un serveur d'authentification associés à leur domaines respectifs.\n\n> **Note **: Concernant le support de l'HTTPS pour ces domaines, il faut savoir que Traefik génère les certificats TLS et les fait signer par Let's Encrypt lors du premier accès. Il est recommandé d'utiliser cURL sur chacun d'eux pour initier la procédure. (exemple: \\*\\*curl -L <http://registry.guillem.me**>) Répéter la procédure dans le cas ou ça échoue.\n\nMaintenant, **sur votre poste local** (sur lequel vous avez installé docker) nous allons nous authentifier à la registry, \"tagguer\" une image puis l'envoyer.\n\n> **Note **: Pensez toujours à remplacer **\\[registry.domain.tld\\]** par le sous-domaine choisi précédemment.\n\n```\ndocker login registry.domain.tld\nUsername: # saisir l'identifiant admin\nPassword: # saisir badmin\nLogin Succeeded\n```\n\nRécupérons une image lambda sur DockerHub, tagguons-la, puis envoyons-la sur notre registry.\n\n```\ndocker pull alpine\ndocker tag alpine registry.domain.tld/alpine\ndocker push registry.domain.tld/alpine\n```\n\n> **Note **: Remplacez toujours et encore le fameux **\\[registry.domain.tld\\]**\n\nSi tout se déroule comme prévu, vous voyez alors quelque chose de proche de :\n\n```\nThe push refers to a repository [registry.domain.tld/alpine]\n011b303988d2: Pushed\nlatest: digest: sha256:1354db23ff5478120c980eca1611a51c9f2b88b61f24283ee8200bf9a54f2e5c size: 528\n```\n\nSi c'est le cas, félicitations, vous avez une registry docker à dispo !\n\n## Au prochain numéro…\n\nNous verrons comment utiliser **docker-compose** pour lancer un environnement de développement en local en tirant profit de notre registry docker et d’un outil de versionning pour fabriquer automatiquement nos images docker.\n\nÀ la prochaine!\n"}