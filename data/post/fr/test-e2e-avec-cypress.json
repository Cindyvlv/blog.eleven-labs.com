{"date":"2020-09-02T00:00:00.000Z","title":"Tester son application avec Cypress","excerpt":"Dans cet article nous allons voir comment mettre en place des tests end-to-end avec Cypress","readingTime":"9mn","authors":["kdung"],"categories":["javascript"],"content":"\n![Logo Cypress](/imgs/posts/2020-09-02-test-e2e-cypress/cypress-logo.png)\n\nLes tests sont devenus un aspect essentiel du développement web, pour ces deux raisons : **vérifier** que l’application fonctionne correctement et **garantir** la meilleure expérience utilisateur possible. Il existe différents types de tests mais aujourd’hui nous allons nous concentrer principalement sur les **tests End-to-end** et comment les implémenter avec **[Cypress](https://cypress.io/)**.\n\n## Que sont les tests end to end ?\n\n![Pyramide des coûts et quantités selon les tests](/imgs/posts/2020-09-02-test-e2e-cypress/pyramid.png)\n\nTout d’abord avant de parler des tests end-to-end, il faut que je vous explique les deux premières couches de cette pyramide (on ne peut pas arriver au sommet sans grimper la montagne).\n\n![GIF Alright](/imgs/posts/2020-09-02-test-e2e-cypress/alright.gif)\n\n**Les tests unitaires (TU)** constituent le socle des tests d’une application. Les TU permettent de tester uniquement un élément individuel de l’application (classe, fonction…).\n\n**Les tests d’intégration** vérifient simplement que les différentes parties de votre programme, que vous avez testées individuellement via des tests unitaires, fonctionnent bien une fois intégrées ensemble. Le but est de créer des cas d'usages réels ou très proches du réel.\n\n**Le test end-to-end** (aussi appelé e2e ou tests de bout-en-bout) est une méthode qui consiste à tester l'ensemble de l'application du début à la fin pour s'assurer que le flux d'application se comporte comme prévu. Il définit les dépendances système du produit et garantit que toutes les pièces intégrées fonctionnent ensemble comme prévu. L'objectif principal des tests de bout en bout (E2E) est de tester l'expérience de l'utilisateur final en simulant le scénario de l'utilisateur réel et en validant le système testé et ses composants pour l'intégration et l'intégrité des données.\n\nCes tests ignorent généralement la structure interne de l'ensemble de l’application et prennent le contrôle du navigateur comme un utilisateur allant sur votre application.\n\n## Qu'est-ce que Cypress ?\nIl existe de nombreux outils de test de bout-en-bout pour les applications Web, tels que TestCafe, Puppeteer et Selenium. Chacun a ses avantages et ses inconvénients. **Donc pourquoi utiliser Cypress ?**\n\nCypress est un framework JS de tests end-to-end. C’est un outil open source permettant de mettre facilement en place ces tests d’applications utilisant React ou des frameworks JavaScript comme Vue, Angular, Elm et bien d’autres.\n\n***\"Fast, easy and reliable testing for anything that runs in a browser.\"***\n\nPar rapport à d’autres outils de tests e2e, Cypress n’a pas besoin d’être couplé à une solution ni à un driver pour sa mise en place. Sa mission est de rendre l’écriture des tests plus rapide (tests exécutés sur le navigateur), plus facile (écriture des tests en JavaScript avec Mocha, Chai et Sinon) et encore plus fiable (visibilité des tests effectués sur le navigateur, screenshot de l’erreur).\n\n![Schéma avant et après Cypress](/imgs/posts/2020-09-02-test-e2e-cypress/cypress-details.png)\n\nCe qui m'a poussé à vous parler aujourd'hui de Cypress est le fait que lors d'un projet j'ai eu l'occasion de pouvoir l'utiliser et de constater la simplicité d'installation et d'écriture des tests mais aussi la robustesse de l'outil.\n\nCe qui démarque Cypress se décompose en plusieurs points :\n - Son architecture : contrairement à la plupart des outils de tests end-to-end, Cypress n'utilise pas de driver Selenium. Alors que Selenium exécute des commandes à distance via le réseau, Cypress s'exécute au sein même de votre boucle d'application, ce qui permet de développer et tester ces scénarios en temps réel. Cette exécution permet aussi de lancer les tests au sein même de votre navigateur. L'écriture des tests se fait donc en JavaScript avec des librairies déjà intégrées dans l'installation de Cypress telles que Mocha, Chai et Sinon.\n - accès natif : comme Cypress opère au sein même de l’application, cela lui permet d'avoir accès à tout, comme par exemple un élément du DOM, ou bien `window` ou `document`.\n - sa robustesse : Cypress est notifié du chargement d'une page. Comme il exécute la grande majorité de ses commandes à l'intérieur du navigateur, il n'y a donc pas de décalage réseau. Lors de l’exécution du scénario, Cypress attend automatiquement que l’élément du DOM soit visible (grâce aux assertions) avant de passer à la suite\n - débuggabilité : l'interface de Cypress permet facilement de faire du débuggage. Comme nous allons le voir par la suite, l'interface va nous montrer visuellement étape par étape l'exécution des commandes, assertions, requêtes réseaux et les temps de chargements et d'exécutions au sein de votre page. Il existe de nombreux messages d'erreurs décrivant la raison exacte pour laquelle Cypress a échoué sur le test du scénario. De plus, Cypress prend des snapshots de l'application et permet donc de revenir dans le temps à l'état dans lequel elle se trouvait lorsque les commandes ont été exécutées, mais aussi d'utiliser l'outil du développement du navigateur, par exemple pour voir les messages dans la console ou voir les requêtes réseaux.\n\n\nAprès ce petit tour des avantages (non-exhaustifs !) de Cypress, voyons comment ca marche.\n\n## Mise en place\n\n**Installation et configuration**\n\nComme expliqué plus tôt, Cypress est simple et rapide à prendre en main. Pour installer Cypress sur votre projet JS, il vous suffit juste d'exécuter à la racine de votre projet :\n\n```shell\nnpm install cypress --save-dev\n```\n\nou bien si vous utilisez yarn\n\n```shell\nyarn add cypress -D\n```\n\nUne fois l'installation terminée, on va ajouter une commande dans le champ `scripts` du `package.json`.\n```json\n {\n    \"scripts\": {\n        \"cypress: \"cypress open\"\n    },\n}\n```\nCette commande va nous permettre de démarrer l'interface d'exécution de tests de Cypress. Comme vous pouvez le voir sur la photo ci-dessous, des fichiers de tests sont affichés sur l'interface de Cypress. Ces fichiers ont été créés lors de l'exécution de la commande. Pour tester sur différents navigateurs, Cypress va tenter de trouver tous les navigateurs compatibles sur la machine. À l'heure où j'écris cet article, Cypress peut effectuer les scénarios de tests sur `Chrome`, `Chromium`, `Electron` et `Firefox`.\n\n![Cypress test runner](/imgs/posts/2020-09-02-test-e2e-cypress/cypress-test-runner.png)\n\nL'exécution du script `yarn cypress` n'a pas seulement généré des fichiers de tests, mais aussi une architecture placée à la racine du code de votre application.\n\n```\n.\n├── cypress\n│   ├── fixtures\n│   ├── integration\n│   ├── plugin\n│   └── support\n├── src\n│   └── ...\n├── cypress.json\n├── ...\n```\nDans ce dossier `cypress` vous pouvez retrouver des exemples et des commentaires pour vous guider dans le développement de vos tests. Le fichier `cypress.json` est le fichier de configuration sur lequel Cypress va se baser pour faire les tests. Dans ce fichier nous allons ajouter l'url de notre application qui servira de préfix pour des commandes de Cypress comme `cy.visit()` ou `cy.request()`. C'est aussi une bonne pratique de stocker notre url afin qu'elle soit accessible dans tous nos tests. Pour en savoir plus sur les possibilités de configuration de Cypress cliquez [ici](https://docs.cypress.io/guides/references/configuration.html#Global)\n```json\n{\n  \"baseUrl\": \"http://localhost:3000\"\n}\n```\n\n**Écriture des tests**\n\nMaintenant que nous avons installé et configuré Cypress, voyons comme écrire des tests.\n\n<div class=\"admonition note\" markdown=\"1\"><p class=\"admonition-title\">Note</p>\n\nPour cette présentation de la mise en place des tests end-to-end avec Cypress, supposons que nous avons une application React permettant d'acheter des produits.\n\n</div>\n\nUn développeur doit savoir comment et quoi tester dans l'application. Écrire des tests sans signification qui augmentent la couverture du code mais ne testent pas la vraie fonctionnalité est une perte de temps.\n\nTout d'abord avant d'écrire ce test il faut avoir le scénario en tête :\n - L'utilisateur arrive sur le site\n - Il se connecte\n - Si les identifiants sont corrects, il arrive sur la liste des produits\n - Il sélectionne un produit\n - Le panier s'incrémente\n - Il clique sur le panier\n - Il arrive sur la page panier\n - Il valide son achat\n - Un message de confirmation apparait\n(oui c'est un scénario assez court !)\n\nUne fois que vous avez votre scénario, vous pouvez commencer à coder. Il suffit de créer votre fichier de tests dans le dossier de Cypress `cypress/integration`.\n\n```javascript\nconst login = require(\"../../fixtures/login\");\n\ncontext(\"Login and buy stuff\", () => {\n  before(() => {\n    cy.visit('/');\n  });\n\n  describe(\"Attempt to sign in\", () => {\n    it('should have link to sign in', () => {\n      cy.get('[data-cy=signInBtn]').click();\n    });\n\n    it(\"Type data and submit form\", () => {\n      cy.get('[data-cy=email]')\n        .type(login.email)\n        .should(\"have.value\", login.email);\n\n      cy.get('[data-cy=password]')\n        .type(login.password)\n        .should(\"have.value\", login.password);\n\n      cy.get('[data-cy=submit]').click();\n    });\n  });\n\n  describe(\"Buy stuff process\", () => {\n    it('url should be /shop', () => {\n      cy.url().should(\"include\", \"/shop\");\n    });\n\n    it('check the cart to be zero', () => {\n      cy.get('[data-cy=cart]').contains(0);\n    })\n\n    it('click on stuff 2', () => {\n      cy.get('[data-cy=stuff-1]').contains('Add');\n      cy.get('[data-cy=stuff-1]').click();\n    });\n\n    it('increment the cart', () => {\n      cy.get('[data-cy=cart]').contains(1);\n    })\n\n    it('click on cart', () => {\n      cy.get('[data-cy=cart]').click();\n    });\n\n    it('redirect to cart view', () => {\n      cy.url().should(\"include\", \"/cart\");\n    });\n\n    it('purchase stuff and see confirm message', () => {\n      cy.get('[data-cy=submit]').contains('PURCHASE');\n      cy.get('[data-cy=submit]').click();\n      cy.get('[data-cy=success]').contains('Thank you for your purchase');\n    });\n  })\n});\n```\n\nLorsque vous souhaitez tester votre scénario, il suffit de cliquer sur le scénario voulu dans l'interface de Cypress et ce dernier le lancera dans le navigateur qui a été sélectionné.\nChaque ligne du test est répertoriée en détails (action, temps ...) sur l'interface de Cypress, la description des tests est séparée comme dans le code (`context`, `describe`, `it`).\n\n![Cypress tests succeed](/imgs/posts/2020-09-02-test-e2e-cypress/cypress-succeed.png)\n\nLorsque le test échoue, l'interface permet de débugger assez rapidement grâce aux messages d'erreurs assez explicites et aux snapshots de l'état avant et après au niveau du test qui a échoué.\n\n![Cypress tests failed](/imgs/posts/2020-09-02-test-e2e-cypress/cypress-failed.png)\n\n## Conclusion\n\nVoilà c'est tout pour aujourd'hui ! J'espère que cet article vous a donné envie d'utiliser Cypress dans vos développments ! Il y a beaucoup de possibilités d'utilisation avec Cypress, comme l'intégration continue avec la commande `cypress run` qui va jouer les tests et retourner les cas de réussite ou d'échecs.\nSi vous souhaitez en savoir plus sur Cypress, je vous invite à regarder la [documentation](https://docs.cypress.io/guides/core-concepts/introduction-to-cypress.html#Cypress-Can-Be-Simple-Sometimes/) qui est très bien alimenté.\n"}