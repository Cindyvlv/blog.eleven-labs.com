{"date":"2019-09-04T00:00:00.000Z","title":"Les nouveautés d'ES6 Partie II","excerpt":"La suite de la partie I est là ! Nous allons voir ensemble d'autres concepts apportés par ES6.","readingTime":"8mn","authors":["mehdidr"],"categories":["javascript"],"content":"\nVous l'attendiez (si si, ne dites pas le contraire), la voici ! La deuxième partie des nouveautés d'ES6 est arrivée\n_Psst, si tu n'as pas lu la partie I, elle se trouve [ici](https://blog.eleven-labs.com/fr/lesnouveauteses6parti) !_\nIl est conseillé de l'avoir lue pour comprendre plus aisément certaines notions qui ne seront pas réexpliquées ici.\n\n## destructuring\n\nLe destructuring, ou en français \"l'affectation par décomposition\" permet d'extraire (techniquement, en faire une copie) des données d'un tableau ou d'un objet, et de les assigner à une variable ou de déclarer une variable grâce à une syntaxe qui ressemble à la structure d'un tableau ou d'un objet.\n\n```javascript\n// Exemple avec un tableau\nvar someArray = [1, 2, 3]\n\n// ES5\nvar first = someArray[0];\nvar second = someArray[1];\nvar third = someArray[2];\n\n// ES6\nconst [ first, second, third ] = someArray;\n\n// Exemple avec un objet\nvar myObject = {\n  foo: 1,\n  bar: 2,\n};\n\n// ES5\nvar foo = myObject.foo;\nvar bar = myObject.bar;\n\n// ES6\nconst { foo, bar } = myObject;\n```\n\nIl est par ailleurs possible de nester les propriétés autant que souhaité, mais aussi de passer celles qui ne nous intéressent pas, de créer des valeurs par défaut et même de les renommer :\n\n```javascript\n// Nester les propriétés\nconst [ foo, [[bar], baz]] = [1, [[2], 3] ];\nconsole.log(foo); // 1\nconsole.log(bar); // 2\nconsole.log(baz); // 3\n\n// Skipper les propriétés\nconst [,,third] = [\"foo\", \"bar\", \"baz\"];\nconsole.log(third); // \"baz\"\n\n// Renommer les propriétés\nconst myObject = {\n  foo: 1,\n  bar: 2,\n};\nconst { foo: renamedFoo } = myObject;\nrenamedFoo; // 1\n\n// Créer une valeur par défaut\nconst person = {\n    name: 'John Doe',\n    country: 'Canada'\n};\n\nconst { name: fullname, country: place, age: years = 25 } = person; // si la clé age est undefined, sa valeur par défaut sera 25\n\nconsole.log(`I am ${fullname} from ${place} and I am ${years} years old.`); // I am John Doe from Canada and I am 25 years old.'\n```\n\nIl faut cependant se méfier lorsque l'on utilise le destructuring sur un objet pour assigner une variable sans la déclarer :\n\n```javascript\n{ blowUp } = { blowUp: 10 }; // Syntax error\n```\n\nCela se produit car javascript considère que l'on cherche à parser toute déclaration commencant par `{` comme un bloc (par exemple, `{ console }` est un bloc valide). Il suffit pour y remédier d'entourer l'assignation entre parenthèses :\n\n```javascript\n({ safe } = {}); // Pas d'erreur\n```\n\nPour creuser le sujet et voir pleins d'exemples différents, je vous conseille de regarder par [ici](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/Affecter_par_d%C3%A9composition).\n\n## rest parameter & spread operator\n\nLe paramètre du reste et le spread operator font partie du sucre syntaxique apporté par ES6, tout comme le destructuring. Ils consistent tous les deux à effectuer plus simplement des opérations complexes sur les objets itérables en utilisant la syntaxe `...`.\n\n### rest parameters\n\nLe paramètre du reste (appelé ainsi car c'est un paramètre de fonction qui va servir à ramasser les \"restes\") remplace un mot-clé utilisé par les fonctions appelé `arguments`. Il permettait, comme son nom l'indique, de récupérer les arguments d'une fonction sous forme de tableau, qui ne conserve aucune des propriétés ou méthodes d'un tableau mis à part `length`.\nDe plus,  il était impossible de ne mettre qu'une partie des paramètres dans l'objet `arguments`, qui par ailleurs n'est pas disponible dans les arrow functions en plus d'être plus gourmand en performances.\n\nLe rest parameter permet donc d'assembler plusieurs valeurs dans un tableau, sans avoir les problèmatiques de l'`arguments`.\n\n```javascript\n// Exemple 1\nconst logArgs = (...args) => console.log(args)\n\nlogArgs('coucou', 3, 'Bob') // args == ['coucou', 3, 'Bob']\n\n// Exemple 2\nconst sumAll = (...args) => { // args is the name for the array\n  let sum = 0;\n\n  for (let arg of args) sum += arg;\n\n  return sum;\n}\n\nconsole.log(sumAll(1)); // 1\nconsole.log(sumAll(1, 2)); // 3\nconsole.log(sumAll(1, 2, 3)); // 6\n```\n\n### spread operator\n\nLe spread operator (appelé opérateur de décomposition en français) permet de développer un objet itérable lorsqu'on a besoin de plusieurs arguments. Son utilisation est donc complètement opposée au rest parameter, et nous donne la possibilité par ailleurs d'éviter l'utilisation d'`apply` et `concat`:\n\n```javascript\n// Exemple 1\nconst arr1 = ['a', 'b'];\nconst arr2 = ['c'];\nconst arr3 = ['d', 'e'];\n\n// ES5\nconsole.log(arr1.concat(arr2, arr3)); // [ 'a', 'b', 'c', 'd', 'e' ]\n\n// ES6\nconsole.log([...arr1, ...arr2, ...arr3]); // [ 'a', 'b', 'c', 'd', 'e' ]\n\n// Exemple 2\n\n// ES5\nconsole.log.apply(console, [\"foo\", \"bar\"]);\n\n// ES6\nconsole.log(...[\"foo\", \"bar\"]); // même résultat\n```\n\nLe spread operator se marie à merveille avec l'utilisation du destructuring :\n\n```javascript\nconst words = [\"foo\", \"bar\", \"baz\"];\n\n// ES5\nvar first = words[0]; // \"foo\"\nvar rest = words.slice(1); // [\"bar\", \"baz\"]\n\n// ES6\nconst [first, ...rest] = words; // même résulat\n```\n\n## Template literals\n\nL'ajout du support des template literals (ou template strings) permet de simplifier la manipulation des chaînes de caractères. Ils sont par ailleurs supportés par la plupart des navigateurs et babel, donc aucune raison de passer à côté !\n\n```javascript\n// Exemple\nconst rep = 42;\n\n// ES5\nconsole.log('La réponse est ' + 42); // La réponse est 42\n\n// ES6\nconsole.log(`La réponse est ${rep}`); // La réponse est 42\n```\n\nUn autre intérêt des template literals est le support multi-lignes :\n\n```javascript\n// ES5\nvar multiline =\n  \"foo \\\n                 bar \\\n                 baz\";\n\nvar multiline2 = \"foo\";\nmultiline2 += \"bar\";\nmultiline2 += \"baz\";\n\n// ES6\nconst multiline = `foo\n                   bar\n                   baz`;\n```\n\n⚠️ Les espaces sont conservés sur l'utlisation du multi-lignes avec les templates literals.\n\n```javascript\nconst str1 = `foo\nbar`;\n\nconst str2 = `foo\n             bar`;\n\nstr1 === str2; // => false\n```\n\n## Maps\n\nLes Maps sont des dictionnaires qui contiennent des clés dont l'ordre d'insertion est mémorisé, auxquelles sont associées des valeurs. Bien qu'ils sont similaires aux objets, il existe certaines différences :\n\n- Un objet possède un `prototype`, ce qui n'est pas le cas des maps.\n- Les clés d'un objet sont soit des chaînes de caractères, soit des `Symbols`, alors que celles d'un Map peuvent avoir n'importe quelle valeur. Par exemple:\n\n```javascript\nconst myMap = new Map();\nmyMap.set(window, 1);\nmyMap.get(window); // 1\n```\n\nPetite particularité des Maps, la valeur `NaN`, qui n'est pas égale à elle-même en JS, est bien gérée.\n\n```javascript\nmyMap.set(NaN, 1);\nmyMap.get(NaN); // 1\n```\n\n- Les clés des Maps sont ordonnées par ordre d'insertion comme dit précédemment, contrairement à celles des objets qui n'ont pas d'ordre particulier. Il est par ailleurs possible d'itérer sur les clés des Maps (avec un `forEach` par exemple), ce qui est impossible avec un objet car il faut au préalable récupérer les clés pour pouvoir itérer dessus. Cela permet d'obtenir facilement un tableau, par exemple :\n\n```javascript\nconst myEntries = [...myMap]; // […[key, value]]\n\n// or\nconst myEntries = [...myMap.entries()];\n```\n\n- Il existe une méthode `size` qui permet de récupérer simplement la taille d'un Map, contrairement aux objets où il faudra compter \"manuellement\". En outre, les maps permettent de meilleures performances lorsqu'il s'agit d'ajouter ou supprimer fréquemment des éléments.\n\n## Nouvelles méthodes pour les tableaux et les chaînes de caractères\n\nL'ES6 apporte aussi de nouvelles méthodes pour les tableaux tels que `from`, qui permet de créer un tableau à partir d'un objet itérable (comme une string, un objet, etc), ou `findIndex` ou encore `fill`, etc.\n\nComme il serait trop long de toutes les énumérer ici, je vous renvoie vers cet [article](https://www.hackerearth.com/fr/practice/notes/hemanth12/es6-array-methods/). Si vous êtes anglophobes, n'hésitez pas à lire la [doc de MDN sur les array](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array) ainsi que la [doc de MDN sur les chaînes de caractères](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String) qui vous donnera de nombreux exemples.\n\nCertaines méthodes sont beaucoup plus utilisées que d'autres, comme par exemple le `map`, le `reduce`, le `push`, ou encore le `join`. Il est cependant utile de connaître (ou du moins de savoir qu'elles existent) toutes les méthodes, car elles ont toutes leur utilité dans des cas spécifiques sur lesquels vous tomberez forcément un jour ou l'autre.\n\n## Conclusion\n\nVoilà, après ces deux parties bien remplies, nous arrivons au terme des fonctionnalités les plus intéressantes apportées par ES6 ! Elles ne sont pas toute expliquées ici, mais vous pouvez les retrouver sur ce [lien](https://exploringjs.com/es6/ch_core-features.html) ou encore [celui-ci](http://es6-features.org/#Constants). Attention cependant, il ne faut pas oublier que chacune des fonctionnalités évoquées est un simple aperçu, n'hésitez pas à creuser les différents sujets abordés. Certains diront qu'il manque les promesses qui est une énorme feature, mais je réserve ça pour un autre article. See ya !\n"}