{"date":"2017-06-07T00:00:00.000Z","title":"Construire et structurer une API GraphQL en Go","excerpt":"GraphQL est disponible depuis maintenant presque 2 ans et les applications qui l'utilisent se font toujours assez rare.","readingTime":"10mn","authors":["vcomposieux"],"categories":[],"content":"GraphQL est disponible depuis maintenant presque 2 ans et les applications qui l'utilisent se font toujours assez rare.\nPourtant, cette implémentation proposée par Facebook offre de nombreuses possibilités que ne permet pas une API REST.\n\n# Introduction\n\nL'objectif de cet article n'est pas de vous expliquer ce qu'est GraphQL, la documentation située à l'adresse http://graphql.org/learn l'explique déjà très bien !\n\nJe me suis donc intéressé à construire une API GraphQL, et tant qu'à avoir une API performante, j'ai choisi le langage Go pour la développer, à l'aide de la librairie `graphql-go` (https://github.com/graphql-go/graphql).\n\n# Structure de fichiers de notre API\n\nLa première chose (et pas des moindres) à prendre en compte lorsque l'on souhaite développer une application est la structure de celle-ci.\n\nEn effet, notre API va être amenée à évoluer, nous allons avoir de plus en plus d'éléments à fournir à nos applications et peut-être allons-nous souhaiter ajouter des composants (pour sécuriser notre API, pour logger des informations, pour limiter le nombre de requêtes, etc ...).\n\nAinsi, voici l'arborescence que je vous propose pour notre API :\n\n```bash\n.\n├── app\n│   ├── config.go\n│   ├── config.json\n│   └── config_test.go\n├── security\n│   ├── security.go\n│   └── security_test.go\n├── mutations\n│   ├── mutations.go\n│   ├── mutations_test.go\n│   ├── user.go\n│   └── user_test.go\n├── queries\n│   ├── queries.go\n│   ├── queries_test.go\n│   ├── user.go\n│   └── user_test.go\n├── types\n│   ├── role.go\n│   ├── role_test.go\n│   ├── user.go\n│   └── user_test.go\n└── main.go\n```\n\nNous retrouvons ici :\n* \"app/\" qui comprendra tout ce qui sera nécessaire à notre application (API), principalement un fichier de configuration (JSON) `config.json` ainsi que le fichier Go permettant de charger ce JSON,\n* \"security/\" permettra de regrouper les classes liées à la sécurisation de notre API,\n* \"mutations/\" permettra de regrouper toutes les mutations GraphQL (modifications de données),\n* \"queries/\" permettra de regrouper toutes les requêtes GraphQL de sélection de données,\n* \"types/\" permettra de regrouper les structures Go utilisées lors de nos mutations ou requêtes.\n\nEnfin, nous retrouvons bien sûr à la racine `main.go` qui est le point d'entrée de notre API.\nNous allons d'ailleurs commencer dès maintenant à construire notre API !\n\n# Point d'entrée de l'API\n\nPour construire notre API, nous allons avoir besoin dans un premier temps d'importer le package \"net/http\" (car notre API GraphQL va être distribuée en HTTP) ainsi que les librairies graphql-go :\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/graphql-go/graphql\"\n\t\"github.com/graphql-go/handler\"\n)\n\nfunc main() {\n\t// Todo: Implement GraphQL handler\n\n\thttp.Handle(\"/\", httpHandler)\n\tlog.Print(\"ready: listening...\\n\")\n\n\thttp.ListenAndServe(\":8383\", nil)\n}\n```\n\nVous remarquerez ici qu'il nous manque la variable `httpHandler`, qui sera en fait le handler HTTP GraphQL qui sera exécuté pour chaque requête sur \"/\". Aussi, nous précisons ici que nous allons écouter sur le port 8383, libre à vous de mettre celui que vous souhaitez.\n\nNotre `httpHandler` va avoir besoin d'un schéma dans lequel nous allons spécifier deux points d'entrée : un pour les requêtes et un second pour les mutations :\n\n```go\nschemaConfig := graphql.SchemaConfig{\n  Query: graphql.NewObject(graphql.ObjectConfig{\n    Name:   \"RootQuery\",\n    Fields: queries.GetRootFields(),\n  }),\n  Mutation: graphql.NewObject(graphql.ObjectConfig{\n    Name:   \"RootMutation\",\n    Fields: mutations.GetRootFields(),\n  }),\n}\n\nschema, err := graphql.NewSchema(schemaConfig)\n\nif err != nil {\n  log.Fatalf(\"Failed to create new schema, error: %v\", err)\n}\n\nhttpHandler := handler.New(&handler.Config{\n  Schema: &schema\n})\n```\n\nDans le cas ou vous n'avez aucune modifications de données mais uniquement des requêtes de sélection, vous pouvez bien sûr supprimer la section concernant les mutations.\n\nIci, il nous manque `queries.GetRootFields()` ainsi que `mutations.GetRootFields()`. Ces méthodes vont nous permettre de définir toutes les `queries` et `mutations` que nous allons définir par la suite.\n\nPlutôt que d'alourdir le fichier `main.go`, j'ai choisi de les déposer sous `queries/queries.go` et `mutations/mutations.go`.\n\n# Structures de données\n\nAvant de commencer à écrire notre première requête, nous devons définir notre modèles de données.\n\nDans cet article, nous allons partir sur des données utilisateur (\"user\") avec un identifiant, un prénom et un nom. Cela donne nous pour notre fichier `types/user.go` :\n\n```go\npackage types\n\nimport (\n\t\"github.com/graphql-go/graphql\"\n)\n\n// User type definition.\ntype User struct {\n\tID        int    `db:\"id\" json:\"id\"`\n\tFirstname string `db:\"firstname\" json:\"firstname\"`\n\tLastname  string `db:\"lastname\" json:\"lastname\"`\n}\n\n// UserType is the GraphQL schema for the user type.\nvar UserType = graphql.NewObject(graphql.ObjectConfig{\n\tName: \"User\",\n\tFields: graphql.Fields{\n\t\t\"id\":         &graphql.Field{Type: graphql.Int},\n\t\t\"firstname\":  &graphql.Field{Type: graphql.String},\n\t\t\"lastname\":   &graphql.Field{Type: graphql.String},\n\t},\n})\n```\n\nNous avons ici définis deux choses :\n* Une structure Go, qui sera utilisée par notre base de données et afin de renvoyer les données de notre API au format JSON,\n* Un object `UserType` qui sera utilisé par notre API GraphQL afin d'indiquer les champs qui peuvent être retournés aux applications.\n\nÀ l'aide de ce modèle de données, nous sommes maintenant prêts à construire notre première requête GraphQL !\n\n# Requêtes\n\nCommençons par éditer le fichier `queries/queries.go` afin d'ajouter une requête `user` qui sera chargée de retourner nos données utilisateur :\n\n```go\npackage queries\n\nimport (\n\t\"github.com/graphql-go/graphql\"\n)\n\n// GetRootFields returns all the available queries.\nfunc GetRootFields() graphql.Fields {\n\treturn graphql.Fields{\n\t\t\"user\": GetUserQuery(),\n\t}\n}\n```\n\nNous avons donc ajoutés un nouveau champ à notre requête principale écrite précédemment (RootQuery) nommé `user` et qui fera appel à la fonction `GetUserQuery()`.\n\nNous allons maintenant définir cette fonction et son comportement dans un fichier dédié sous `queries/user.go` :\n\n```go\npackage queries\n\nimport (\n\t\"../types\"\n\n\t\"github.com/graphql-go/graphql\"\n)\n\n// GetUserQuery returns the queries available against user type.\nfunc GetUserQuery() *graphql.Field {\n\treturn &graphql.Field{\n\t\tType: graphql.NewList(types.UserType),\n\t\tResolve: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\tvar users []types.User\n\n      // ... Implémenter la logique de base de données ici\n\n\t\t\treturn users, nil\n\t\t},\n\t}\n}\n```\n\nNotre première requête est prête : nous allons utiliser le type de données `UserType`, il ne vous reste plus qu'à implémenter la logique de retour de vos données !\n\nVous pouvez à cet endroit faire un appel à tout outil de stockage de vos données : bases de données relationnelles ou non, SQL ou non, fichier, mémoire, tout est envisageable.\n\n# Ajouter des relations à votre API\n\nImaginons maintenant que vous ayez des roles (pour gérer des accès à certaines ressources) associés à vos utilisateurs.\n\nVous pouvez également demander à votre API de retourner ceux-ci.\nPour cela, nous allons commencer par implémenter une nouvelle structure `Role` ainsi qu'un nouveau type `RoleType` pour GraphQL.\n\nCréez donc le fichier `types/role.go` avec le code suivant :\n\n```go\npackage types\n\nimport (\n\t\"github.com/graphql-go/graphql\"\n)\n\n// Role type definition.\ntype Role struct {\n\tID   int    `db:\"id\" json:\"id\"`\n\tName string `db:\"name\" json:\"name\"`\n}\n\n// RoleType is the GraphQL schema for the user type.\nvar RoleType = graphql.NewObject(graphql.ObjectConfig{\n\tName: \"Role\",\n\tFields: graphql.Fields{\n\t\t\"id\":   &graphql.Field{Type: graphql.Int},\n\t\t\"name\": &graphql.Field{Type: graphql.String},\n\t},\n})\n```\n\nVoilà qui est fait. Il faut maintenant que nous spécifions à notre `UserType` qu'il est possible d'obtenir les roles de l'utilisateur.\n\nPour cela, éditez le fichier `types/user.go` et ajoutez une nouvelle section `graphql.Field` vers votre `RoleType` :\n\n```go\nvar UserType = graphql.NewObject(graphql.ObjectConfig{\n\tName: \"User\",\n\tFields: graphql.Fields{\n\t\t// ... already defined fields\n\t\t\"roles\": &graphql.Field{\n\t\t\tType: graphql.NewList(RoleType),\n\t\t\tResolve: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\t\tvar roles []Role\n\n\t\t\t\t// userID := params.Source.(User).ID\n\t\t\t\t// Implement logic to retrieve user associated roles from user id here.\n\n\t\t\t\treturn roles, nil\n\t\t\t},\n\t\t},\n\t},\n})\n```\n\nNotez ici que le `Type` spécifié est un `graphql.NewList(RoleType)` car nous allons retourner une liste de roles et non pas un seul role.\n\nPour effectuer votre requête, vous pouvez utiliser `params.Source` pour obtenir les informations de l'élément principal (ici, l'utilisateur) et ainsi obtenir vos données liées à cet utilisateur.\n\nEnfin, ce qui est intéressant ici est que le requêtage de données (roles) sera effectué uniquement si le client effectuant la requête GraphQL demande à obtenir les roles.\n\n# Effectuer des appels à votre API\n\nÀ partir de là, vous pouvez donc intéroger votre API avec la requête suivante :\n\n```bash\ncurl\n  -X POST\n  -H 'Content-Type: application/json'\n  -d '{\"query\": \"query { users { id,firstname,lastname,roles{name} } }\"}'\n  http://localhost:8383/\n\n{\"data\":{\"user\":[{\"id\":1,\"firstname\":\"Vincent\",\"lastname\":\"COMPOSIEUX\",\"roles\":[]}, ...]}}\n```\n\nBien entendu, uniquement les champs demandés dans la requête vous seront retournés, c'est le principe.\n\nGraphQL offre bien sûr des possibilités intéressantes au niveau des requêtes avec notamment des aliases, variables et fragments qui ne sont pas l'objectif de cet article mais je vous invite à faire un tour dans la documentation, ça se comprend très simplement facilement :\n\n* Aliases : http://graphql.org/learn/queries/#aliases\n* Fragments : http://graphql.org/learn/queries/#fragments\n* Variables : http://graphql.org/learn/queries/#variables\n\n# Mutations\n\nCôté mutations, le fonctionnement est identique aux requêtes. Nous allons donc créer notre première mutation et vous allez voir que ça ressemble beaucoup aux queries.\n\nCréez le fichier \"mutations/mutations.go\" et spécifions notre `RootMutation` avec notre fonction `GetRootFields()` :\n\n```go\npackage mutations\n\nimport (\n\t\"github.com/graphql-go/graphql\"\n)\n\n// GetRootFields returns all the available mutations.\nfunc GetRootFields() graphql.Fields {\n\treturn graphql.Fields{\n\t\t\"createUser\": GetCreateUserMutation(),\n\t}\n}\n```\n\nIci, nous allons créer une mutation pour ajouter un nouvel utilisateur dans notre base de données.\n\nDéclarons donc maintenant la fonction `GetCreateUserMutation()` dans le fichier `mutations/user.go` :\n\n```go\npackage mutations\n\nimport (\n\t\"../types\"\n\n\t\"github.com/graphql-go/graphql\"\n)\n\n// GetCreateUserMutation creates a new user and returns it.\nfunc GetCreateUserMutation() *graphql.Field {\n\treturn &graphql.Field{\n\t\tType: types.UserType,\n\t\tArgs: graphql.FieldConfigArgument{\n\t\t\t\"firstname\": &graphql.ArgumentConfig{\n\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t},\n\t\t\t\"lastname\": &graphql.ArgumentConfig{\n\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t},\n\t\t},\n\t\tResolve: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\tuser := &types.User{\n\t\t\t\tFirstname: params.Args[\"firstname\"].(string),\n\t\t\t\tLastname:  params.Args[\"lastname\"].(string),\n\t\t\t}\n\n      // Add your user in database here\n\n\t\t\treturn user, nil\n\t\t},\n\t}\n}\n```\n\nVotre mutation est prête à être utilisée !\n\nComme vous pouvez le remarquer, nous avons ici ajoutés une section `Args` qui nous permet de définir des arguments à notre fonction, par exemple : `createUser(firstname: \"John\", lastname: \"Snow\")`.\n\nIl est ensuite possible de tester votre API en effectuant la requête HTTP suivante :\n\n```bash\ncurl\n    -X POST\n    -H 'Content-Type: application/json'\n    -d '{\"query\": \"mutation { createUser(firstname: \\\"John\\\", lastname: \\\"Snow\\\") { id,firstname,lastname } }\"}'\n    http://localhost:8383\n```\n\nVous pouvez bien sûr choisir d'obtenir en retour uniquement l'identifiant de l'utilisateur nouvellement créé.\n\n# Securité\n\nLa plupart de vos APIs ne sont certainement pas publiques, il vous faut donc y ajouter un composant de sécurité, et c'est ce que nous allons faire ici en intégrant une authentification JWT (https://jwt.io/).\n\nNous allons utiliser la librairie `dgrijalva/jwt-go` (https://github.com/dgrijalva/jwt-go) afin de simplifier l'intégration de JWT dans notre application.\n\nAjoutez simplement dans votre fichier `security/security.go` le contenu suivant :\n\n```go\npackage security\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n)\n\n// Handle security middleware aims to implement a JWT authentication.\nfunc Handle(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")[7:] // 7 corresponds to \"Bearer \"\n\n\t\ttoken, _ := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t\t}\n\n      var secret = \"my-high-security-secret\" // Prefer to store this secret in a configuration file\n\n\t\t\treturn []byte(secret), nil\n\t\t})\n\n\t\tif claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n\t\t\tlog.Printf(\"JWT Authenticated OK (app: %s)\", claims[\"app\"])\n\n\t\t\tnext.ServeHTTP(w, r)\n\t\t}\n\t})\n}\n```\n\nIci, nous récupérons le token reçu dans le header `Authorization: Bearer xxx` et allons l'utiliser pour le comparer avec notre secret.\n\nDans le cas ou le token est valide, l'application continuera à exécuter le handler HTTP, sinon, une erreur sera levée.\n\nPour utiliser ce composant de sécurité, il faut repasser sur notre fichier `main.go` afin d'importer le répertoire `security` et de modifier :\n\n```go\nhttp.Handle(\"/\", httpHandler)\n```\n\nen :\n\n```go\nhttp.Handle(\"/\", security.Handle(httpHandler))\n```\n\nVous disposez maintenant d'une API GraphQL performante et sécurisée !\n\n# Conclusion\n\nL'implémentation de GraphQL en Go est plutôt simple à prendre en main et les performances du langage permettent de construire une API performante.\n\nIl nous est également possible de bien structurer celle-ci afin de séparer notamment les queries, les mutations et les autres composants.\n\nSi vous voulez tester cette structure, les sources sont disponibles ici : https://github.com/eko/graphql-go-structure\n"}