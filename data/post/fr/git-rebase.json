{"date":"2021-09-22T00:00:00.000Z","title":"Git rebase","excerpt":"Aujourd'hui, nous utilisons tous git pour gérer le code source des projets, que ce soit pour notre usage personnel ou professionnel.","readingTime":"5mn","authors":["tthuon"],"categories":[],"content":"\nAujourd'hui, nous utilisons tous git pour gérer le code source des projets, que ce soit pour notre usage personnel ou professionnel.\nNous savons tous commiter ou tirer des modifications. Mais il y a un problème assez récurrent dans les projets à plusieurs collaborateurs : les conflits.\nPour mieux les gérer et les éviter, je vous propose d'aborder une commande git : rebase.\n\n*Notez qu'après lecture de ces quelques lignes, un autre article sera susceptible de vous intéresser aussi, intitulé [Introduction à Gitlab CI/CD](https://blog.eleven-labs.com/fr/introduction-gitlab-ci/) (qui comme son nom l'indique vous initie au fonctionnement de Gitlab CI/CD). N'hésitez pas à aller y jeter un oeil :)* \n\n## Le problème\n\nGit permet d'avoir un historique complet des modifications du code source. Pour réaliser une fonctionnalité, chaque contributeur va créer une branche depuis la branche *master*.\n\nLes développements commencent et chacun modifie des lignes de codes.\n\nNous avons Jean qui a terminé le développement d'une fonctionnalité. Elle est fusionnée dans *master*. Tout se passe bien.\n\nMarc a également terminé son développement, mais il a modifié les même fichiers que Jean. Si la branche de marc est fusionnée à ce moment, il y aura des **conflits**.\n\n## La solution\n\nIl est donc nécessaire de mettre à jour sa branche avant de pousser ses modifications. Cette mise à jour va inclure toutes les modifications de Jean dans la branche de Marc. Ça s'appelle un *rebase*.\n\n```sh\ngit rebase\n```\n\nCette commande va prendre tous les commits de la branche en cours pour les appliquer à la suite de l'historique de la branche cible (très souvent *master*).\n\nIl est important de voir l'historique git comme un empilement d'éléments (*commit*).\n\n## Exemple\n\nJ'ai une branche *master* avec le code source de mon application.\n\n```\ncommit c1\nAuthor: lepiaf\nDate: Sun Jun 12 16:32:19 2016 +0200\n\n    initialize tutorial\n```\n\nJe crée une branche pour implémenter une fonctionnalité.\n\n```sh\ngit checkout -b myfeat\n```\n\nUn autre personne crée une branche avec une autre fonctionnalité à implémenter.\n\n```sh\ngit checkout -b anotherfe\n```\n\n![gitrebase-init]({{site.baseurl}}/assets/2016-06-21-git-rebase/gitrebase-init.png)\n\nLes développements avancent. La branche *myfeat* :\n\n```\ncommit c2\nAuthor: lepiaf\nDate:   Sun Jun 12 17:06:00 2016 +0200\n\n    create a branch\n\ncommit c1\nAuthor: lepiaf\nDate:   Sun Jun 12 16:32:19 2016 +0200\n\n    initialize tutorial\n```\n\n![gitrebase-myfeat-commit]({{site.baseurl}}/assets/2016-06-21-git-rebase/gitrebase-myfeat-commit.png)\n\nLa branche *my-feat* est fusionnée en premier dans *master*.\n\n```sh\ngit checkout master\ngit merge myfeat\n```\n\nEt mon historique de *master*\n\n```\ncommit c1\nAuthor: lepiaf\nDate:   Sun Jun 12 17:06:00 2016 +0200\n\n    create a branch\n\ncommit c1\nAuthor: lepiaf\nDate:   Sun Jun 12 16:32:19 2016 +0200\n\n    initialize tutorial\n```\n\n![gitrebase-myfeat-merge]({{site.baseurl}}/assets/2016-06-21-git-rebase/gitrebase-myfeat-merge.png)\n\nIci il y a eu une fusion rapide.\n\nAvec la branche *anotherfe* je crée un autre commit.\n\n```\ncommit c3\nAuthor: lepiaf\nDate:   Sun Jun 12 17:15:59 2016 +0200\n\n    add title level 2\n\ncommit c1\nAuthor: lepiaf\nDate:   Sun Jun 12 16:32:19 2016 +0200\n\n    initialize tutorial\n```\n\n![gitrebase-anotherfe-commit]({{site.baseurl}}/assets/2016-06-21-git-rebase/gitrebase-anotherfe-commit.png)\n\nSi je fusionne cette branche avec *master*, je vais avoir des problèmes car j'ai modifié le même fichier. Je vais d'abord faire un rebase depuis master pour appliquer mes modifications à la suite des modifications de *master*.\n\n```sh\ngit rebase master\nPremièrement, rembobinons head pour rejouer votre travail par-dessus...\nApplication : add title level 2\n```\n\nJe vois que le commit \"c3\" est bien appliqué après les modification \"c1\" et \"c2\".\n\n![gitrebase-anotherfe-rebase]({{site.baseurl}}/assets/2016-06-21-git-rebase/gitrebase-anotherfe-rebase.png)\n\nIci, le *rebase* s'est bien déroulé car il n'y a pas eu de modification au même endroit.\n\nEnsuite je peux fusionner *anotherfe* dans *master* sans problème.\n\n```\ncommit c3\nAuthor: lepiaf\nDate:   Sun Jun 12 17:15:59 2016 +0200\n\n    add title level 2\n\ncommit c2\nAuthor: lepiaf\nDate:   Sun Jun 12 17:06:00 2016 +0200\n\n    create a branch\n\ncommit c1\nAuthor: lepiaf\nDate:   Sun Jun 12 16:32:19 2016 +0200\n\n    initialize tutorial\n```\n\nJe vois que master contient bien les modifications de *myfeat* et *anotherfe*.\n\n![gitrebase-master-final]({{site.baseurl}}/assets/2016-06-21-git-rebase/gitrebase-master-final-1.png)\n\n### Gestion des conflits\n\nIl arrive que les modifications soient sur le même fichier et sur les même lignes. Dans ce cas, git ne sait pas lesquelles appliquer.\n\nJe vais créer deux branches: *feat-commit* et *feat-cherry-pick*\n\nSur *feat-commit*, j'ai un commit et il est prêt à être fusionné sur *master*.\n\n```sh\ncommit 98dfce3f58f158b966dbd4a8ef177b2a4aa23f18\nAuthor: lepiaf\nDate:   Sun Jun 12 17:23:21 2016 +0200\n\n    create commit\n\ncommit 13f1553f92a9ef09da02a695743dd0f6952b4b82\nAuthor: lepiaf\nDate:   Sun Jun 12 17:15:59 2016 +0200\n\n    add title level 2\n\n(...)\n```\n\nJe merge *feat-commit* dans *master*.\n\n```sh\ngit checkout master\ngit merge feat-commit\n```\n\nTout se passe bien.\n\nMaintenant, je dois fusionner *feat-cherry-pick* dans *master*.\n\nComme je sais qu'il y a eu des modifications sur *master*, je vais faire un *git rebase* pour appliquer mes modifications au dessus de ceux de *master*.\n\n```sh\ngit checkout feat-cherry-pick\ngit rebase master\n```\n\nEt là, kaboum !\n\n```\ngit rebase master\nPremièrement, rembobinons head pour rejouer votre travail par-dessus...\nApplication : how to cherry pick\nUtilisation de l'information de l'index pour reconstruire un arbre de base...\nM   README.md\nRetour à un patch de la base et fusion à 3 points...\nFusion automatique de README.md\nCONFLIT (contenu) : Conflit de fusion dans README.md\nÉchec d'intégration des modifications.\nLe patch a échoué à 0001 how to cherry pick\nLa copie du patch qui a échoué se trouve dans :\n   /home/nous/Sites/git/.git/rebase-apply/patch\n\nLorsque vous aurez résolu ce problème, lancez \"git rebase --continue\".\nSi vous préférez sauter ce patch, lancez \"git rebase --skip\" à la place.\nPour extraire la branche d'origine et stopper le rebasage, lancez \"git rebase --abort\".\n```\n\nLe rebase n'a pas fonctionné. Il y a des conflits dans le fichier README.md.\n\nGit va marquer les sections en conflit avec des chevrons.\n\n```\n<<<<<<< HEAD\n```\n\n### Commit\n\nTo commit a change:\n\n```bash\ngit commit -m \"my message\"\n```\n\n### Cherry pick\n\nTo cherry-pick a commit\n\n```bash\ngit cherry-pick\n```\n\nD'un côté il y a le HEAD qui correspond au master, de l'autre la branche en cours de rebase.\n\nDans notre cas, je veux garder les deux modifications et les fusionner. J'édite le fichier en supprimant les chevrons.\n\n### Commit\n\nTo commit a change:\n\n```bash\ngit commit -m \"my message\"\n```\n\n### Cherry pick\n\nTo cherry-pick a commit\n\n```bash\ngit cherry-pick\n```\n\nJ'ajoute mes modifications et je continue. Git rebase va s'arrêter à chaque commit où il y a des conflits lors de la fusion.\n\n```sh\ngit add README.md\ngit rebase --continue\n```\n\nLe rebase est terminé. L'historique de *master* est propre.\n\nPour référence: [git-rebase]({{site.baseurl}}https://git-scm.com/docs/git-rebase) et [Git branching - rebasing]({{site.baseurl}}https://git-scm.com/book/en/v2/Git-Branching-Rebasing){:rel=\"nofollow noreferrer\"}\n\nImages créées avec <http://learngitbranching.js.org/?NODEMO>\n"}