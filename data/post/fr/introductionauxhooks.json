{"date":"2019-04-03T00:00:00.000Z","title":"Introduction aux hooks","excerpt":"Une petite introduction à la nouvelle fonctionnalité de React, les hooks !","readingTime":"7mn","authors":["mehdidr"],"categories":["javascript"],"content":"\nLes **hooks** arrivent avec la release de la version 16.8 de React (sans breaking changes !), et amènent avec eux la solution à de nombreux problèmes causés par certains patterns.\n\nNous allons comparer ensemble les deux méthodes les plus populaires avant l’arrivée des hooks : les HOC et les renderProps. Il est intéressant de voir quels problèmes peuvent poser ces méthodes, et comment les hooks simplifient le code et résolvent ces problèmes.\n\n## Avant l’utilisation des hooks\n\nPrenons un exemple qui montre la position de la souris.\n\nVoilà à quoi ressemble le code classique :\n\n```jsx\nimport React, { Component } from 'react';\n\nexport default class MouseRender extends Component {\n  state = { x: 0, y: 0 };\n\n  componentDidMount() {\n      window.addEventListener('mousemove', this.onMouseMove);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('mousemove', this.onMouseMove);\n  }\n\n  onMouseMove = e => this.setState({ x: e.clientX, y: e.clientY });\n\n  render() {\n    const { x, y } = this.state;\n\n    return (\n      <span>\n        Mouse X : { x }, Mouse Y: { y }\n      </span>\n    );\n  }\n};\n```\n\nCe code peut vite poser problème, principalement pour deux raisons :\n\n- Si le mouvement de la souris est nécessaire dans un autre composant, il va falloir dupliquer ce code.\n- Si on complexifie le composant en ajoutant d’autres comportements de la souris, cela peut rapidement devenir illisible, notamment à cause du contenu du `componentDidMount` et du `componentWillUnmount`.\n\nVoilà comment on peut régler le problème avec les deux méthodes dont nous avons parlé plus haut :\n\n### HOC (Higher Order Component)\n\nUn HOC est une fonction qui prend un composant en paramètre, et retourne un nouveau composant en lui ajoutant un comportement (voir le [decorator pattern](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript)). Cela permet de séparer la logique et le rendu dans le DOM. Voilà donc à quoi ressemble le même code en utilisant un HOC :\n\n```jsx\nimport React, { Component } from 'react';\n\nconst withMousePosition = ComponentToWrap => {\n  return class MousePositionHoc extends Component {\n    state = { x: 0, y: 0 };\n\n    componentDidMount() {\n        window.addEventListener('mousemove', this.onMouseMove);\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('mousemove', this.onMouseMove);\n    }\n\n    onMouseMove = e => this.setState({ x: e.clientX, y: e.clientY });\n\n    render() {\n      return (\n        <ComponentToWrap { ...this.state } />\n      );\n    }\n  }\n};\n\nclass MouseRender extends Component {\n  render() {\n    const { x, y } = this.props;\n\n    return (\n      <span>\n        Mouse X : { x }, Mouse Y: { y }\n      </span>\n    )\n  }\n}\n\nconst EnhanceMouseRender = withMousePosition(MouseRender);\nexport default EnhanceMouseRender;\n```\n\nLes HOC posent plusieurs problèmes :\n\n- Ils étirent le code en longueur, car ils nécessitent de créer un composant pour chaque élément dynamique que l’on souhaite intégrer dans le DOM.\n- Il n’est pas possible de différencier la donnée qui vient du HOC et la donnée qui est passée au composant.\n- Ils peuvent poser des problèmes de conflits, à cause du nommage des props (qui peut vite devenir compliqué en fonction du nombre de HOC).\n- Si beaucoup de HOC sont présents, cela peut causer des problèmes de performances.\n\n### renderProps\n\nUne autre solution est d’utiliser les **renderProps**, qui permettent de partager la logique entre plusieurs composants en passant en propriété d’un composant une fonction qui permet de générer un autre composant :\n\n```jsx\nimport React, { Component } from 'react';\n\nclass MousePosition extends Component {\n  state = { x: 0, y: 0 };\n\n  componentDidMount() {\n    window.addEventListener('mousemove', this.onMouseMove);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('mousemove', this.onMouseMove);\n  }\n\n  onMouseMove = e => this.setState({ x: e.clientX, y: e.clientY });\n\n  render() {\n    return (\n      this.props.children(this.state)\n    );\n  }\n};\n\nexport default class MouseRender extends Component {\n  render() {\n    return (\n      <MousePosition>\n        {({ x, y }) => (\n          <span>Mouse X : { x }, Mouse Y: { y }</span>\n        )}\n      </MousePosition>\n    )\n  }\n}\n```\n\nLe principal intérêt d'utiliser des renderProps, c'est d'éviter la duplication de code.\nCependant les **renderProps** amènent certains problèmes :\n\n- La lisibilité : utiliser les **renderProps** implique de wrapper les composants, et peut vite devenir un véritable enfer (voir [Pyramid of Doom](https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)))\n- Utiliser les `PureComponent` devient compliqué : le shallow comparison retournera toujours faux pour les nouvelles props, et chaque render générera donc une nouvelle valeur pour la prop (voir [la doc](https://reactjs.org/docs/render-props.html#be-careful-when-using-render-props-with-reactpurecomponent)).\n\nLa nouvelle fonctionnalité, les **hooks**, pourrait donc être une alternative qui éliminerait les soucis rencontrés par ces différentes méthodes.\n\n## Hooks : mode d'emploi\n\nLes **hooks** sont des fonctions qui permettent d’aller chercher les données dans le state et dans le lifecycle à partir de fonctions. Il ne faut les utiliser qu’au plus haut niveau, et il ne faut donc pas les appeler dans des boucles, des conditions, des classes ou des nested functions. Les hooks sont toujours appelés dans le même ordre.\n\nPour reprendre l’exemple de la souris, voici à quoi ressemble le code avec l’utilisation des **hooks** :\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nconst useMousePosition = () => {\n  const [position, setMousePosition] = useState({ x: 0, y: 0 });\n\n  const handleMouseMove = e => setMousePosition({ x: e.clientX, y: e.clientY });\n\n  useEffect(() => {\n    window.addEventListener('mousemove', handleMouseMove);\n    return () => window.removeEventListener('mousemove', handleMouseMove);\n  });\n\n  return position;\n}\n\nconst MouseRender = () => {\n  const mouse = useMousePosition();\n  return (\n    <span>Mouse X : { mouse.x }, Mouse Y: { mouse.y }</span>\n  )\n}\n\nexport default MouseRender;\n```\n\nComme on peut le voir, on utilise 2 hooks dans ce code :\n\n- `useState`, comme son nom l’indique, permet d’utiliser le state : le premier argument étant le state initial (qui n’a pas nécessairement besoin d’être un objet), et le second étant la fonction à appliquer sur cette valeur.\n- `useEffect` indique que le composant peut causer des effets de bord comme par exemple fetcher des données ou modifier manuellement le DOM et vient remplacer `componentDidMount`, `componentDidUpdate` et `componentWillUnmount` dans la même API.\n\nIl est aussi possible de créer ses propres hooks : il suffit de créer une fonction Javascript qui commence par « use » et qui appelle d’autres hooks. Dans notre exemple, il s’agit de la fonction `useMousePosition`.\n\nIl existe d’autres hooks, comme `useContext` qui utilise le context API, ou `useReducer` qui permet de manager son state local avec des reducers, à la manière de redux.\n\n\n## Conclusion\n\nLes hooks ne sont pas indispensables à votre code, mais vous permettront de créer des composants qui n'ont plus besoin de classes, et vous permettront de gagner de nombreuses lignes de code.\nIl existe de [nombreux](https://nikgraf.github.io/react-hooks/) hooks qui vous faciliteront la vie. La hype autour des hooks est justifiée par les changements qu'ils vont probablement apporter à l'écosystème React.\n\nIl y a beaucoup à dire sur les hooks, cet article est loin d’être exhaustif ! Pour les anglophones, n’hésitez pas à  [cliquer sur ce lien](https://github.com/rehooks/awesome-react-hooks) qui vous donnera toutes les ressources nécessaires !\n"}