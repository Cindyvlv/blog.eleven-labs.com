{"date":"2017-01-09T00:00:00.000Z","title":"La programmation fonctionnelle avec Choo","excerpt":"Encore un nouveau framework JS?!!?! Ça commence à bien faire! Et oui encore un, mais celui-ci est super mignon ! Vous allez voir !","readingTime":"6mn","authors":["rascarlito"],"categories":["javascript"],"content":"\nBonjour ! je vais vous parler d'un nouveau framework JavaScript qui s'appelle [Choo](https://github.com/yoshuawuyts/choo) (ou ChooChoo pour les intimes).\n\nEncore un nouveau framework JS?!!?! Ça commence à bien faire!\n\nEt oui encore un, mais celui-ci est super mignon ! Vous allez voir !\n\n6 méthodes\n==========\n\nEn effet, la simplicité de Choo est ce qui le caractérise le plus. Son API est composée de six méthodes uniquement. Vous allez me dire que ce n'est pas possible. Eh ben si, c'est possible de reproduire un système très similaire en fonctionnement au couple React + Redux avec uniquement six méthodes à manipuler :\n\n-   const app = choo() Instancie le framework\n-   app.model() Crée un modèle pour contenir et manipuler des données\n-   app.router() Déclare les routes de l'application\n-   app.start() Crée le premier rendu en renvoyant l'arbre DOM généré par la route déclenchée\n-   app.use() Déclare un plugin. Cette interface n'est pas nécessaire la plupart du temps\n-   send() Envoie un événement depuis une vue à un modèle pour modifier ses données et engendrer un nouveau rendu\n\nVoici un exemple des plus basiques :\n\n```js\nconst choo = require('choo')\nconst html = require('choo/html')\n\n// Instancier l'application\nconst app = choo()\n\n// Déclarer un modèle avec ses reducers\napp.model({\n    namespace: 'counter',\n    state: { value: 0 },\n    reducers: {\n        increment (state, data) {\n            return { value: state.count + 1 }\n        }\n    }\n})\n\n// Déclarer une vue\nfunction mainView (state, prev, send) {\n    return html `\n        <div>\n            <div>${state.count}</div>\n            <button onclick=${increment}>Increment</button>\n        </div>\n    `;\n\n    function increment () {\n        send('counter:increment')\n    }\n}\n\n// Attacher la vue à une route\napp.router(['/', mainView])\n\n// Activer le rendu de l'application\nconst tree = app.start()\n// Attacher l'arbre DOM généré au document\ndocument.body.appendChild(tree)\n```\n\nEt voilà ! Un petit compteur avec un bouton pour incrémenter la valeur du compteur, rien de plus simple !\n\nMaintenant, voyons ça un peu plus en détails.\n\nCharger les dépendances\n=======================\n\n```js\nconst choo = require('choo')\nconst html = require('choo/html')\n```\n\nRien de plus banal ici. On charge la méthode choo() qui va nous servir à démarrer notre petit train. Puis, on charge une méthode html qui n'est rien d'autre que la librairie open-source bel, une des dépendances de Choo. En effet, ce n'est pas Choo qui s'occupe du DOM. À la place, il délègue ça à une autre petite librairie qui sait déjà le faire.\n\nDémarrer le petit train\n=======================\n\n```js\nconst app = choo()\n```\n\nOn instancie le framework en exécutant la méthode choo() à laquelle on peut passer un objet pour écouter certains événements globaux. On en récupère un objet qui va nous permettre d'accéder aux autres méthodes du framework.\n\nLes modèles\n===========\n\n```js\nconst http = require('xhr')\n\napp.model({\n    namespace: 'counter',\n    state: { count: 0 },\n    effects: {\n        fetchCount: (state, data, send, done) => {\n            http.get('/counter', { json: true }, (err, res, body) => {\n                if (err) return done(err)\n                send('counter:increment', body.value, done)\n            })\n        }\n    },\n    reducers: {\n        increment (state, data) {\n            return { value: state.count + 1 }\n        }\n    }\n})\n```\n\nUn modèle avec Choo est simplement un objet qui décrit un état initial et fournit quelques méthodes pour modifier cet état. L'exemple ici est un peu plus complexe pour montrer les paramètres plus avancés du fonctionnement des modèles.\n\nLes données sont représentées par le state qui est un objet avec le contenu que l'on souhaite.\n\nLes reducers sont des méthodes synchrones qui sont chargées de modifier le state. C'est le seul endroit où l'on peut réellement le modifier, le reste de l'application étant obligé d'appeler ces reducers via la méthode send() que chaque vue reçoit en paramètre pour modifier le state.\n\nChoo représente les données dans un objet de state global, ce qui veut dire que peu importe le nombre de modèles que l'on crée, tous les state de ces derniers seront stockés dans un même objet. Pour éviter les conflits, on peut ajouter un namespace au modèle avec un nom unique.\n\nEnfin, nous avons les effects qui vont servir à exécuter un appel asynchrone pour ensuite modifier le state via les reducers. Pour appeler les effects, on utilise également la méthode send().\n\nLes vues\n========\n\n```js\nconst html = require('choo/html')\n\nfunction mainView (state, prev, send) {\n    return html `\n        <div>\n            <div>${state.count}</div>\n            <button onclick=${increment}>Increment</button>\n        </div>\n    `;\n\n    function increment () {\n        send('counter:increment')\n    }\n}\n```\n\nToutes les vues Choo sont tout simplement des fonctions qui retournent du DOM. Un peu comme en React, on va écrire le HTML dans nos fichiers JavaScript mais simplement dans une [template string ES2015](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals). Pour transformer cette string en DOM, Choo se repose sur la librairie [bel](https://github.com/shama/bel){:rel=\"nofollow noreferrer\"}. La vue va également s'occuper d'écouter les événements utilisateur pour réagir en exécutant les effects ou reducers des modèles pour mettre à jour le state de l'application.\n\nLe routeur\n==========\n\n```js\napp.router({ default: '/404' }, [\n    ['/', require('./views/main')],\n    ['/404', require('./views/error')]\n])\n```\n\nTous les frameworks front-end se doivent d'avoir un bon routeur. Celui de Choo est très simple et efficace. Il suffit de lui donner une liste couple url/vue en forme d'Array. On peut également lui dire quelle route exécuter par défaut si la route demandée n'est pas trouvée.\n\nLe routeur va s'occuper d'écouter les clics sur les liens dans les vues pour rediriger automatiquement sur la bonne route en utilisant l'[API HTML5 pushState](https://developer.mozilla.org/en-US/docs/Web/API/History_API){:rel=\"nofollow noreferrer\"}.\n\nCommencer le voyage !\n=====================\n\n```js\nconst tree = app.start()\ndocument.body.appendChild(tree)\n```\n\nC'est le début de l'aventure ! Il ne reste plus qu'à demander à Choo d'exécuter le premier rendu de l'application et de rattacher le DOM généré au document et voilà !\n\nPour plus d'informations, d'exemples, et de petits trains mignons rendez-vous sur la [page github de Choo](https://github.com/yoshuawuyts/choo) ou sur sa [page de démonstration](https://choo.io/){:rel=\"nofollow noreferrer\"}.\n\nBon voyage !\n"}