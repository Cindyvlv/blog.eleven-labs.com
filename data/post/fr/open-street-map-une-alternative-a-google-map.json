{"date":"2020-02-05T00:00:00.000Z","title":"OpenStreetMap - une alternative à Google Maps","excerpt":"Ajouter une carte interactive sans utiliser Google Maps","readingTime":"14mn","authors":["talgrin"],"categories":["javascript"],"content":"\n## Intro\nEn tant que développeur, j'ai un jour dû ajouter une carte interactive sur un site.\nOn avait pris l'habitude d'utiliser Google Maps, qui proposait une offre gratuite avec une limite de requêtes par mois. Il existait aussi une autre offre payante, elle sans restrictions. Mais l'offre gratuite a fini par ête supprimée...\n\nNe pouvant pas prendre la version payante, je me suis intéressé à une version open source de Google Maps appelée [Open Street Map](https://www.openstreetmap.fr/)\n\nDans cet article, je vous propose de vous montrer l'utilisation de cette solution dans un écosystème Symfony.\nAinsi, nous aborderons les points suivants :\n\n - Installer les différentes librairies\n - Chercher une adresse\n - Ajouter notre position sur la carte\n\n## La Stack Technique\n\n- Symfony 4.4\n-   WebpackLibrairie JS :\n\t-   Jquery\n\t-   Bootstrap\n\t-   Leaflet\n\t-   Leaflet-easybutton\n\t-   devbridge-autocomplete\n\t-   @ansur/leaflet-pulse-icon\n\n## Les bases : affichons une carte\n\nCommençons par installer les différentes librairies JS dont nous aurons besoin en lançant la commande suivante :\n``` bash\nyarn add leaflet leaflet-easybutton @ansur/leaflet-pulse-icon @ansur/leaflet-pulse-icon devbridge-autocomplete\n```\n\nCréons un composant JS qui aura la responsabilité de gérer notre carte.\n```jsx\n// assets/js/components/map.js\n'use strict';\n\nimport L from 'leaflet';\nimport 'devbridge-autocomplete';\n\n// Pour une raison obscure, lorsque nous utilisons Webpack, nous devons redéfinir les icons\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n    iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n    iconUrl: require('leaflet/dist/images/marker-icon.png'),\n    shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\n});\n\nrequire('leaflet-easybutton');\nrequire('@ansur/leaflet-pulse-icon');\n\nclass Map {\n    init(mapId, center = [45.5, 2], zoom = 5) {\n        this.map = L.map(mapId, { center: center, zoom: zoom });\n        L.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png', {\n            attribution: '&copy; <a href=\"https://osm.org/copyright\">OpenStreetMap</a> contributors'\n        }).addTo(this.map);\n    }\n}\n\nexport default Map;\n```\nComme Google Map, nous devons définir un container HTML\n```twig\n{# templates/default/index.html.twig #}\n<div class=\"container\">\n    <div class=\"row\">\n        <div class=\"col-10\">\n            <div id=\"map\"></div>\n        </div>\n        <div class=\"col-2\">\n            <input type=\"text\" name=\"address\" id=\"address\" />\n        </div>\n    </div>\n</div>\n```\nSans oublier le SCSS, sinon la carte ne s'affiche pas\n```css\n// assets/scss/map.scss\n@import \"~bootstrap\";\n@import \"~leaflet\";\n@import \"~@ansur/leaflet-pulse-icon/dist/L.Icon.Pulse.css\";\n\n#map {\n   height: 500px;\n}\n```\n\n![](/imgs/posts/2020-02-05-open-street-map-une-alternative-a-google-map/init-map.jpeg)\n\n## Chercher une adresse\nNotre besoin est le suivant : lorsque je commence à entrer une adresse ou le nom de mon bar favori, je voudrais avoir une liste déroulante qui affiche les différentes propositions sans utiliser Google. Lorsque je clique sur une adresse, un marqueur s'affiche sur la carte.\n\nPour ce faire, nous allons faire appel à une [API tiers](https://photon.komoot.de), gratuite, qui va convertir une recherche en longitude et latitude.\n\nPour afficher la liste des suggestions, nous allons utiliser le composant Jquery `autocomplete` comme suit :\n```jsx\n_search () {\n     let proprieties = ['name', 'housenumber', 'street', 'suburb', 'hamlet', 'town', 'city', 'state', 'country'];\n\n     $('#address').autocomplete({\n         serviceUrl: 'https://photon.komoot.de/api/',\n         paramName: 'q',\n         params: { lang: 'fr', limit: 5 },\n         dataType: 'json',\n         onSelect: (suggestion) => {\n             let position = suggestion.data.geometry.coordinates;\n\n             // À la selection, on ajoute un marqueur sur la carte et on la recentre\n             L.marker([position[1], position[0]]).addTo(this.map);\n             this.map.setView([position[1], position[0]], 12);\n         },\n         transformResult: (response) => {\n             // On reformate la réponse de l'api afin de respecter le contrat du plugin\n             return {\n                 suggestions: $.map(response.features, (dataItem) => {\n                     return {\n                         value: proprieties\n                             .map((p) => { return dataItem.properties[p]; })\n                             .filter((v) => { return !!v; }).\n                             join(', '),\n                         data: dataItem\n                     };\n                 })\n             };\n         }\n     });\n }\n```\n\n## Afficher notre localisation\n\nIl existe, en HTML 5, un composant natif  ``navigator.geolocation`` pour géolocaliser la personne. Pas de panique, lorsque l'on utilise une pop-in demandant l'autorisation s'affiche :\n\n![](/imgs/posts/2020-02-05-open-street-map-une-alternative-a-google-map/pop-in.jpeg)\n\n<div class=\"admonition important\" markdown=\"1\"><p class=\"admonition-title\">Important</p>\n\nIl faut que le site soit en https pour que la géolocalisation HTML se fasse\n</div>\n\nNous avons deux situations :\n - l'utilisateur accepte, c'est super, on affiche un marqueur sur la carte\n - l'utilisateur refuse, c'est moins cool, mais on peut par exemple estimer une zone géographique en utilisant son adresse IP\n\n### Étape 1 : la géolocalisation en JS\n\nComme promis, nous allons utiliser la notion `navigator.geolocation` mais surtout la méthode ``getCurrentPosition``. Elle prend deux callbacks, d'une part pour exécuter du code en cas de succès et d'autre part en cas d'échec. Le callback d'erreur s'exécute si l'utilisateur refuse de donner sa position.\n\nJe suis parti du principe que nous aurions besoin d'utiliser ce code plusieurs fois. Ainsi, j'ai créé un composant `Utils`\n```jsx\n'use strict';\n\nclass Utils {\n     static getCurrentPosition(success) {\n         if (navigator.geolocation) {\n            navigator.geolocation.getCurrentPosition(\n                 (position) => success('js', position.coords),\n                 () => success('php', Utils.getCurrentPositionWithPhp()),\n                 { enableHighAccuracy: true }\n             );\n         } else {\n             console.error('navigator.geolocation is not enable to this navigator');\n             success('php', Utils.getCurrentPositionWithPhp());\n         }\n     }\n\n     static getCurrentPositionWithPhp() {\n         console.log('Get position by PHP');\n     }\n}\n\nexport default Utils;\n```\n\nVous l'aurez compris, nous allons l'appeler dans notre composant `map`\n```jsx\n_getCurrentPosition() {\n    Utils.getCurrentPosition((provider, coords) => {\n        if (provider === 'js') {\n        //On stocke la position de l'utilisateur pour centrer la carte s'il clique sur le bouton de position\n            this.latitude = coords.latitude;\n            this.longitude = coords.longitude;\n            // On ajoute un icon différent de nos lieux\n            const icon = L.icon.pulse({ color: 'blue', fillColor: 'blue', heartbeat: 3 });\n            // On ajoute le marqueur sur la carte\n            L.marker([coords.latitude, coords.longitude], { icon: icon }).addTo(this.map);\n            // On crée un nouveau bouton pour localiser l'utilisateur\n            L.easyButton({\n                position: 'topright',\n                states: [{\n                    onClick: () => this.map.setView([this.latitude, this.longitude], 12),\n                    title: 'Me localiser',\n                    icon: '<span class=\"target\">&target;</span>'\n                }],\n            }).addTo(this.map);\n            this.map.setView(new L.LatLng(this.latitude, this.longitude), 12);\n       } else {\n           // On recentre la carte par rapport aux coordonnées récoltées en PHP\n           this.map.setView(new L.LatLng(coords.lat, coords.lon), 11);\n       }\n    });\n}\n```\n![](/imgs/posts/2020-02-05-open-street-map-une-alternative-a-google-map/current-position-js.jpeg)\n\n### Étape 2 : Localisation en PHP\n\nLorsque l'utilisateur refuse la localisation, nous pouvons estimer une zone géographique en utilisant son IP grâce à http://ip-api.com/json\nL'idée est de faire appel, avec - par exemple -  le client HTTP de Symfony, à cette api, de stocker le résultat dans **du cache** afin d'optimiser. Et oui c'est pour cela que nous allons utiliser l'éco-système de Symfony ; car nous ne pouvons pas le faire en JS car c'est une adresse en HTTP.\n\nEt bien let's go :\n```php\n<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Controller;\n\nuse App\\Service\\Localisation\\LocalisationInterface;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Psr\\Log\\LoggerInterface;\nuse Symfony\\Component\\Cache\\CacheItem;\nuse Symfony\\Contracts\\Cache\\CacheInterface;\nuse Symfony\\Contracts\\HttpClient\\HttpClientInterface;\n\n/**\n * Class LocalisationController.\n */\n Class LocalisationController\n{\n  /**\n   * @var LoggerInterface\n   */\n  private $logger;\n\n  /**\n   * @var HttpClientInterface\n   */\n  private $client;\n\n  /**\n   * @var CacheInterface\n   */\n  private $cache;\n\n  /**\n   * LocalisationController constructor.\n   *\n   * @param LoggerInterface $logger\n   * @param CacheInterface $cache\n   * @param HttpClientInterface $client\n   */\n  public function __construct(LoggerInterface $logger, CacheInterface $cache, HttpClientInterface $client)\n  {\n      $this->logger = $logger;\n      $this->cache = $cache;\n      $this->client = $client;\n  }\n\n  /**\n   * @Route(\"/localisation\", name=\"localisation\", options={\"expose\"=true})\n   * @param Request $request\n   *\n   * @return JsonResponse\n   */\n  public function getCurrentLocalisation(Request $request): JsonResponse\n  {\n     $ip = $request->query->get('ip');\n\n     /** @var CacheItem $item */\n     $item = $this->cache->getItem($ip);\n\n     // On vérifie si l'item cache est toujours valable\n     if (!$item->isHit()) {\n      $url = sprintf('http://ip-api.com/json/%s', $ip);\n      $response = $this->client->request('GET', $url);\n      $this->logger->info('User localisation', ['provider' => 'ip', 'url' => $url, 'response' => $response]);\n\n      //On stocke la valeur et on ajoute une date d'expiration\n      $item\n          ->set($response->toArray())\n          ->expiresAfter(3600)\n      ;\n      $this->cache->save($item);\n     }\n\n     return new JsonResponse($item->get());\n  }\n}\n```\nMaintenant, appellons cette route en Ajax dans notre composant `utils` dans la méthode `getCurrentPositionWithPhp`\n\n\n```jsx\nstatic getCurrentPositionWithPhp() {\n     // On la conserve dans sessionStorage pour éviter de surcharger notre back\n     if (sessionStorage['localisation']  === undefined) {\n         $.ajax({\n             url: '/localisation?ip=' + Utils.getAddressIp(),\n             type: 'GET',\n             dataType: 'json',\n             async: false,\n             success: (data) => {\n                 sessionStorage['localisation'] = JSON.stringify(data);\n             }\n         });\n     }\n\n     return JSON.parse(sessionStorage['localisation']);\n }\n\n static getAddressIp() {\n     // Là aussi, on la conserve dans sessionStorage pour éviter de surcharger notre back\n     if (sessionStorage['ip'] === undefined) {\n         $.ajax({\n             url : 'https://api.ipify.org/?format=json',\n             type : 'GET',\n             dataType : 'json',\n             async: false,\n             success: (data) => {\n                 sessionStorage['ip'] = data.ip;\n             }\n         });\n     }\n\n     return sessionStorage['ip'];\n }\n```\n\n## Conclusion\n\nEn conclusion, nous pouvons dire que l'alternative OpenStreetMap peut réellement rivaliser avec son concurrent le plus célèbre, tout en étant gratuit. C'est votre porte-monnaie qui va être content !\nJ’espère que vous avez apprécié cet article et que vous allez prendre beaucoup de plaisir à jouer avec OpenStreetMap.\n\nÀ bientôt pour de nouvelles aventures ;)\n\n"}