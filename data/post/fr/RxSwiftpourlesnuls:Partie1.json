{"date":"2019-09-25T00:00:00.000Z","title":"RxSwift pour les nuls - Partie 1","excerpt":"Dans cet article, on abordera les Observables, qui sont le coeur du RxSwift, ainsi que les subjects","readingTime":"7mn","authors":["Safia11"],"categories":[],"content":"Savoir utiliser RxSwift dans son projet iOS est un vrai plus. Parmi ses avantages, on peut lister : améliorer l'expérience utilisateur, et permettre une bonne gestion des threads. De plus, cette librairie, basée sur les observables, va permettre d’écrire un code asynchrone d’une manière plus concise et compacte. A titre d'information, le préfixe Rx dans RxSwift signifie “ReactiveX”.\n\n​​Pour utiliser RxSwift, il faut tout d'abord [l’installer](https://github.com/ReactiveX/RxSwift#installation) en utilisant la gestion des dépendances (CocoaPods, Carthage ou bien Swift Package Manager).\n​\n​Dans cet article, nous aborderons tout d'abord la programmation réactive. Ensuite nous explorerons les observables. Enfin, nous verrons ce que sont les subjects.\n​\n\n## Programmation  réactive\n\nLa programmation réactive est un paradigme de programmation, c’est-à-dire un modèle de programmation basé sur des observables et les événements qui y sont liés.\n\nDans la programmation réactive, on crée un flux de données, c’est-à-dire des données disponibles au fils du temps qui réalisent de manière ordonnée des actions X ou Y.  On peut diviser ce flux en deux parties. La première partie, considérée comme la source d’émission des données, les émet. En même temps, la deuxième partie elle, \"écoute\" et récupère cette émission.\n\nMaintenant que vous avez le bagage minimum requis, on peut passer à la suite.\n​Dans les parties suivantes, je vais traiter des Observables qui sont le coeur du RxSwift ainsi que des Subjects.\n​\n​\n## Les Observables\n​\n​Un Observable ? C’est quoi ?\n​\n​Le framework RxSwift est basé sur les observables. En RxSwift on les appelle “Observable sequence” alors que pour les autres plateformes, c’est bien “Observable streams”.\nLes observables sont donc une séquence d'éléments qui peuvent émettre des valeurs. Ces valeurs peuvent être des Int, String ou bien un autre Object.\n\n​Imaginons que l'observable soit une chaîne youtube et que les observers soient des abonnés. A chaque fois qu'une vidéo sera ajoutée à la chaine, les abonnés seront notifiés de son arrivée.\n​\n​Découvrons comment implémenter tout ça en utilisant les Operators :\n\n\n ```Swift\nimport RxSwift\n\nlet observable1 = Observable.just(1)\n\nlet observable2 = Observable.of(1,2,3)\n\nlet observable3 = Observable.of([1,2,3])\n\nlet observable4 = Observable.from([1,2,3,4,5])\n\n```\n​\n- just( ): Ici on a créé un observable qu’on a nommé “observable1” en utilisant la classe Observable. Cette classe contient plusieurs méthodes qui permettent de créer un observable.\n​\n​Pour cet exemple on a utilisé la méthode \"just\". Elle retourne une séquence qui contient un et un seul élément. Dans notre cas il s'agit de 1.\n​\n​Après avoir créé notre premier observable avec la méthode \"just\", on peut en créer d'autres. Dans ce cas, on utilisera alors \"of\" qui va nous permettre de créer une séquence d’éléments différents, comme c'est le cas pour l'observable2. ​Si on souscrit à ses éléments, on récupérera les valeurs 1, 2 et 3. Notez qu'ici, le type d’observable est Observable&lt;Int&gt;, alors que pour l'observable3, il s'agit de Observable&lt;[Int]&gt;.\n​\n- from( ): Ici on a utilisé “from” pour créer un Observable qui prend un array d’éléments comme paramètre et le convertit. Notez bien que le type de l’Observable est Observable&lt;Int&gt;\n​\nOn vient de créer nos observables qui émettent les events, mais c’est quoi la prochaine étape me direz-vous ?\n​\nLa prochaine étape, c'est de recevoir ce qui a été émis. En un autre terme plus technique : “To subscribe”\n\n​\n**Subscribing**\n​\nQuand on souscrit à un observable, on reçoit les événements émis par celui-ci.\n​\nL’événement a trois états. En effet, c’est une énumération qui a trois “case” :\n​\n- next\n- error\n- completed\n\nOn souscrit en utilisant “subscribe” qui prend une closure en tant que paramètre.\n​\n```Swift\nimport RxSwift\n\nlet observable = Observable.from([1,2,3,4,5])\n\nobservable.subscribe { event in\n    print(event)\n}\n​\n​/*\n​Résultat  Console:\n​next(1)\n​next(2\n​next(3)\n​next(4)\n​next(5)\n​completed\n\n```\n\nMais comment récupérer les valeurs 1, 2, 3, 4 et 5 ? C’est simple, en utilisant .element :\n​\n```Swift\nimport RxSwift\n\nlet observable = Observable.from([1,2,3,4,5])\n\nobservable.subscribe { event in\n    if let element = event.element {\n        print(element)\n    }\n}\n​\n​/*\n​Résultat  Console:\n​1\n​2\n​3\n​4\n​5\n​*/\n```\n\nIl existe une autre méthode pour pouvoir accéder aux éléments d’un observateur sans avoir à unwrapper, en utilisant subscribe(onNext) :\n​\n```Swift\nimport RxSwift\n\nlet observable = Observable.from([1,2,3,4,5])\n\nobservable.subscribe(onNext: { element in\n    print(element)\n})\n​\n​/*\n​Résultat  Console:\n​1\n​2\n​3\n​4\n​5\n​*/\n```\n\nNotez que le completed event n’est pas affiché.\n​\n​**Dispose Bag**\nQuand on crée une subscription, elle nous retourne un subscriber et ce dernier sera toujours là pour observer cette séquence. Du coup il faut être sûr de disposer de ces subscribers. Si on ne les dispose pas on aura une fuite de mémoire.\n​\nIl existe 2 méthodes pour disposer, en utilisant dispose() ou bien disposeBag :\n​\nPassons à la pratique. Dans le premier exemple on utilisera dispose() et pour le deuxième DisposeBag()\n​\n```Swift\n\nimport RxSwift\n\nlet observable = Observable.from([1,2,3,4,5])\n\nlet subscription = observable.subscribe(onNext: { element in\n    print(element)\n})\n\nsubscription.dispose()\n\n```\n​\n```Swift\n\nimport RxSwift\n\nlet disposeBag = DisposeBag()\n\nObservable.of(\"A\", \"B\", \"C\").subscribe {\n    print($0)\n}.disposed(by: disposeBag)\n\n```\n​\n## Subjects\n​\nSubject est à la fois un Observable et un Observer. Yes, 2 in 1.\n​\n​\n​En RxSwift, il existe plusieurs types de subjects. Dans cet article je n'en mentionnerai que de trois, qui sont : Publish Subject, Behavior Subject, Replay Subject.\n\n​\n**Publish Subject**\n\nPublish Subject émet les nouveaux événements seulement aux nouveaux souscrits. Si d’autres événements ont été ajoutés au subject avant la souscription d’un subscriber, il ne vas pas les recevoir.\n​\n\n```Swift\n\nimport RxSwift\n\nlet subject = PublishSubject<String>() // (1)\nsubject.onNext(\"Something1\")\n\nsubject.subscribe { event in //(2)\n    print(event)\n}\n\nsubject.onNext(\"Something2\")\nsubject.onNext(\"Something3\")\nsubject.dispose() //(3)\nsubject.onNext(\"Something4\")\n​\n​/*\n​Résultat  Console:\n​next(Something2)\n​next(Something3)\n​*/\n\n```\n\n(1) : Ici le subject est une séquence vide.\n​\n(2) : Si on exécute, on ne verra pas la souscription. La raison est qu’on a créé la subscription après avoir créé l’événement (il n'y a pas de subscribers ). Mais si on a créé l’événement après la souscription, on peut du coup les récupérer.\n​\nOn pourrait comparer cela à un utilisateur Instagram qui ne peut pas voir les nouveautés d'un compte (les events) tant qu'il n'en est pas abonné (souscrit).\n​\n(3) : toutes les souscriptions qui arrivent après le dispose seront négligées, même l’événement completed est ignoré.\n​\n\n**Behavior  Subject**\n\nParfois on voudrait que le subscriber reçoive l’événement le plus récent  même s’il souscrit après. Le Behavior Subject va renvoyer le dernier événement ou bien la valeur initiale, dans le cas où il n’y a pas d'événements récents avant sa souscription ainsi que d'événements après la souscription. Notez que le Behavior Subject doit absolument être initialisé par une valeur qui sera considérée comme le premier next event.\n\n```Swift\nimport RxSwift\nlet disposeBag = DisposeBag()\n\nlet subject = BehaviorSubject(value: \"First\")\n\nsubject.subscribe { (event) in\n    print(event)\n    }.disposed(by: disposeBag)\n\nsubject.onNext(\"Second\")\nsubject.onNext(\"Third\")\nsubject.onNext(\"Fourth\")\n\n​/*\n​Résultat  Console:\n​next(First)\n​next(Second)\n​next(Third)\n​next(Fourth)\n​*/\n\n```\n\n```Swift\nimport RxSwift\n\nlet disposeBag = DisposeBag()\nlet subject = BehaviorSubject(value: \"First\")\n\nsubject.onNext(\"Before Subscribing\")\nsubject.onNext(\"Before Subscribing 2\")\n\nsubject.subscribe { (event) in\n    print(event)\n    }.disposed(by: disposeBag)\n\nsubject.onNext(\"Second\")\nsubject.onNext(\"Third\")\nsubject.onNext(\"Fourth\")\n​\n​/*\n​Résultat  Console:\n​next(Before  Subscribing  2)\n​next(Second)\n next(\"Third\")\n​next(Fourth)\n​*/\n\n```\n\nBehavior Subject est à peu près similaire à Publish Subject. La seule différence est que pour qu’il puisse être initialisé, on doit au moins lui passer une valeur initiale.\n\nNotez que dans le premier exemple, le subscriber a été initialisé avec la valeur “First” et qu'il n’y avait pas d’autres événements avant la souscription. C’est donc la seule valeur prise en compte avant celle-ci. Or dans ce deuxième exemple, deux events ont eu lieu avant la souscription et le seul event pris en compte est le plus récent qui est “Before Subscribing 2”\n​\n\n**Replay Subject**\n\nOn vient de voir 2 types de subjects, le Publish Subject ainsi que le Behavior Subject. Regardons un peu ce que fait le Replay Subject.\n​\nReplay Subject émet un nombre spécifique d’événements avant la souscription. Ce nombre est la valeur du buffer.\n\n\n```Swift\nimport RxSwift\nlet disposeBag = DisposeBag()\n\nlet subject = ReplaySubject<String>.create(bufferSize: 2)\n\nsubject.onNext(\"Premier\")\nsubject.onNext(\"Deuxième\")\nsubject.onNext(\"Troisième\")\n\nsubject.subscribe { event in\n    print(event)\n    }.disposed(by: disposeBag)\n\nsubject.onNext(\"Quatrième\")\nsubject.onNext(\"Cinquième\")\nsubject.onNext(\"Sixième\")\n\n​/*\n​Résultat  Console:\n​next(Deuxième)\n​next(Troisième)\n​next(Quatrième)\n​next(Cinquième)\n​next(Sixième)\n​*/\n\n```\n\nReplay subjects fait passer les derniers événements en se basant sur la longueur du buffer précisé lors de la création du subject.\n​\n​\n## Conclusion\n​\nC’est tout pour cette première partie. J’espère que c’était une découverte intéressante de RxSwift et plus spécialement de ce que sont les Observables, les Subscribers ainsi que les Subjects. Une deuxième partie arrivera bientôt où je traiterai des “Filtering Operators”, “Transforming Operators” ainsi que des “Combing Operators”. Stay tuned !\n"}