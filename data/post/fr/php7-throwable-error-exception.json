{"date":"2018-02-11T00:00:00.000Z","title":"PHP 7 Throwable Errors Exceptions","excerpt":"Les erreurs sont présentes dans notre code, dans le code des librairies externes, ou même en cas de défaillance matérielle. C'est pourquoi la maîtrise des Throwable est indispensable afin d'avoir une gestion d'erreurs de qualité.","readingTime":"13mn","authors":["amoutte"],"categories":["php"],"content":"\nPHP 7 apporte un changement à la façon dont les erreurs sont rapportées.\nDésormais la plupart des erreurs sont rapportées en lançant des exceptions `Error`.\n\nLes `Throwable` vont remonter la pile d'exécution (bubble up) jusqu'à rencontrer un des cas suivants :\n - si elle rencontre un bloc `catch` qui supporte ce type d'erreur ;\n - si un gestionnaire d'exception est configuré via `set_exception_handler()` ;\n - sinon l'exception sera convertie en erreur FATAL et sera traitée par le système traditionnel.\n\nNous allons donc, plus en détails, définir et voir comment utiliser `Throwable`, `Error` et `Exception`.\n\n## Définition\n\n### Throwable\n\n`Throwable` est une interface PHP 7 qui représente une erreur dans le script.\n\n```php\ninterface Throwable\n{\n    public function getMessage(): string;       // La raison de l'erreur\n    public function getCode(): int;             // Le code de l'erreur\n    public function getFile(): string;          // Le fichier dans lequel l'erreur à débuter\n    public function getLine(): int;             // La ligne à laquel l'erreur à débuter\n    public function getTrace(): array;          // Retourne la stack trace en array comme debug_backtrace()\n    public function getTraceAsString(): string; // Retourne la stack trace en chaine de caractère\n    public function getPrevious(): Throwable;   // Retourne le `Throwable` précédent\n    public function __toString(): string;       // Convertit en chaine de caractère\n}\n```\n\n`Errors` et `Exceptions` sont les deux types de bases qui l'implémentent.\n\nVoici la hiérarchie des `Throwable` :\n\n```\ninterface Throwable\n  |- Error implements Throwable\n      |- ArithmeticError extends Error\n          |- DivisionByZeroError extends ArithmeticError\n      |- AssertionError extends Error\n      |- ParseError extends Error\n      |- TypeError extends Error\n          |- ArgumentCountError extends TypeError\n  |- Exception implements Throwable\n      |- ClosedGeneratorException extends Exception\n      |- DOMException extends Exception\n      |- ErrorException extends Exception\n      |- IntlException extends Exception\n      |- LogicException extends Exception\n          |- BadFunctionCallException extends LogicException\n              |- BadMethodCallException extends BadFunctionCallException\n          |- DomainException extends LogicException\n          |- InvalidArgumentException extends LogicException\n          |- LengthException extends LogicException\n          |- OutOfRangeException extends LogicException\n      |- PharException extends Exception\n      |- ReflectionException extends Exception\n      |- RuntimeException extends Exception\n          |- OutOfBoundsException extends RuntimeException\n          |- OverflowException extends RuntimeException\n          |- PDOException extends RuntimeException\n          |- RangeException extends RuntimeException\n          |- UnderflowException extends RuntimeException\n          |- UnexpectedValueException extends RuntimeException\n```\n\n> ⚠ Attention ! Vous ne pouvez implémenter `Throwable` qu'à travers `Error` et `Exception`.\n> Sinon vous obtiendrez une erreur FATAL\n> `PHP Fatal error:  Class MyClass cannot implement interface Throwable, extend Exception or Error instead`\n> Il est quand même possible d'étendre cette interface dans le domaine utilisateur.\n\n```php\ninterface MyThrowable extends Throwable {\n    public function myCustomMethod();\n}\n\nclass MyException extends Exception implements MyThrowable {\n    public function myCustomMethod()\n    {\n        // implement custom method code\n    }\n}\n```\n\n### Error\n\n`Error` est la classe de base de toutes les erreurs internes de PHP.\n\nLes plus communes sont :\n - `ParseError`, qui est lancée quand on `require` ou `eval` un code qui contient une erreur de syntax.\n - `TypeError`, qui est lancée quand le typehint d'un argument/retour d'une fonction n'est pas respecté. _Et également en `strict mode` quand on passe un nombre invalid d'arguments à une fonction native de PHP._\n\n_Vous pourriez être amenés à throw des `Error` dans votre code si par exemple vous parsez un fichier et qu'il contient une erreur de syntaxe.\nOu si vous avez une fonction avec un nombre de paramètres variable et que le nombre/type d'arguments n'est pas correct._\n\n### Exception\n\n`Exception` est la classe de base de toutes les exceptions utilisateurs.\n\nIl est très fréquent de lancer ou créer des `Exception`.\nC'est d'ailleurs sur le fonctionnement et l'utilisation des `Exception` que nous allons nous concentrer.\n\n## Utilisation\n\n### Lancer une exception\n\nPour lancer une exception, il suffit d'utiliser le mot clé `throw`.\n\n```php\nthrow new Exception('Mon message d\\'erreur.');\necho \"Affichage d'un contenu texte.\";\n```\n\n> Il faut savoir qu'une `Exception` interrompt l'exécution des instructions suivantes.\n> Dans l'exemple le `echo` ne sera pas exécuté.\n\n### Attraper une exception\n\nPour attraper et gérer l'exception, il faut utiliser la structure `try` `catch`.\n```php\ntry {\n    if (!$_GET['titre']) {\n        throw new Exception('Impossible d\\'afficher le titre. Le titre est requis.');\n    }\n    echo $_GET['titre'];\n} catch (Exception $e) {\n    echo '⚠ Une exception est survenue : ' . $e->getMessage();\n}\n```\n> Dans cet exemple le script affichera le titre s'il est fourni\n> sinon il affichera le message d'erreur comme quoi il est obligatoire.\n\nVous pouvez également effectuer de multiple `catch` afin de séparer les différents types d'`Exception`.\nIl faut placer les `catch` dans l'ordre du plus précis au moins précis.\n\n```php\ntry {\n    if (!$_GET['titre']) {\n        throw new Exception('Impossible d\\'afficher le titre. Le titre est requis.');\n    }\n    if (!is_string($_GET['titre'])) {\n        throw new RuntimeException('Le titre doit être une chaîne de caractères.');\n    }\n    echo $_GET['titre'];\n} catch (RuntimeException $e) {\n    echo $e->getMessage();\n} catch (Exception $e) {\n    echo '⚠ Une exception est survenue : ' . $e->getMessage();\n}\n```\n\n> Ici `RuntimeException` étends `Exception`, il faudra donc catch `RuntimeException` avant les `Exceptions`.\n\nDepuis PHP 7.1 il est également possible de spécifier plusieurs types d'`Exception` dans le catch en utilisant le caractère `|`\n\n```php\ntry {\n    // Code\n} catch (OutOfBoundsException | LogicException $e) {\n    echo '⚠ Une exception est survenue : ' . $e->getMessage();\n}\n```\n\n__⚠ Il est très important de bien choisir l'`Exception` que l'on veut lancer ou attraper, sinon la gestion d'erreur ne sera pas consistante.__\n\n**Également à savoir**\n\nLa `LogicException` référence une erreur de code qui devrait, la plupart du temps, mener à un correctif sur le code.\nAttraper une `LogicException` a généralement pour but d'afficher une page d'erreur et de logger en vue d'informer le développeur.\n\nLa `RuntimeException` représente une erreur survenue durant l'exécution (donnée invalide, erreur d'une source de données).\nAttraper une `RuntimeException` est très utile pour exécuter un code alternatif qui permettra au script de finir son exécution.\n\nℹ️ _Il est très fortement recommandé d'avoir un exception handler afin d'afficher une page d'erreur au visiteur.\nMais aussi pour éviter d'afficher des informations sensibles (url du fichier, stack trace, message d'erreur ...)\nLa bonne pratique étant de ne pas laisser une exception casser le site._\n\n```\nset_exception_handler(function($exception){\n    echo 'Une erreur est survenue. Veuillez rééssayer ulterieurement.';\n    // log($exception->getMessage());\n    // email au developpeur\n});\n```\n\n### Les codes d'erreurs\n\nLe code d'erreur est un `integer` qui peut être utilisé pour codifier/identifier l'erreur.\n\n> Il permet par exemple d'afficher le code de l'erreur plutôt que le message de l'`Exception` au visiteur.\n> Il permet de masquer la raison de l'erreur, qui peut dans certains cas contenir des informations sensibles.\n\n## Utilisation avancée\n\n### Créer une exception personalisée\n\nIl est très utile de créer des exceptions personnalisées afin qu'elles puissent identifier un problème plus précisément, mais aussi afin de pouvoir transporter des données supplémentaires (texte, object, array...).\n\n```php\nclass MyObject\n{\n    public $content;\n}\n\nclass MyObjectException extends RuntimeException\n{\n    /**\n     * @var MyObject\n     */\n    private $myObject;\n\n    public function __construct(MyObject $myObject, $message = \"\", $code = 0, Throwable $previous = null)\n    {\n        parent::__construct($message, $code, $previous);\n        $this->myObject = $myObject;\n    }\n\n    /**\n     * @return MyObject\n     */\n    public function getMyObject()\n    {\n        return $this->myObject;\n    }\n}\n```\n\n> Quand `MyObjectException` est attrapée, on peut récupérer l'objet `MyObject` via la méthode `getMyObject()`\n> ce qui permet de gérer encore plus précisément les erreurs.\n\n### Relancer une exception\n\nParfois il est utile de tracer/loguer ce qui s'est mal déroulé.\nDans ce cas on va donc attraper l'`Exception`, logger un message d'erreur avant de relancer l'`Exception`.\n\n```php\ntry {\n    // mise à jour d'un contenu\n} catch (Exception $e) {\n    // log('La mise à jour a échoué.');\n    throw $e;\n}\n```\n\nExemple concret :\n\n```php\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Psr\\Log\\NullLogger;\n\nclass UserFactory implements LoggerAwareInterface\n{\n    use LoggerAwareTrait;\n\n    private $passwordGenerator;\n\n    public function construct(PasswordGeneratorInterface $passwordGenerator)\n    {\n        $this->passwordGenerator = $passwordGenerator;\n        $this->logger = new NullLogger();\n    }\n\n    public function create()\n    {\n        try {\n            $user = new User();\n            $password = $this->passwordGenerator->generatePassword();\n            $user->setPassword($password);\n\n            return $user;\n        } catch (Exception $exception) {\n            $this->logger->error('Une erreur est survenue pendant la creation d\\'un utilisateur. Raison: ' . $exception->getMessage());\n\n            throw $exception;\n        }\n    }\n}\n\ninterface PasswordGeneratorInterface\n{\n    public function generatePassword();\n}\n```\n\n> Ici, on peut remarquer que l'on va seulement logger un message d'erreur et laisser remonter (bubble up) l'exception.\n\n### Encapsuler un exception\n\nIl existe également l'encapsulation d'une `Exception` dans une autre `Exception` afin de créer un stack trace complète.\n\n```php\ntry {\n    // mise à jour d'un contenu\n} catch (RuntimeException $exception) {\n    throw new UpdateContentException('Erreur de mise a jour du contenu.', 0, $exception);\n}\n\nclass UpdateContentException extends RuntimeException {}\n```\n\n> Peu importe le type d'exception qui serait lancée pendant la mise à jour du contenu, le code\n> renverra toujours une `UpdateContentException`\n> Si on attrape l'`UpdateContentException` on peut récupérer l'`Exception` précédente grâce à la méthode `getPrevious()`\n\n\nExemple concret\n```php\nclass UserFactory\n{\n    private $passwordGenerator;\n\n    public function construct(PasswordGeneratorInterface $passwordGenerator)\n    {\n        $this->passwordGenerator = $passwordGenerator;\n    }\n\n    public function create()\n    {\n        try {\n            $user = new User();\n            $password = $this->passwordGenerator->generatePassword();\n            $user->setPassword($password);\n\n            return $user;\n        } catch (RuntimeException $exception) {\n            throw new UserFactoryException('Une erreur est survenue pendant la creation d\\'un utilisateur.', 0, $exception);\n        }\n    }\n}\n\nclass UserFactoryException extends RuntimeException {}\n\ninterface PasswordGeneratorInterface\n{\n    public function generatePassword();\n}\n```\n\n> On peut voir ici que peu importe la `RuntimeException` qui se produit dans `$this->passwordGenerator->generatePassword()`\n> l'`Exception` qui sera remontée est une `UserFactoryException` qui nous informe que la création a échouée.\n> La séparation des couches logicielles est respectée.\n\n## Conclusion\n\nNous avons vu comment lancer et attraper une exception en PHP ainsi que des notions un peu plus avancées sur la création d'une exception personnalisée pouvant transporter des données supplémentaires utilisables en cas d'erreur.\nSans oublier la gestion du logging/tracing grâce au rethrow et à l'encapsulation d'exception.\n\n**Les erreurs sont présentes dans notre code, dans le code des librairies externes, ou même en cas de défaillance matérielle, c'est pourquoi la maîtrise des Throwable est indispensable afin d'avoir une gestion d'erreurs de qualité.**\n\nLes points positifs :\n - Une meilleure visibilité de ce qui s'est déroulé ;\n - Des erreurs plus lisibles ;\n - Différents types et niveaux d'erreurs afin de pouvoir séparer les erreurs métiers des erreurs logicielles ;\n - Facilite le débogage ;\n - Un meilleur découpage des responsabilités logicielles (SOLID) ;\n - L'utilisation des codes d'erreurs, qui permet de masquer la réelle raison aux visiteurs ;\n\nLes points négatifs\n - Il faut savoir quand encapsuler/relancer une exception ;\n - La lecture/mise en forme de la stack trace peut être complexe ;\n - Il ne faut pas oublier de gérer toutes les exceptions `catch`/`set_exception_handler` afin qu'aucune information sensible ne soit affichée aux visiteurs.\n\n## Autres articles intéressants\n\n* [Bien gérer ses exceptions](/fr/php_bien-gerer-ses-exceptions/)\n* [Errors in PHP 7](http://php.net/manual/fr/language.errors.php7.php)\n* [Example](https://3v4l.org/sDMsv)\n* [Throwable Exceptions and Errors in PHP 7](https://trowski.com/2015/06/24/throwable-exceptions-and-errors-in-php7/)\n"}