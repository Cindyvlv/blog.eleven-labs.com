{"date":"2022-02-09T00:00:00.000Z","title":"Communication entre composants avec des événements personnalisés","excerpt":"Besoin de travailler avec différents Framework JS et donc de faire communiquer l'ensemble des composants d'une application ?","readingTime":"13mn","authors":["fpasquet"],"categories":["javascript"],"content":"\nBesoin de travailler avec différents Framework JS et donc de faire communiquer l'ensemble des composants d'une application ?\nUne des solutions qui s'offre à vous est de faire appel aux événements personnalisés, natifs aux navigateurs. À découvrir dans cet article.\n\n---\n\n## Événements personnalisés, kesako ?\n\nIls sont identiques aux événements classiques tels que `click`, `submit`, `focus`..., sauf qu'ils sont créés manuellement.\nIl existe deux possibilités pour créer un événement personnalisé, soit en utilisant [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent) (si besoin de passer des données) soit en faisant simplement appel à `Event`.\n\nDans l'exemple ci-dessous, la fonction permet de créer l'événement personnalisé :\n```ts\nconst createCustomEvent = function <TData = { [key: string]: string }>(\n  eventName: string,\n  data?: TData\n): Event | CustomEvent<TData> {\n  if (data) {\n    return new CustomEvent<TData>(eventName, { detail: data });\n  }\n\n  return new Event(eventName);\n};\n```\n\nÀ présent, il suffit simplement d'envoyer les événements personnalisés:\n```ts\nconst customEvenOpen = createCustomEvent(\"open\");\nconst customEventCount = createCustomEvent<{ count: number }>(\"count\", {\n  count: 1\n});\nif (customEvenOpen) {\n  document.dispatchEvent(customEvenOpen);\n}\nif (customEventCount) {\n  document.dispatchEvent(customEventCount);\n}\n```\n\n> `document` est utilisé comme gestionnaire d'événements unique pour tous les événements personnalisés, car il centralise toutes les méthodes d'événement et dissocie les événements personnalisés des nœuds spécifiques de la page.\n\nEt dernière étape, il faudra écouter ces événements et implémenter la logique :\n```tsx\nconst open = () => {};\nconst count = ({ detail: { count } }: CustomEvent<{ count: number }>): void => {};\ndocument.addEventListener(\"open\", open);\ndocument.addEventListener(\"count\", count as EventListener);\n```\n\nIl faut bien penser à nettoyer et supprimer les écouteurs d'événements quand cela est nécessaire, voir exemple ci-dessous :\n```ts\ndocument.removeEventListener(\"open\", open);\ndocument.removeEventListener(\"count\", count as EventListener);\n```\n\nPar ailleurs, une façon de s'assurer que les écouteurs d'événements sont bien présents et qu'ils n'ont pas été attachés plusieurs fois à la page web est de vérifier cela à l'aide des outils de développement Chrome. Voici à quoi cela peut ressembler :\n\n![Outils de développement pour événements personnalisé sur Chrome](/imgs/posts/2022-02-09-communication-entre-composants-avec-des-evenements-personnalises/event-listeners-on-chrome.png)\n\nPour aller plus loin, il existe un troisième argument pour la méthode [`addEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) qui n'a pas été évoqué précédemment. Il s'agit de l'argument `once`, qui peut s'avérer être utile pour que l'écouteur d'événement ne soit exécuté qu'une seule fois et qu'il soit détruit automatiquement après son invocation.\n```ts\ndocument.addEventListener(\"open\", open, { once: true });\n```\n\n---\n\n## Un exemple avec React\n\nL'application a été créée avec `Create React App` et `Chakra UI`. Elle représente un parcours classique sur un ecommerce, c'est-à-dire, ajouter un produit au panier, afficher le montant total du panier et afficher le panier complété.\n\n![Application React - Liste des produits](/imgs/posts/2022-02-09-communication-entre-composants-avec-des-evenements-personnalises/application-react-product-list.png)\n\n![Application React - Panier](/imgs/posts/2022-02-09-communication-entre-composants-avec-des-evenements-personnalises/application-react-cart.png)\n\nVoici le conteneur de l'application. Dans celui-ci se trouvent trois conteneurs (`ViewCartButtonContainer`, `AddToCartButtonContainer`, `CartContainer`).\n```tsx\n// src/containers/App.tsx\n...\n\nimport { AddToCartButtonContainer } from '../AddToCartButton';\nimport { CartContainer } from '../Cart';\nimport { ViewCartButtonContainer } from '../ViewCartButton';\n\nexport const App: React.FC = () => {\n    const logo = (\n        <Stack direction=\"row\">\n            <ElevenLabsIcon height=\"24px\" />\n            <Heading size=\"md\" ml=\"5px\">Shop</Heading>\n        </Stack>\n    );\n\n    return (\n        <ChakraProvider theme={theme}>\n            <NavBar\n                logo={logo}\n                rightContent={<ViewCartButtonContainer />}\n            />\n            <Box p={4}>\n                <Stack spacing={4} as={Container} maxW={'3xl'}>\n                    <ProductList\n                        products={products}\n                        renderAddToCartButton={(product: Product) => (\n                            <AddToCartButtonContainer\n                                product={product}\n                            />\n                        )}\n                    />\n                </Stack>\n            </Box>\n            <CartContainer />\n        </ChakraProvider>\n    );\n}\n```\n\nTous ces conteneurs sont totalement indépendants et communiquent via un système de bus d'événements par le biais du hook `useCart`.\n\nCe hook expose la liste des produits dans le panier ainsi que son prix total mais aussi les trois méthodes et événements personnalisés :\n\n- La mise à jour du panier (`updateCart`)\n\nPour cela, l'événement `updateCart` est écouté via le `useEffect` qui déclenche la méthode `onUpdateCart`.\nCette méthode ajoute ou modifie la quantité d'un produit dans le panier. Il est préférable de [mémoïser](https://fr.wikipedia.org/wiki/M%C3%A9mo%C3%AFsation) la fonction à l'aide de `useCallback` pour éviter des rendus superflus.\nÀ noter que dans le `useEffect`, l'écouteur est supprimé à chaque changement de la méthode `onUpdateCart`. Ceci est appliqué à tous les `useEffect` de l'exemple.\n\n- La suppression du panier (`clearCart`)  \n- Et l'ouverture de ce panier (`openCart`)\n\nPour ces deux derniers événements, la logique des écouteurs d'événements est similaire.\n\n```tsx\n// src/hooks/useCart.ts\n...\n\nexport const useCart = (): UseCart => {\n    const [cartItems, setCartItems] = useState<CartProduct[]>([]);\n\n    const onUpdateCart = useCallback((event: CustomEvent<CartProduct>): void => {\n        const cartItem = event.detail;\n        const cartItemsDraft = [...cartItems];\n        const cartItemIndex = cartItemsDraft.findIndex(({ id }) => id === cartItem.id);\n        if (cartItemIndex !== -1) {\n            if (cartItem?.quantity !== undefined) {\n                if (cartItem.quantity === 0) {\n                    cartItemsDraft.splice(cartItemIndex, 1);\n                } else {\n                    cartItemsDraft[cartItemIndex].quantity = cartItem.quantity;\n                }\n            } else {\n                cartItemsDraft[cartItemIndex].quantity++;\n            }\n        } else {\n            cartItemsDraft.push({ ...cartItem, quantity: 1 });\n        }\n        setCartItems(cartItemsDraft);\n    }, [cartItems]) as EventListenerOrEventListenerObject;\n\n    const onClearCart = useCallback(() => {\n        setCartItems([]);\n    }, []);\n\n    useEffect(() => {\n        document.addEventListener(EventType.UPDATE_CART, onUpdateCart);\n        return () => {\n            document.removeEventListener(EventType.UPDATE_CART, onUpdateCart, false);\n        }\n    }, [onUpdateCart]);\n\n    useEffect(() => {\n        document.addEventListener(EventType.CLEAR_CART, onClearCart);\n        return () => {\n            document.removeEventListener(EventType.CLEAR_CART, onClearCart, false);\n        }\n    }, [onClearCart]);\n\n    const totalPrice = useMemo(() => {\n        return cartItems.reduce((total, cartItem) => {\n            total += (cartItem.salePrice ?? cartItem.price) * cartItem.quantity;\n            return total;\n        }, 0);\n    }, [cartItems]);\n\n    return {\n        totalPrice,\n        currency: 'EUR',\n        cartItems,\n        openCart: () => document.dispatchEvent(new Event(EventType.OPEN_CART)),\n        updateCart: (options) => document.dispatchEvent(\n            new CustomEvent(EventType.UPDATE_CART, {\n                detail: options\n            })\n        ),\n        clearCart: () => document.dispatchEvent(new Event(EventType.CLEAR_CART)),\n    };\n};\n```\n\nConcernant les conteneurs, le premier d'entre eux (`ViewCartButtonContainer`) affiche le montant du panier et permet de se rendre sur celui-ci.\n```tsx\n// src/containers/ViewCartButtonContainer.tsx\n...\n\nexport const ViewCartButtonContainer: React.FC = () => {\n    const { cartItems, totalPrice, currency, openCart } = useCart();\n\n    return (\n        <ViewCartButton\n            totalPrice={totalPrice}\n            currency={currency}\n            numberOfProducts={cartItems.length}\n            openCart={openCart}\n        />\n    );\n}\n```\n\nLe second conteneur (`AddToCartButtonContainer`) permet d'ajouter un produit au panier et de changer sa quantité.\n\n```tsx\n// src/containers/AddToCartButtonContainer.tsx\n...\n\nexport interface AddToCartButtonContainerProps { product: Product; }\n\nexport const AddToCartButtonContainer: React.FC<AddToCartButtonContainerProps> = ({ product }) => {\n    const { cartItems, updateCart } = useCart();\n\n    return (\n        <AddToCartButton\n            cartItem={cartItems.find(cartItem => cartItem.id === product.id) || { ...product, quantity: 0 }}\n            updateCart={updateCart}\n        />\n    );\n}\n```\n\nEt enfin, le dernier conteneur (`CartContainer`) affiche les produits se trouvant dans le panier.\n```tsx\n// src/containers/CartContainer.tsx\n...\n\nexport const CartContainer: React.FC = () => {\n    const { isOpen, onOpen, onClose } = useDisclosure();\n    const { cartItems, totalPrice, currency, updateCart, clearCart } = useCart();\n\n    useEffect(() => {\n        document.addEventListener(EventType.OPEN_CART, onOpen);\n        return () => {\n            document.removeEventListener(EventType.OPEN_CART, onOpen, false);\n        }\n    }, [onOpen]);\n\n    return (\n        <Drawer onClose={onClose} isOpen={isOpen} size=\"full\">\n            <DrawerOverlay />\n            <DrawerContent>\n                <DrawerCloseButton />\n                <DrawerBody>\n                    <Cart\n                        cartItems={cartItems}\n                        currency={currency}\n                        totalPrice={totalPrice}\n                        updateCart={updateCart}\n                        clearCart={clearCart}\n                        goToCheckout={() => {}}\n                        continueShopping={onClose}\n                    />\n                </DrawerBody>\n            </DrawerContent>\n        </Drawer>\n    );\n}\n```\n\nLe rendu final de l'application, est disponible [ici](https://example-react-app-with-custom-events-fpasquet.vercel.app/).\nLe code est accessible [ici](https://github.com/fpasquet/example-react-app-with-custom-events).\n\nLes événements personnalisés sont très appréciés des feature teams mais aussi des projets ayant une architecture micro frontend, car ils peuvent être indépendants les uns des autres et aussi agnostiques au framework JS.\n\nÀ bientôt !\n"}