{"date":"2017-01-25T00:00:00.000Z","title":"[iOS] Comment coupler les delegates et les closures ?","excerpt":"Faisons collaborer les delegates et les closures","readingTime":"7mn","authors":["thuchon"],"categories":[],"content":"\n### Introduction\n\nSalut les Astronautes, aujourd'hui on va continuer dans notre lancée sur le mobile, toujours en NATIF.\n\nCet article s'inscrit dans la lignée des 2 précédents, et il est impératif de les avoir lu pour comprendre ce dont il s'agit ici :\n\n[Delegates VS Closures](https://blog.eleven-labs.com/fr/delegates-closures/){:rel=\"nofollow noreferrer\"}\n\n[Pourquoi j'aime les listeners](https://blog.eleven-labs.com/fr/android-listeners/){:rel=\"nofollow noreferrer\"}\n\nSi vous avez lu les 2 précédents articles, vous devez vous douter de ce dont celui-ci va parler.\n- Mais oui on sait, allez dépêche-toi là, on veut savoir comment faire un truc aussi sexy que les listeners mais sur iOS cette fois-ci.\n- Ok, juste encore un petit peu de blabla technique et on se lance.\n\n**Comment ça va se passer :**\n\nBon comme le premier article, pour que tout le monde soit heureux, je vais vous produire du DUMMY code en Objective-C comme en Swift.\n\nDans le monde du développement iOS, comme vous avez pu le comprendre, on peut utiliser les delegates ou bien les closures. En général, on va utiliser la closure pour plus de flexibilité et c'est aussi plus simple à mettre en place. Cependant, dans certains cas, des composants graphiques par exemple sont juste utilisables via un delegate ou un datasource. Je pense à 2 de ces composants que j'utilise beaucoup: UITableView et UICollectionView.\n\nSur ces 2 composants par exemple, pas possible d'utiliser de blocks/closures, et on doit passer par un bon delegate à l'ancienne. Dans l'absolu, ce n'est pas très gênant, sauf dans le cas où on se retrouve avec plusieurs de ces composants sur le même écran. Les méthodes deviennent alors énormes et cela devient compliqué de faire du code élégant. Ce que je vous propose ici est une petite solution que je trouve assez propre.\n\n### Mise en situation\n\nComme dans les deux articles précédents, on va juste faire un Appel GET sur une URL  donnée et avoir un système qui nous prévient en cas de succès comme d'erreur. On va aller un peu plus vite que dans le premier article, car ce sont des notions que vous devez déjà maîtriser.\n\nC'est parti pour le code !\n\nNotre but ici est de réaliser une classe qui fait un GET sur une URL donnée. Je veux prévenir l'objet qui a été l'instigateur de cette requête si elle a réussi ou non. Pour éviter un couplage fort, on va utiliser le principe du delegate, grâce à ça, je n'aurai pas à connaitre le type exact de cet objet.\n\nOn va agir en 3 étapes:\n\n- Créer un protocol\n- Créer des blocks/closures\n- Créer une classe qui hérite du protocole et qui a nos 2 blocks/closures en variables.\n\n##### Objective-C\n\n```Objective-C\ntypedef void (^successBlock)();\ntypedef void (^failureBlock)();\n\n@protocol RequestManagerObjCDelegate\n\n- (void)onRequestSuccess;\n- (void)onRequestFailure;\n\n@end\n\n@interface RequestManagerObjCDelegateImplementation : NSObject\n{\n\n}\n\n@property (weak, nonatomic) successBlock success;\n@property (weak, nonatomic) failureBlock failure;\n\n@end\n\n@interface RequestManagerObjC : NSObject\n\n- (void)get:(NSString*)url;\n\n@property (nonatomic, weak) id delegate;\n\n@end\n```\n\nOn va maintenant implémenter la classe qui va hériter du protocole. Elle va donc contenir les 2 méthodes **onRequestSuccess** et **onRequestFailure** et chacune appellera le block/closure qui lui correspondra.\n\n```Objective-C\n@implementation RequestManagerObjCDelegateImplementation\n\n- (void)onRequestSuccess {\n    self.success();\n}\n\n- (void)onRequestFailure {\n    self.failure();\n}\n\n@end\n```\n\nEnsuite, on code la classe **RequestManager** que vous devez commencer à connaître\n\n```Objective-C\n@implementation RequestManagerObjC\n\n- (void)get:(NSString *)url {\n    //Do the call\n    BOOL requestSucceed = [self isSuccess];\n\n    //After the call\n    if (requestSucceed) {\n        [self.delegate onRequestSuccess];\n    } else {\n        [self.delegate onRequestFailure];\n    }\n}\n\n- (BOOL)isSuccess {\n    return YES;\n}\n\n@end\n```\n\nPuis on va faire une méthode pour appeler notre webservice\n\n```Objective-C\n- (void)callWebService {\n\n    RequestManagerObjC* manager = [[RequestManagerObjC alloc] init];\n\n    successBlock success = ^void() {\n\n    };\n\n    failureBlock failure = ^void() {\n\n    };\n\n    RequestManagerObjCDelegateImplementation* delegate = [[RequestManagerObjCDelegateImplementation alloc] init];\n    delegate.success = success;\n    delegate.failure = failure;\n\n    manager.delegate = delegate;\n    [manager get: @\"http://plop.fr\"];\n}\n```\n\nOn va un peu regarder ensemble ce que l'on a codé.\n- On a instancié notre **Manager,** qui va appeler le webservice\n- On a définit nos deux **blocks/closures**\n- On a instancié notre **Delegate**\n- On a assigné nos deux **blocks/closures**\n- On a assigné le **Delegate** au Manager\n- On appelle le webservice\n\nJe vous donne le code Swift pour les plus impatients\n\n##### Swift\n\n```Swift\nprotocol RequesterDelegateSwift {\n    func onRequestSuccess()\n    func onRequestFailure()\n}\n\nclass RequesterDelegateSwiftImplementation:  RequesterDelegateSwift {\n    var requestSuccess: ((Void) -> Void)?\n    var requestFailure: ((Void) -> Void)?\n\n    func onRequestSuccess() {\n        if let successClosure = self.requestSuccess {\n            successClosure()\n        }\n    }\n\n    func onRequestFailure() {\n        if let failureClosure = self.requestFailure {\n            failureClosure()\n        }\n    }\n}\n\nclass RequestManagerSwift {\n\n    var delegate: RequesterDelegateSwift?\n\n    func get(url: String) {\n        //Do the call\n        let requestSucceed: Bool = self.isSuccess()\n\n        //After the call\n        if requestSucceed {\n            self.delegate?.onRequestSuccess()\n        } else {\n            self.delegate?.onRequestFailure()\n        }\n    }\n\n    private func isSuccess() -> Bool {\n        return true\n    }\n}\n\nfunc callWebService() {\n\n    let manager: RequestManagerSwift = RequestManagerSwift()\n    let requesterDelegate: RequesterDelegateSwiftImplementation = RequesterDelegateSwiftImplementation()\n    requesterDelegate.requestSuccess = {\n\n     }\n\n     requesterDelegate.requestFailure = {\n\n     }\n\n     manager.delegate = requesterDelegate\n     manager.get(url: \"http://plop.fr\")\n }\n```\n\nSi maintenant j'appelle la méthode callWebService, vu le dummy code que l'on a fait, le résultat sera un passage dans le block/closure requestSuccess.\n\n**Mais pourquoi faire tout ça ?**\n\nEn effet, pourquoi faire tout ça, alors que dans notre cas, on pouvait juste utiliser un **Delegate** ou des **blocks/closures** comme dans le premier article ? Cela complexifie le code, et on a l'impression de faire les choses deux fois...\nComme je vous l'ai dit au début de l'article, cette solution vient pour un besoin assez spécifique. Celui de rendre un **Delegate** plus flexible quand on est obligé de passer par ce design pattern.\n\n**Problèmes soulevés**\n\n- Si le **Protocol** contient beaucoup de méthodes, on en a beaucoup à ré-implémenter.\n- On doit aussi définir tous les **blocks/closures** correspondants.\n- Il faut redéfinir les **blocks/closures** pour chaque appel.\n\n**Gains apportés**\n\n- Des delegates plus flexibles\n- Du code localisé\n- Des méthodes réduites\n- Une gestion plus fine des retours du **Delegate**\n\n### Conclusion\n\nCette solution n'est pas parfaite, mais reste assez élégante et n'est pas trop lourde à mettre en place.\nAprès, je vous laisse tester et me dire ce que vous en pensez dans les commentaires.\n\nAllez, salut les astronautes :)\n"}