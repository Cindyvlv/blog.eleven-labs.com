{"date":"2016-02-24T00:00:00.000Z","title":"Annuler une fonctionnalité avant une mise en production","excerpt":"Git workflow","readingTime":"5mn","authors":["tthuon"],"categories":[],"content":"\nGit workflow\n============\n\nConnaissez-vous le \"git workflow\" ? Si ce n'est pas le cas, je vous invite à lire cet article <http://nvie.com/posts/a-successful-git-branching-model>\n\nJe vais mettre ci-dessous l'image pour bien l'avoir en tête :\n\n![Git workflow](http://nvie.com/img/git-model@2x.png){:rel=\"nofollow noreferrer\"}\n\n> \"Git workflow. source: http://nvie.com/posts/a-successful-git-branching-model\"\n\nCe schéma est intéressant, cependant, il manque une réponse à une question : comment faire pour annuler une fonctionnalité depuis la branche *release* ?\n\nCe flux de travail suppose que toutes les fonctionnalités en *develop* soient *recettées* par le *product owner* et validées. Mais si une fonctionnalité n'est pas validée, alors qu'elle est en *develop *: nous sommes un peu coincés. La branche *release* permet de préparer la mise en production. Il faut donc l'utiliser pour fixer les éventuels bogues et annuler les fonctionnalités non validées. C'est sur ce dernier point que l'article va se concentrer.\n\nMaîtriser git comme un chef\n===========================\n\nPosons le décor : nous avons une branche *master* qui sera utilisée pour la mise en production, une branche *develop* pour toutes les nouvelles fonctionnalités du *sprint* en cours, et enfin une branche de *release* pour préparer la mise en production.\n\nÇa donne ceci :\n\n![git workflow](/imgs/posts/2016-02-24-annuler-une-fonctionnalite-avant-une-mise-en-production/init_git.png)\n\nUn développeur créé une nouvelle fonctionnalité. Il va créer sa branche depuis *develop et* la nommer \"*feat-my-awesome-feature*\". Des fichiers sont créés, il y a un commit et la branche est poussée.\n\n```sh\ngit checkout develop\ngit checkout -b feat-my-awesome-feature\n# faire des modifications\ngit add -A\ngit commit -m \"create some awesome code\"\ngit push origin feat-my-awesome-feature\n```\n\n![GIT feature](/imgs/posts/2016-02-24-annuler-une-fonctionnalite-avant-une-mise-en-production/git_feature.png)\n\nLa *code review* est ok, les tests passent, la branche est *fusionnée* dans *develop* pour être déployée en environnement d'intégration. Lors d'une *pull request*, le *merge* est fait en no-ff (*no fast forward*). Cela signifie qu'il y a un *commit* de *merge* dans l'historique. C'est important car il sera utilisé plus tard.\n\n```\ngit checkout develop\ngit merge --no-ff feat-my-awesome-feature\ngit push origin develop\n```\n\n![Git Awesome Feature](/imgs/posts/2016-02-24-annuler-une-fonctionnalite-avant-une-mise-en-production/git_awesome_feature.png)\n\nJe refais de même avec une seconde fonctionnalité : *feat-killer-feature*\n\n```\ngit checkout develop\ngit checkout -b feat-killer-feature\n# faire des modifications\ngit add -A\ngit commit -m \"create killer code\"\ngit push origin feat-killer-feature\n```\n\n![Git Killer Feat](/imgs/posts/2016-02-24-annuler-une-fonctionnalite-avant-une-mise-en-production/git_killer_feat.png)\n\nEt je *merge*.\n\n```\ngit checkout develop\ngit merge --no-ff feat-killer-feature\ngit push origin develop\n```\n\n![Git merge killer feat](/imgs/posts/2016-02-24-annuler-une-fonctionnalite-avant-une-mise-en-production/git_merge_killer_feat.png)\n\nVoilà, mon décor est posé. Petite vue en mode terminal.\n\n![Git log](/imgs/posts/2016-02-24-annuler-une-fonctionnalite-avant-une-mise-en-production/git_log.png)\n\nPréparation de la branche release\n---------------------------------\n\nNotre *sprint* va bientôt s'achever, préparons la branche de *release*. Mais au dernier moment, un *product owner* affolé voit que la fonctionnalité n'est pas valide. Il ne faut pas passer cette fonctionnalité en production.\n\n![seriously](/imgs/posts/2016-02-24-annuler-une-fonctionnalite-avant-une-mise-en-production/seriously.png)\n\nIl faut gérer cette situation !\n\nFaisons avancer *release* vers *develop*.\n\n```sh\ngit checkout release\ngit merge develop --no-ff\n```\n\nIl est important de faire un *merge --no-ff* car cela va permettre de garder une trace dans l'historique sur cette annulation.\n\n![Git release](/imgs/posts/2016-02-24-annuler-une-fonctionnalite-avant-une-mise-en-production/git_release.png)\n\nAnnuler la branche \"feat-my-awesome-feature\"\n============================================\n\nCette fonctionnalité n'est pas si géniale que ça (selon le *product owner*), je vais donc l'annuler de la branche *release*, mais je veux pouvoir la garder en *develop* pour l'améliorer dans le prochain *sprint*.\n\nJe vais donc faire un *revert.*\n\n```sh\ngit checkout release\ngit revert -m 1 <commit de merge de feat-my-awesome-feature>\n```\n\nSi je fais un *git log*, je vais retrouver mon *commit* de *merge* correspondant :  184a372a608b632636f20a1ab7c64027cc9eecc2\n\nEn appliquant cette commande, un nouveau *commit* va être créé : un *commit* de *revert*. Cela va permettre d'indiquer qu'il y a eu *revert* et donc une annulation de l'ensemble des modifications de ce *commit*.\n\nMon historique indique bien un *commit* de *revert* avec en commentaire une explication:\n\n```\ncommit 15c3c27a603263d1e59f5b137e7acfc6dcad5ce0\nAuthor: Thierry Thuon <thierry.thuon.ext@francetv.fr>\nDate:   Fri Feb 19 12:49:07 2016 +0100\n\n    Revert \"Merge branch 'feat-my-awesome-feature' into develop\"\n\n    This reverts commit 184a372a608b632636f20a1ab7c64027cc9eecc2, reversing\n    changes made to 59596dd37699742262fc5a2705e2b9396540af77.\n```\n\nJe pousse ma branche *release* et la *merge* dans *master*. Il faut toujours pousser en --*no-ff* pour avoir un *commit* de *merge*, et donc avoir la possibilité de faire un *revert*.\n\n```sh\ngit push origin release\ngit checkout master\ngit merge release --no-ff\n```\n\nDepuis *master*, je vois que j'ai bien la fonctionnalité *feat-killer-feature* uniquement.\n\nRemettre à jour develop\n=======================\n\nMaintenant, une autre problématique se pose : si je *merge* de nouveau *develop* dans *release*,  git considère qu'il n'y a aucune modification. C'est à cause du *commit* de *revert* dans la branche *release*. Pour cela, il faut annuler ce *commit* de *revert* (en gros, annuler une annulation x) ).\n\nJe vais tout d'abord mettre à jour *develop.*\n\n```sh\ngit checkout develop\ngit merge release\n```\n\nIci je n'ai pas besoin de faire un *--no-ff*, j'applique les modifications directement en *fast-forward*.\n\nDepuis *develop*, je cherche mon *commit* de *revert* : 15c3c27a603263d1e59f5b137e7acfc6dcad5ce0\n\nEt j'applique un *revert* sur ce *commit*.\n\n```sh\ngit revert <commit de revert>\n```\n\nUn nouveau *commit* s'ajoute : il annule un *commit* d'annulation (\"revert the revert\").\n\n```\ncommit b7f210da78305284f72edc2e671e5be1f167faad\nAuthor: Thierry Thuon <thierry.thuon.ext@francetv.fr>\nDate:   Fri Feb 19 13:01:53 2016 +0100\n\n    Revert \"Revert \"Merge branch 'feat-my-awesome-feature' into develop\"\"\n\n    This reverts commit 15c3c27a603263d1e59f5b137e7acfc6dcad5ce0.\n```\n\nJe retrouve bien les modifications de ma branche *feat-my-awesome-feature*. Et lors de la prochaine *release*, si tout est ok, elle pourra passer en *master*. Sinon, il faudra faire de nouveau un *revert* dans *release*.\n\nPour conclure, cette solution permet d'avoir la rigueur du *git workflow*, tout en ayant la souplesse et la possibilité d'annuler une fonctionnalité complète juste avant une mise en production. L'exemple montré ici est un cas nominal, mais la plupart du temps il peut y avoir un risque de conflit. Cette technique fonctionne bien pour des fonctionnalités isolées. De plus, il est important de bien faire les *merge* vers *release* et *master* en *no fast forward* (*--no-ff*). Enfin, il ne faut pas oublier les *commit* de *revert* lors de la mise à jour de *develop*.\n\nJe vous mets en lien la démo: <https://github.com/eleven-labs/cancel-story-before-deploying-prod/network>\n"}