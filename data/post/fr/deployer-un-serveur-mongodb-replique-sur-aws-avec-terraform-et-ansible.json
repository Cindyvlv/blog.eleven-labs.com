{"date":"2017-12-04T00:00:00.000Z","title":"Déployer un serveur MongoDB répliqué sur AWS avec Terraform et Ansible","excerpt":"J'ai récemment eu l'occasion de déployer un serveur MongoDB sur Amazon Web Services (AWS). Afin de limiter les problèmes de crash et de perte de données, celui-ci est également répliqué avec deux autres serveurs, idéalement dans une zone géographique différente pour assurer de la haute disponibilité.","readingTime":"12mn","authors":["vcomposieux"],"categories":[],"content":"\nJ'ai récemment eu l'occasion de déployer un serveur MongoDB sur Amazon Web Services (AWS). Afin de limiter les problèmes de crash et de perte de données, celui-ci est également répliqué avec deux autres serveurs, idéalement dans une zone géographique différente pour assurer de la haute disponibilité.\n\nPour l'automatisation de la création des machines EC2, j'ai utilisé [Terraform](https://www.terraform.io/){:rel=\"nofollow\"} (et son provider `aws`) ainsi que [Ansible](https://www.ansible.com/) pour le provisionnement. Cet article décrit la logique technique que nous avons mis en place pour y arriver.\n\n## Contexte\n\nNous avons donc un cluster MongoDB composé de trois instances EC2 (disons de type `t2.large`).\n\nParmi ces instances, MongoDB va élire un serveur master, appelé `primaire` dans le langage MongoDB ainsi que des serveurs slaves, appelés `secondaires`.\n\nAfin que ces trois serveurs se partagent les mêmes données, nous allons devoir créer ce que MongoDB appelle un [replica set](https://docs.mongodb.com/manual/tutorial/deploy-replica-set/){:rel=\"nofollow\"}, soit un ensemble de données.\n\nCe qu'il est important de noter est que seul le serveur `primaire` pourra lire ou écrire des données. Les serveurs `secondaires` sont là pour prendre le relai au cas ou le serveur `primaire` serait amené à être indisponible. Ceci est possible grâce à une élection qui est lancée automatiquement par MongoDB pour élire un nouveau serveur `primaire`.\n\nVoici donc l'infrastructure cible que nous cherchons à obtenir pour cette réplication :\n\n![MongoDB Replication](/imgs/posts/2017-11-01-deployer-un-mongodb-replique-sur-aws-avec-terraform-et-ansible/replication.svg)\n\n\nComme vous pouvez le voir sur ce schéma, seul le noeud primaire est utilisé pour la lecture/écriture, les deux autres réplicas sont là pour la synchronisation des données à jour du serveur primaire en temps réel ainsi que dans le but d'éventuellement devenir primaire à leur tour, dans le cas ou le serveur primaire actuel deviendrait indisponible.\n\nLa définition d'un serveur (primaire ou secondaire) se fait via le biais d'une élection à la majorité, qui a lieu entre les serveurs. Ainsi, vous aurez forcément besoin d'avoir au minimum trois serveurs afin qu'une majorité puisse être constituée.\n\nImpossible donc de définir ce modèle de réplication avec seulement deux serveurs dans votre cluster.\n\n## Terraform : création des serveurs\n\nPassons maintenant à la création des machines sur AWS : nous avons fait le choix de [Terraform](https://www.terraform.io){:rel=\"nofollow\"} pour cette partie, un outil d'automatisation de ressources.\n\nTerraform est un outil permettant d'industrialiser des tâches d'infrastructure telles que, dans notre cas, la création de machines EC2 sur notre compte AWS.\n\nAfin de créer un serveur MongoDB (prenons ici le cas d'un premier serveur), nous utilisons le code terraform suivant :\n\n```\n# EC2 Instance: MongoDB 1\nresource \"aws_instance\" \"mongodb_one\" {\n    availability_zone = \"${var.AWS_REGION}a\"\n\n    tags {\n        Name = \"${var.ENVIRONMENT}-mongodb-one\"\n    }\n\n    ami = \"<votre-id-ami>\"\n\n    instance_type = \"t2.large\"\n\n    root_block_device {\n        volume_type = \"gp2\"\n        volume_size = \"100\"\n    }\n\n    security_groups = [\n        \"${aws_security_group.mongodb.name}\"\n    ]\n\n    associate_public_ip_address = true\n\n    key_name = \"id_rsa\"\n}\n```\n\nDans ce script, nous spécifions une nouvelle ressource de type `aws_instance` et la nommons `mongodb-one`.\n\nCette instance sera dans la zone `a` de notre région AWS, définie en variable d'environnement.\n\nNous devons également spécifier l'image AMI (Amazon Image) qui sera utilisée sur cette instance. Pour ce faire, je vous invite à sélectionner un identifiant d'AMI parmi ceux disponibles sur Amazon, en utilisant cette commande via le CLI AWS par exemple :\n\n```json\n$ aws ec2 describe-images --filters \"Name=root-device-type,Values=ebs\" \"Name=name,Values=ubuntu*hardy*\"\n\n[\n    {\n        \"Architecture\": \"x86_64\",\n        \"CreationDate\": \"2011-10-07T09:09:03.000Z\",\n        \"ImageId\": \"ami-ffecde8b\",\n        \"ImageLocation\": \"063491364108/ubuntu-8.04-hardy-server-amd64-20111006\",\n        \"ImageType\": \"machine\",\n        \"Public\": true,\n        \"KernelId\": \"aki-4cf5c738\",\n        \"OwnerId\": \"063491364108\",\n        \"RamdiskId\": \"ari-2ef5c75a\",\n        \"State\": \"available\",\n        \"BlockDeviceMappings\": [\n            {\n                \"DeviceName\": \"/dev/sda1\",\n                \"Ebs\": {\n                    \"Encrypted\": false,\n                    \"DeleteOnTermination\": true,\n                    \"SnapshotId\": \"snap-eb7aa883\",\n                    \"VolumeSize\": 8,\n                    \"VolumeType\": \"standard\"\n                }\n            },\n            {\n                \"DeviceName\": \"/dev/sdb\",\n                \"VirtualName\": \"ephemeral0\"\n            }\n        ],\n        \"Description\": \"Ubuntu 8.04 Hardy server amd64 20111006\",\n        \"Hypervisor\": \"xen\",\n        \"Name\": \"ubuntu-8.04-hardy-server-amd64-20111006\",\n        \"RootDeviceName\": \"/dev/sda1\",\n        \"RootDeviceType\": \"ebs\",\n        \"VirtualizationType\": \"paravirtual\"\n    }\n    ...\n]\n```\n\nVous aurez ainsi accès aux images Ubuntu Hardy supportant les volumes EBS (Elastic Block Storage) Amazon.\n\nLe champ qui vous intéressera est bien sûr `ImageId`, que vous devez copier dans votre code Terraform.\n\nNous spécifions ensuite le type d'instance ainsi que le type de disque et le sizing que nous souhaitons utiliser pour notre serveur.\n\nEnsuite, vous noterez également que nous spécifions une entrée `security_groups` (groupe de sécurité) pour notre instance qui est dynamique et qui pointe en fait sur une autre ressource que nous avons à déclarer.\n\nAinsi, déclarons notre groupe de sécurité pour ce serveur MongoDB :\n\n```\n# MongoDB security group\nresource \"aws_security_group\" \"mongodb\" {\n  name        = \"mongodb-${var.ENVIRONMENT}\"\n  description = \"Security group for mongodb-${var.ENVIRONMENT}\"\n\n  tags {\n    Name = \"mongodb-${var.ENVIRONMENT}\"\n  }\n}\n\nresource \"aws_security_group_rule\" \"mongodb_allow_all\" {\n  type            = \"egress\"\n  from_port       = 0\n  to_port         = 0\n  protocol        = \"-1\"\n  cidr_blocks     = [\"0.0.0.0/0\"]\n\n  security_group_id = \"${aws_security_group.mongodb.id}\"\n}\n\nresource \"aws_security_group_rule\" \"mongodb_ssh\" {\n  type            = \"ingress\"\n  from_port       = 22\n  to_port         = 22\n  protocol        = \"tcp\"\n  cidr_blocks     = [\"0.0.0.0/0\"]\n\n  security_group_id = \"${aws_security_group.mongodb.id}\"\n}\n\nresource \"aws_security_group_rule\" \"mongodb_mongodb\" {\n  type            = \"ingress\"\n  from_port       = 27017\n  to_port         = 27017\n  protocol        = \"tcp\"\n  cidr_blocks     = [\"0.0.0.0/0\"]\n\n  security_group_id = \"${aws_security_group.mongodb.id}\"\n}\n\nresource \"aws_security_group_rule\" \"mongodb_mongodb_replication\" {\n  type            = \"ingress\"\n  from_port       = 27019\n  to_port         = 27019\n  protocol        = \"tcp\"\n  cidr_blocks     = [\"0.0.0.0/0\"]\n\n  security_group_id = \"${aws_security_group.mongodb.id}\"\n}\n```\n\nIci, un tas de règles sont spécifiées dans notre groupe de sécurité.\n\nNous avons en effet besoin d'autoriser en entrée les ports `22` (SSH), `27017` (port par défaut de MongoDB) ainsi que `27019` qui est utilisé par MongoDB pour gérer les communications entre les serveurs.\n\nVous noterez que l'on autorise ici toutes les provenances dans l'entrée `cidr_blocks`, bien évidemment il faut dans les faits restreindre au maximum ces accès.\n\nNous en avons terminé avec la partie Terraform : nous sommes capables de créer un serveur MongoDB (EC2) sur AWS mais il nous reste à provisionner le serveur.\n\n## Ansible : provisioning\n\nPour provisionner le serveur MongoDB, nous utilisons un playbook Ansible. Voici la définition du playbook :\n\n```yaml\n- hosts: db-mongodb\n  become: yes\n  roles:\n  - project.provision.mongodb\n```\n\nLe host `db-mongodb` correspond à la fois au serveur primaire et aux serveurs secondaires.\n\nNous distinguons ces serveurs car nous devons définir un premier serveur primaire lorsque nous allons provisionner le cluster.\n\n```\n# Primary server\n[db-mongodb-master]\n<adresse ip> ansible_user=root\n\n# Secondary servers\n[db-mongodb-slave-1]\n<adresse ip> ansible_user=root\n\n[db-mongodb-slave-2]\n<adresse ip> ansible_user=root\n\n# MongoDB Groups\n[db-mongodb-slave:children]\ndb-mongodb-slave-1\ndb-mongodb-slave-2\n\n[db-mongodb:children]\ndb-mongodb-master\ndb-mongodb-slave\n```\n\nPour le host `db-mongodb` nous allons jouer un rôle `project.provision.mongodb` dont nous allons avoir le besoin d'effectuer les actions suivantes :\n\n* Installation et création d'un service système MongoDB\n* Préparation du fichier de configuration MongoDB\n* Activation de la réplication avec les autres hosts\n* Création des comptes utilisateurs\n* Démarrage de l'instance MongoDB\n\nCommençons par l'installation et l'activation de MongoDB :\n\n```yaml\n- name: Install mongodb\n  apt:\n    name: mongodb-org\n    state: present\n    allow_unauthenticated: yes\n\n- name: Create systemd service file\n  template:\n    src: mongod.service\n    dest: /etc/systemd/system/mongodb.service\n\n- name: Enable Mongod service\n  command: systemctl enable mongodb.service\n  become: yes\n  when: env == 'dev'\n```\n\nRien de très spécial jusque-là. Notez que le fichier `mongod.service` est directement disponible dans notre code Ansible et peut être variabilisé sur certaines valeurs.\n\nC'est également le cas pour la configuration MongoDB que nous importons aussi sur le serveur :\n\n```yaml\n- name: Copy MongoDB configuration file\n  template:\n    src: mongod.conf\n    dest: /etc/mongod.conf\n```\n\nAfin d'activer la réplication, notez que nous avons besoin de spécifier dans ce fichier de configuration, un nom de replica set (ici, `rs0`) :\n\n```yaml\nreplication:\n  replSetName: \"rs0\"\n```\n\nCette réplication fonctionnera uniquement dans le cas où les serveurs peuvent communiquer entre eux.\n\nIl est également important de sécuriser ces échanges, c'est pourquoi nous allons également créer une clé qui aura pour but d'authentifier les serveurs discutant entre eux :\n\n\n```yaml\n- name: Prepare authorization key file\n  local_action: shell openssl rand -base64 756 > {{ playbook_dir }}/passwords/{{ env }}/mongodb-key\n  when: database_replica_type == \"master\"\n\n- name: Create mongodb home directory\n  file:\n    state: directory\n    path: /home/mongodb\n    owner: mongodb\n    group: mongodb\n    mode: 0755\n\n- name: Copies key to both master and slaves\n  copy:\n    src: \"{{ playbook_dir + '/passwords/' + env + '/mongodb-key'}}\"\n    dest: /home/mongodb/mongodb-key\n    owner: mongodb\n    group: mongodb\n    mode: 0400\n  when: database_replica_type != false\n\n- name: Add key to mongodb configuration\n  lineinfile:\n    dest: /etc/mongod.conf\n    state: present\n    regexp: '#  keyFile:'\n    line: '  keyFile: /home/mongodb/mongodb-key'\n    backrefs: yes\n  when: database_replica_type != false\n```\n\n\nNous créons ici la clé nécessaire avec `openssl`, la copions sur les serveurs et la spécifions dans le fichier de configuration (un redémarrage de MongoDB sera nécessaire ensuite afin de prendre en compte cette clé).\n\nFinalement, démarrons ou redémarrons nos serveurs MongoDB à l'aide du service système précédemment créé :\n\n```yaml\n- name: Restart mongodb\n  command: systemctl restart mongodb.service\n```\n\nLorsque vous vous connecterez ensuite à vos différents serveurs MongoDB, vous aurez donc l'élément `PRIMARY` ou `SECONDARY` dans la console, comme dans l'exemple ci-dessous, ce qui vous permet de savoir où vous vous situez :\n\n```\nroot@mongodb:~# mongo --host localhost -u user -p<password> admin\nMongoDB shell version: 3.2.17\nconnecting to: localhost:27017/admin\nrs0:PRIMARY>\n```\n\nVous pouvez également vérifier la configuration de votre réplication via la commande `rs.conf()` dans les différents serveurs MongoDB :\n\n```\nrs0:PRIMARY> rs.conf()\n{\n\t\"_id\" : \"rs0\",\n\t\"version\" : 3,\n\t\"protocolVersion\" : NumberLong(1),\n\t\"members\" : [\n\t\t{\n\t\t\t\"_id\" : 0,\n\t\t\t\"host\" : \"<ip1>:27017\",\n\t\t\t\"arbiterOnly\" : false,\n\t\t\t\"buildIndexes\" : true,\n\t\t\t\"hidden\" : false,\n\t\t\t\"priority\" : 1,\n\t\t\t\"tags\" : {\n\n\t\t\t},\n\t\t\t\"slaveDelay\" : NumberLong(0),\n\t\t\t\"votes\" : 1\n\t\t},\n\t\t{\n\t\t\t\"_id\" : 1,\n\t\t\t\"host\" : \"<ip2>:27017\",\n\t\t\t\"arbiterOnly\" : false,\n\t\t\t\"buildIndexes\" : true,\n\t\t\t\"hidden\" : false,\n\t\t\t\"priority\" : 1,\n\t\t\t\"tags\" : {\n\n\t\t\t},\n\t\t\t\"slaveDelay\" : NumberLong(0),\n\t\t\t\"votes\" : 1\n\t\t},\n\t\t{\n\t\t\t\"_id\" : 2,\n\t\t\t\"host\" : \"<ip3>:27017\",\n\t\t\t\"arbiterOnly\" : false,\n\t\t\t\"buildIndexes\" : true,\n\t\t\t\"hidden\" : false,\n\t\t\t\"priority\" : 1,\n\t\t\t\"tags\" : {\n\n\t\t\t},\n\t\t\t\"slaveDelay\" : NumberLong(0),\n\t\t\t\"votes\" : 1\n\t\t}\n\t],\n    ...\n```\n\nAinsi, plus de doute sur votre configuration. Vous avez également la possibilité de donner du poids à certains serveur, ce qui permettra d'influencer les élections d'un nouveau serveur primaire en cas de panne sur votre cluster via la propriété `priority`.\n\n## Conclusion\n\nDéployer un cluster MongoDB avec un réplication active sur une infrastructure spécifiée via du code Terraform et provisionnée avec Ansible est vraiment très simple. En effet, MongoDB nous facilite beaucoup les choses car il ne suffit que de quelques lignes de configuration pour activer la réplication.\n\nToute la logique d'élection et de re-définition de serveur primaire est gérée par MongoDB.\n\nPour aller plus loin au niveau de la réplication MongoDB, je vous invite à parcourir la documentation officielle de MongoDB qui explique très bien, avec des schémas, le fonctionnement et les différents paramètres de configuration disponibles pour configurer au mieux vos réplicas : [https://docs.mongodb.com/v3.0/core/replication-introduction/#replication-introduction](https://docs.mongodb.com/v3.0/core/replication-introduction/#replication-introduction){:rel=\"nofollow\"}.\n"}