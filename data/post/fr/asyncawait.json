{"date":"2019-11-06T00:00:00.000Z","title":"Async / await","excerpt":"Après avoir décortiqué les promesses, nous allons voir comment utiliser async await.","readingTime":"8mn","authors":["mehdidr"],"categories":["javascript"],"content":"\nAprès avoir vu en profondeur comment fonctionnent les promesses et comment les utiliser, nous allons nous pencher sur une fonctionnalité arrivée avec l'ES7 : `async/await`.\n`Async` await nous permet de résoudre un problème né de l'utilisation de code asynchrone en javascript : le [callback hell](http://callbackhell.com/), récurrent lorsque l'on cherche à faire de l'asynchrone de manière séquentielle.\n`Async/await` n'est globalement que du sucre syntaxique, qui nous permet de lire du code asynchrone comme s'il était synchrone.\n\n⚠️ Il est important de connaître et de comprendre les promesses pour maîtriser `async/await`. Si ce n'est pas votre cas, je vous conseille de lire mon précédent [article](https://blog.eleven-labs.com/fr/lespromessesenjavascript/) qui traite justement des promesses.\n\n![]({{site.baseurl}}/assets/2019-11-06-async-await/async-await.jpg)\n\n## Définition\n\n### async\n\nMettre le mot `async` devant une fonction lui donne l'instruction de retourner une promesse. Si une erreur apparaît pendant l'exécution, la promesse est rejetée. Si la fonction retourne une valeur, la promesse est résolue avec cette valeur. Et si une promesse est retournée, elle reste inchangée.\n\n```javascript\nasync function asyncFunction() {\n // équivaut à : return Promise.resolve('résultat');\n return 'résultat';\n}\n\nasyncFunction().then(console.log) // \"résultat\"\n```\n\nles fonctions async rendent le code beaucoup plus concis que l'utilisation de promesses normales :\n\n```javascript\n// Utilisation du then\nconst makeRequest = () =>\n  getJSON()\n    .then(data => {\n      console.log(data)\n      return \"done\"\n    })\n\nmakeRequest()\n\n// Utilisation d'async\nconst makeRequest = async () => {\n  console.log(await getJSON())\n  return \"done\"\n}\n\nmakeRequest()\n```\n\n### await\n\nLe mot-clé `await` ne peut être utilisé qu'à l'intérieur d'une fonction async. Il nous permet d'attendre que la promesse retourne son résultat (ou une erreur) pour continuer l'exécution du code.\n\n```javascript\nasync function getAsyncNumber1() // renvoie une promesse avec comme valeur un nombre\nasync function getAsyncNumber2() // même chose que ligne du dessus\n\nconst getAsyncAddition = async () => {\n const number1 = await getAsyncNumber1();\n const number2 = await getAsyncNumber2();\n return number1 + number2;\n}\n```\n\nPour avoir le même résultat sans `await`, il faudrait\n\n- soit imbriquer un `then()` dans un autre :\n\n```javascript\nconst getAsyncAddition = () => getAsyncNumber1().then(number1 => getAsyncNumber2().then(number2 => number1 + number2));\n```\n\nCe qui, vous en conviendrez, est difficile à lire.\n\n- soit déclarer une variable dans le scope de la fonction :\n\n```javascript\nconst getAsyncAddition = () => {\n let number;\n return getAsyncNumber1()\n   .then(vnumber => {\n     number1 = vnumber1;\n     return getAsyncNumber2();\n   })\n   .then(number2 => number1 + number2);\n}\n```\n\nVoici une liste de règles importantes à retenir sur async await :\n\n- les fonctions async retournent une promesse.\n- les fonctions async utilisent une `Promise` implicite pour retourner un résultat. Même si une promesse n'est pas retournée explicitement, la fonction async fait en sorte que le code soit passé par une promesse.\n- `await` bloque l'exécution du code à l'intérieur d'une fonction async. Il permet de s'assurer que la prochaine ligne soit exécutée quand la promesse est résolue. Donc si du code asynchrone est déjà en train de s'exécuter, `await` n'aura pas d'effet sur lui.\n- il peut y avoir plusieurs `await` à l'intérieur d'une fonction async.\n- Il faut bien faire attention lors de l'utilisation d'`await` dans une boucle, car le code peut facilement s'exécuter de manière séquentielle au lieu d'être executé en parallèle.\n- `await` est toujours utilisé pour une seule promesse.\n\n## Pourquoi utiliser async await ?\n\nOn pourrait se demander pourquoi utiliser cette fonctionnalité, alors que les promesses existent déjà en JS.\n\n- Comme vous l'avez vu avec les exemples ci-dessus, `async/await` nous permet d'avoir un code beaucoup plus concis et nous évite le callback hell.\n- L'utilisation d'`async/await` permet d'améliorer la gestion d'erreur, car il est possible de gérer les erreurs synchrones et asynchrones en même temps (ce qui n'était pas le cas auparavant), notamment grâce à l'utilisation d'un `try/catch`.\n\n```javascript\nconst makeRequest = () => {\n  try {\n    getJSON()\n      .then(result => {\n        // this parse may fail\n        const data = JSON.parse(result)\n        console.log(data)\n      })\n      // décommenter ce bloc pour gérer les erreurs asynchrones\n      // .catch((err) => {\n      //   console.log(err)\n      // })\n  } catch (err) {\n    console.log(err)\n  }\n}\n```\n\nDans cet exemple, le `try/catch` va casser si le `JSON.parse` casse car il se passe à l'intérieur d'une promesse. Il est nécessaire d'utiliser un `.catch()` sur la promesse et donc dupliquer la gestion d'erreur. Voici le même code avec `async/await` :\n\n```javascript\nconst makeRequest = async () => {\n  try {\n    // this parse may fail\n    const data = JSON.parse(await getJSON())\n    console.log(data)\n  } catch (err) {\n    console.log(err)\n  }\n}\n```\n\nMais il est aussi possible d'utiliser un catch à l'appel de la fonction avec async/await :\n\n```javascript\nconst doSomethingAsync = async () => {\n    let result = await someAsyncCall();\n    return result;\n}\n\ndoSomethingAsync().\n  .then(successHandler)\n  .catch(errorHandler);\n```\n\n- Il arrive assez souvent d'appeler une promesse (qu'on va appeler promesse1) et d'utiliser sa valeur de retour pour appeler une deuxième promesse (qui s'appelle sans surprise promesse2), pour ensuite utiliser le résultat de ces deux promesses pour appeler promesse3. Le code ressemble donc à ceci :\n\n```javascript\n\nconst makeRequest = () => {\n  return promise1()\n    .then(value1 => {\n      // Du code\n      return promise2(value1)\n        .then(value2 => {\n          // Du code\n          return promise3(value1, value2)\n        })\n    })\n}\n```\n\nIl est possible ici d'englober les promesses 1 et 2 dans un `Promise.all` pour éviter d'avoir à imbriquer les promesses :\n\n```javascript\nconst makeRequest = () => {\n  return promise1()\n    .then(value1 => {\n      // Du code\n      return Promise.all([value1, promise2(value1)])\n    })\n    .then(([value1, value2]) => {\n      // Du code\n      return promise3(value1, value2)\n    })\n}\n```\n\nLe problème de cette approche est qu'elle sacrifie la sémantique au profit de la lisibilité. Il n'y a aucune raison de mettre les promesses 1 et 2 dans un tableau, excepté pour éviter l'imbriquation de promesses.\n\nCe qui est rendu beaucoup plus simple grâce à `async/await` :\n\n```javascript\nconst makeRequest = async () => {\n  const value1 = await promise1()\n  const value2 = await promise2(value1)\n  return promise3(value1, value2)\n}\n```\n\n- Le debugging est rendu beaucoup plus simple grâce à l'utilisation d'`async/await`. On peut mettre des points d'arrêts contrairement à l'utilisation de promesses.\n\n- Il est possible d'utiliser `await` sur des opérations synchrones et asynchrones. Par exemple, écrire `await 5` revient à écrire `Promise.resolve(5)`.\n\n## Top-level await\n\nAvant de passer à la conclusion, j'aimerais aborder un sujet qui est encore en draft (au stage 3, donc probablement bientôt disponible !) au moment où j'écris ces lignes : le top-level `await`.\n\nLe top-level `await` permet aux modules d'agir comme des fonctions async. Il était possible auparavant d'importer un module dans une fonction async, mais un problème se posait : l'`export` de ce module pouvait être accessible avant que la fonction async soit résolue. Cela pouvait poser problème car si un autre module importe le module présent dans la fonction async, le résultat était potentiellement `undefined`.\n\nUn article écrit par Rich Harris a cependant mis en avant certaines craintes à propos de cette nouvelle proposition, notamment:\n\n- Top-level `await` pourrait bloquer l'exécution du code.\n- Top-level `await` pourrait bloquer le `fetch` des ressources.\n- Top-level `await` pourrait créer des problèmes d'intéropérabilité avec les modules [CommonJS](https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch11s03.html).\n\nPour résoudre ces problématiques, la version en stage 3 propose ces solutions :\n\n- Top-level `await` ne bloque pas les exécutions en parralèle.\n- Top-level `await` se produit durant la phase d'execution du module (qui correspond à la dernière phase, après l'initialization et la configuration), ce qui signifie qu'il se produit après que les ressources soient `fetch`.\n- Top-level `await` se limite aux modules, il ne supportera pas les scripts ou les modules CommonJS.\n\nUne solution qui permettrait donc d'utiliser dynamiquement les modules en JavaScript mais qui soulève malgré tout plusieurs questions, car les imports impératifs sont plus lents et mauvais pour les performances d'une application que les imports déclaratifs.\n\nPour ceux qui aimeraient avoir plus d'informations sur ces deux sujets, voici quelques ressources :\n\n- [La proposition top-level await](https://github.com/tc39/proposal-top-level-await)\n\n- [L'article écrit par Rich Harris: Top-level await is a footgun](https://gist.github.com/Rich-Harris/0b6f317657f5167663b493c722647221)\n\n- [Why imperative imports are slower than declarative imports](https://gist.github.com/Rich-Harris/41e8ccc755ea232a5e7b88dee118bcf5)\n\nCes 3 ressources sont par contre en anglais, mais pour les anglophobes, il n'y a pas à s'inquièter car il est très probable que l'on entendra parler à nouveau du top-level `await`.\n\n## Conclusion\n\n`async/await` est une fonctionnalité incroyable qui permet d'écrire de l'asynchrone facilement. Il est cependant important de comprendre que pour le langage, `async/await` fonctionne exactement comme une promesse et qu'il ne résoud pas tout les problèmes, comme la gestion de plusieurs appels asynchrones qui sont indépendants. Les fonctions async fonctionnent exactement comme les promesses, mais sont utiles pour gérer les erreurs, éviter d'imbriquer ses promesses, et lire du code asynchrone comme du code synchrone. J'espère que cet article vous aura aidé à y voir plus clair !\n"}