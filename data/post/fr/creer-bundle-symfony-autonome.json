{"date":"2016-12-16T00:00:00.000Z","title":"Créer un bundle Symfony autonome","excerpt":"Dans ce post nous allons voir step-by-step comment créer de zéro un bundle symfony autonome.","readingTime":"8mn","authors":["VEBERArnaud"],"categories":["php"],"content":"Dans ce post nous allons voir step-by-step comment créer de zéro un bundle symfony autonome.\nCe bundle n'aura aucune responsabilité fonctionnelle, il servira simplement à dérouler les étapes de création d'un\nbundle autonome.\n\n---\n\n### Les étapes\n* [Bootstrap du projet](#bootstrap-du-projet)\n* [Bundle minimal](#bundle-minimal)\n* [Application embarquée](#application-embarquée)\n* [Utilisation autonome](#utilisation-autonome)\n  * [Application console](#application-console)\n  * [Application web](#application-web)\n* [Tests](#tests)\n  * [Tests unitaires](#tests-unitaires)\n  * [Tests fonctionnels](#tests-fonctionnels)\n* [Conclusion](#conclusion)\n\n---\n\n## Bootstrap du projet\n\nCommençons par créer un fichier composer.json pour notre projet.\n\n```json\n{\n    \"name\": \"acme/standalone-bundle\",\n    \"description\": \"acme standalone bundle\",\n    \"type\": \"bundle\",\n    \"require\": {}\n}\n```\n\nAfin d'optimiser les performances en production, nous séparons les sources et les tests.\nReprenons notre composer.json et ajoutons-y ces règles d'autoload.\n\n```json\n{\n    \"name\": \"acme/standalone-bundle\",\n    \"description\": \"acme standalone bundle\",\n    \"type\": \"bundle\",\n    \"require\": {},\n    \"autoload\": {\n        \"psr-4\": {\n            \"Acme\\StandaloneBundle\\\": \"src/\"\n        }\n    },\n    \"autoload-dev\": {\n        \"psr-4\": {\n            \"Acme\\StandaloneBundle\\Tests\\\": \"tests/\"\n        }\n    }\n}\n```\n\nLançons un composer install afin d'initialiser le projet.\n\n```bash\ncomposer install\n```\n\nComposer crée un dossier vendor que nous ne souhaitons pas versionner.\nPour indiquer à git que ce dossier doit être ignoré, il faut créer le fichier `.gitignore` à la racine du projet et y\najouter le path vers le dossier à ignorer.\n\n```ini\n# .gitingore\n\n/vendor\n```\n\n## Bundle minimal\n\nPour créer notre bundle minimal, nous devons créer la classe `\\Acme\\StandaloneBundle\\StandaloneBundle` qui étend\n`\\Symfony\\Component\\HttpKernel\\Bundle\\Bundle`.\n\n```php\n<?php\n// src/StandaloneBundle.php\n\nnamespace Acme\\StandaloneBundle;\n\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\nclass StandaloneBundle extends bundle\n{\n}\n```\n\nLa classe parente est disponible dans le composant `symfony/http-kernel`, ajoutons cette dépendance à notre projet avec\ncomposer.\n\n```bash\ncomposer require \"symfony/http-kernel:3.1.*\"\n```\n\nNotre bundle minimal est maintenant prêt, il peut être register dans une application Symfony.\n\n## Application embarquée\n\nAfin d'être sûr que notre bundle fonctionne comme attendu au sein d'une application symfony, nous allons embarquer une\napplication minimale dans notre projet.\n\nDans le kernel de cette application embarquée, nous allons surcharger les méthodes\n* registerBundles: pour y register notre bundle\n* registerContainerConfiguration: pour définir l'emplacement de notre fichier de configuration\n\n```php\n<?php\n// tests/App/AppKernel.php\n\nnamespace Acme\\StandaloneBundle\\Tests\\App;\n\nuse Symfony\\Component\\HttpKernel\\Kernel;\nuse Symfony\\Component\\Config\\Loader\\LoaderInterface;\n\nclass AppKernel extends Kernel\n{\n    public function registerBundles()\n    {\n        return [\n            new \\Symfony\\Bundle\\FrameworkBundle\\FrameworkBundle(),\n            new \\Acme\\StandaloneBundle\\StandaloneBundle(),\n        ];\n    }\n\n    public function registerContainerConfiguration(LoaderInterface $loader)\n    {\n        $loader->load(__DIR__.'/config/config.yml');\n    }\n}\n```\n\nOn en profite pour ajouter en dépendance de dev le composant `symfony/framework-bundle`\n\n```bash\ncomposer require --dev \"symfony/framework-bundle:3.1.*\"\n```\n\nLe composant FrameworkBundle requiert au minimum la configuration d'un secret, que nous ajoutons au fichier\ntests/App/config/config.yml\n\n```yaml\n# tests/App/config/config.yml\n\n# FrameworkBundle Configuration\nframework:\nsecret: This is a secret, change me\n```\n\nPour que ce fichier de configuration en yaml puisse être chargé par le kernel, nous devons ajouter en dépendance de dev\nle composant `symfony/yaml`.\n\n```bash\ncomposer require --dev \"symfony/yaml\"\n```\n\nAu boot, le kernel crée un dossier de cache et un dossier de logs que l'on ne souhaite pas versionner.\nOn ajoute alors ces dossiers au `.gitignore`\n\n```ini\n# .gitingore\n\n/vendor\n/tests/App/cache\n/tests/App/logs\n```\n\n## Utilisation autonome\n\n### Application console\n\nPour pouvoir créer dans notre bundle autonome des commandes symfony, nous devons dans un premier temps ajouter en\ndépendance de dev le composant symfony/console puis ajouter à notre application minimale le script console.\n\n```bash\ncomposer require --dev \"symfony/console:3.1.*\"\n```\n\n```php\n<?php\n// tests/App/console\n\nnamespace Acme\\StandaloneBundle\\Tests\\App;\n\nrequire_once __DIR__ . '/../../vendor/autoload.php';\n\nuse Symfony\\Bundle\\FrameworkBundle\\Console\\Application;\n\n$kernel = new AppKernel('dev', true);\n$application = new Application($kernel);\n$application->run();\n```\n\nNous pouvons maintenant lancer des commandes en utilisant la console.\n\n```bash\nphp tests/App/console\n```\n\n### Application web\n\nMaintenant que nous pouvant lancer des commandes, intéressons-nous au web.\nAfin de pouvoir appeler un contrôleur, nous devons ajouter à notre application minimale un frontal web.\n\n```php\n<?php\n// tests/App/app_dev.php\n\nnamespace Acme\\StandaloneBundle\\Tests\\App;\n\nrequire_once __DIR__ . '/../../vendor/autoload.php';\n\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n$kernel = new AppKernel('dev', true);\n$request = Request::createFromGlobals();\n$response = $kernel->handle($request);\n$response->send();\n$kernel->terminate($request, $response);\n```\n\nAjoutons un contrôleur et la configuration du routing afin de pouvoir tester notre frontal web.\n\n```php\n<?php\n// src/Controller/FooController.php\n\nnamespace Acme\\StandaloneBundle\\Controller;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\n\nclass FooController extends Controller\n{\n    public function barAction()\n    {\n        return new JsonResponse(['foo' => 'bar']);\n    }\n}\n```\n\n```yaml\n# src/Resources/config/routing.yml\n\nstandalone_foobar:\n    path: /\n    defaults:\n    _controller: StandaloneBundle:Foo:bar\n```\n\n```yaml\n# tests/App/config/routing.yml\n\n_main:\n    resource: ../../../src/Resources/config/routing.yml\n```\n\n```yaml\n# tests/App/config/config.yml\n\n# FrameworkBundle Configuration\nframework:\n    secret: This is a secret, change me\n    router:\n        resource: '%kernel.root_dir%/config/routing.yml'\n        strict_requirements: ~\n```\n\nMaintenant que nous avons un frontal web disponible dans notre projet, voyons comment lancer un serveur web très simple\nqui dirige directement vers celui-ci.\n\nPour commencer ajoutons le composant symfony/process.\n\n```bash\ncomposer require --dev \"symfony/process:3.1.*\"\n```\n\nL'ajout de ce composant nous permet d'utiliser le serveur web interne de php.\n\n```bash\nphp tests/App/console server:run -d tests/App\n```\n\nOuvrez votre navigateur vers [](http://127.0.0.1:8000/){:rel=\"nofollow noreferrer\"}, le json `{\"foo\": \"bar\"}` doit s'afficher.\nVous avez maintenant un bundle capable de recevoir des requêtes HTTP et d'y répondre sans avoir besoin de configurer un\nserveur web pour le développement.\n\n## Tests\n\n### Tests unitaires\n\nPour exécuter les tests unitaires sur notre projet, nous allons utiliser la librairie phpunit.\n\nAjoutons cette dépendance de dev\n\n```bash\ncomposer require --dev \"phpunit/phpunit\"\n```\n\nAjoutons le fichier de configuration phpunit dans notre projet.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!-- phpunit.xml -->\n\n<phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:noNamespaceSchemaLocation=\"http://schema.phpunit.de/4.3/phpunit.xsd\"\n    backupGlobals=\"false\"\n    colors=\"true\"\n    bootstrap=\"./vendor/autoload.php\"\n    >\n\n    <php>\n        <server name=\"KERNEL_DIR\" value=\"./tests/App/\" />\n    </php>\n\n    <testsuites>\n        <testsuite name=\"StandaloneBundle Suite\">\n            <directory suffix=\"Test.php\">./tests/</directory>\n        </testsuite>\n    </testsuites>\n\n    <filter>\n        <whitelist processUncoveredFilesFromWhitelist=\"true\">\n            <directory suffix=\".php\">./src/</directory>\n        </whitelist>\n    </filter>\n\n    <logging>\n        <log type=\"coverage-clover\" target=\"build/logs/clover.xml\"/>\n        <log type=\"coverage-html\" target=\"build/coverage\" />\n    </logging>\n</phpunit>\n```\n\nAjoutons un test unitaire pour tester notre configuration.\n\n```php\n<?php\n// tests/Unit/Controller/FooControllerTest.php\n\nnamespace Acme\\StandaloneBundle\\Tests\\Unit\\Controller;\n\nuse Acme\\StandaloneBundle\\Controller\\FooController;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\n\nclass FooControllerTest extends \\PHPUnit_Framework_TestCase\n{\n    private $controller = null;\n\n    protected function setUp()\n    {\n        $this->controller = new FooController();\n    }\n\n    protected function tearDown()\n    {\n        $this->controller = null;\n    }\n\n    public function testBarAction()\n    {\n        $this->assertInstanceOf(JsonResponse::class, $this->controller->barAction());\n    }\n}\n```\n\nOn lance ensuite la suite de test, qui nous affiche qu'un test et une assertion ont été exécutés sans problèmes.\n\n```bash\n./vendor/bin/phpunit\n```\n\n### Tests fonctionnels\n\nPour lancer les tests fonctionnels, nous allons encore une fois utiliser la librairie phpunit.\n\nCommençons par ajouter le composant symfony/brower-kit, puis nous étendrons le WebTestCase symfony pour override la\nméthode getKernelClass afin renvoyer le bon FQCN de notre Kernel embarqué, puis nous rajouterons de la configuration au\nframework bundle.\n\n```bash\ncomposer require \"symfony/browser-kit:3.1.*\"\n```\n\n```php\n<?php\n// tests/WebTestCase.php\n\nnamespace Acme\\StandaloneBundle\\Tests;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Test\\WebTestCase as BaseWebTestCase;\n\nabstract class WebTestCase extends BaseWebTestCase\n{\n    protected static function getKernelClass()\n    {\n        return 'Acme\\StandaloneBundle\\Tests\\App\\AppKernel';\n    }\n}\n```\n\n```yaml\n# tests/App/config/config.yml\n\n# FrameworkBundle Configuration\nframework:\n    secret: This is a secret, change me\n    router:\n        resource: '%kernel.root_dir%/config/routing.yml'\n        strict_requirements: ~\n    test: ~\n```\n\nNous allons maintenant utiliser ce WebTestCase pour créer un client et parcourir les pages web de notre projet.\n\n```php\n<?php\n// tests/Functional/Controller/FooControllerTest.php\n\nnamespace Acme\\StandaloneBundle\\Tests\\Functional\\Controller;\n\nuse Acme\\StandaloneBundle\\Tests\\WebTestCase;\n\nclass FooControllerTest extends WebTestCase\n{\n    private $client = null;\n\n    private $container = null;\n\n    public function setUp()\n    {\n        $this->client = static::createClient();\n        $this->container = $this->client->getContainer();\n    }\n\n    public function tearDown()\n    {\n        $this->client = null;\n        $this->container = null;\n    }\n\n    public function testBarAction()\n    {\n        $this->client->request('GET', '/');\n\n        $this->assertTrue($this->client->getResponse()->isSuccessful());\n    }\n}\n```\n\nNous pouvons maintenant relancer les tests\n\n```bash\n./vendor/bin/phpunit\n```\n\nNous avons maintenant deux tests et deux assertions en succès.\n\n## Conclusion\n\nEn quelques étapes nous avons un bundle symfony autonome.\nUn bundle qui est capable de lancer ses propres tests unitaires et fonctionnels mais également de faire tourner son\npropre serveur web, très utile pour le développement.\n\nJ'espère que ce post vous aura donné l'envie de développer des bundles autonomes.\nN'hésitez pas à poser des questions dans les commentaires, et à me dire si vous voulez que je continue sur le sujet en\nexpliquant comment rajouter des composants (twig, web-profiler, ...), comment faire de votre bundle autonome un projet\nopen-source distribué via packagist aux quatre coins du monde.\n"}