{"date":"2022-03-29T00:00:00.000Z","title":"NestJS : le cycle de vie d'une requête","excerpt":"Cet article vous expliquera précisemment chaque étape par laquelle passent une requête et une réponse dans une application NestJS.","readingTime":"12mn","authors":["ajacquemin"],"categories":["javascript"],"content":"\nBienvenue dans cet article ayant pour but de faire un tour d'horizon du cycle de vie d'une requête puis d'une réponse dans un environnement NestJS !\n\n<br />\n\n<div style=\"text-align: center;\">\n    <img src=\"/imgs/posts/2022-03-04-nestjs-le-cycle-de-vie-dune-requete/nest-logo.png\" width=\"300px\" alt=\"NestJS logo\" style=\"display: block; margin: auto;\"/>\n    <i>NestJS Framework</i>\n</div>\n\n<br />\n\nLe but ici sera de donner une représentation précise de chaque étape que peut rencontrer une requête, dans l'ordre, et avec des exemples. Une fois lu une première fois, gardez cet article dans un coin, à la manière d'un **pense-bête**. \nAinsi, en cas de confusion ou d'esprit embrumé le lendemain d'un jeudi soir un peu arrosé, il sera votre meilleur allié pour que votre gueule de bois passe inaperçue.\n\nVoilà d'ailleurs un **sommaire** pour retrouver rapidement la partie qui vous intéresse :\n\n- [Présentation globale du cycle de vie requête / réponse](#cycle-de-vie--vue-globale)\n- [Les niveaux de déclaration](#niveaux-de-déclaration)\n- [Présentation des Middlewares](#les-middlewares)\n- [Présentation des Guards](#les-guards)\n- [Présentation des Interceptors](#les-interceptors)\n- [Présentation des Pipes](#les-pipes)\n- [Présentation du Controller](#le-controller)\n- [Présentation des Exception Filters](#les-exception-filters)\n- [Conclusion](#conclusion)\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nVous pouvez être totalement débutant en NestJS et quand même lire cet article. C'est peut-être même recommandé.\n</div>\n\n## Cycle de vie : vue globale\nRien de tel qu'un schéma que je vous ai concocté pour entrer dans le vif du sujet. Je vous laisse vous en imprégner.\n\n![](/imgs/posts/2022-03-04-nestjs-le-cycle-de-vie-dune-requete/nest-lifecycle-schema.png)\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nIl s'agit d'un parcours plutôt exhaustif d'une requête, mais la seule étape réellement essentielle ici est le **Controller**. Il a pour rôle de recevoir votre requête, la traiter, et renvoyer une réponse. Tout le reste est facultatif.\n</div>\n\nComme vous pouvez le constater, une requête, avant d'arriver au **Controller**, peut passer par 4 premières couches qui sont dans l'ordre : **Middleware** -> **Guard** -> **Interceptor** -> **Pipe**.\nPuis, libre à votre **Controller** d'appeler tout **Service** (où par convention repose votre logique métier) ou **Repository** (pour les appels à la base de données) pour traiter la requête.\nEnfin, le **Controller** renverra une réponse qui, comme vous le constatez, peut à nouveau passer par un **Interceptor**, puis par les **Exception Filters**.\nNous allons dans cet article expliquer à quoi correspond chacune de ces étapes.\n\nChacune de ces couches peut être déclarée sur un ou plusieurs niveaux, rendez-vous dans la section suivante pour les découvrir.\n\n## Niveaux de déclaration\n\nAvant de définir plus en détail chacune des couches vues précédemment, il me semblait important de parler des *niveaux de déclaration*.\nEn réalité, chacune de ces étapes que traverse la requête peut se diviser en 1 ou plusieurs sous-étapes. Pas de panique, rien de très compliqué ici, voyons par l'exemple.\n\nTout d'abord, il existe 5 niveaux de déclarations :\n\n- Déclaration **globale**\n- Déclaration au niveau **Module**\n- Déclaration au niveau **Controller**\n- Déclaration au niveau **Route**\n- Déclaration au niveau **paramètre de route**\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nPar exemple, un Interceptor peut être déclaré à 3 niveaux :\n\n- Globalement\n- Au niveau d'un controller\n- Au niveau d'une route\n\nUn Interceptor global intercepte toutes les requêtes, tandis qu'un Interceptor placé au niveau d'un Controller / d'une route intercepte seulement les requêtes qui passent par ce Controller / cette route.\n</div>\n\nAinsi, sachez que lors d’une requête, au sein de chaque couche, l’ordre de passage est toujours :\n\nNiveau **global** => Niveau **module** => Niveau **controller** => Niveau **route** => Niveau **paramètre de route**.\n\nReprenons donc une partie de notre schéma vu plus haut, mais mis à jour. Cela donnerait  :\n\n![](/imgs/posts/2022-03-04-nestjs-le-cycle-de-vie-dune-requete/updated-lifecycle-schema.png)\n\nCi-dessous à titre indicatif, vous trouverez des exemples de déclaration pour chaque niveau. Rendez-vous dans les prochaines sections pour les présentations plus poussées de toutes nos couches (Middlewares, Interceptors...).\n\n### Déclaration globale\n\nExemple avec un Guard :\n\n```javascript\n// app.module.ts\n\n// ...\n  providers: [\n    {\n      provide: APP_GUARD,\n      useClass: UserGuard,\n    },\n  ],\n// ...\n```\n\n=> Ce Guard est appliqué globalement = à toute l'application (quel que soit le module où il est déclaré).\n\n\n### Déclaration niveau module\n\nExemple avec un Middleware :\n\n```javascript\n// app.module.ts\n\n// ...\n\n// Style de déclaration spécifique aux Middlewares\nconfigure(consumer: MiddlewareConsumer): void {\n    consumer\n      .apply(LoggerMiddleware)\n      .forRoutes('*');\n}\n```\n\n=> Ce Middleware est déclaré au niveau d'un module, il est donc appelé après tout éventuel Middleware déclaré globalement. Cela étant dit, un Middleware déclaré comme ci-dessus s'applique sur toutes les routes de l'application grâce au wildcard `*`.\n\n\n### Déclaration niveau Controller\n\nExemple avec un Interceptor :\n\n```javascript\n// some-controller.ts\n\n@UseInterceptors(LoggingInterceptor)\nexport class SomeController {}\n```\n\n=> Cet Interceptor sera appliqué à toutes les routes de ce Controller.\n\n### Déclaration niveau route\n\nExemple avec un Guard :\n\n```javascript\n// some-controller.ts\n\n// ...\n@UseGuards(new RolesGuard())\n@Get()\nasync someRoute(): any {\n  // ...\n}\n// ...\n```\n\n### Déclaration niveau paramètres de route\n\nExemple avec un Pipe :\n\n```javascript\n// some-controller.ts\n\n// ...\n@Get(':id')\nasync someRoute(@Param('id', ParseIntPipe) id: number): any {\n  // ...\n}\n// ...\n```\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nL'annotation `@Param` permet de sélectionner un paramètre de l'URL, ici `:id`.\n</div>\n\nPassons maintenant à l'explication de chacun de ces concepts que nous survolons depuis le début. Pour chacun, en début de section, je mettrai une petite note indiquant à quel(s) niveau(x) il est déclarable.\n\n## Les Middlewares\n\n<div  class=\"admonition info\"  markdown=\"1\"><p  class=\"admonition-title\">Niveaux de déclaration possibles</p>\n\n- Global\n- Module\n</div>\n\nVous êtes peut-être déjà familiers du concept si vous avez déjà fait du développement en NodeJS.\nLe Middleware est toujours appelé avant le Controller et il a accès à la requête ainsi qu'à la réponse (par conséquent pas encore peuplée par le retour du Controller).\n\nVoilà un exemple de Middleware en Nest :\n\n```javascript\n@Injectable()  \nexport class CurrentUserMiddleware implements NestMiddleware {  \n  constructor(private userService: UserService) {}  \n  \n  async use(req: Request, _: Response, next: NextFunction): Promise<void> {  \n    const { userId } = req.session;  \n  \n    if (userId) {  \n      const user = await this.userService.getUserById(userId);  \n  \n      if (user) {  \n        req.currentUser = user;  \n      }  \n    }  \n  \n    next();  \n  }  \n}\n```\n\nDans cet exemple, nous récupérons un potentiel objet `session` dans la requête, puis nous peuplons la requête avec un *user* complet, à l'aide de l'id trouvé dans la `session`. Enfin, nous n'oublions pas d'appeler `next()` pour continuer l'exécution.\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nUn Middleware doit implémenter la fonction `use()`.\n\nDe plus, il doit se terminer par un appel à la fonction `next()` pour pouvoir passer à la suite des étapes d'exécution. Sans le `next()`, la requête est suspendue.\n</div>\n\n## Les Guards\n\n<div  class=\"admonition info\"  markdown=\"1\"><p  class=\"admonition-title\">Niveaux de déclaration possibles</p>\n\n- Global\n- Controller\n- Route\n</div>\n\nLe Guard est une classe dont la mission est le plus souvent l'autorisation. Un Guard a accès à tout le **contexte d'exécution** d'une requête. Il a donc la connaissance de ce qui sera exécuté après lui (quel Controller, quelle fonction, quelle route...). \n\nIl peut par exemple vérifier quels sont les rôles nécessaires pour accéder au Controller qui sera appelé dans la foulée, et avorter la requête si elle ne contient pas le rôle requis.\n\nPrenons l'exemple d'un Guard appelé à la suite du Middleware que nous avons écrit plus haut. Voilà ce qu'on pourrait faire :\n\n```javascript\n@Injectable()\nexport class AdminRoleGuard implements CanActivate {\n  canActivate(context: ExecutionContext): boolean {\n    const request = context.switchToHttp().getRequest();\n\n    return request.currentUser.role === UserRole.ADMIN;\n  }\n}\n```\n\nIci, on vérifie si l'utilisateur stocké plus tôt dans la requête a le rôle **ADMIN**. \n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Note</p>\n\nUn Guard doit implémenter la fonction  `canActivate()`, qui retourne un booléen, de manière synchrone ou dans une Promesse ou un Observable. \n</div>\n\n## Les Interceptors\n\n<div  class=\"admonition info\"  markdown=\"1\"><p  class=\"admonition-title\">Niveaux de déclaration possibles</p>\n\n- Global\n- Controller\n- Route\n</div>\n\nOn compare souvent les Interceptors avec les Middlewares. Leurs différences sont nombreuses mais en voici quelques unes :\n\n- Un Interceptor est appelé à la fois lors de la **requête**, mais aussi lors de la **réponse**.\n- Comme le Guard, l'Interceptor a accès au **contexte d'exécution** (qui contient la requête), contrairement au Middleware qui a accès à la requête, mais pas au contexte d'exécution.\n- Comme vous le savez maintenant, l'Interceptor est appelé **après** le Guard. Le Middleware est lui appelé **avant**.\n\nSouvent, les Interceptors sont utilisés pour *serializer* les réponses renvoyées par le Controller, par exemple :\n\n```javascript\nclass UserSerializerInterceptor implements NestInterceptor {\n  intercept(_: ExecutionContext, next: CallHandler): Observable<unknown> {\n    return next.handle().pipe(\n      map((user) =>\n        plainToInstance(UserDto, user),\n      ),\n    );\n  }\n}\n```\n\nL'Interceptor doit implémenter la fonction `intercept()` qui prend 2 arguments, représentant respectivement :\n\n- Un **ExecutionContext**, contenant notamment la requête.\n- un **CallHandler**, qui donne accès à la réponse.\n\n<div  class=\"admonition note\"  markdown=\"1\"><p  class=\"admonition-title\">Comment ça marche ?</p>\n\nL'interface `CallHandler` implémente la méthode `handle()`, qui retourne un Observable. C'est ainsi que l'Interceptor reste à l'écoute de la réponse. Réponse que vous pouvez ensuite manipuler comme n'importe quel Observable classique. Ici on utilise la fonction `plainToInstance()` de la librairie *class-transformer*, qui serialize un objet Javascript selon une classe donnée; ici un hypothétique UserDto.\n</div>\n\n## Les Pipes\n\n<div  class=\"admonition info\"  markdown=\"1\"><p  class=\"admonition-title\">Niveaux de déclaration possibles</p>\n\n- Global\n- Controller\n- Route\n- Paramètre de route\n</div>\n\nLes Pipes ont 2 cas d'usage : la **validation** des données, et la **transformation**.\n\nVoici un exemple tiré cette fois de la [documentation de NestJS](https://docs.nestjs.com/pipes) :\n\n```javascript\n@Injectable()\nexport class ParseIntPipe implements PipeTransform<string, number> {\n  transform(value: string, metadata: ArgumentMetadata): number {\n    const val = parseInt(value, 10);\n    \n    if (isNaN(val)) {\n      throw new BadRequestException('Validation failed');\n    }\n    \n    return val;\n  }\n}\n```\n\nIci on récupère une chaîne de caractères que nous tentons de **transformer** en nombre. Si la chaîne de caractères contient autre chose que des chiffres, on fait échouer la **validation**.\n\nVoilà l'utilisation de ce Pipe, associé à un paramètre d'une route :\n\n```javascript\n@Get(':id')\nasync findOne(@Param('id', ParseIntPipe) id: number): Cat {\n  return this.catsService.findOne(id);\n}\n```\n\n## Le Controller\n\nEt nous voilà au coeur du traitement de notre requête. Nous ne perdrons pas de temps ici à expliquer tout ce qu'est capable de faire un Controller en NestJS car ce n'est pas l'objet de cet article.\n\nMais voilà un exemple d'un Controller appelé dans la lignée de nos exemples précédents :\n\n```javascript\n@Get('admin/some-secret-route')\n@UseGuards(AdminRoleGuard)\nasync findOne(): User {\n  return this.adminService.somePrivateData();\n}\n```\n\n<div  class=\"admonition important\"  markdown=\"1\"><p  class=\"admonition-title\">Important</p>\n\nAvec l'annotation `@UseGuards()`, on utilise également un Guard (celui que nous avons écrit plus haut) au niveau de la route. Ainsi, nous sommes sûrs que l'utilisateur qui appelle cette route est bien un administrateur.\n</div>\n\nNous n'irons pas plus loin dans le traitement de la **requête**, sachez juste qu'habituellement un Controller appelle un service, à l'intérieur duquel se trouve la logique métier, et les appels éventuels aux Repositories, où résident la connexion à la base de données.\n\n> Votre mantra : quoiqu'il arrive, votre Controller doit récupérer une requête, et retourner une réponse.\n\n## Les Exception filters\n\n<div  class=\"admonition info\"  markdown=\"1\"><p  class=\"admonition-title\">Niveaux de déclaration possibles</p>\n\n- Global\n- Controller\n- Route\n</div>\n\n\nLes Exception Filters permettent de `catch` les exceptions que vous déclenchez dans votre code, pour les transformer en messages d'erreur lisibles dans la réponse du serveur.\nNestJS fournit par défaut un Exception Filter **global** qui récupère toutes les Exceptions de type `HttpException`. \n\nC'est-à-dire que vous pouvez par exemple faire ceci dans un Controller :\n\n```javascript\n@Get('some-admin-route')\nasync adminRoute(): any {\n  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);\n}\n```\n\nEt par défaut, NestJS génèrera une réponse JSON reprenant le code d'erreur `403` d'une exception Forbidden.\n\nLa plupart du temps vous n'avez donc par à créer d'Exception Filter custom, vu qu'une bonne pratique est de renvoyer des erreurs HTTP pour des applications REST ou encore GraphQL ; et donc Nest s'en occupera pour vous.\n\nMais voici tout de même un court exemple de ce à quoi ressemble la définition d'un Exception Filter :\n\n```javascript\n@Catch(HttpException)\nexport class CustomExceptionFilter implements ExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    // handle exception\n  }\n}\n```\n\nL'annotation `@Catch()` permet de spécifier quelle exception vous souhaitez \"écouter\".\n\nLe deuxième argument de la fonction `catch()` est un objet de type `ArgumentHost`. Cet objet contient tout le contexte d'exécution ; vous pouvez y retrouver notamment la **requête** et la **réponse**. C'est surtout cette dernière qui vous intéresse, pour par exemple y ajouter un message relatif à l'exception récupérée.\n\n## Conclusion\n\nVous savez à présent à peu près tout sur le cycle de vie d'une requête en NestJS. Le but était surtout de donner une meilleure vue d'ensemble de ces différentes étapes, de leur **ordre** d'exécution, et de leur utilité. Mais si vous voulez en savoir plus sur **comment** les implémenter, à différents niveaux (module, controller, route...), n'hésitez pas à vous référer à la [documentation officielle de NestJS](https://docs.nestjs.com).\n\nÀ très bientôt 👋\n"}