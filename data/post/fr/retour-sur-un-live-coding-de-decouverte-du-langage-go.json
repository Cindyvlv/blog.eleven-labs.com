{"date":"2017-08-23T00:00:00.000Z","title":"Retour sur un live-coding de découverte du langage Go","excerpt":"Cet article fait suite à un workshop / live-coding que j'ai eu l'occasion d'organiser chez Eleven Labs pour une initiation au langage Go.","readingTime":"10mn","authors":["vcomposieux"],"categories":[],"content":"\nCet article fait suite à un workshop / live-coding que j'ai eu l'occasion d'organiser chez Eleven Labs pour une initiation au langage Go.\n\nLes workshops sont pour moi le meilleur moyen d'entrer dans un sujet technique que l'on ne maîtrise pas encore. Ils permettent une pratique concrète du sujet, tout en étant accompagné par une personne (pas forcémment experte sur le sujet) qui a déjà été confrontée au sujet, qui a travaillé son workshop et qui saura donc vous donner les billes nécessaires pour bien commencer.\n\nDéfinition du sujet\n-------------------\n\nL'objectif premier de ce workshop était de permettre aux participants (la plupart n'ayant jamais écrit une ligne de Go) de sortir de ces trois heures de live-coding en ayant appris la logique du langage ainsi qu'en sachant maîtriser ses concepts.\n\nIl fallait alors trouver un sujet qui permette de pratiquer tous ces concepts, qui puisse paraître complexe au début mais qui en fait soit rapidement développé. Après un temps de réflexion, j'ai donc choisi de partir sur un cas concret que chaque développeur participant au workshop pourra un jour trouver utile au niveau web : un worker (ou message queue) en Go.\n\nPrésentation de WorkMQ\n----------------------\n\nWorkMQ est le nom de code du projet (ou plutôt de la librairie) développé durant ce workshop.\n\nL'idée est simple :\n\n* L'application doit pouvoir recevoir des messages en entrée, et chaque message doit appartenir à une `Queue` (file d'attente),\n* L'application doit pouvoir traiter ces messages en permettant de mettre à disposition de chaque queue un nombre donné de `Workers` (processus de traitement),\n* L'application doit pouvoir fournir en HTTP des statistiques sur son état actuel.\n\nAvant de rentrer dans les détails, voici un schéma expliquant le fonctionnement de notre librairie :\n\n![WorkMQ Schema](/imgs/posts/2017-08-23-retour-sur-un-live-coding-de-decouverte-du-langage-go/schema.jpg)\n\nComme vous pouvez le voir sur ce diagramme, nous avons ici quatre `Queues` de définies, et chacune d'entre elles dispose de trois `Workers`.\n\nNotre librairie (`WorkMQ`, ici le point central), fournira un [Channel (au sens du langage Go)](https://golang.org/ref/spec#Channel_types){:rel=\"nofollow noreferrer\"} dans lequel seront stockés les messages de la queue correspondante qui seront dépilés par le premier worker disponible.\n\nConfiguration\n-------------\n\nLoin d'être le meilleur moyen de gérer la configuration d'une application, le fichier `json` reste une des manières simple qui permet d'écrire les premières lignes de Go tout en permettant de comprendre les principes de base du langage.\n\nPour lire la configuration (écrite donc dans un fichier JSON) et la transformer sous forme de `struct` (structures) Go, nous avons commencé par définir la structure de données de notre configuration de la manière suivante :\n\n```json\n{\n  \"ports\": {\n    \"udp\": \":10001\",\n    \"http\": \":8080\"\n  },\n  \"queues\": {\n    \"queue.1s\": {\n      \"processor\": \"processor.logger.1s\",\n      \"num_workers\": 150\n    },\n    \"queue.2s\": {\n      \"processor\": \"processor.logger.2s\",\n      \"num_workers\": 200\n    }\n  }\n}\n```\n\nSimple et efficace, celle-ci nous permet de définir les ports `UDP` (pour l'envoi des messages) et `HTTP` (pour l'export de statistiques) ainsi que les noms de nos `queues` et les identifiants des `processor` associés. Nous reviendrons sur les processors un peu plus tard.\n\nCe qui est intéressant et que nous allons également pouvoir contrôler ici est, pour chaque `queue`, le nombre de workers que nous souhaitons voir disponibles.\n\nCôté Go, nous avons commencé par importer les librairies nécessaires, ici, que des packages natifs, ce qui m'a permis d'expliquer rapidement le concept d'import de librairies internes mais aussi externes ainsi que que la logique de namespaces en répertoires dans un projet :\n\n```go\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n)\n```\n\nPuis, nous avons donc défini les `struct` associées à chaque élément de configuration JSON :\n\n```go\n// Config is the configuration type definition.\ntype Config struct {\n\tPorts  PortsConfig            `json:\"ports\"`\n\tQueues map[string]QueueConfig `json:\"queues\"`\n}\n\n// PortsConfig is the \"port\" configuration section type definition.\ntype PortsConfig struct {\n\tUDP  string `json:\"udp\"`\n\tHTTP string `json:\"http\"`\n}\n\n// QueueConfig is the \"queues\" configuration section type definition.\ntype QueueConfig struct {\n\tProcessor  string `json:\"processor\"`\n\tNumWorkers int    `json:\"num_workers\"`\n}\n```\n\nJusque là, rien de particulier si ce n'est se familiariser avec le typage des données et la notation.\n\nIl était maintenant temps d'écrire notre première `fonction` en Go, pour lire le fichier `config.json` à la racine du projet et importer les données de JSON vers Go :\n\n```go\nfunc GetConfig() Config {\n\tfile, _ := os.Open(\"./config.json\")\n\tdecoder := json.NewDecoder(file)\n\n\tconfig := Config{}\n\terr := decoder.Decode(&config)\n\n\tif err != nil {\n\t\tfmt.Println(\"An error occurs on configuration loading:\", err)\n\t}\n\n\treturn config\n}\n```\n\nIl est important ici de discuter avec les participants de la gestion d'erreur, des possibles plusieurs éléments de retour, de la déclaration de variables avec assignation directe, bref, beaucoup d'éléments à assimiler dans cette petite fonction.\n\nLe coeur de notre librairie\n---------------------------\n\nLa configuration prête à être exploitée, nous avons pu commencer à mettre en place le coeur de notre librairie. L'occasion d'introduire la notion de pointeurs, quand et comment les utiliser.\n\nNous avons donc écrit la structure de données ainsi que la fonction d'initialisation de notre librairie :\n\n```go\ntype Workmq struct {\n\tConfig     Config\n\tQueues     map[string]chan Message\n\tProcessors map[string]Processor\n\tCounters   RateCounters\n\tWorkers    []Worker\n\tWg         sync.WaitGroup\n}\n\n// Init initializes processor part\nfunc Init() *Workmq {\n\tconfig := GetConfig()\n\tprocessors := make(map[string]Processor)\n\tqueues := make(map[string]chan Message)\n\n\tcounters := RateCounters{\n\t\t\"sent\": ratecounter.NewRateCounter(1 * time.Second),\n\t}\n\n\treturn &Workmq{\n\t\tConfig:     config,\n\t\tQueues:     queues,\n\t\tProcessors: processors,\n\t\tCounters:   counters,\n\t}\n}\n```\n\nDans ce bout de code qui initialise un pointeur de structure `Workmq`, la plupart des sujets que je souhaitais traiter sont à expliquer :\n* La structure globale de `Workmq` (config, queues, processors, workers, counters, ...),\n* La notion de `channels`,\n* La notion de synchronisation (attente) des `goroutines` lorsque nous exploitons un `channel` à l'intérieur.\n\nEn bref, le gros du sujet et des principes les plus intéressants du langage sont expliqués dans cette partie.\n\nLes workers (partie intégrante du coeur)\n----------------------------------------\n\nLe type de structure `Worker` est en effet partie intégrante de notre librairie. Un worker va :\n* Se voir associer à une `queue` (comme défini dans la configuration),\n* Se voir associer un `Processor` (comme défini dans la configuration) pour traiter les messages de cette `queue`,\n* Récupérer le `channel` de messages pour traiter les messages arrivants,\n* Et enfin, récupérer une instance de `RateCounter`, une librairie externe que nous utilisons pour calculer le nombre de messages traités à la seconde.\n\nVoici la définition de nos workers :\n\n```go\npackage workmq\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/paulbellamy/ratecounter\"\n)\n\n// Worker struct\ntype Worker struct {\n\tID        int\n\tQueue     string\n\tMessage   <-chan Message\n\tProcessor Processor\n\tCounter   *ratecounter.RateCounter\n}\n\n// NewWorker creates a new Worker instance\nfunc NewWorker(id int, queue string, processor Processor, message <-chan Message, counter *ratecounter.RateCounter) Worker {\n\treturn Worker{ID: id, Queue: queue, Processor: processor, Message: message, Counter: counter}\n}\n\n// Process listens for a processor on the worker.\nfunc (w *Worker) Process() {\n\tfmt.Printf(\"-> Worker %d ready to process queue \\\"%s\\\"...\\n\", w.ID, w.Queue)\n\n\tfor message := range w.Message {\n\t\tw.Counter.Incr(1)\n\t\tw.Processor(w, message)\n\t}\n}\n```\n\nLa première chose importante à retenir, est que la notation `func (w *Worker) Process() {` permet à cette méthode `Process()` d'être appelée uniquement sur un type de structure `Worker`.\n\nEnsuite, la notion intéressante à expliquer ici également est la notation des `channel` :\n* `<-chan` : signifie que le channel sera utilisé en lecture uniquement,\n* `chan<-` : signifie que le channel sera utilisé pour recevoir des données uniquement.\n\nEnfin, vous pouvez également faire un tour sur les boucles `for` et leurs notations avec `range`.\n\nLes processors (partie intégrante du coeur)\n-------------------------------------------\n\nRien de très nouveau par rapport aux workers lors de la déclaration de nos processors alors je me suis servi de cette structure pour présenter la gestion d'erreurs en Go ainsi que les notations et mots clés utiles pour ajouter et supprimer des éléments d'un tableau :\n\n```go\npackage workmq\n\nimport \"fmt\"\n\n// Processor type\ntype Processor func(worker *Worker, message Message)\n\n// AddProcessor adds a processor into the processors list\nfunc (w *Workmq) AddProcessor(name string, processor Processor) {\n\tw.Processors[name] = processor\n}\n\n// GetProcessor retrieves a processor from its name\nfunc (w *Workmq) GetProcessor(name string) (Processor, error) {\n\tif _, ok := w.Processors[name]; !ok {\n\t\treturn nil, fmt.Errorf(\"Unable to find processor '%s'\", name)\n\t}\n\n\treturn w.Processors[name], nil\n}\n\n// RemoveProcessor removes a processor from its name\nfunc (w *Workmq) RemoveProcessor(name string) {\n\tdelete(w.Processors, name)\n}\n```\n\nLes notions à expliquer ici étaient :\n-les notations `if _, ok := w.Processors[name]; !ok` qui permettent de rentrer dans la condition en cas d'erreur (`!ok`) ou non (`ok`) --comment utiliser `nil` et `error` pour retourner notre processor ou aucun, mais tout de même retourner une erreur si le cas se présentait de ne pas disposer du processor demandé.\n\nAussi, vous noterez la notation `delete(w.Processors, name)` qui permet de supprimer un élément d'une `map`.\n\nToutes ces petites choses ne paient pas de mine mais sont intéressantes à apprendre lorsque vous découvrez le langage Go. Sinon, vous allez devoir aller fouiller dans la documentation à chaque fois pour savoir comment l'écrire.\n\nLa réception en UDP et l'exposition en HTTP\n-------------------------------------------\n\nVoilà, tout était prêt et nous n'avions plus qu'à recevoir nos messages (en UDP) et exposer (en HTTP) nos statistiques d'utilisation de la librairie.\n\nAinsi, nous avons deux `goroutines` qui tournent afin d'écouter sur les deux ports :\n\n```go\ngo w.ListenUDP()\ngo w.ListenHTTP()\n```\n\nCommençons par la réception de messages en UDP :\n\n```go\n// ListenUDP creates a UDP server that listens for new messages\nfunc (w *Workmq) ListenUDP() {\n\tdefer w.Wg.Done()\n\n\taddress, _ := net.ResolveUDPAddr(\"udp\", w.Config.Ports.UDP)\n\tconnection, _ := net.ListenUDP(\"udp\", address)\n\n\tdefer connection.Close()\n\n\tbuf := make([]byte, 1024)\n\n\tfor {\n\t\tn, _, _ := connection.ReadFromUDP(buf)\n\t\tw.Counters[\"sent\"].Incr(1)\n\n\t\tmessage := TransformStringToMessage(buf[0:n])\n\t\tw.Queues[message.Queue] <- message\n\t}\n}\n```\n\nLes messages reçus sont sous la forme JSON et doivent respecter la structure suivante :\n\n```json\n{\n  \"queue\": \"queue.1s\",\n  \"body\": \"This is the message that should be managed by the queue 1 second.\"\n}\n```\n\nNous écoutons donc chaque nouvel élément envoyé sur le port défini dans notre configuration et transformons le message reçu de `[]byte` en structure `Message` grâce à une fonction `TransformStringToMessage` que nous avons défini.\n\nEnfin, nous avons ajouté ce message dans le channel correspondant à la queue avec la notation `w.Queues[message.Queue] <- message`.\n\nÀ ce moment là, le message sera donc traité par le premier worker disponible dans notre pool de worker.\n\nDernière étape : l'exposition de statistiques en HTTP. De la même façon, nous écrivons donc notre fonction `ListenHTTP()` qui tourne dans une `goroutine` séparée :\n\n```go\n// ListenHTTP creates a HTTP server to expose statistics information\nfunc (w *Workmq) ListenHTTP() {\n\tdefer w.Wg.Done()\n\n\thttp.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) {\n\t\tfmt.Fprintln(writer, fmt.Sprintf(\"Sent rate: %d/s\", w.Counters[\"sent\"].Rate()))\n\n\t\tvar keys []string\n\t\tfor key := range w.Queues {\n\t\t\tkeys = append(keys, key)\n\t\t}\n\n\t\tsort.Strings(keys)\n\n\t\tfor _, key := range keys {\n\t\t\tfmt.Fprintln(writer, fmt.Sprintf(\"\\n-> %s (%d workers):\", key, w.Config.Queues[key].NumWorkers))\n\t\t\tfmt.Fprintln(writer, fmt.Sprintf(\"\tAcknowledge: %d/s\", w.Counters[key].Rate()))\n\t\t\tfmt.Fprintln(writer, fmt.Sprintf(\"\tMessages: %d\", len(w.Queues[key])))\n\t\t}\n\t})\n\n\terr := http.ListenAndServe(w.Config.Ports.HTTP, nil)\n\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe error: \", err)\n\t}\n}\n```\n\nNous avons ici bouclé sur toutes les queues et affichons les données des compteurs en sortie. Rien de vraiment sorcier par rapport à ce que nous avons déjà appris précédemment.\n\nPour vous aider à visualiser le résultat, voici la sortie HTTP :\n\n![HTTP Output](/imgs/posts/2017-08-23-retour-sur-un-live-coding-de-decouverte-du-langage-go/output.gif)\n\nConclusion\n----------\n\nAvant tout, le code de la librairie est disponible en open-source ici : [https://github.com/unikorp/workmq](https://github.com/unikorp/workmq){:rel=\"nofollow noreferrer\"}.\n\nPour ce live-coding / workshop, j'avais deux objectifs :\n* Permettre à mes participants de ressortir de la session en ayant écrit une librairie open-source complète et fonctionnelle,\n* Permettre à mes participants de découvrir la plupart des fonctionnalités principales du langage Go afin de leur permettre de développer dès le lendemain en Go s'ils le souhaitaient.\n\nJe pense que le contrat est rempli avec ce projet et j'espère qu'il vous servira pour découvrir Go vous-même ou le faire découvrir à vos collègues.\n\nN'hésitez pas à contacter Eleven Labs ou à me contacter directement si vous souhaitez organiser des sessions de workshop sur des technologies.\n"}