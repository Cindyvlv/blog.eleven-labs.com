{"date":"2020-08-12T00:00:00.000Z","title":"Deno Vs Node - Top 5 des nouveautés de Deno","excerpt":"Dans cet article, nous allons voir quelques nouveautés offertes par Deno","readingTime":"4mn","authors":["plerouge"],"categories":["javascript"],"content":"\nLe créateur de NodeJS, Ryan Dahl, a publié un nouveau runtime qui vise à résoudre de nombreuses lacunes de Node.\nVotre première réaction pourrait être « Oh super, un autre framework Javascript ? Juste ce dont j'avais besoin… ».\nNe vous inquiétez pas, j’ai eu la même réaction.\nAprès avoir compris les avantages, j'ai également vu pourquoi Deno est exactement ce dont un développeur Javascript back-end a besoin en 2020.\nJetons un coup d'œil aux 5 principales nouveautés qu'offre Deno aux développeurs JavaScript.\n\n## 1. Du Javascript moderne (ES Modules)\n\n![](/imgs/posts/2020-08-12-deno-vs-node/modern.png)\n\nSi vous êtes un développeur React, vous avez remarqué que la syntaxe d'importation des packages est différente lorsque vous travaillez avec NodeJS.\nEn effet, Node a été créé en 2009, il y a eu de nombreuses mises à jour et améliorations de Javascript depuis lors.\n\nDans React (et Deno), nous utilisons la syntaxe moderne :\n\n```\nimport package from 'package'\n```\n\ntandis que dans Node, nous utilisons la syntaxe :\n\n```\nconst package = require (\"package\").\n```\n\nL'importation des modules ES est plus performante pour deux raisons :\n\n  - Avec l'importation, vous pouvez charger de manière sélective uniquement les parties dont vous avez besoin à partir d'un package, ce qui économise de la mémoire.\n  - Le chargement est **synchrone** avec *require* tandis que *import* charge les modules de manière **asynchrone**, ce qui améliore les performances.\n\nSi vous avez bien remarqué, dans l'image ci-dessus nous importons le package **moment** à partir d'une URL, ce qui nous amène au prochain avantage de Deno.\n\n## 2. Packages décentralisés\n\nAvec Deno, vous n'êtes plus dépendant de NPM.\nC'est vrai, plus de *package.json*.\nChaque package est chargé à partir d'une URL.\nDans NodeJS, pour utiliser un package, vous devez d'abord l'installer à partir de NPM :\n\n```\nnpm i moment\n```\n\nAttendez qu'il s'installe, puis incluez-le dans votre application :\n\n```\nconst moment = require(\"moment\")\n```\n\nDe plus, chaque fois que quelqu'un souhaite exécuter votre dépôt NodeJS localement, il doit installer toutes les dépendances de NPM.\nDans Deno, le package est importé à partir d'une URL, donc si vous voulez utiliser moment, vous importez simplement [https://deno.land/x/moment/moment.ts](https://deno.land/x/moment/moment.ts).\n\n![](/imgs/posts/2020-08-12-deno-vs-node/moment.jpeg)\n\nUn autre énorme avantage en ce qui concerne les packages dans Deno,\nc'est que **chaque package est mis en cache sur le disque dur après l'installation**.\nCela signifie que l'installation d'un package n'a lieu qu'une seule fois.\nSi vous souhaitez importer à nouveau la dépendance, n'importe où, il ne sera pas nécessaire de la télécharger.\n\n## 3. Await en top level : Utiliser Await en dehors d'une fonction asynchrone\n\n![](/imgs/posts/2020-08-12-deno-vs-node/await.png)\n\nDans Node, le mot clé *await* n'est accessible que dans une fonction asynchrone.\nAvec Deno, vous pouvez l'utiliser n'importe où, sans l'encapsuler dans une fonction asynchrone.\nPresque toutes les applications Javascript incluent de nombreuses fonctions asynchrones.\nCette mise à niveau rend le code beaucoup plus propre et simple.\n\n## 4. TypeScript natif, aucune configuration nécessaire\n\n![](/imgs/posts/2020-08-12-deno-vs-node/type.jpeg)\n\nFaire fonctionner TypeScript avec NodeJS est un processus en plusieurs étapes.\nVous devez installer Typescript, mettre à jour package.json, tsconfig.json et vous assurer que vos modules prennent en charge @types.\nDans Deno, tout ce que vous avez à faire est d'enregistrer votre fichier avec l'extension .ts au lieu de .js, **le compilateur TypeScript est déjà intégré**.\n\n## 5. Accès à l'API navigateur (Window, Fetch)\n\nPour éxécuter des requêtes HTTP en javascript, nous pouvons utiliser l'API Fetch.\nDans NodeJS, nous n'avons pas accès à l'API du navigateur, nous ne pouvons donc pas appeler nativement une fonction de récupération de données.\n\nIl faut d'abord installer le package :\n\n```\nnpm i node-fetch\n```\n\nEnsuite nous importons le package :\n\n```\nconst fetch = require(\"node-fetch\")\n```\n\nEt ce n'est qu'alors que nous pouvons faire un appel de récupération.\nDeno a nativement accès à l'objet window, ce qui signifie que vous pouvez simplement appeler *fetch (\"https://something.com\")*\nainsi que tout autre élément dans l'API du navigateur sans installer de librairies.\n\nLorsqu'il est combiné avec l'avantage top level d'*await*,\nvous pouvez maintenant voir à quel point le code Deno est plus simple que le code Node :\n\n![](/imgs/posts/2020-08-12-deno-vs-node/api.jpeg)\n\n## Ça ne s'arrête pas là\n\nDeno a de nombreux autres avantages, comme être plus sécurisé par défaut. Vous pouvez exécuter des binaires WebAssembly, il a de nombreuses librairies intégrées... et la liste est longue.\n\nTous les points mentionnés dans cet article sont interconnectés, se réunissant pour former un runtime javascript back-end 2020 plus moderne.\n\nDeno remplacera-t-il finalement Node ? Peut-être, peut-être pas. Cela prendra probablement plusieurs années.\nL'écosystème NodeJS est énorme, il faudra du temps à Deno pour le rattraper.\nMais les développeurs Javascript ont récemment privilégié Deno pour leurs nouveaux projets, donc si vous cherchez à démarrer un nouveau projet bientôt, cela vaut vraiment la peine d'être examiné.\nPour plus d'informations sur la façon de commencer, visitez [https://deno.land/](https://deno.land).\n"}