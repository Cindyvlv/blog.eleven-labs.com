{"date":"2017-12-22T00:00:00.000Z","title":"Optimiser son application React","excerpt":"React est, à l'heure où j'écris ces lignes, le framework JavaScript le plus utilisé du marché. Grâce à son DOM virtuel, il a montré qu'il était l'un des plus performant. Mais à cause d'exemples peut-être trop simples et d'une croyance aveugle en la toute puissance de React, il peut en résulter de sérieux problèmes de performance.","readingTime":"16mn","authors":["mlenglet"],"categories":["javascript"],"content":"\n[React](https://reactjs.org/){:rel=\"nofollow\"} est, à l'heure où j'écris ces lignes, le framework JavaScript le plus utilisé du marché. Grâce à son DOM virtuel, il a montré qu'il était l'un des plus performant. Mais à cause d'exemples peut-être trop simples et d'une croyance aveugle en la \"toute puissance\" de React (Amen), il peut en résulter de sérieux problèmes de performance.\n\n## Le problème\n\nPrenons l'exemple d'une application assez simple et commune. On réalise un back-office permettant de gérer les différents articles sur un blog. Cela consiste donc, dans un premier temps, à simplement afficher un tableau de données.\n\nVous vous exécutez donc et pensant avoir fini vous constatez ceci :\n\n![Exemple d'application lente]({{site.baseurl}}/assets/2017-12-22-optimiser-son-application-react/slow-app.gif)\n\n> MéKéCéCéCeBordel ?!\n\nVotre application est lente et peu réactive (un comble pour du React...).\nAllons faire un petit tour dans la console de Chrome à l'onglet Timeline. Ici on va pouvoir capturer tout ce qui se passe au niveau code, mémoire et rendu pendant un laps de temps donné.\nAprès quelques bidouilles, voici ce qu'on obtient :\n\n![Flamegraph de l'application]({{site.baseurl}}/assets/2017-12-22-optimiser-son-application-react/slow-app-flamegraph.png)\n\nAlors au premier abord, ça peut être un peu repoussant mais c'est en fait très simple. Sur ce \"FlameGraph\", on peut voir que lorsque l'utilisateur a cliqué, ce n'est pas seulement les lignes de notre tableau qui se sont redessinées mais toute l'application ! En bref, à chaque changement de `state` dans votre application, vous réinitialisez compètement cette dernière à zéro comme si vous étiez au tout premier rendu de la page.\n\n> Mais React n'est pas censé faire un différentiel intelligent avec son DOM virtuel avant de modifier réellement le DOM ?\n\nAlors si, mais React n'est pas si intelligent que ça... Il faut lui donner un peu la main.\n\n## Les solutions\n\nEn effet, React n'est pas magique. Il faut lui indiquer vous-même quand effectuer un rendu et comment.\n\n### Découper ses composants\n\nUne première étape pour l'optimisation sera de découper intelligemment ses composants. Vous savez sûrement que React fonctionne sur le principe d'avoir le plus possible de composants réutilisables de taille assez réduite voire atomique.\nPrenons l'exemple du code ci-dessous :\n\n```jsx\n// in Datagrid.js\nrender() {\n  const {resource, childre, ids, data, currentSort} = this.props;\n  return (\n    <table>\n      <thead>\n        <tr>\n          {React.Children.map(children, (field, index) => (\n            <DatagridHeaderCell\n              key={index}\n              field={field}\n              currentSort={currentSort}\n              updateSort={this.updateSort}\n            />\n          ))}\n        </tr>\n      </thead>\n      <tbody>\n        {React.Children.map(children, (field, index) => (\n          <DatagridCell\n            record={data[id]}\n            key={`${id}-${index}`}\n            field={field}\n            resource={resource}\n          />\n        ))}\n      </tbody>\n    </table>\n  );\n}\n```\n\nCela semble être une implémentation très simple d'un tableau de données, mais elle est particulièrement inefficace.\nChaque appel `<DatagridCell>` affiche au moins deux ou trois composants. Comme vous pouvez le voir dans le screencast de l'interface initiale, la liste a 7 colonnes, 11 lignes, ce qui signifie 7x11x3 = 231 composants référencés. Quand seul le `currentSort` change, c'est une perte de temps. Même si React ne met pas à jour le DOM réel si le DOM virtuel est inchangé, il faut environ 500 ms pour traiter tous les composants.\n\nAfin d'éviter un rendu inutile du body de la table, il faut d'abord l'extraire :\n\n```jsx\n// in Datagrid.js\nrender() {\n  const {resource, childre, ids, data, currentSort} = this.props;\n  return (\n    <table>\n      <thead>\n        <tr>\n          {React.Children.map(children, (field, index) => (\n            <DatagridHeaderCell\n              key={index}\n              field={field}\n              currentSort={currentSort}\n              updateSort={this.updateSort}\n            />\n          ))}\n        </tr>\n      </thead>\n      <DatagridBody resource={resource} ids={ids} data={data}>\n        {children}\n      </DatagridBody>\n    </table>\n  );\n}\n```\n\n```jsx\n// in DatagridBody.js\nimport React from 'react';\n\nconst DatagridBody = ({ resource, ids, data, children }) => (\n    <tbody>\n      {ids.map(id => (\n        <tr key={id}>\n          {React.Children.map(children, (field, index) => (\n            <DatagridCell\n              record={data[id]}\n              key={`${id}-${index}`}\n              field={field}\n              resource={resource}\n            />\n          ))}\n        </tr>\n      ))}\n    </tbody>\n);\n\nexport default DatagridBody;\n```\n\nL'extraction du body de la table n'a aucun effet sur les performances, mais elle facilitera l'optimisation. Les gros composants à usage général sont difficiles à optimiser. Les petits composants à une seule responsabilité sont beaucoup plus faciles à gérer.\n\n### shouldComponentUpdate\n\nLa documentation React est très claire sur la façon d'éviter les répétitions inutiles: `shouldComponentUpdate()`. Par défaut, React restitue toujours un composant au DOM virtuel. En d'autres termes, c'est votre travail en tant que développeur de vérifier que les `props` ou le `state` d'un composant n'ont pas changé et d'ignorer complètement le rendu dans ce cas.\n\nDans le cas du composant `<DatagridBody>` ci-dessus, il ne devrait pas y avoir de rendu supplémentaire du BO sauf si les `props` ont changé.\n\nDonc le composant devrait être complété comme suit :\n\n```jsx\n// in DatagridBody.js\nimport React, {Component} from 'react';\n\nclass DatagridBody extends Component {\n  shouldComponentUpdate(nextProps) {\n      return (nextProps.ids !== this.props.ids || nextProps.data !== this.props.data);\n  }\n\n  render() {\n    const { resource, ids, data, children } = this.props;\n    return (\n        <tbody>\n          {ids.map(id => (\n            <tr key={id}>\n              {React.Children.map(children, (field, index) => (\n                <DatagridCell\n                  record={data[id]}\n                  key={`${id}-${index}`}\n                  field={field}\n                  resource={resource}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n    );\n  }\n}\n\nexport default DatagridBody;\n```\n\nAvec cette optimisation, le re-rendu du composant `<Datagrid>` après avoir cliqué sur un des headers de la table ignore entièrement le body et ses 231 composants. Cela réduit le temps de mise à jour de 500ms à 60ms. C'est une amélioration nette des performances de plus de 400ms !\n\n### PureComponent\n\nAu lieu d'implémenter manuellement `shouldComponentUpdate()`, une solution est d'hériter de `PureComponent` au lieu de `Component`. Quand la méthode `shouldComponentUpdate` par défaut de `Component` retourne systématiquement `true`, celle de `PureComponent` effectue une comparaison des `props` en utilisant une égalité stricte (`===`) :\n\n```jsx\n// in DatagridBody.js\nimport React, {PureComponent} from 'react';\n\nclass DatagridBody extends PureComponent {\n  render() {\n    const { resource, ids, data, children } = this.props;\n    return (\n        <tbody>\n          {ids.map(id => (\n            <tr key={id}>\n              {React.Children.map(children, (field, index) => (\n                <DatagridCell\n                  record={data[id]}\n                  key={`${id}-${index}`}\n                  field={field}\n                  resource={resource}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n    );\n  }\n}\n\nexport default DatagridBody;\n```\n\nCela a l'avantage de faire gagner du temps mais il faut faire attention à son implémentation :\n- Son utilisation n'est pas toujours justifiée, dans le cas de l'exemple ci-dessus (un tri de table), `resource` et `children` ne seraient pas concernés. Effectuer un test sur ces `props` serait donc inutile et une implémentation manuelle de `shouldComponentUpdate` plus appropriée.\n- Du fait de l'égalité stricte (`===`), vous ne pourrez pas utiliser efficacement `PureComponent` si vos `props` sont des objets ou des tableaux. La comparaison se faisant en adresse pour ces structures, il faudrait tester via une implémentation manuelle de `shouldComponentUpdate`. Une solution alternative et beaucoup plus intelligente est de ne plus utiliser d'objets et tableaux JavaScript mais d'utiliser à la place des structures [Immutable.js](https://facebook.github.io/immutable-js/){:rel='nofollow'}.\n\n### Se servir du workflow\n\nUne bonne façon d'optimiser son code est d'éviter tout calcul lourd ou inutile dans la méthode `render`. La solution est d'utiliser le workflow de React pour parvenir à nos fins. Dans l'exemple ci-dessous, on a une liste d'utilisateurs qui peuvent éventuellement être filtrés via un champ de recherche.\n\nOn ne veut rendre que si la liste des utilisateurs après filtrage a changé et pas constamment :\n- Si un utilisateur n'est plus dans la liste complète mais qu'il faisait déjà partie des utilisateurs filtrés, on ne veut pas rendre.\n- Si, bien que la valeur dans le champ de recherche soit différente, le résultat reste le même, on ne veut pas rendre.\n\nOn va donc implémenter la méthode `componentWillReceiveProps` pour y vérifier si les `props` `users` et `search` ont changé et, le cas échéant, recalculer la nouvelle liste d'utilisateurs filtrée que nous stockerons dans le `state`.\n\nLa méthode `shouldComponentUpdate` nous assurera que nous ne re-rendons le composant que si cette liste filtrée a effectivement changé.\n\n```jsx\nimport React, {Component} from 'react';\nimport PropTypes from 'prop-types';\nimport {List} from 'immutable';\n\nfunction getFilteredUsers(users, search) {\n  // retourne une nouvelle liste immutable d'utilisateurs filtrés\n};\n\nclass UsersPage extends Component {\n  static propTypes = {\n    search: PropTypes.string,\n    users: PropTypes.instanceOf(List).isRequired,\n  };\n\n  static defaultProps = {\n    search: null,\n  };\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      filteredUsers: getFilteredUsers(props.users, props.search),\n    };\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.users !== this.props.users || nextProps.search !== this.props.search) {\n      const filteredUsers = getFilteredUsers(nextProps.users, this.props.search);\n      this.setState({ filteredUsers });\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return nextState.filteredUsers !== this.state.filteredUsers;\n  }\n\n  render() {\n    return (\n      <TableBody>\n        {this.state.filteredUsers.map((user) => <UserRow key={user.get('id')} user={user} />)}\n      </TableBody>\n    )\n  }\n}\n\nexport default UsersPage;\n```\n\n### Attention aux objets en JSX\n\nUne fois que vos composants deviennent plus \"purs\", vous commencez à détecter les mauvais modèles qui mènent à des répétitions inutiles. Le plus commun est la déclaration directe d'objets dans JSX (le fameux `{{`). Petit exemple :\n\n```jsx\nimport React from 'react';\nimport MyTableComponent from './MyTableComponent';\n\nconst Datagrid = (props) => (\n    <MyTableComponent style={{ marginTop: 10 }}>\n        ...\n    </MyTableComponent>\n)\n```\n\nLe style du composant `<MyTableComponent>` reçoit une nouvelle valeur chaque fois que le composant `<Datagrid>` est rendu. Donc, même si `<MyTableComponent>` est pur, il sera rendu à chaque fois que `<Datagrid>` est rendu. En fait, chaque fois que vous transmettez un objet littéral en tant que `prop` à un composant enfant, vous cassez la pureté. La solution est simple :\n\n```jsx\nimport React from 'react';\nimport MyTableComponent from './MyTableComponent';\n\nconst tableStyle = { marginTop: 10 };\nconst Datagrid = (props) => (\n    <MyTableComponent style={tableStyle}>\n        ...\n    </MyTableComponent>\n)\n```\n\nEn créant l'objet au préalable, vous vous assurez que ce dernier ne soit pas considéré comme changé par le composant `<MyTableComponent>`.\n\n### Le piège des \"stateless functions\"\n\nUne petite parenthèse sur les \"stateless functions\". Comme vous l'avez sûrement remarqué précédemment, nous avons systématiquement déclaré des classes pour gérer l'optimisation de nos composants car il n'y a pas moyen d'implémenter la méthode `shouldComponentUpdate` sur une simple fonction.\n\n> J'imagine qu'il doit y avoir une optimisation spécifique pour les \"stateless functions\", non ?\n\nEh bien... non. C'est prévu mais à l'heure où j'écris ces lignes, rien n'a été fait. Une \"stateless function\" est transpilée en une classe à la compilation...\n\n![Commentaire sur github confirmant le problème des stateless functions]({{site.baseurl}}/assets/2017-12-22-optimiser-son-application-react/stateless-function-github.png)\n\nAinsi il est plutôt conseillé d'utiliser des `Component` ou `PureComponent`, car vous pouvez y maîtriser le workflow.\nVous pouvez jeter un coup d'oeil à cet article pour de plus amples informations : [\"7 reasons to outlaw React's functional components\"](https://medium.freecodecamp.org/7-reasons-to-outlaw-reacts-functional-components-ff5b5ae09b7c){:rel=\"nofollow\"}\n\nAinsi si vous vouliez réaliser un composant \"statique\" qui rend systématiquement la même chose, vous devrez transformer cette fonction :\n\n```jsx\nfunction ResetButton(props) {\n  return (\n    <IconButton>\n      <NavigationClose />\n    </IconButton>\n  );\n}\n```\n\nEn cette classe :\n\n```jsx\nclass ResetButton extends React.Component {\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  render() {\n    return (\n      <IconButton>\n        <NavigationClose />\n      </IconButton>\n    );\n  }\n}\n```\n\n## Détecter les besoins\n\nSi vous avez une application React de taille importante dans laquelle aucune de ces optimisations n'a été faite, le refactoring peut-être long et fastidieux. Il serait intéressant de cibler en priorité les points les plus critiques de votre appli, où vous pourriez focaliser dans un premier temps votre attention.\n\n### Extension React pour Chrome et Firefox\n\nReact-Developer-Tools, disponible pour [Chrome](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi){:rel=\"nofollow\"} et [Firefox](https://addons.mozilla.org/fr/firefox/addon/react-devtools/){:rel=\"nofollow\"} permet de débugger efficacement une application React. Elle permet d'afficher notamment dynamiquement les éléments de la page qui sont redessinés au fur et à mesure de vos interactions.\n\n### ReactOpt\n\n[ReactOpt](https://github.com/reactopt/reactopt){:rel=\"nofollow\"} est un outil d'audit puissant qui affichera un compte-rendu détaillé des performances de votre application.\n\n## Conclusion\n\nL'ensemble des techniques présentées dans cet article sont indispensables à la réalisation d'une application React rapide et réactive.\n[Redux](https://redux.js.org/){:rel=\"nofollow\"} ou encore [reselect](https://github.com/reactjs/reselect){:rel=\"nofollow\"} sont aussi des pistes que vous pouvez explorer afin d'améliorer encore cette optimisation. Mais n'oubliez pas que nous n'avons optimisé que la partie \"update\" de votre application, c'est-à-dire uniquement lorsque l'application est déjà chargée. Le premier chargement est tout aussi important si ce n'est plus, et la solution à ce problème est le SSR (Server Side Rendering). Je vous redirige donc vers l'excellent article de [Vincent](/authors/vcomposieux/) sur ce sujet : [\"Migrer une application React Client-Side en Server-Side avec NextJS\"](/fr/migrer-une-application-react-client-side-en-server-side-avec-nextjs/).\n"}