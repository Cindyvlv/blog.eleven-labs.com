{"date":"2021-10-20T00:00:00.000Z","title":"RabbitMQ, des bases Ã  la maÃ®trise (Partie 1)","excerpt":"Rabbitmq est un message broker trÃ¨s complet et robuste, c'est pourquoi le comprendre et l'utiliser est assez simple. En revanche, le maÃ®triser l'est un peu moins...","readingTime":"5mn","authors":["amoutte"],"categories":[],"content":"\nRabbitMQ est un message broker trÃ¨s complet et robuste, c'est pourquoi le comprendre et l'utiliser est assez simple. en revanche, le maÃ®triser l'est un peu moins...\nC'est pourquoi je vous propose cette sÃ©rie de deux articles. Vous pouvez retrouver la partie 2 en [cliquant ici](https://blog.eleven-labs.com/fr/rabbitmq-partie-2-la-maitrise/).\n\n> Bref, pour commencer, avant de manger du pÃ¢tÃ© de lapin il va falloir bouffer des carottes !\n\n## Introduction\n\nRabbitMQ a de nombreux points forts, ce qui en fait une solution utilisable sur tous types/tailles de projet.\n\nEn voici quelques-uns :\n\n- Utilise AMQP (courante: 0.9.1)\n- DÃ©veloppÃ© en `Erlang` ce qui en fait un logiciel trÃ¨s robuste\n- SystÃ¨me de *clustering* pour la haute disponibilitÃ© et la scalabilitÃ©\n- Un systÃ¨me de [plugins](https://www.rabbitmq.com/plugins.html) qui permet d'apporter d'autre fonctionnalitÃ©s (management, ldap, shovel, mqtt, stomp, tracing, AMQP 1.0)\n- Les vhost permettent de cloisonner des environnements (mutualiser le serveur, env dev/preprod/prod)\n- *Quality Of Service* (QOS) permet de prioriser les messages\n\n## AMQP\n\n> Ok, donc on va commencer par semer des carottes\n\nAfin de pouvoir utiliser efficacement RabbitMQ il faut comprendre le fonctionnement du protocol `AMQP`.\n\n### Le Broker\n\nRabbitMQ est un message broker, son rÃ´le est de transporter et router les messages depuis les publishers vers les consumers.\nLe broker utilise les `exchanges` et `bindings` pour savoir si il doit dÃ©livrer, ou non, le message dans la queue.\n\nVoici le fonctionnement global du `broker` :\n\n> Le `publisher` va envoyer un `message` dans un `exchange` qui va, en fonction du `binding`, router le `message` vers la ou les `queues`.\n> Ensuite un `consumer` va consommer les messages.\n\n![RabbitMQ Broker]({{site.baseurl}}/assets/2018-03-11-rabbitmq-partie-1-les-bases/rabbitmq-broker.jpg)\n\nNous allons donc dÃ©tailler les diffÃ©rents Ã©lÃ©ments qui composent le `broker`.\n\n### Le message\n\nLe message est comme une requÃªte HTTP, il contient des `attributs` ainsi qu'un `payload`.\nParmi les `attributs` du protocol vous pouvez y ajouter des `headers` depuis votre publisher.\n\n> Liste des properties du protocol\n> content_type, content_encoding, priority, correlation_id, reply_to, expiration, message_id, timestamp, type, user_id, app_id, cluster_id\n\nLes `headers` seront disponibles dans `attributes[headers]`.\n\nL'attribut `routing_key`, bien qu'optionnel, n'en est pas moins trÃ¨s utile dans le protocol.\n\n### Les Bindings\n\nLes bindings, ce sont les rÃ¨gles que les exchanges utilisent pour dÃ©terminer Ã  quelle queue il faut dÃ©livrer le message.\nLes diffÃ©rentes configurations peuvent utiliser la `routing key` (direct/topic exchanges) ainsi que les `headers`(header exchanges).\nDans le cas des `exchanges` fanout, les `queues` n'ont qu'Ã  Ãªtre bindÃ©es pour recevoir le message.\n\nNous allons dÃ©tailler leurs utilisations.\n\n### Les Exchanges\n\nUn `exchange` est un routeur de message. Il existe diffÃ©rents types de routages dÃ©finis par le type d'`exchange`.\n\n> Vous publiez dans un exchange. Vous ne consommez pas un exchange !\n\n> Important Ã  savoir : l'`exchange` `amq.default` est l'`exchange` par dÃ©faut de rabbit. Vous ne pouvez ni le supprimer ni vous binder dessus.\n\n*Cet exchange est auto bindÃ© avec toutes les `queues` avec une `routing key` Ã©gale au nom de la queue.*\n\n![RabbitMQ Exchange default]({{site.baseurl}}/assets/2018-03-11-rabbitmq-partie-1-les-bases/rabbitmq-exchange-default.jpg)\n\n### L'exchange type fanout\n\nL'`exchange` `fanout` est le plus simple. En effet il dÃ©livre le message Ã  **toutes** les queues bindÃ©es.\n\n![RabbitMQ Exchange Fanout]({{site.baseurl}}/assets/2018-03-11-rabbitmq-partie-1-les-bases/rabbitmq-exchange-fanout.jpg)\n\n### L'exchange type direct\n\nL'`exchange` `direct` n'autorise que le binding utilisant strictement la `routing key`.\n\n![RabbitMQ Exchange Direct]({{site.baseurl}}/assets/2018-03-11-rabbitmq-partie-1-les-bases/rabbitmq-exchange-direct.jpg)\n\nSi la `routing_key` du message est strictement Ã©gale Ã  la `routing_key` spÃ©cifiÃ©e dans le binding alors le message sera dÃ©livrÃ© Ã  la queue.\n\n> binding.routing_key == message.routing_key\n\n### L'exchange type topic\n\nL'`exchange` `topic` dÃ©livre le message si `routing_key` du message matche le pattern dÃ©fini dans le binding.\n\n![RabbitMQ Exchange Topic]({{site.baseurl}}/assets/2018-03-11-rabbitmq-partie-1-les-bases/rabbitmq-exchange-topic.jpg)\n\nUne `routing key` est composÃ© de plusieurs segments sÃ©parÃ©s par des `.`. Il y a Ã©galement 2 caractÃ¨res utilisÃ©s dans le matching.\n\n`*` n'importe quelle valeur de segment\n\n`#` n'importe quelle valeur de segment une ou plusieurs fois\n\nPar exemple pour la `routing key` `foo.bar.baz`\n\n- `foo.*.baz` match\n- `foo.*.*` match\n- `foo.#` match\n- `foo.#.baz` match\n- `*.*.baz` match\n- `#.baz` match\n- `#.bar.baz` match\n- `#` match\n- `foo.*` **non trouvÃ©**\n\n> match(binding.routing_key, message.routing_key)\n\n### L'exchange type headers\n\nL'`exchange` `headers` dÃ©livre le message si les `headers` du binding matchent les headers du message.\n\n![RabbitMQ Exchange Headers]({{site.baseurl}}/assets/2018-03-11-rabbitmq-partie-1-les-bases/rabbitmq-exchange-headers.jpg)\n\nL'option `x-match` dans le binding permet de dÃ©finir si **un seul** header ou **tous** doivent matcher.\n\n### x-match = any\n\nAvec le `x-match = any` le message sera dÃ©livrÃ© si un seul des headers du binding correspond Ã  un header du message.\n\n> binding.headers[attrName1] == message.headers[attrName1] `OU` binding.headers[attrName2] == message.headers[attrName2]\n\n*Le message sera dÃ©livrÃ© si le header `attrName1` (configurÃ© au moment du binding) est Ã©gal au header `attrName1` du message*\n\nOU\n\n*si le header `attrName2` est Ã©gal au header `attrName2` du message.*\n\n### x-match = all\n\nAvec le `x-match = all` le message sera dÃ©livrÃ© si **tous** les headers du binding correspondent aux headers du message.\n\n> binding.headers[attrName1] == message.headers[attrName1] `ET` binding.headers[attrName2] == message.headers[attrName2]\n\n*Ici le message sera dÃ©livrÃ© seulement si les headers `attrName1` ET `attrName2` (du binding) sont Ã©gaux aux headers `attrName1` et `attrName2` du message.*\n\n### Les Queues\n\nUne queue est l'endroit oÃ¹ sont stockÃ©s les messages. Il existe des options de configuration afin de modifier leurs comportements.\n\nQuelques options :\n\n - Durable, (stockÃ©e sur disque) la queue survivra au redÃ©marrage du broker. Attention seuls les messages *persistants* survivront au redÃ©marrage.\n - Exclusive, sera utilisable sur une seule connexion et sera supprimÃ©e Ã  la clÃ´ture de celle-ci.\n - Auto-delete, la queue sera supprimÃ©e quand toutes les connections sont fermÃ©es (aprÃ¨s au moins une connexion).\n\n> Vous publiez dans un exchange. Vous ne consommez pas un exchange !\n> (quand vous croyez publier dans une queue en rÃ©alitÃ© le message est publiÃ© dans l'`exchange` `amq.default` avec la `routing key` = queue name)\n\n## Consumer\n\nLe rÃ´le du `consumer` est d'exÃ©cuter un traitement aprÃ¨s avoir rÃ©cupÃ©rÃ© un ou plusieurs `messages`.\n\nPour ce faire il va rÃ©server (prefetching) un ou plusieurs `messages` depuis la `queue`, avant d'exÃ©cuter un traitement.\nGÃ©nÃ©ralement si le traitement s'est correctement dÃ©roulÃ© le consumer va acquitter le message avec succÃ¨s (basic.ack).\nEn cas d'erreur le `consumer` peut Ã©galement acquitter nÃ©gativement le `message` (basic.nack).\nSi le `message` n'est pas acquittÃ©, il restera Ã  sa place dans la queue et sera re fetch un peu plus tard.\n\n> Vous voila maintenant fin prÃªts Ã  rÃ©colter vos carottes !\n\n> Vous pouvez maintenant [consulter la partie 2 (maÃ®trise)](https://blog.eleven-labs.com/fr/rabbitmq-partie-2-la-maitrise/), dans laquelle nous verrons comment attraper les lapins, et comment prÃ©parer le pÃ¢tÃ©. ğŸ˜œ\n\n## Liens utiles\n\nhttp://www.rabbitmq.com/documentation.html\n"}