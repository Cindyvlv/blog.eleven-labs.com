{"date":"2018-04-05T00:00:00.000Z","title":"Ta liste des courses avec API Platform","excerpt":"API Platform se veut être un framework complet permettant de créer des projets web se basant sur des APIs orientées ressource","readingTime":"7mn","authors":["vdelpeyroux"],"categories":["php","javascript"],"content":"Dans la continuité de l'article de notre très cher confrère Romain Pierlot sur [Api Platfrom](https://blog.eleven-labs.com/fr/creer-une-api-avec-api-platform/), nous allons essayer de faire le tour des nouvelles fonctionnalités de ce framework, et par la même occasion,  mettre en place une application web, comportant une api `REST Hydra` / `Graphql` avec un backend et un client full Javascript.\n\nPour les présentations, [API Platform](https://api-platform.com/) se veut être un framework complet permettant de créer des projets web se basant sur des APIs orientées ressource, ce qui est un peu le standard d'architecture des besoins contemporains de notre domaine.\n\n## Installation d'API Platform\n\nCommençons par installer ce framework en local.\n\nClonons donc ce projet dans notre workspace préféré :\n\n```shell\ngit clone git@github.com:api-platform/api-platform.git\ncd api-platform\n```\net ensuite mettons-nous sur la dernière version taguée. Au moment où j'écris cet article, la dernière version est la v2.2.5\n\n```shell\ngit checkout tags/v2.2.5\n```\nCe fichier docker-compose.yml à la racine du projet, ne nous laisse pas indifférent,\nallons donc poper ces conteneurs docker de ce pas.\n(mes versions : [docker](https://docs.docker.com/install/) :17.05.0-ce  [docker-compose](https://docs.docker.com/compose/install/) : 1.18.0)\n\n```shell\ndocker-compose up -d\n```\n\nPassons rapidement en vue les images créées :\n\n```shell\ndocker-compose ps\n```\n\nIl y a donc 6 conteneurs docker :\n\n - un conteneur php, pour l'api avec PHP 7.2 et php-fpm\n - un conteneur db, pour la base de donnée [PostgreSQL](https://www.postgresql.org/)\n - un conteneur cache-proxy Varnish\n - un conteneur admin pour le backend en [React](https://reactjs.org/)\n - un conteneur api, pour le serveur http de l'api [Nginx](https://nginx.org/en/)\n - un conteneur client, contenant un client React/[Redux](https://redux.js.org/)\n - et un conteneur h2-proxy pour orchestrer toutes ces images en local (h2 pour http2)\n\nAutant vous dire qu'au niveau des technos, ils ont dépensé sans compter...\n\nOuvrons notre navigateur pour aller à l'url [https://localhost](https://localhost)\n\nVous allez devoir accepter d'ajouter une exception de sécurité dans votre navigateur par rapport au certificat TLS qui a été généré au moment de l'installation.\n\nSi vous voyez cette belle page d'accueil, c'est que tout s'est bien passé !\n\n![homepage](/imgs/posts/2018-04-05-api-platform/ready.png)\n\n## Création de modèle de données\n\nPour pouvoir créer notre api, il va falloir décrire nos ressources en codant de simples objets PHP avec leurs propriétés.\nCréons pour l'exemple une simple liste de courses, parce que niveau mémoire c'est plus trop ça.\nPour des questions de simplicité on va juste créer une classe shoppingItem et utiliser la vue List que propose le client API Platform que nous verrons plus tard (mais sachez que toutes les relations entre entités sont très bien gérées).\n\n\n```php\n<?php\n// api/src/Entity/ShoppingItem.php\n\nnamespace App\\Entity;\n\nuse Doctrine\\ORM\\Mapping as ORM;\nuse Symfony\\Component\\Validator\\Constraints as Assert;\n\n/**\n * An item of a shopping list.\n *\n * @ORM\\Entity\n */\nclass ShoppingItem\n{\n    /**\n     * @var int The id of this item.\n     *\n     * @ORM\\Id\n     * @ORM\\GeneratedValue\n     * @ORM\\Column(type=\"integer\")\n     */\n    private $id;\n\n    /**\n     * @var string the name of the item.\n     *\n     * @ORM\\Column\n     * @Assert\\NotBlank\n     */\n    public $name;\n\n    /**\n     * @var boolean if the item has been purchased.\n     *\n     * @ORM\\Column(type=\"boolean\")\n     */\n    public $isCheck = false;\n\n    public function getId(): ?int\n    {\n        return $this->id;\n    }\n\n    public function getIsCheck(): ?string\n    {\n        return $this->isCheck ? \"yes\" : \"no\";\n    }\n}\n```\n\nOn va en profiter pour supprimer la classe php de démo api/src/Entity/Greeting.php :\n\n```shell\nrm ./api/src/Entity/Greeting.php\n```\n\net exécuter la commande doctrine pour synchroniser la base de données avec notre nouveau model :\n\n```shell\ndocker-compose exec php bin/console doctrine:schema:update --force --complete\n```\n\nLe `--complete` effacera la table `gretting` de la base de données, ce que la commande ne fait pas par défaut.\n\nMaintenant, ajoutons l'annotation magique d'API Platform à notre entité pour que le framework puisse détecter les propriétés à exposer par l'api et autoriser les opérations CRUD liées à l'objet.\n\n```php\n<?php\n// api/src/Entity/ShoppingItem.php\n\n// ...\nuse ApiPlatform\\Core\\Annotation\\ApiResource;\n\n/**\n * ...\n *\n * @ApiResource\n */\nclass ShoppingItem\n{\n    // ...\n}\n```\n\nEt voilà, notre API est ready !\n\nAllons à cette adresse  [https://localhost:8443](https://localhost:8443)\n\nVous devriez voir cette page, qui décrit toutes les actions possibles sur cette ressource :\n\n![docapi](/imgs/posts/2018-04-05-api-platform/apidoc.png)\n\nOh joie! Api Platform intègre une version personnalisée de [Swagger UI](https://swagger.io/swagger-ui/), qui permet de documenter vos ressources et par la même occasion de les tester, mais propose également une alternative avec [NelmioApiDoc Bundle](https://github.com/nelmio/NelmioApiDocBundle).\nLe format par défaut  de l'api est le [JSON-LD](https://json-ld.org/) avec l'extension [Hydra](http://www.hydra-cg.com/), qui est une version plus évoluée que le JSON standard donnant plus d'informations sur la ressource ainsi que les opérations possibles sur cette dernière. L'api supporte également les formats courants tels que le JSON, XML, HAL, JSONAPI et très récemment le [graphQL](https://graphql.org/) ...que nous allons bien évidemment nous empresser d'activer !\n\n\n## Activer GraphQL\n\nPour cela, il va falloir installer la librairie [graphql-php](https://github.com/webonyx/graphql-php) :\n\n```shell\ndocker-compose exec php composer req webonyx/graphql-php\n```\nEt voilà ! L'interface graphique GraphiQL est disponible ici [https://localhost:8443/graphql](https://localhost:8443/graphql)\n\n![graphql](/imgs/posts/2018-04-05-api-platform/graphql.png)\nRien de mieux pour commencer à se faire les dents sur ce super langage.\n\n## Le Backend\n\nAPI Platform intègre un backend utilisant la librairie [Admin On Rest](https://github.com/marmelab/admin-on-rest), un client en React avec [material design](https://github.com/material-components/material-components-web) qui se bind directement sur une api, et construit ses vues en fonction des ressources disponibles et des opérations permises :\n[https://localhost:444](https://localhost:444)\n\n![admin](/imgs/posts/2018-04-05-api-platform/backend.png)\n\nEn sachant que ce backend est entièrement paramétrable.\n\n## Création d'une application React/Redux\n\nLe dernier point que j'aborderai et qui n'est pas des moindres, c'est la génération d'une Progressive Web App avec React/Redux, mais il est également possible de générer une application en [Vue.js](https://vuejs.org/) ou une application en [React Native](https://facebook.github.io/react-native/)\n\nCréons notre application JavaScript :\n\n```shell\ndocker-compose exec client generate-api-platform-client\n```\n\n![console](/imgs/posts/2018-04-05-api-platform/consolegen.png)\n\nAjoutons maintenant les routes et les reducers générés dans index.js comme ceci :\n\n```js\n//client/src/index.js\n\nimport React from 'react';\nimport ReactDom from 'react-dom';\nimport { createStore, combineReducers, applyMiddleware } from 'redux';\nimport { Provider } from 'react-redux';\nimport thunk from 'redux-thunk';\nimport { reducer as form } from 'redux-form';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport createBrowserHistory from 'history/createBrowserHistory';\nimport { syncHistoryWithStore, routerReducer as routing } from 'react-router-redux';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport 'font-awesome/css/font-awesome.css';\nimport registerServiceWorker from './registerServiceWorker';\nimport Welcome from './Welcome';\nimport shoppingitem from './reducers/shoppingitem/';\nimport shoppingitemRoutes from './routes/shoppingitem';\n\nconst store = createStore(\n  combineReducers({routing, form, shoppingitem}),\n  applyMiddleware(thunk),\n);\n\nconst history = syncHistoryWithStore(createBrowserHistory(), store);\n\nReactDom.render(\n  <Provider store={store}>\n    <Router history={history}>\n      <Switch>\n        <Route path=\"/\" component={Welcome} strict={true} exact={true}/>\n        {shoppingitemRoutes}\n        <Route render={() => <h1>Not Found</h1>}/>\n      </Switch>\n    </Router>\n  </Provider>,\n  document.getElementById('root')\n);\n\nregisterServiceWorker();\n\n```\n\nConcernant le choix des librairies, nous remarquerons que React Router est utilisé pour la navigation,\nRedux Form pour gérer les formulaires et Redux Thunk pour gérer les requêtes ou autres traitements asynchrones (désolé pour les utilisateurs de redux-saga), avec une gestion des Services Workers.\n\n\nNous pouvons maintenant aller à l'url de la vue `list` de notre ressource `shoppingItem`: [https://localhost/shopping_items/](https://localhost/shopping_items/)\nParfait, vous avez votre liste de courses en react/redux qui va bien :\n\n![listecourse](/imgs/posts/2018-04-05-api-platform/listcourse.png)\n\n\n## Pour conclure\n\nCe framework est vraiment des plus complets. Ce que l'on vient d'aborder ne couvre même pas le quart de ce que propose API Platform dans sa globalité, et toutes ces possibilités se basent sur de bonnes pratiques.\n\nLe seul point négatif que l'on peut lui trouver c'est son architecture qui est orientée événement, se basant sur le système des events kernel de Symfony. L'avantage est que cela donne une grande liberté pour développer de nouvelles fonctionnalités.\n\nCela devient un inconvénient sur de gros projet où l'historique du code produit par moult développeurs, sûrement très bien attentionnés, devient un peu trop conséquent. Cela peut très vite partir dans tout les sens, et au final être un enfer à débugger.\n\n## À venir\n\nJ'aurais aimé vous parler de l'intégration de FOSuser bundle avec l'autentification JWT, des tests en Behat, PHPUnit, déployer son projet API Platform sur un cluster Kubernetes en quelques lignes de commande mais le temps me manque, je vous réserve donc cela pour la prochaine fois.\n"}