{"date":"2022-04-26T00:00:00.000Z","title":"Organiser son pipeline Gitlab CI avec les templates","excerpt":"Lorsqu'il y a plusieurs services à maintenir et à déployer, le code des pipelines des différents services est très souvent copié-collé. Nous verrons dans cet article comment mutualiser le code !","readingTime":"5mn","authors":["tthuon"],"categories":["architecture"],"content":"\nLors de ma mission chez Maisons du Monde en tant que SRE, j'ai découvert une nouvelle façon d'organiser le code du pipeline GitLab.\n\nLorsqu'il y a plusieurs services à maintenir et à déployer, le code des pipelines des différents\nservices est très souvent copié-collé. Ce n'est pas DRY (Don't Repeat Yourself).\n\nIl est donc recommandé dans ce cas de mutualiser le code. Il existe plusieurs façons de procéder, mais nous nous attarderons dans cet article sur la façon suivante.\n\n## Un pipeline Gitlab CI\n\nPrenons cet exemple de pipeline Gitlab CI. Il se lance au moment d'une merge-request\net lors d'un merge dans la branche par défaut.\n\nLe pipeline construit les dépendances, lance les tests et construit l'application.\n\n```yaml\nworkflow:\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'\n\nimage: golang:1.18\n\nstages:\n  - install\n  - test\n  - build\n\ninstall:\n  stage: install\n  script:\n    - go mod download\n\ntest:\n  stage: test\n  script:\n    - mkdir report\n    - go test -json -cover -coverprofile report/coverage.out > report/unittest.json\n  artifacts:\n    paths:\n      - report\n  dependencies:\n    - install\n\nbuild:\n  stage: build\n  script:\n    - mkdir -p build\n    - go build -o build/awesome-app\n  dependencies:\n    - test\n  artifacts:\n    paths:\n      - build/\n```\n\n## Le concept du template off-the-shelf\n\nJe pourrais mettre ce pipeline complet en tant que template et le réutiliser partout. Cependant, si\nune équipe veut gérer son pipeline différement, ou qu'elle veut ajouter des outils supplémentaires tel que\ngosec, elle ne pourra pas le faire simplement.\n\nLe principe est de créer des templates pour chaque job. Ainsi l'équipe responsable du pipeline est libre\nde les utiliser ou non. Elle peut également en décider l'ordre. C'est le concept du template off-the-shelf\n(cela peut être traduit littéralement par \"patron sur étagère\" ou \"livre sur étagère\").\n\nCréons un dépôt git avec tous les templates : gitlab-ci-library\n\nL'organisation des dossiers est libre, mais il faut veiller à sa cohérence. Ce dépôt git va grandir au\nfur et à mesure des ajouts des templates pour les différents besoins.\n\n```\ncode\n  |- go\n    |- install.yaml\n    |- test.yaml\n    |- build.yaml\n```\n\nLe dossier de niveau 1 sera le thème. Ensuite je spécifie le langage et enfin chaque fichier va contenir le template.\n\nRépartissons le code des différents jobs dans chacun des fichiers correspondants.\n\n```yaml\n# code/go/install.yaml\n.template:code:go:install:\n  variables:\n    GO_VERSION: 1.18\n  image: golang:$GO_VERSION\n  script:\n    - go mod download\n```\n\n```yaml\n# code/go/test.yaml\n.template:code:go:test:\n  variables:\n    REPORT_PATH: report\n    GO_VERSION: 1.18\n  image: golang:$GO_VERSION\n  script:\n    - mkdir -p ${REPORT_PATH}\n    - go test -json -cover -coverprofile ${REPORT_PATH}/coverage.out > ${REPORT_PATH}/unittest.json\n  artifacts:\n    paths:\n      - ${REPORT_PATH}\n```\n\n```yaml\n# code/go/build.yaml\n.template:code:go:build:\n  variables:\n    BUILD_PATH: build\n    GO_VERSION: 1.18\n  image: golang:$GO_VERSION\n  script:\n    - mkdir -p ${BUILD_PATH}\n    - go build -o ${BUILD_PATH}\n  artifacts:\n    paths:\n      - ${BUILD_PATH}\n```\n\nLa gestion des dépendences entre jobs est laissée à l'équipe de développement des services.\n\nEn plus de mutualiser en un seul endroit le code des jobs des pipelines, il est possible de donner\ndes options pour les rendre configurables. Par exemple, le dossier où sera stocké le rapport peut être\nchangé sans impacter la fonctionnalité.\n\nTous les templates dont nous avons besoin pour transformer le pipeline seront inclus via le mot clef `include`.\nAvec l'option `ref`, les templates sont versionnés. Un outil tel que [renovate](https://docs.renovatebot.com/)\npourra faire des MR de mise à jour de la version.\n\nCi-dessous le nouveau pipeline avec l'inclusion des templates.\n\n```yaml\ninclude:\n  - project: gitlab-ci-library\n    ref: 1.0.0\n    file:\n      - '/code/go/install.yaml'\n      - '/code/go/test.yaml'\n      - '/code/go/build.yaml'\n\nworkflow:\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'\n\nstages:\n  - install\n  - test\n  - build\n\ninstall:\n  stage: install\n  extends: .template:code:go:install\n\ntest:\n  stage: test\n  extends: .template:code:go:test\n  dependencies:\n    - install\n\nbuild:\n  stage: build\n  extends: .template:code:go:build\n  dependencies:\n    - test\n```\n\nCe nouveau pipeline est plus lisible. Le développeur s'affranchit de la complexité des jobs. Il se concentre sur\nl'ordre et les fonctionnalités du pipeline. Il pourra ajouter un job de code lint plus tard par exemple.\n\nDans une autre équipe qui gère un autre service, le pipeline pourrait ressembler à ça par exemple :\n\n```yaml\ninclude:\n  - project: gitlab-ci-library\n    ref: 1.0.0\n    file:\n      - '/code/go/install.yaml'\n      - '/code/go/test.yaml'\n\nworkflow:\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'\n\nvariables:\n  GO_VERSION: 1.17\n\nstages:\n  - download deps\n  - testing\n\ndownload_deps:\n  stage: download deps\n  extends: .template:code:go:install\n\ntest_app:\n  stage: testing\n  extends: .template:code:go:test\n  dependencies:\n    - download deps\n```\n\nLe nom des stages est différent. La version de go est différente. Et pourtant, les fonctionnalités des templates restent les mêmes.\n\n## Conclusion\n\nCette organisation du code permet de mutualiser le code à un seul endroit. Le développeur choisi et configure les templates\nqui vont lui permettre de créer son pipeline. Il en garde ainsi la pleine maîtrise car il connait les besoins de son application.\n\nDu côté SRE, cette organisation permet de répondre aux besoins de toutes les applications sans avoir à répéter le code.\nChaque template est générique dans son fonctionnement, mais pleinement configurable.\n\n## Ressources\n\n- [https://docs.gitlab.com/ee/ci/yaml/index.html#includefile](https://docs.gitlab.com/ee/ci/yaml/index.html#includefile)\n- [https://docs.renovatebot.com/](https://docs.renovatebot.com/)\n"}