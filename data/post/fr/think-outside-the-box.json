{"date":"2018-05-21T00:00:00.000Z","title":"[iOS] Let's think outside the box","excerpt":"Utilisons le Framework comme il n'est pas prévu pour","readingTime":"17mn","authors":["thuchon"],"categories":[],"content":"\n## Introduction\n\nSalut les Astronautes, ça faisait un bail que je n'avais pas écrit un article, et aujourd'hui j'ai décidé de revenir en force avec un sujet bien technique et bien poussé comme on les aime.\n\nAttention pour celui-ci, il va falloir s'accrocher ! Même si le principe est plutôt simple, on va voir du code assez technique et on va vraiment pousser le framework et l'utiliser de manière tricky pour qu'il fasse des choses qu'il n'est pas trop supposé faire ;)\n\nNe vous en faites pas, je vais bien vous expliquer chaque étape, et bien décortiquer chaque bout de code.\n\nÇa fait un petit moment que je me retrouve à développer des projets dans lesquels les features doivent être configurables.<br/>\nLe plus souvent on me demande de faire en sorte que des features soient activables ou désactivables à distance.\n\nOn peut prendre l'exemple d'un burger menu, où chaque entrée correspond à une fonctionnalité de l'application, et on souhaite choisir celles qui sont accessibles.<br/>\nCe n'est pas spécialement compliqué à faire, et c'est très pratique pour le business.<br/>\nNéanmoins, je me suis toujours dit, il manque un truc, j'ai envie d'aller plus loin.<br/>\nEt donc, on en arrive là...\n\nAujourd'hui, je vais vous montrer comment \"piloter\" le comportement d'une application depuis un fichier JSON déposé sur un serveur distant.<br/>\nQuézaco?<br/>\nMais il est fou ce garçon, il est resté trop longtemps dans l'espace.<br/>\n\nPour que la suite de cet article soit plus simple, on va définir ensemble quelques mots clefs pour que vous ne soyez pas perdus.<br/>\nJe vais beaucoup utiliser le mot \"module\". Un module correspond à un ensemble de fonctionnalités que l'on peut facilement ré-utiliser et que l'on peut potentiellement sortir d'une application pour le mettre par exemple en tant que **Pod**<br/>\nLe terme suivant sera \"action\", j'entends par \"action\" : \"Fais telle chose\" dans mon application, pour la durée de l'article, ce sera un output console, une ouverture de page web, ce genre de choses.<br/>\nMaintenant que l'on a éclairci et défini les termes nécessaires à la bonne compréhension de cet article, je pense qu'il est temps de passer à la suite.<br/>\n\n\n**Comment nous allons procéder :**\n\nPour réussir à produire ce que l'on veut, on va devoir faire cohabiter 3 langages :\n\n- **JSON** pour la configuration\n- **Objective-C** pour taper bien bas dans le framework\n- **Swift** pour notre application\n\n\n## Mise en situation\n\nAccrochez-vous, c'est là que que tout commence.\n\nNotre but est de réaliser une application qui contient des features, mais qui n'a pas de structure comportementale.<br/>\nChaque feature va être définie comme un module, donc du code bien séparé qui vit sa vie et qui est disponible sans aucune dépendance au moment où il doit être utilisé.<br/>\nUne fois que l'on a bien compris ça, il faut se dire que ce que l'on veut réaliser est en 3 différentes parties :\n\n- Les modules\n- Notre application\n- Le comportement de notre application\n\nJe vous expliquerai par la suite chaque partie une à une.\n\nNotre objectif ici est de réaliser une application qui pourra charger à chaud des modules et leur faire exécuter des actions qui leur sont propres, mais sans que la séquence de ces actions soit défini dans le code de notre application.\n\nOn va donc procéder en 3 étapes :\n\n- Récupérer la liste des modules ainsi que la liste des actions sur un serveur distant\n- Charger ces modules\n- Exécuter les actions des modules\n\n### Les modules\n\nIci on va définir 3 modules et expliquer ce qu'ils font :\n\nPremier module\n```Swift\nimport Foundation\n@objc\n\nclass MyFirstModule: NSObject {\n\n    func sayHello() {\n        let name = String(describing: type(of: self))\n        print(\"Hello My name is \\(name)\")\n    }\n\n    func sayGoodBye() {\n        let name = String(describing: type(of: self))\n        print(\"GoodBye My name was \\(name)\")\n    }\n}\n```\nCe module est très simple, il contient deux méthodes, **sayHello** et **sayGoodBye**. Ces deux méthodes vont écrire sur la console le message défini à l'intérieur de celle-ci.\n\n\nSecond module\n```Swift\nimport Foundation\n@objc\n\nclass MySecondModule: NSObject {\n\n    func sayHello() {\n        let name = String(describing: type(of: self))\n        print(\"What's up? My name is \\(name)\")\n    }\n\n    func sayGoodBye() {\n        let name = String(describing: type(of: self))\n        print(\"See you, My name was \\(name)\")\n    }\n}\n```\nCe module est un clone du premier, la seule différence est le texte à l'intérieur de nos deux méthodes.\n\n\nTroisième module\n```Swift\nimport UIKit\n\n@objc\nclass MyThirdModule: NSObject {\n\n    func openUrl(url: String) {\n        let uri = URL(string: url)!\n        UIApplication.shared.open(uri, options: [:], completionHandler: nil)\n    }\n}\n```\nCe troisième module contient une seule méthode, il va ouvrir une instance safari et aller sur l'url passée en paramètre, rien de bien compliqué.\n\n\nComme vous pouvez le voir, les modules n'ont aucune intelligence, ils font juste ce qui leur est demandé.\n\n\n### L'application\n\nIntéressons-nous maintenant à l'application, c'est le coeur du projet.<br/>\nEn effet, comme défini plus haut, nous allons agir en 3 étapes :<br/>\n\n- Récupérer nos modules sur le serveur distant\n- Charger les modules\n- Exécuter les actions des modules\n\n### La récupération des modules\n\nPour procéder à cette récupération, nous allons utiliser 2 libs :\n\n- Alamofire pour tout ce qui est appels réseaux\n- Gloss pour la transformation du JSON en objet\n\nTout d'abord la récupération du fichier JSON présent sur notre serveur.<br/>\nLà, rien de bien méchant, on fait un GET avec la librairie Alamofire et on transforme ce JSON en GenericProtocol (une classe créée spécialement pour récupérer nos infos) via une petite classe perso que j'utilise toujours dans mes projets.\n\nLa classe en question\n```Swift\nimport Foundation\nimport Gloss\n\nclass BinderManager {\n\n    static func readValue<T: Glossy>(json: JSON, type: T.Type) -> T? {\n        if let result = T.init(json: json) {\n            return result\n        }\n        return nil\n    }\n\n    static func readValue<T: Glossy>(json: [JSON], type: T.Type) -> [T]? {\n        if let result = [T].from(jsonArray: json) {\n            return result\n        }\n        return nil\n    }\n}\n```\nLe GenericProtocol\n```Swift\nimport Foundation\nimport Gloss\n\nstruct GenericAction: Glossy {\n    var method: String?\n    var value: String?\n\n    init?(json: JSON) {\n        self.method = \"func\" <~~ json\n        self.value = \"value\" <~~ json\n    }\n\n    func toJSON() -> JSON? {\n        return nil\n    }\n}\n\nstruct GenericProtocol: Glossy {\n\n    var name: String?\n    var realObject: AnyObject?\n    var actions: [GenericAction]?\n\n    init?(json: JSON) {\n        self.name = \"name\" <~~ json\n\n        if let programmingObject = ObjectCreator.create(self.name) {\n            self.realObject = programmingObject as AnyObject\n        }\n\n        self.actions = \"actions\" <~~ json\n    }\n\n    func toJSON() -> JSON? {\n        return nil\n    }\n}\n```\nOn peut voir que j'utilise la librairie Gloss pour le mapping (question d'habitude).<br/>\nNotre GenericProtocol a un nom, une liste d'actions et un realObject. Je reviendrai plus tard sur ce realObject.<br/>\nEt s'en suit la transformation du JSON en objet après le retour du call HTTP.<br/>\n\n```Swift\nfunc getModules() {\n    let uri = \"http://plop.fr/Protocols.json\"\n    let completionHandlerHttp : (DataResponse<Any>) -> Void = { response in\n        switch response.result {\n        case .success:\n            if let jsonArray = response.value as? [JSON] {\n                if let modules = BinderManager.readValue(json: jsonArray, type: GenericProtocol.self) {\n                        self.useModules(modules: modules)\n                }\n            }\n            break\n        case .failure(let error):\n            print(error)\n            break\n        }\n    }\n\n    Alamofire.request(uri, method: .get, headers: nil).validate().responseJSON(completionHandler: completionHandlerHttp)\n}\n```\nAu-dessus, je vous ai parlé du realObject. Mais qu'est-ce que c'est que ça?<br/>\nEt bien en fait ce realObject c'est notre module, on l'instancie et garde une référence accessible dessus, je me suis inspiré des pointeurs sur fonctions en C pour cette idée.\n\nPassons maintenant au chargement/création de nos modules.\n\n### Le chargement de nos modules\n\nLe code sur lequel nous allons nous concentrer ici correspond à ces 3 petites lignes.\n```Swift\nif let programmingObject = ObjectCreator.create(self.name) {\n    self.realObject = programmingObject as AnyObject\n}\n```\nCela me sert à instancier mon module en me basant sur son nom.<br/>\nAu début de l'article, je vois ai parlé d'***Objective-C***, on y arrive enfin.<br/>\nJ'utilise l'Objective-C pour accéder à une couche vraiment basse pour instancier des classes basées sur leurs noms.<br/>\nVoici la classe qui nous permet de faire ça (Objective-C oblige en 2 fichiers, le .h et le .m), le tout avec un Bridging-Header pour que ce code soit visible pour Swift.\n```Objective-C\n\n#import <Foundation/Foundation.h>\n\n@interface ObjectCreator : NSObject\n\n+ (id)create:(NSString *)className;\n\n@end\n\n\n#import \"ObjectCreator.h\"\n\n@implementation ObjectCreator\n\n+ (Class)create:(NSString *)className\n{\n    Class daClass = NSClassFromString(className);\n    return [daClass new];\n}\n\n@end\n```\nDonc, si je résume, on a récupéré notre JSON via un call HTTP, transformé ce JSON en objet et instancié des classes qui contiennent des actions (nos modules).<br/>\nC'est bien beau tout ça, mais comment on fait pour les utiliser ces fameux modules?<br/>\nDans la méthode **getModules** on fait appel à une autre méthode **useModules**, on va aller regarder de côté-là.\n\n### Exécuter les actions des modules\n\nD'avance, je suis désolé, cette méthode va piquer les yeux.<br/>\nJe vous entends venir avec vos \"mais la complexité cyclomatique, c'est illisbile, comment on peut reprendre ça ?!\"<br/>\nEn même temps, appeler des méthodes sur des objets au Runtime, vous vous doutiez bien que ça n'allait pas être super clean et être fait en 2 lignes.<br/>\nJe vous demande juste de me faire confiance pour cette méthode et je vais vous expliquer du mieux que je peux ce qu'elle fait.<br/>\n\n```Swift\nfunc useModules(modules: [GenericProtocol]) {\n    for module in modules {\n        if let actions = module.actions {\n            for action in actions {\n                if let method = action.method {\n                    let selector = NSSelectorFromString(method)\n                    if let obj = module.realObject, obj.responds(to: selector) {\n                        if let value = action.value {\n                            _ = obj.perform(selector, with: value)\n                        } else {\n                            _ = obj.perform(selector)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nC'est parti pour l'explication ligne par ligne:\n\nOn boucle sur notre liste de modules.<br/>\nOn vérifie que chaque module a une liste d'actions.<br/>\nOn boucle sur la liste d'actions du module.<br/>\nOn vérifie que l'action possède bien une méthode (pour rappel une action peut avoir une méthode et un paramètre).<br/>\nOn récupère le selector, c'est la signature de la méthode.<br/>\nOn vérifie que le realObject existe, et qu'il contient bien le selector.<br/>\nSi l'action a un paramètre alors on exécute cette action en lui passant le paramètre.<br/>\nSi l'action n'a pas de paramètre, on exécute alors juste l'action.<br/>\n\nWaow, c'était intense, mais je pense que c'était nécessaire pour une bonne compréhension du sujet.<br/>\n\nBon, maintenant, c'est bien, on a une application qui peut avoir un comportement dicté à distance, mais si on se penchait un peu plus sur ce comportement ?<br/>\nOn enchaîne ?\n\n### Le comportement de notre app\n\n```JSON\n[\n    {\n        \"name\": \"GenericProtocol.MyFirstModule\",\n        \"actions\": [\n            {\n                \"func\": \"sayHello\"\n            }\n            ,\n            {\n                \"func\": \"showPopup\"\n            },\n            {\n                \"func\": \"sayGoodBye\"\n            }\n        ]\n    },\n    {\n        \"name\": \"GenericProtocol.MySecondModule\",\n        \"actions\": [\n            {\n                \"func\": \"sayHello\"\n            }\n            ,\n            {\n                \"func\": \"showPlop\"\n            },\n            {\n                \"func\": \"sayGoodBye\"\n            }\n        ]\n    },\n    {\n        \"name\": \"GenericProtocol.MyThirdModule\",\n        \"actions\": [\n            {\n                \"func\": \"openUrlWithUrl:\",\n                \"value\": \"https://eleven-labs.com/\"\n            }\n        ]\n    }\n]\n```\n\nIl s'agit d'un array JSON qui contient 3 objets (modules).<br/>\nLe champ **name** correspond au nom du module, **actions** à la liste de méthodes du module (**func** étant le nom de chaque méthode et **value** la valeur à passer à la méthode).<br/>\nJ'ai bien fait exprès pour les deux premiers modules de rajouter des actions inexistantes, car nous voulons un système un minimum robuste.\n\n### Petit Interlude\n\nOn a codé nos modules.<br/>\nOn a réalisé une application pouvant charger et utiliser ces modules.<br/>\nOn a défini le comportement de notre application.<br/>\nC'est quoi les prochaines étape ?<br/>\nL'avant-dernière étape, c'est d'appeler notre méthode **getModules** dans **viewDidLoad**\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    getModules()\n    // Do any additional setup after loading the view, typically from a nib.\n}\n```\nEt maintenant la dernière étape.\nBah, tout simplement tester ce que ça donne :)\n\n## It's time to run the APP\n\nBon, on a enfin tout en place, il suffit juste de runner notre application.\nNotre belle application se lance et que se passe-t-il ?\n\nPour ce qui est visible dans le simulateur, on va voir notre application s'ouvrir, afficher notre dummy screen, puis ouvrir Safari et aller sur le site d'**Eleven-Labs**.<br/>\nHum, c'est étrange ça, ça me rappelle l'action que l'on avait définie dans le 3ème module.<br/><br/>\n![AppVideo](/imgs/posts/2018-05-21-let-s-think-outside-the-box/appvideo.gif){:height=\"1104px\" width=\"621px\"}<br/><br/>\nSi on se penche maintenant sur la console, on va pouvoir observer des outputs.<br/>\nMais dis-donc, ces outputs là, ce ne seraient pas ceux que l'on a définis pour nos deux premiers modules ?!.<br/><br/>\n![ConsoleOutput](/imgs/posts/2018-05-21-let-s-think-outside-the-box/console-output.png)<br/><br/>\nJe pense que vous commencez à comprendre le truc non ?<br/>\nToutes les actions que l'on a définies dans le **JSON** et qui existent vraiment dans le module se sont réalisées.<br/>\nPlutôt cool non ? :)\n\n## Mais pourquoi faire tout ça ?\n\nVous devez vous dire, mais pourquoi faire tout ça ?<br/>\nPour différentes raisons.<br/>\nLa première étant que c'est très, très fun. Il faut de temps en temps sortir des sentiers battus et essayer de nouvelles choses, pousser le langage, pousser le framework, pousser les outils avec lesquels vous travaillez.\nDéstructurer une application peut être très utile, vous aider à établir de nouvelles architectures, voir des problématiques sous des angles différents et vous apporter des solutions pour des projets futurs.\n\nVoilà, j'espère que cet article vous a donné envie d'essayer de nouvelles choses et qu'il vous poussera à penser \"**Outside the box**\".\n\nJe vous donne un lien pour télécharger le projet déjà tout fait.<br/>\nIl suffit de le cloner, faire un pod install et la suite vous la connaissez.<br/>\n[Le Projet](https://github.com/ettibo/GenericProtocols){:rel=\"nofollow noreferrer\"}\n\nAllez, salut les astronautes :)\n"}