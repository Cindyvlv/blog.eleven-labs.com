{"date":"2015-04-30T00:00:00.000Z","title":"MongoDB 3 is out","excerpt":"Et voilà, la version 3 de MongoDB est disponible depuis le 3 Février 2015 et nous arrive avec beaucoup de changements, en particulier en ce qui concerne les performances.","readingTime":"5mn","authors":["cmoncade"],"categories":[],"content":"Et voilà, la version 3 de MongoDB est disponible depuis le 3 Février 2015 et nous arrive avec beaucoup de changements, en particulier en ce qui concerne les performances.\n\n<br/>\n[![FINAL - 3.0Launch-Infographic-v7-1](/assets/2015-04-30-mongodb-3/final-3.0launch-infographic-v7-1.jpg)](/assets/2015-04-30-mongodb-3/final-3.0launch-infographic-v7-1.jpg){: .center-image .no-link-style}\n\nCes chiffres font rêver mais sont quand même à relativiser car vous ne verrez pas vos performances s'améliorer de 80%. Tout dépend du cas d'usage, mais toujours est-il que le système d'allocation des données ainsi que l'accès à ces dernières a été entièrement revu.\n\n# I. Nouveautés\n\n*   Gestion des locks au niveau des collections et documents, selon le moteur utilisé (MMAPv1, WiredTiger)\n*   Un nouveau moteur de stockage: WiredTiger\n*   Compression des données stockées (WiredTiger).\n*   Le nombre de Replica Set augmenté à 50, contre 12 avant\n*   Performances accrues pour les indexes\n*   Une nouvelle version de MMS à déployer en local (nommée Ops Manager).\n*   Amélioration de la sécurité\n*   Les tools mongodump, mongorestore... ont été réécrits en Go et sont du coup plus rapides\n\n# II. Locks\n\nDans MongoDB, que ce soit pour de la lecture ou de l'écriture, un lock va être créé avant de commencer à accéder aux données.\n\n*   Un lock en lecture peut être partagé entre plusieurs opérations de lecture.\n*   Un lock d’écriture ne peut pas être partagé, donc aucune autre opération ne peut avoir lieu en même temps\n\nLes locks peuvent donc être très pénalisants (surtout en écriture) puisque l’accès à la base est interdit pendant la mise à jour d’une donnée. Les temps d’écriture sont très importants pour les performances globales.\n\nAvant la version 3, les locks se situaient au niveau de la base, ce qui signifiait qu'un accès à un document dans une collection bloquait toutes autres opérations sur l'ensemble de la base.\n\nA partir de la version 3, les locks sont gérés de manières plus fines:\n\n*   au niveau collection pour le moteur MMAPv1\n*   voir au niveau document pour WiredTiger\n\nLes performances sont donc grandement améliorées, surtout sur une base qui reçoit un grand nombre d'opérations d'écriture.\n\n# II. Moteurs de base de données: MMAPv1 vs WiredTiger\n\nLa première révolution de la version 3 est qu'un nouveau moteur de base de données est disponible, WiredTiger.\n\nMais attention, l'instance mongod se lancera par défaut avec MMAPv1\\. L'utilisation de WiredTiger se fera via une nouvelle option --storageEngine disponible au moment de l'initialisation de votre process \"mongod\".\n\nCeci afin de ne pas casser la compatibilité avec les anciennes versions.\n\nEn effet, la structure des fichiers (définie avec l'option --dbpath) crée par un mécanisme MMAP, est complètement différente de celle qui sera crée par le moteur WiredTiger. Il vous faudra donc passer par quelques manipulations pour migrer de l'un vers l'autre mais rassurez vous, rien d'insurmontable, en particulier dans le cas de Replica.\n\nPar contre rien ne vous empêche d'utiliser les deux systèmes dans un replica set.\n\n### A - MMAPv1\n\nComme dit précédemment, MMAPv1 reste le moteur de stockage par défaut.\n\nLes principales évolutions se résument à sa nouvelle gestion des locks et au système de journalisation, qui a aussi été amélioré.\n\n### B - WiredTiger\n\nWiredTiger présente deux avantages par rapport au MMAP:\n\n*   la manière d'allouer les données sur le disque:\n\nécriture asynchrone déclenchée par défaut toutes les 60 secondes ou les 2Go de données\n\n*   la compression des données et des indexes :\n\ndeux algorithmes de compression sont disponibles, snappy et zlib. La différence vient du fait que snappy (utilisé par défaut) a un taux de compression plus faible que zlib, mais est du coup plus rapide.\n\n*   les locks au niveau document, ce qui permet plusieurs écritures simultanées dans la même collection\n\nVous trouverez <a href=\"http://blog.ippon.fr/2015/03/11/mongodb-v3-la-revolution-22/\" rel=\"nofollow noreferrer\" style=\"color:#0000ff;\">ici</a> un benchmark sur les différentes versions de MongoDB (v2.6.7, v3:MMAPv1 et v3:WiredTiger).\n\n# III. Ops Manager\n\nOps Manager est le nouvel outil d'administration de MongoDB et qui n'est ni plus ni moins qu'une version MMS en local, destinée aux entreprises.\n\nL'administration des bases est plutôt bluffante. Pour avoir vu une démo en live, l'initialisation et le déploiement sur des VMs chez Amazon (EC2), sur lesquelles ont été déployées des shards répliqués, s'est fait en un clin d’œil.\n\nVous avez la main sur les versions à déployer et les migrations se font via un bouton, tout est transparent.\n\nL'administration de bases MongoDB n'a jamais été aussi simple et facilitera la vie de vos DBA.\n\n# IV. Autres\n\nOn trouvera également des améliorations au niveau des shards, de la sécurité et des outils que sont mongodump/mongorestore/mongostat...\n\nLa commande explain() a aussi été revue et va analyser de manière plus détaillée vos requêtes.\n\nVous trouverez plus de détails sur l'ensemble des changements sur la <a href=\"http://docs.mongodb.org/manual/release-notes/3.0/\" rel=\"nofollow noreferrer\" style=\"color:#0000ff;\">release notes</a> de MongoDB.\n\n# Conclusion\n\nCette version 3 arrive avec beaucoup de changements, très alléchants, en particulier au niveau des performances. On peut résumer les principales révolutions dans le nouveau moteur WiredTiger et la gestion des locks.\n\nÀ vous de vous faire votre propre avis, car la mise en place et l'administration d'une base MongoDB est devenu relativement simple.\n"}