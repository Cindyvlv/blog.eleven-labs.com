{"date":"2017-02-02T00:00:00.000Z","title":"Des tests unitaires en Swift avec Xcode","excerpt":"Des tests unitaires en Swift avec Xcode","readingTime":"11mn","authors":["ibenichou"],"categories":[],"content":"\nBonjour à vous les astronautes !!! :)\n\nAujourd'hui, nous allons voir ensemble un nouveau tuto de l'espace sous iOS/Xcode.\n\nLe sujet : **Les tests unitaires** !\n\nLe but de cet article est de vous sensibiliser aux tests sous Xcode et de vous apporter les bases pour vous lancer. N’hésitez pas à écrire un commentaire si vous avez des questions ou autres...\n\nVous avez sûrement entendu la phrase : \"tester c'est douter\", mais dans mon équipe on aime bien rajouter: \"mais douter c'est bien\".\n\nAlors un test unitaire c'est quoi ?\n\nUn test unitaire permet de :\n* Vérifier le bon fonctionnement d'une méthode, une classe, une portion d'un programme... ;\n* Garantir une non-régression de votre code ;\n* Se rendre compte que son code est trop long et compliqué, ce qui entraîne une refacto.\n\n\nEn général, un test se décompose en trois parties, suivant le schéma « **AAA** », qui correspond aux mots anglais « Arrange, Act, Assert », que l’on peut traduire en français par Arranger, Agir, Auditer.\n\n* **Arranger** : Il s’agit dans un premier temps de définir les objets, les variables nécessaires au bon fonctionnement de son test (initialiser les variables, initialiser les objets à passer en paramètres de la méthode à tester, etc.) ;\n* **Agir** : Il s’agit d’exécuter l’action que l’on souhaite tester (en général, exécuter la méthode que l’on veut tester, etc.) ;\n* **Auditer** : Vérifier que le résultat obtenu est conforme à nos attentes.\n\nBon ça c'est la théorie, passons un peu à la pratique.\n\nSur Xcode, pour effectuer des tests, nous utiliserons le framework fournit par Apple qui s’appel XCTest.\n\nCe framework fournit pas mal de choses mais je ne vous en dis pas plus, après on va me reprocher de spoiler :)\n\n## Test sur un(e) Model/Classe\n\nTout d’abord, nous allons créer une structure Astronaute (dans un dossier Model pour faire genre on fait du MVC :p ) comme ceci :\n\n```swift\nimport Foundation\n\nstruct Astronaute {\n    let name: String\n    let grade: String\n    let sex: String\n\n    let planet: String?\n\n    init(name: String, grade: String, sex: String, planet: String? = nil) {\n        self.name = name\n        self.grade = grade\n        self.sex = sex\n        self.planet = planet\n    }\n}\n```\n\nComme vous pouvez le constater, un Astronaute a obligatoirement un nom, un grade et un sexe mais n’a pas forcément de planète (c’est pas bien ça !).\n\nOn vient de créer cette structure donc le bon réflexe à prendre c’est de la tester tout de suite.\n\nAlors commentkonfé ?\n\nLorsque vous créez un projet, généralement Xcode vous demande si vous désirez ajouter des units tests (checkbox). Si vous avez coché cette case alors vous avez un dossier finissant par **Tests** qui s'est créé à la racine. Supprimez le fichier généré dedans et créez un dossier Model afin de respecter l’architecture mise en place (c’est dans les bonnes pratiques).\n\nUne fois cette étape terminée, faites clique droit sur le dossier &gt; New File et sélectionnez Unit Test Case Class.\n\n<img src=\"/imgs/posts/2017-02-02-test-unitaire-swift-xcode/capture-d-ecran-2017-01-16-a-23.18.39.png\" />\n\nLe nommage de la classe doit obligatoirement finir par Tests, soit dans notre cas **AstronauteTests**.\n\nNous allons maintenant nous attarder sur la classe générée afin de vous expliquer la base.\n\n```swift\nimport XCTest\n\nclass AstronauteTests: XCTestCase {\n\n    override func setUp() {\n        super.setUp()\n    }\n\n    override func tearDown() {\n        super.tearDown()\n    }\n\n    func testExample() {\n    }\n\n    func testPerformanceExample() {\n        self.measure {\n        }\n    }\n\n}\n```\n\nLa première chose à noter est qu’on importe XCTest. Comme vous vous en doutez, ceci permet d’avoir accès au framework XCTest.\n\nEnsuite nous avons plusieurs méthodes que nous allons voir en détail :\n\n* **setUp()**. Cette méthode est appelée avant chaque invocation de chaque méthode de test écrit dans la classe. Pour ceux ou celles qui font des tests avec phpunit vous avez sûrement reconnu cette méthode ;\n* **tearDown()**. Cette méthode est appelée après l’invocation de chaque méthode de tests écrits dans la classe ;\n* **testExample()**. Méthode créée par défaut par Xcode. Il est important de savoir que chaque méthode de test que vous allez créer doit absolument être préfixée par **test**;\n* **testPerformanceExample()**. Méthode créée par défaut par Xcode. Dans celle-ci, Xcode nous montre que nous pouvons aussi faire un test de performance. Tester la perfomance de votre code permet de s’assurer que les algorithmes les plus importants qui demandent un traitement particulier restent performants avec le temps.\n\n```swift\nimport XCTest\n@testable import tuto_xctest\n\nclass AstronauteTests: XCTestCase {\n\n    func testInitAstronaute() {\n        let astronaute = Astronaute(name: \"Pepito\", grade: \"Amiral\", sex: \"Male\")\n\n        XCTAssertEqual(\"Pepito\", astronaute.name)\n        XCTAssertEqual(\"Amiral\", astronaute.grade)\n        XCTAssertEqual(\"Male\", astronaute.sex)\n    }\n}\n```\n\n\nRien ne vous choque ? J’ai ajouté un @testable import {nomDeMonProjet}.\n\nEn effet, sur chaque classe de test que vous allez créer, vous devrez ajouter ceci afin d’autoriser l’accès au AppDelegate notamment mais aussi à l’ensemble des classes et méthodes créées dans votre application. Cependant, @testable donne accès seulement aux méthodes dites internes et non aux méthodes privées.\n\nNous allons créer notre première méthode de test. Pour ceci, nous allons tester que notre structure Astronaute initialise bien les valeurs qu'on lui passe. C'est pourquoi, nous allons créer la méthode **testInitAstronaute** (bien évidemment la bonne pratique est de donner un nom qui indique ce qu’on souhaite tester et son nom doit être en camelCase).\n\nDans cette méthode, nous initialisons dans une constante astronaute la structure Astronaute avec les paramètres obligatoires.\n\nPour tester que nos valeurs sont bien passées à la structure, il n’y a rien de plus simple.\n\nNous allons utiliser une méthode fournie par le framework XCTest. Dans notre cas, nous testerons l’égalité entre deux valeurs et nous nous servirons de la méthode **XCTAssertEqual** (la notion d’assert a déjà été vue plus haut) qui prend plusieurs arguments.\n1. expression1 : Une expression de type scalaire C ;\n2. expression2 : Une expression de type scalaire C ;\n3. …: Une description optionnelle lors d’un échec. Cette description doit être typée en String.\n\nCette méthode génère un échec lorsque expression1 != expression2.\n\nBon on a écrit notre test mais comment on l’exécute ?\n\nIl y a 3 solutions :\n\n1. Vous lancez tous les tests via CMD + U ;\n2. Vous passez votre curseur sur le carré vide à côté du nom de la classe et celui-ci se transforme en bouton play. Ce procédé va lancer tous les tests de votre classe (cf. screenshot ci-dessous) ;\n3. Même procédure que la solution 2 mais seulement sur la méthode que vous souhaitez tester.\n\n<img src=\"/imgs/posts/2017-02-02-test-unitaire-swift-xcode/capture-d-ecran-2017-01-17-a-23.46.10.png\" />\n\nPour finir notre test, nous allons rajouter la méthode **testInitAstronuateWithPlanet** >qui va tester l’initialisation d’un astronaute avec une planète (oui j’aime bien mettre des noms en rapport avec Star Wars :) ).\n\n```swift\nfunc testInitAstronuateWithPlanet() {\n  let astronaute = Astronaute(name: \"Skywalker\", grade: \"Jedi\", sex: \"Male\", planet: \"Tatooine\")\n\n  XCTAssertEqual(\"Tatooine\", astronaute.planet)\n}\n```\n\nBon normalement nous avons testé tous les cas possibles sur notre structure. Mais comment en être sûr ?\n\nLa solution : le code coverage. Il permet d’écrire le taux de code source testé d'un programme. Comment faire sous Xcode ?\nCliquez sur l’icone (cf. screenshot ci-dessous) et cliquez sur “Edit Schema”\n\n<img src=\"/imgs/posts/2017-02-02-test-unitaire-swift-xcode/capture-d-ecran-2017-01-18-a-00.19.57.png\" />\n\nAllez dans l’onglet Test et cochez la case “Gather coverage data” (cf. screenshot ci-dessous)\n\n<img src=\"/imgs/posts/2017-02-02-test-unitaire-swift-xcode/capture-d-ecran-2017-01-18-a-00.21.30.png\" />\n\nUne fois ces étapes effectuées, relancez le processus de test sur votre classe et cliquez sur l’icône qui ressemble à un message dans votre onglet à gauche puis dans l’onglet principal sélectionnez Code Coverage. N’oubliez pas de cocher dans cette partie la checkbox “Show Test Bundles”\n\n<img src=\"/imgs/posts/2017-02-02-test-unitaire-swift-xcode/capture-d-ecran-2017-01-18-a-00.23.46.png\" />\n\n## Test sur un ViewController\n\nMaintenant nous allons créer une méthode qui va changer le texte d'un label en fonction d'une condition. Voici le code d'exemple (rien de très compliqué).\n```swift\nimport UIKit\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var uiText: UILabel!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n\n    func changeLabel(score: Int) {\n        if (score > 0) {\n            self.uiText.text = \"Gagner\"\n\n            return;\n        }\n\n        self.uiText.text = \"Perdu\"\n    }\n\n}\n```\n\nNous allons voir en détails ensemble comment tester ceci :\n```swift\nimport XCTest\n@testable import tuto_xctest\n\nclass ViewControllerTests: XCTestCase {\n    var controller:ViewController!\n\n    override func setUp() {\n        super.setUp()\n\n        let storyboard = UIStoryboard(name: \"Main\", bundle: Bundle.main)\n        controller = storyboard.instantiateInitialViewController() as! ViewController\n    }\n\n    override func tearDown() {\n        super.tearDown()\n\n        controller = nil\n    }\n\n    func testScoreIsWinChangeLabel() {\n        let _ = controller.view\n        controller.changeLabel(score: 1)\n\n        XCTAssertEqual(\"Gagner\", controller.uiText.text)\n    }\n\n    func testScoreIsLooseChangeLabel() {\n        let _ = controller.view\n        controller.changeLabel(score: 0)\n\n        XCTAssertEqual(\"Perdu\", controller.uiText.text)\n    }\n\n}\n```\n\nNous devons créer une variable de type ViewController afin d'accéder pour chaque méthode de test à celle-ci.\n1. **setUp()** : (qui sera appelée avant chaque invocation de méthode de test)\n    1. Nous créons une constante storyboard qui va récupérer le storyboard Main (qui est par défaut votre storyboard) ;\n    2. Nous faisons appel à la méthode **instantiateInitialViewController** du storyboard afin d'instancier et renvoyer le controller de vue initial.\n1. **tearDown()** : (qui sera appelée après chaque invocation de méthode de test). Nous mettons à nil notre controller pour plus de sécurité.\n3. **testScoreIsWinChangeLabel()** :\n    1. Nous souhaitons accéder au texte du label uiText de notre controller. Cependant sans l'instruction  `let _= controller.view` vous allez relever une erreur car le label sera égal à nil.\n    Comment est-ce possible ? Quand nous avons créé notre label dans notre storyboard, celui-ci s’instancie une fois que la vue est chargée. Mais dans notre classe unitaire, la méthode **loadView()** n’est jamais déclenchée.\n    Le label n’est donc pas créé et il est égal à nil. Une solution pour ce problème serait alors d'appeler **controller.loadView()** mais Apple ne le recommande pas car cela cause des problèmes de **memory leaks** quand les objets qui ont déjà été chargés sont de nouveau chargés.\n    L’alternative est d’utiliser la propriété **view** de votre controller qui déclenchera toutes les méthodes requises.\n    *Note : L'utilisation d'un underscore (_) comme nom de constante a pour but de réduire le nom de la constante car nous n'avons pas vraiment besoin de la vue. Cela dit au compilateur qu'on prétend avoir l'accès à la vue et qu'on déclenche toutes les méthodes.*\n    2. Nous appelons la méthode concernée et nous vérifions l’assertion entre notre string et notre texte du label.\n\n## Conclusion\n\nJ’espère que cet article vous a plu et qu’il vous a donné envie de faire pleins de test unitaires. J’insiste sur le fait que faire des tests est vraiment important car :\n* Cela vérifie le bon fonctionnement de votre code ;\n* Cela cible plus facilement une erreur due à un changement de code ;\n* Vous y gagnerez sur le long terme.\n"}