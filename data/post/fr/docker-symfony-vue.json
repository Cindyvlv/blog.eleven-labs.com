{"date":"2017-11-10T00:00:00.000Z","title":"Démarrer avec Docker, Symfony et Vue.js","excerpt":"Dans cet article nous allons vous décrire comment configurer un projet Docker, Symfony et Vue.js","readingTime":"19mn","authors":["nicolas","jiefmoreno"],"categories":["php","javascript"],"content":"\nDans cet article nous allons vous montrer comment mettre en place une application web avec symfony et Vue.js dans un environnement docker. À la fin de cet article vous aurez un projet prêt au développement. Vous pouvez également retrouver le projet sur le github d’Eleven-labs sur ce dépôt [eleven-labs/docker-symfony-vue](https://github.com/eleven-labs/docker-symfony-vue){:rel=\"nofollow noreferrer\"}\n\n## ENVIRONNEMENT : Docker\nPour l'environnement nous allons nous baser sur le projet de Maxence POUTORD disponible sur son [GitHub](https://github.com/maxpou/docker-symfony){:rel=\"nofollow noreferrer\"} auquel nous allons apporter quelques modifications.\nDans un premier temps nous changeons de base de données pour passer sur [PostgreSQL](https://www.postgresql.org){:rel=\"nofollow noreferrer\"}. Pour ce faire nous modifions le fichier `docker-compose.yml` se trouvant à la racine de notre projet :\n\n```yaml\n# ...\n\npostgres:\n\timage: postgres:9.6\n\tports:\n\t\t- ${POSTGRES_PORT}:5432\n\tenvironment:\n\t\tPOSTGRES_DB: ${POSTGRES_DB}\n\t\tPOSTGRES_USER: ${POSTGRES_USER}\n\t\tPOSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n\nphp:\n\tbuild: docker/php7-fpm\n\tenv_file: ./.env\n\tvolumes:\n\t\t- ${SYMFONY_APP_PATH}:/var/www/symfony\n\tlinks:\n\t\t- postgres\n\n# ...\n```\n\nEnsuite nous ajoutons à notre stack Node JS pour Vue.js ainsi que Redis pour la gestion des sessions. Toujours dans le fichier `docker-compose.yml` :\n```yaml\n# …\n\nredis:\n\timage: redis:3.2.10\n\nnode:\n\tbuild: docker/node\n\tvolumes:\n\t\t- ${SYMFONY_APP_PATH}:/var/www/symfony\n\tcommand: bash -c \"yarn && yarn dev\"\n```\nPuis nous créons le Dockerfile pour Node JS dans le répertoire `docker/node` :\n```dockerfile\nFROM node:8\n\nRUN apt-get update && \\\n\tapt-get install -y \\\n\t\tcurl \\\n\t\tapt-transport-https\n\nRUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - && \\\n\techo \"deb https://dl.yarnpkg.com/debian/ stable main\" | tee /etc/apt/sources.list.d/yarn.list\n\nRUN apt-get update && apt-get install yarn\n\nWORKDIR /var/www/symfony\n```\n\nEnfin nous modifions le Dockerfile de PHP qui se trouve dans le répertoire `docker/php7-fpm` pour installer la librairie cliente de PostgreSQL [libpq-dev](https://www.postgresql.org/docs/9.5/static/libpq.html) ainsi que l’extension [pdo_pgsql](http://php.net/manual/en/ref.pdo-pgsql.php){:rel=\"nofollow noreferrer\"} pour PHP :\n```dockerfile\n# ...\nRUN apt-get update && \\\n\tapt-get install -y \\\n\t\tgit \\\n\t\tunzip \\\n\t\tlibpq-dev\n\n# …\n\nRUN docker-php-ext-install pdo pdo_pgsql\n\n# ...\n```\nDans le même fichier, nous en profitons aussi pour supprimer l’alias de la commande pour Symfony 2 `RUN echo 'alias sf=\"php app/console\"' >> ~/.bashrc`\n\nEt nous mettons à jour nos variables du fichier `.env.dist` se trouvant à la racine du projet :\n```dotenv\n# PATH DIR\nSYMFONY_APP_PATH=./\nLOGS_DIR=./docker/logs\n\n# DATABASE\nPOSTGRES_DB=\nPOSTGRES_USER=\nPOSTGRES_PASSWORD=\nPOSTGRES_PORT=\n\n# PORT WEB\nWEB_PORT=\nELK_PORT=\n\n# SYMFONY\nSECRET=\n\n#SMTP\nSMTP_USER=\nSMTP_PASSWORD=\nSMTP_HOST=\nSMTP_TRANSPORT=\n\n#REDIS\nREDIS_DNS=\n```\n\n## BACKEND : Symfony\nMaintenant que notre environnement est prêt, nous installons Symfony, je vous invite à suivre le [tutoriel officiel sur le site de symfony](https://symfony.com/doc/current/setup.html){:rel=\"nofollow noreferrer\"}.\nNous allons personnaliser Symfony pour notre projet et pour ce faire nous supprimons l'appel à trois scripts exécutés lors du `composer install ` ou du `composer update`, qui se trouvent dans le fichier `composer.json` à la racine du projet, et qui sont :\n\n- `installRequirementsFile`\n- `prepareDeploymentTarget`,\n- `buildParameters`.\n\nCe qui nous donne :\n```json\n// …\n{\n\"deploy-scripts\": [\n\t\"Sensio\\\\Bundle\\\\DistributionBundle\\\\Composer\\\\ScriptHandler::buildBootstrap\",\n\t\"Sensio\\\\Bundle\\\\DistributionBundle\\\\Composer\\\\ScriptHandler::clearCache\",\n\t\"Sensio\\\\Bundle\\\\DistributionBundle\\\\Composer\\\\ScriptHandler::installAssets\"\n],\n\"symfony-scripts\": [\n\t\"@deploy-scripts\"\n],\n\"post-install-cmd\": [\"@symfony-scripts\"],\n\"post-update-cmd\": [\"@symfony-scripts\"]\n},\n\n// ...\n```\nNous pouvons donc supprimer les lignes de contrôle d’accès du fichier `app_dev.php` qui se trouvent dans `web/` (ATTENTION: ce fichier ne devra plus se trouver dans un environnement de production) :\n\n```php\n<?php\n\n// ...\n\nif (isset($_SERVER['HTTP_CLIENT_IP'])\n    || isset($_SERVER['HTTP_X_FORWARDED_FOR'])\n    || !(in_array(@$_SERVER['REMOTE_ADDR'], ['127.0.0.1', '::1']) || PHP_SAPI === 'cli-server')\n) {\n    header('HTTP/1.0 403 Forbidden');\n    exit('You are not allowed to access this file. Check '.basename(__FILE__).' for more information.');\n}\n\n// ...\n```\nNous pouvons supprimer les fichiers `web/config.php` et `app/config/parameters.yml.dist`, et éditer le fichier `app/config/parameters.yml` comme ceci :\n```yaml\nparameters:\n    # Database parameters\n    database_host: postgres\n    database_port: '%env(POSTGRES_PORT)%'\n    database_name: '%env(POSTGRES_DB)%'\n    database_user: '%env(POSTGRES_USER)%'\n    database_password: '%env(POSTGRES_PASSWORD)%'\n\n    # Mailer parameters\n    mailer_transport: '%env(SMTP_TRANSPORT)%'\n    mailer_host: '%env(SMTP_HOST)%'\n    mailer_user: '%env(SMTP_USER)%'\n    mailer_password: '%env(SMTP_PASSWORD)%'\n\n    # Secret\n    secret: '%env(SECRET)%'\n\n    # Redis parameters\n    redis_dsn: '%env(REDIS_DNS)%'\n    redis_options: ~\n    session_ttl: 86400\n```\nNotre projet est installé et personnalisé, il ne reste plus qu'à installer quelques bundles :\n- friendsofsymfony/rest-bundle, pour la mise en place rapide d’une API REST\n- jms/serializer-bundle, pour faciliter la sérialisation et désérialisation des données\n- predis/predis et snc/redis-bundle, pour la communication avec redis et la gestion des sessions\n- (optionnel) doctrine/doctrine-fixtures-bundle, pour générer des données\n\nAvec cette commande, nous les installons `docker-compose exec -T --user www-data php composer require friendsofsymfony/rest-bundle jms/serializer-bundle predis/predis snc/redis-bundle doctrine/doctrine-fixtures-bundle`\n\nNous les référençons dans `app/AppKernel.php` :\n```php\n<?php\n\n// ...\n\nclass AppKernel extends Kernel\n{\n    public function registerBundles()\n    {\n        $bundles = [\n            // ...\n            new FOS\\RestBundle\\FOSRestBundle(),\n            new JMS\\SerializerBundle\\JMSSerializerBundle(),\n            new Snc\\RedisBundle\\SncRedisBundle(),\n            new AppBundle\\AppBundle(),\n        ];\n\n        if (in_array($this->getEnvironment(), ['dev', 'test'], true)) {\n            // ...\n            $bundles[] = new Doctrine\\Bundle\\FixturesBundle\\DoctrineFixturesBundle();\n\n\t// ..\n        }\n// ...\n}\n```\n\nEt nous les configurons :\n```yaml\n# SerializerBundle Configuration\njms_serializer:\n    metadata:\n        auto_detection: true\n\n# FOSRestBundle Configuration\nfos_rest:\n    body_converter:\n        enabled: true\n        validate: true\n    serializer:\n        serialize_null: true\n    param_fetcher_listener: true\n    routing_loader:\n        default_format: json\n        include_format: false\n    view:\n        view_response_listener: true\n    format_listener:\n        rules:\n            - { path: '^/api', priorities: ['json'], fallback_format: 'json' }\n            - { path: '^/', stop: true }\n\n# RedisBundle Configuration\nsnc_redis:\n    clients:\n        session_client:\n            type: predis\n            logging: false\n            alias: session_client\n            dsn: %redis_dsn%\n            options: %redis_options%\n    session:\n        client: session_client\n        prefix: app_session_\n        ttl: '%session_ttl%'\n```\nVoilà qui est fait pour la partie docker et symfony. Nous allons maintenant passer à la partie Vue.js\n\n## FRONTEND : Vue.js\nSi vous n’êtes pas familier avec Vue.js, vous pouvez visiter la [page officielle du framework](https://vuejs.org){:rel=\"nofollow noreferrer\"}. Vous trouverez des tutoriels très bien faits et traduits en français.\n\nTout d’abord, initialisons notre gestionnaire de package :\n```bash\nsymfony-vue $ yarn init\nyarn init v1.3.2\nquestion name (symfony-vue):\nquestion version (1.0.0):\nquestion description: symfony <3 vue\nquestion entry point (index.js):\nquestion repository url:\nquestion author: Wilson\nquestion license (MIT):\nquestion private:\nsuccess Saved package.json\n✨  Done in 49.10s.\nsymfony-vue $\n\n```\nPour nous permettre d’utiliser ES6 tout en restant compatible, nous utilisons babel :\n\n```json\n/* .babelrc */\n{\n  \"presets\": [\n    [\n      \"env\",\n      {\n       \"targets\": {\n          \"browsers\": [\n            \"last 2 versions\",\n            \"Chrome >= 52\",\n            \"FireFox >= 44\",\n            \"Safari >= 7\",\n            \"ie >= 10\",\n            \"last 4 Edge versions\",\n          ],\n        },\n      },\n    ],\n    \"stage-2\",\n    \"vue\",\n  ],\n}\n```\nEt pour gérer nos différents bundles nous utilisons Webpack. Voici notre configuration :\n```javascript\n/* app/config/webpack.config.js */\n\nconst path = require('path');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nconst webpack = require('webpack');\nconst autoprefixer = require('autoprefixer');\n\nmodule.exports = {\n  entry: {\n    page1: './src/AppBundle/Resources/js/page1/entrypoint.js',\n    page2: './src/AppBundle/Resources/js/page2/entrypoint.js',\n  },\n  output: {\n    path: path.resolve(__dirname, '../../src/AppBundle/Resources/public'),\n    filename: 'js/[name].js',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {\n          scss: 'style!css!sass',\n        },\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        exclude: /node_modules/,\n      },\n      {\n        test: /\\.s[a|c]ss$/,\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: [\n            'css-loader',\n            'postcss-loader',\n            {\n              loader: 'postcss-loader',\n              options: {\n                plugins: [\n                  autoprefixer({\n                    remove: false,\n                    browsers: [\n                      'last 2 versions',\n                      'Chrome >= 52',\n                      'FireFox >= 44',\n                      'Safari >= 7',\n                      'ie >= 10',\n                      'last 4 Edge versions',\n                    ],\n                  }),\n                ],\n              },\n            },\n            'sass-loader',\n          ],\n        }),\n      },\n      {\n        test: /\\.(jpg|png|svg)$/,\n        loader: 'file-loader',\n      },\n    ],\n  },\n  plugins: [\n    new ExtractTextPlugin({\n      filename: 'css/style.css',\n    }),\n    new webpack.LoaderOptionsPlugin({\n      options: { sassLoader: { includePaths: [path.resolve(__dirname, '../node_modules')] } },\n    }),\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: `'${process.env.NODE_ENV}'`,\n      },\n    }),\n  ],\n};\n\n```\nNous avons aussi configuré Webpack pour utiliser SASS.\n\nNous pouvons ajouter les scripts suivants à notre package.json pour lancer et builder notre application :\n\n```json\n/* package.json */\n// ...\n\n\"dev\": \"NODE_ENV=dev webpack --config ./app/config/webpack.conf.js --devtool source-map --debug --watch --display-error-details\",\n\"build\": \"NODE_ENV=production webpack --config ./app/config/webpack.conf.js --progress --colors --optimize-minimize\",\n\n// ...\n```\nComme vous pouvez le voir, nous avons deux entrypoints différents dans notre configuration Webpack. De ces deux entrypoints, Webpack va générer deux bundles. De cette façon, nous allons pouvoir intégrer des applications Vue.js à différentes pages Twig.\n\nPour cet exemple, nous allons créer un composant “message” que nous allons appeler dans deux pages différentes.\nCréons d’abord notre composant, qui prend en propriété “text” :\n```javascript\n/* src/AppBundle/Resources/js/components/message/index.vue */\n<template>\n  <div class=\"message\">\n    {{ text }}\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'message',\n  props: {\n    text: {\n      type: String,\n      required: true\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n</style>\n\n```\nAppelons-le dans notre page 1 :\n\n```javascript\n/* src/AppBundle/Resources/js/page1/index.vue */\n<template>\n\t<Message text=\"Hello page 1\" />\n</template>\n\n<script>\nimport Message from '../components/message/index.vue';\nexport default {\n  name: 'Page1Container',\n  data() {\n    return { };\n  },\n  components: {\n    Message,\n  },\n};\n</script>\n```\n\nIl faut ensuite créer notre application Vue.js :\n\n```javascript\n/* src/AppBundle/Resources/js/page1/entrypoint.js */\n\nimport Vue from 'vue';\n\nimport Page1 from './index.vue';\n\nexport const vm = new Vue({\n  el: '#app1',\n  components: {\n    app: Page1,\n  },\n  render: h => h('app'),\n});\n```\n\nPuis nous appelons notre application dans la page Twig :\n\n```twig\n/* src/AppBundle/Resources/views/App/index.html.twig */\n\n{% extends '@App/App/layout.html.twig' %}\n\n{% block container %}\n<div id=\"app1\"></div>\n<script type=\"text/javascript\" src=\"{{ asset('bundles/app/js/page1.js') }}\"></script>\n{% endblock %}\n```\n\n\nNous faisons de même pour la page 2 :\n\n```javascript\n/* src/AppBundle/Resources/js/page2/index.vue */\n\n<template>\n\t<Message text=\"Hello page 2\" />\n</template>\n\n<script>\nimport Message from '../components/message/index.vue';\nexport default {\n  name: 'Page2Container',\n  data() {\n    return { };\n  },\n  components: {\n    Message,\n  },\n};\n</script>\n```\n\n```javascript\n/* src/AppBundle/Resources/js/page2/entrypoint.js */\n\nimport Vue from 'vue';\n\nimport Page2 from './index.vue';\n\nexport const vm = new Vue({\n  el: '#app2',\n  components: {\n    app: Page2,\n  },\n  render: h => h('app'),\n});\n```\n\n\n```twig\n/* src/AppBundle/Resources/views/App/page2.html.twig */\n\n{% extends '@App/App/layout.html.twig' %}\n\n{% block container %}\n<div id=\"app2\"></div>\n<script type=\"text/javascript\" src=\"{{ asset('bundles/app/js/page2.js') }}\"></script>\n{% endblock %}\n```\n\n\n\n## COMMUNICATION\nParfois nous avons besoin d’envoyer des informations de Symfony vers Vue.js. Selon la taille de l’information et sa sensibilité, nous pouvons passer par une requête API, ou par un Data Layout.\n\nCommençons par le Data Layout. Le Data Layout est un objet déclaré globalement, qui sera donc accessible par notre template Twig, et notre application Vue.js.\n\nNous allons d’abord définir un objet dataLayout au niveau le plus haut de nos templates Twig :\n\n\n```twig\n/* app/Resources/views/app.html.twig */\n\n<!DOCTYPE html>\n<html lang=\"{{ app.request.locale }}\">\n    <head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <meta charset=\"UTF-8\" />\n\n        <title>{% block title %}{% endblock %}</title>\n\n        {% block stylesheets %}{% endblock %}\n\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"{{ asset('favicon.ico') }}\" />\n    </head>\n    <body>\n        {% block data_layout %}\n            <script type=\"text/javascript\" id=\"dataLayout\">\n                var dataLayout = {};\n            </script>\n        {% endblock %}\n        {% block body %}{% endblock %}\n\n        {% block javascripts %}{% endblock %}\n    </body>\n</html>\n```\n\n\nVeillez à bien respecter l’ordre d’appel des scripts : en premier le dataLayout et ensuite l’application Vue.js. Sinon vous n’aurez pas accès à l’objet global dataLayout, car il ne sera pas encore créé.\nEnsuite nous allons envoyer des données depuis Symfony, et les récupérer dans notre Twig :\n\n```php\n/* src/AppBundle/Controller/appController.php */\n\n// ...\npublic function indexAction(): Response\n    {\n        return $this->render('@App/App/index.html.twig', [\n          'message'=>'hello !'\n          ]);\n    }\n// ...\n```\n\n\n```twig\n/* src/AppBundle/Resources/views/App/index.html.twig */\n\n// ...\n{% block data_layout %}\n    {{ parent() }}\n    <script type=\"text/javascript\">\n      dataLayout.message = \"{{ message }}\";\n    </script>\n{% endblock %}\n\n// ...\n```\n\n\nIl faut maintenant récupérer le message depuis Vue.js. Modifions notre index.vue de la page 1 :\n\n```javascript\n/* src/AppBundle/Resources/js/page1/index.vue */\n<template>\n\t<Message :text=\"message\" />\n</template>\n\n// ...\ndata() {\n    return {\n      message: '',\n    };\n// ...\nmounted() {\n    this.$set(this, 'message', dataLayout.message);\n  },\n};\n</script>\n\n```\n\nPlus classiquement, nous pouvons récupérer les informations depuis un appel API.\nCréons une route “/hello/:astronaut” :\n\n```php\n/* src/AppBundle/Controller/apiController.php */\n/**\n* Class ApiController\n* @package AppBundle\\Controller\n*/\nclass ApiController extends FOSRestController\n{\n   /**\n    * @Rest\\View()\n    * @Rest\\Get(\"hello/{astronaut}\", defaults={\"astronaut\" = null})\n    *\n    * @param string $astronaut\n    *\n    * @return string\n    */\n   public function getHelloAction(string $astronaut = null)\n   {\n       return isset($astronaut) ? \"Hello $astronaut\" : \"Hello Astronaut\";\n   }\n}\n\n```\nEt modifions notre page2/index.vue :\n\n```javascript\n/* page2/index.vue */\n<template>\n\t<Message :text=\"message\" />\n</template>\n// ...\ndata() {\n    return {\n      message: '',\n    };\n// ...\nmounted() {\n    fetch('/api/hello/wilson')\n        .then(response => response.json)\n        .then(({ message }) => this.$set(this, 'message', message))\n  },\n};\n</script>\n\n```\n\nEt voilà, vous pouvez maintenant faire communiquer votre application Symfony avec Vue.js\n\n## EXTRA : UN SCRIPT POUR SE SIMPLIFIER LA VIE\nVoici un petit extra pour se simplifier la vie. Comme vous avez pu le voir, pour l’installation de bundle, nous devions écrire une commande assez longue donc pour ne pas la réécrire entièrement, je vous propose de créer un script dédié à notre projet.\nNous définissons dans un premier temps la fonction d'entrée et la fonction d’information sur l'usage comme ceci :\n```bash\n#!/bin/bash\n\n# ...\n\nusage ()\n{\n    echo \"usage: bin/docker COMMAND [ARGUMENTS]\n\n    init              Initialize the project\n    start             Start project\n    stop              Stop project\n    bash              Use bash inside the app container\n    exec              Executes a command inside the app container\n    destroy           Remove all the project Docker containers with their volumes\n    console           Use the Symfony console\n    composer          Use Composer inside the app container\n    test              Run test project inside the app container\n    \"\n}\n\nmain ()\n{\n    declare CMD=$1\n\n    if [ -z $1 ]; then\n        usage\n        exit 0\n    fi\n\n    if [[ ! $1 =~ ^init|start|stop|bash|destroy|console|composer|exec|tests$ ]]; then\n        echo \"$1 is not a supported command\"\n        exit 1\n    fi\n\n    $@\n}\n\nmain $@\n```\nEnsuite nous implémentons nos fonctions. Je vais prendre uniquement l’exemple de `composer`, mais vous pouvez retrouver l'intégralité du script [ici](https://github.com/eleven-labs/docker-symfony-vue/master/bin/app){:rel=\"nofollow noreferrer\"}.\n```bash\n#!/bin/bash\n\n# …\n\n# run Composer inside the app container\ncomposer ()\n{\n    declare ARGS=$@\n    docker-compose exec -T --user www-data php composer $ARGS\n}\n\n# …\n```\n\nEt voilà le tour est joué ! Maintenant au lieu d’écrire `docker-compose exec -T --user www-data php compose [repository/bundleName]`, nous écrirons `bin/app compose [repository/bundleName]`\n\n## EN CONCLUSION\nVous disposez d’un projet configuré pour utiliser la puissance de Symfony et la simplicité de Vue.js. N’hésitez pas à nous poser des questions ou à nous laisser un commentaire !\n"}