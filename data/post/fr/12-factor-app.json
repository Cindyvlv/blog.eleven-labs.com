{"date":"2017-03-28T00:00:00.000Z","title":"12 Factor app","excerpt":"Dans ce post nous allons découvrir le manifeste 12 Factor App.","readingTime":"12mn","authors":["VEBERArnaud"],"categories":[],"content":"\n## Qu'est-ce que le \"12 Factor app\"\n\nLe \"12 Factor app\" est un manifeste qui propose 12 bonnes pratiques concernant le développement d'applications web.\nCe manifeste, écrit par Adam Wiggins (co-fondateur d'Heroku), est né de ses observations et de son expérience dans le\ndéveloppement et le déploiement d'applications web.\n\nCe manifeste s'applique à tous les langages et toutes les plateformes, c'est pourquoi il se contente de décrire les\ndécisions de conception de haut niveau sans donner de détail sur l'implémentation.\n\nDans ce post, nous allons parcourir ensemble ces 12 facteurs, en extraire le concept et tenter de l'appliquer au monde\nPHP.\n\n## L'application \"12 Factor\"\n\n### I Base de code\n\n*__Une base de code suivie avec un système de contrôle de version, plusieurs déploiements__*\n\nCe premier facteur nous dit que tout le code doit se trouver à un seul emplacement centralisé et versionné.\nOn y apprend également qu'une base de code est à l'origine de plusieurs déploiements, et qu'un déploiement ne doit pas\nêtre lié à plusieurs bases de code.\nDans le cas où du code serait commun à plusieurs applications, alors celui-ci doit être factorisé puis extrait sous\nforme de librairie.\n\nEn utilisant cette approche, nous avons une base de code qui ne contient que le code de l'application, et l'utilisation\nd'un gestionnaire de dépendances permet de récupérer les bibliothèques supplémentaires nécessaires au fonctionnement de\nl'application.\n\nLa solution évidente pour mettre en oeuvre ce facteur, est l'utilisation d'un système de contrôle de version (VCS) pour\ngérer les modifications apportées au référentiel central.\n\n### II Dépendances\n\n*__Déclarez explicitement et isolez les dépendances__*\n\nLes applications web modernes sont rarement conçues comme des monolithes à usage unique.\nElles sont au contraire conçues pour tirer partie de librairies (généralement externes).\n\nCependant l'utilisation de ces librairies externes peut introduire des problèmes :\n* Si nous ajoutons la librairie au projet, la base de code de ce dernier va considérablement augmenter et rendre\ncompliquée la mise à jour d'une de ces librairies sans affecter notre application principale.\n* Si nous n'ajoutons pas la librairie au projet, c'est le déploiement du code qui devient difficile.\nOù trouver la librairie ?\nQuelle version utiliser ?\n\nNous pouvons résoudre ces problèmes en utilisant un outil de gestion de dépendances.\nLes gestionnaires de dépendances visent à rendre la composition d'application beaucoup plus simple en récupérant et\ngérant les librairies pour nous.\nIl suffit de lister les dépendances ainsi que les versions que requiert notre application et l'outil de gestion fait le\nreste pour nous.\n\nDans le monde PHP, le gestionnaire de dépendances le plus utilisé est [composer](http://getcomposer.org/){:rel=\"nofollow noreferrer\"}, fortement\ninspiré de [npm](https://www.npmjs.com/) pour node et [bundler](http://bundler.io/){:rel=\"nofollow noreferrer\"} pour ruby, il installe les\ndépendances requise dans un dossier vendor.\nIl crée également dans ce dossier vendor des fichiers d'autoload permettant de faire un mapping dépendance-namespace et\nainsi les rendre disponibles dans l'application.\nLa définition de ces dépendances se fait dans le fichier `composer.json` et les versions réellement installées des\nlibrairies sont trackées dans le `composer.lock` afin d'installer exactement les mêmes versions sur tous les\ndéploiements.\n\n### III Configuration\n\n*__Stockez la configuration dans l’environnement__*\n\nLes applications web nécessitent de la configuration. Que ce soit pour spécifier l'emplacement des ressources attachées\n(base de données, api, ...), le réglage des préférences de l'application ou l'environnement cible (dev, prod, ...).\n\nPour configurer notre application, une approche souvent utilisée est le fichier de configuration; un script simple qui\ndéfinit certaines variables. Mais cette approche n'est pas idéale pour plusieurs raisons :\n* Généralement, nous voulons utiliser des paramètres basés sur l'environnement.\nNous ne souhaitons pas que les serveurs de développement accèdent aux bases de données de production.\nEn utilisant l'approche du fichier de configuration, nous aurions besoin de plusieurs fichiers ainsi que d'un moyen de\nchoisir le fichier à utiliser.\n* Les fichiers de configurations contiennent des informations sensibles que l'on ne souhaite pas ajouter à la base de\ncode.\n\nUne meilleure approche consiste à utiliser des variables d'environnement configurées au niveau du serveur web ou du\nsystème.\nCes variables sont donc spécifiques au serveur sur lequel l'application s'exécute.\n\nEn PHP, les valeurs de ces variables d'environnement peuvent être récupérées au runtime par la fonction\n[getenv](http://php.net/manual/fr/function.getenv.php){:rel=\"nofollow noreferrer\"}.\nLe framework Symfony va plus loin en transformant toutes les variables d'environnements commençant par `SYMFONY__` en\nparamètre, utilisable dans la configuration de l'application.\n\n### IV Services externes\n\n*__Traitez les services externes comme des ressources attachées__*\n\nL'application ne fait pas de distinction entre les services locaux et les services tiers.\nLe remplacement d'une base de données PostgreSQL locale par une autre gérée chez un tiers doit pouvoir se faire sans\nmodifications dans le code de l'application, seul la configuration doit changer.\n\nEn conséquence, le remplacement des services externes devient trivial. Cela implique également que l'application doive\ninteragir avec ces services externes de la même façon, que l'on soit en environnement de dev ou de prod.\n\nPrenons l'exemple d'une application Symfony (Standard Edition) avec Doctrine, les informations de connexion à la base de\ndonnées sont récupérées depuis la configuration de l'application.\nLe switch d'une base de données locale à une base de données distante se fait par simple changement des informations de\nconnexion à celle-ci et le code permettant cette communication n'a pas besoin de subir de modifications.\n\n### V Assemblez (build), publiez (releases), exécutez (run)\n\n*__Séparez strictement les étapes de build et d’exécution__*\n\nLe processus de déploiement d'une application est divisé en trois étapes distinctes :\n* L'étape d'assemblage (build), est une étape de transformation qui convertit une base de code en un ensemble\nexécutable.\n* L'étape de publication (release), contient à la fois la construction et la configuration et est prête pour une\nexécution immédiate dans l'environnement d'exécution.\n* L'étape d'exécution (run), exécute l'application dans un environnement d'exécution, en lançant un ensemble de\nprocessus de l'application dans une version donnée.\n\nCela peut sembler compliqué, mais l'idée clé est simple : nous devons séparer le processus de déploiement en deux phases\ndistinctes.\nLa première phase est de transformer la base de code en un livrable (build).\nLa deuxième phase consiste à mettre à jour l'environnement pour que le nouveau livrable soit utilisé (release + run).\n\nNous faisons cela pour trois raisons :\n* Les modifications en environnement de production sont impossibles.\nToutes modification doit être faite dans la base de code, qui sera ensuite transformée en livrable puis exécutée.\n* Une simplification de l'action de rollback (retour à une version antérieure) de l'application en cas de problème.\n* La mise en place de ce workflow permet d'automatiser les déploiements, ce qui les rend moins coûteux et en augmente la\nfréquence.\nQui dit déploiements plus fréquents dit également boucle de feedback plus courte, permettant le développement d'un\nmeilleur logiciel et moins de stress lors des déploiements.\n\n### VI Processus\n\n*__Exécutez l’application comme un ou plusieurs processus sans état__*\n\nL'application doit être conçue pour que chaque requête puisse être traitée par des processus différents, non liés et non\ncommunicants.\nCe modèle de conception \"sans état et sans partage\" (stateless) est indispensable à la scalabilité horizontale.\n\nConsidérons le modèle client-serveur.\nDans ce modèle, nous avons des serveurs qui gèrent les demandes des clients. Si nous voulons augmenter le nombre de\nrequêtes que le système peut gérer, nous avons deux options :\n* Augmenter la puissance de traitement des serveurs, augmentant ainsi le nombre de demandes que chacun peut traiter.\nOn parle alors de scalabilité verticale.\n* Ajouter plus de serveurs.\nOn parle alors de scalabilité horizontale.\n\nLa scalabilité verticale est plus simple à court terme, mais devient rapidement coûteuse et affiche des rendements\ndécroissants en termes de performance.\nLa scalabilité horizontale, d'autre part, est assez linéaire en termes de coût vs performance et permet d'être tolérant\naux pannes.\n\n### VII Associations de ports\n\n*__Exportez les services via des associations de ports__*\n\nDans certains cas, les applications web sont exécutées dans un serveur web.\nC'est par exemple le cas des applications web PHP fonctionnant à l'intérieur d'Apache, ou des applications web Java\nfonctionnant à l'intérieur de Tomcat.\n\nLes applications \"12 factor\" sont auto-suffisantes, et ne se basent pas sur l'injection au moment de l'exécution d'un\nserveur web dans l'environnement.\nC'est l'application web qui expose HTTP comme un service en l'associant à un port et écoute les requêtes qui arrivent\nsur ce port.\n\nOn peut par exemple citer les librairies de serveur web `Thin` pour Ruby, `Tornado` pour Python ou encore `Jetty` pour\nJava.\n\nCôté PHP, on a depuis la version 5.4.0 la possibilité de lancer un serveur web depuis PHP en CLI.\nCependant la documentation PHP nous met en garde concernant ce serveur web intégré.\n\n> Avertissement\n>\n> Ce serveur web a été prévu pour aider dans le développement des applications.\n> Il peut également être utile pour les tests, et pour les démonstrations d'applications qui sont exécutées dans des\n> environnements contrôlés.\n> Mais par contre, il n'a pas été conçu pour être un serveur web complet.\n> Aussi, il ne devrait pas être utilisé dans un réseau public.\n>\n> [Source](http://php.net/manual/fr/features.commandline.webserver.php){:rel=\"nofollow noreferrer\"}\n\nVous l'aurez compris, PHP ne permet pas de satisfaire ce point en conservant un mode de fonctionnement intégré au\nserveur web et non l'inverse.\n\n### VIII Concurrence\n\n*__Grossissez à l’aide du modèle de processus__*\n\nLes processus de l'application sont considérés comme des élèves modèle.\nCela signifie que, pour mettre à l'échelle notre application, nous créons plus de processus afin de tenir la charge.\nNous utilisons également différent types de processus pour différents types de tâches.\n\nL'avantage considérable de la concurrence sont les performances versus le coût.\nLa scalabilité par la parallélisation, donc horizontale, permet une croissance quasi-linéaire en termes de coûts et de\ndemandes traitées (à condition que l'application soit conçue pour cette stratégie de croissance).\n\nUn autre avantage évident est la tolérance aux pannes. Une défaillance de processus ne paralysera pas l'application.\n\nEnfin, la parallélisation offre une application plus rapide et réactive. La possibilité de différer le traitement du\nthread principal signifie que le serveur web n'a pas besoin d'attendre que les actions de fond se terminent avant\nd'envoyer la réponse HTTP au client.\n\n### IX Jetable\n\n*__Maximisez la robustesse avec des démarrages rapides et des arrêts gracieux (graceful)__*\n\nLes processus sont dit jetables, c'est à dire qu'ils peuvent être démarrés ou stoppés rapidement à n'importe quel\ninstant.\nCela permet d'ajouter des processus très rapidement en cas d'augmentation de la charge sur l'application et au contraire\nd'en supprimer quand la charge diminue.\n\nTrois points sont particulièrement importants ici :\n* Minimiser le temps de démarrage des processus.\nIdéalement, un processus prend quelques secondes entre le moment où une commande le lance et celui où il est en marche\net prêt à recevoir des requêtes.\nUn court temps de démarrage rend plus agile les processus de release et de scalabilité horizontale.\n* Éteindre gracieusement les processus lorsqu'ils reçoivent un signal SIGTERM.\nPour un processus web, s’éteindre en douceur se fait en arrêtant d’écouter sur le port de service (refusant, par la même\noccasion, toute nouvelle requête), en permettant à la requête courante de se terminer, et en quittant ensuite.\nPour un processus de worker, s’éteindre gracieusement est réalisé en renvoyant le travail en cours dans la file de\ntravaux ; par exemple un NACK en RabbitMQ.\n* Robustesse face aux morts subites, dans le cas d’une panne du hardware.\nBien que ce soit bien moins courant qu’un arrêt gracieux, cela peut arriver malgré tout.\nL’approche recommandée est l’utilisation d’un broker de message tel que RabbitMQ, capable de renvoyer les tâches dans la\nfile lorsqu’un client se déconnecte ou ne répond plus.\n\n### X Parité dev/prod\n\n*__Gardez le développement, la validation et la production aussi proches que possible__*\n\nLes applications \"12 factor\" sont conçues pour le déploiement continu et la conservation d'un fossé étroit entre les\ndifférents environnements.\n\nLe déploiement continu permet de :\n* Réduire le delta temporel : un développeur peut écrire du code et le déployer quelques heures ou même juste quelques\nminutes plus tard, là où il devait attendre plusieurs jours ou semaines avant de pouvoir mettre en production son\ndéveloppement.\n* Améliorer le workflow : les personnes qui écrivent le code sont impliquées dans son déploiement ; ce qui les\nsensibilise également à la surveillance du comportement en production de son code.\n\nL'autre point à ne pas négliger concerne les outils.\n\nSi l'environnement de production utilise PHP 5.6 et MySQL sur Linux, l'environnement de développements doit utiliser les\nmêmes outils.\nSi le développeur utilise PHP 7.1 et Sqlite sur OS X, il augmente la probabilité d'avoir des comportement non prévus en\nproduction.\n\n### XI Logs\n\n*__Traitez les logs comme des flux d’événements__*\n\nLes logs sont des flux d’événements, ordonnés dans le temps, collectés à travers les flux de sortie de tous les\nprocessus et services externes qui tournent.\nLes logs, dans leur forme brute, sont au format texte avec un événement par ligne, n’ont pas de début ou de fin fixe,\nmais se remplissent en continu tant que l’application est en marche.\n\nUne application \"12 factor\" ne s’inquiète jamais du routage ou du stockage de ses flux de sortie.\nElle ne devrait pas tenter d’écrire ou de gérer les fichiers de logs.\nÀ la place, chaque processus qui tourne écrit ses flux d’événements, sans tampon, vers stdout, la sortie standard.\n\nPar déploiement, les flux de chaque processus seront capturés par leur environnement d’exécution, assemblés avec les\nautres flux de l’application, et routés vers une ou plusieurs destinations pour un visionnage et un archivage de longue\ndurée.\nLe lieu d’archivage n’est pas visible et ne peut être configuré par l’application : ils sont complètements gérés par\nl’environnement d’exécution.\n\n### XII Processus d’administration\n\n*__Lancez les processus d’administration et de maintenance comme des one-off-processes__*\n\nLa formation de processus est la liste des processus qui sont utilisés pour le fonctionnement normal de l’application\n(comme gérer les requêtes web) lorsqu’elle tourne.\nLes développeurs vont souvent vouloir effectuer des tâches occasionnelles d’administration ou de maintenance, comme :\n* Lancer les migrations de base de données.\n* Lancer une console (également appelée terminal REPL).\n* Exécuter des scripts ponctuels inclus dans le dépôt de code.\n\nLes processus ponctuels d’administration devraient être lancés dans un environnement identique à ceux des processus\nstandards de l’application.\nIls s’exécutent sur une release, en utilisant la même base de code et configuration que tout processus qui tourne pour\ncette release.\nLe code d’administration doit être livré avec le code de l’application afin d’éviter les problèmes de synchronisation.\n\nEn PHP, il est possible d'exéctuer un script ponctuel grâce à l'exécutable php suivi du chemin vers le fichier contenant\nle script (par ex. `php scripts/fix_bad_records.php`).\nLe composant [console](https://github.com/symfony/console){:rel=\"nofollow noreferrer\"} de Symfony facilite la création et le test de tâches\nd'administrations.\n"}