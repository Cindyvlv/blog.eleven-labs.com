{"date":"2020-01-22T00:00:00.000Z","title":"Une application React plus réactive - Le lazy load","excerpt":"Dans cet article, nous allons vous présenter le lazy load et comment l’implémenter dans un projet React pour optimiser le chargement de vos pages.","readingTime":"8mn","authors":["kcordier"],"categories":["javascript"],"content":"\n## Intro\n\nBon ! Vous avez fluidifié les interactions de votre application grâce à [l’optimistic ui](https://blog.eleven-labs.com/fr/optimistic-ui-avec-react-et-apollo-js/), vous avez diminué l'impression d’attente lors du chargement de vos pages grâce au [skeleton screen](https://blog.eleven-labs.com/fr/skeleton-screen-avec-react-et-apollo-js/), et malgré tout ça vos pages mettent encore trop longtemps à s'afficher. J’ai une petite question pour vous :\n\nQu’est-ce qui fait en moyenne 50% du poids de votre page (selon [HTTP Archive](https://httparchive.org/)) et qui serait susceptible de ralentir le chargement de notre site ?\n.\n.\n.\nC’est élémentaire mon cher Wilson… Ce sont les **images**.\n\nDonc la solution ici est simple, réduire le poids des images de votre page. Pour cela, il existe une multitude de services en ligne, comme par exemple l'outil de google [squoosh.app](http://squoosh.app). Mais on peut aller encore plus loin.\n\nEt si on n'affichait aucune image ?\n\nLoin de moi l'idée de retourner dans l'ancien temps du web 1.0 et du minitel, mais plutôt d'utiliser la technique du **Lazy loading**\n\n## On m'vois plus, on m'vois\n\nLe **lazy loading** est une technique, aujourd'hui largement répandue dans le web, qui consiste à charger un contenu de manière asynchrone. Cela permet de grandement alléger le poids des pages web en affichant uniquement le contenu nécessaire au bon fonctionnement de la page et ainsi assurer un chargement rapide, ce qui peut de surcroît améliorer votre SEO.\nDans la pratique, cette technique est utilisée pour les médias mais elle est surtout utile pour ne pas charger les contenus qui n’apparaissent pas à l'utilisateur. On peut prendre l'exemple des commentaires d'un article qui ne s'afficheraient uniquement si l'utilisateur a pris la peine de descendre jusqu'en bas de la page.\n\nMalheureusement, il existe un problème avec cette technique, qui est le référencement des données. Les robots des moteurs de recherche n’exécutant pas le JS, il n'est pas possible d'indexer les contenus affichés de manière asynchrone, du moins en partie. Pour les images nous pouvons utiliser la balise  **\\<noscript\\>** qui sera exécutée uniquement dans les cas où le javascript n'est pas actif, et qui permettra à votre moteur de recherche préféré de voir votre image.\n\nMaintenant que nous avons la théorie, mettons-la en pratique avec React.\n\n## Mise en place du lazy loading\n\nL'idée n'est pas de créer un simple composant image mais de créer un hook qui puisse centraliser la logique du lazy loading et être utilisée dans de multiples exemples :\n\n```jsx\n// useIntersectionObserver.jsx\nimport { useState, useEffect } from 'react';\nimport 'intersection-observer';\n\nconst useIntersectionObserver = (ref, { threshold, root, rootMargin } = {}) => {\n  // configure the state\n  const [state, setState] = useState({\n    inView: false,\n    triggered: false,\n  });\n\n  useEffect(() => {\n    let observer;\n    // check that the element exists, and has not already been triggered\n    if (ref.current && !state.triggered) {\n      if (IntersectionObserver) {\n        observer = new IntersectionObserver(\n          (entries, observerInstance) => {\n            // checks to see if the element is intersecting\n            if (entries[0].intersectionRatio <= 0) {\n              return;\n            }\n\n            // unobserve the element\n            observerInstance.disconnect();\n            // if it is update the state, we set triggered as to not re-observe the element\n            setState({\n              inView: true,\n              triggered: true,\n            });\n          },\n          {\n            threshold: threshold || 0,\n            root: root || null,\n            rootMargin: rootMargin || '0%',\n          },\n        );\n      }\n\n      observer.observe(ref.current);\n    }\n\n    return () => {\n      if (observer && observer.unobserve && ref.current) {\n        observer.unobserve(ref.current);\n      }\n    };\n  }, [ref]);\n\n  return [state.inView];\n};\n\nexport default useIntersectionObserver;\n```\n\nIci nous utilisons **IntersectionObserver** (ou vous pouvez trouver la doc [ici](https://developer.mozilla.org/fr/docs/Web/API/Intersection_Observer_API)), cette librairie permet de détecter les possibles intersections entre un élément et la ligne de flottaison.\nCe hook prend en paramètre la référence d'un élément de la page, ainsi que les options de **IntersectionObserver** afin de pouvoir mieux paramétrer au cas par cas. Une fois l’élément détecté dans le champ de vision, nous changeons un state qui est renvoyé aux clients de notre hook, tout en pensant bien à nous déconnecter de l'observer.\n\nGrâce à ce hook nous pouvons ainsi créer notre composant d'image \"**lazy loaded**\" comme ceci :\n\n```jsx\n// ImageLazyLoad.jsx\n\nimport React, { useRef, useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\n\nimport { useIntersectionObserver } from '../../hooks';\nimport SkeletonItem from '../SkeletonItem';\n\nconst _loaded = {};\n\nconst ImageLazyLoad = ({ className, url, alt, placeholder = null, forcePreloadImage = false }) => {\n  const elementRef = useRef(null);\n  const [inView] = useIntersectionObserver(elementRef);\n  const [loaded, setLoaded] = useState(_loaded[url]);\n\n  useEffect(() => {\n    if (inView) {\n      if (_loaded[url]) {\n        setLoaded(true);\n\n        return;\n      }\n\n      const img = new Image();\n      img.src = url;\n      img.onload = () => {\n        _loaded[url] = true;\n        setLoaded(true);\n      };\n    }\n  }, [inView]);\n\n  return (\n    <div ref={elementRef} className={className ? `${className}-wrapper` : null}>\n      {!loaded ? (\n        placeholder ? (\n          placeholder\n        ) : (\n          <SkeletonItem className={className} />\n        )\n      ) : (\n        <img src={url} className={className} alt={alt} />\n      )}\n      <noscript>\n        <img src={url} className={className} alt={alt} />\n      </noscript>\n    </div>\n  );\n};\n\nexport default ImageLazyLoad;\n```\n\nDans ce composant nous utilisons le retour de **useIntersectionObserver** afin de savoir quand charger l'image. Pour cela nous utilisons l'objet **Image**  et sa fonction **onLoad**  qui nous permet de savoir quand l'image à fini de charger et ainsi quand interchanger le placeholder (par défaut le skeleton item créé dans cet [article](https://blog.eleven-labs.com/fr/skeleton-screen-avec-react-et-apollo-js/) ) et l'image définitive. On n'oublie pas de rajouter une seconde image dans une balise **\\<noscript\\>** afin de référencer notre image.\n\nVoici le résultat :\n\n![](/imgs/posts/2020-01-22-lazy-load-react/image-lazy-load.gif)\n\nSi vous voulez un effet d'image floue comme le fait le site **Medium**, c'est possible.\n\n![](/imgs/posts/2020-01-22-lazy-load-react/medium-lazy-load.jpeg)\n\nLa technique la plus simple est d'afficher une image de petite taille (et donc moins lourde), et de l’étirer à la taille souhaitée. Dans notre exemple nous pouvons déclarer en paramètre de placeholder l'image que nous adapterons au contenu grâce au CSS.\n\n```jsx\n<ImgLazyLoad\n  url={`https://picsum.photos/200/200/?image=${index}`}\n  alt={'alt'}\n  className={'image'}\n  placeholder={<img className={'placeholder'} src={`https://picsum.photos/30/30/?image=${index}`} alt={'alt'} />}\n/>\n```\n\nVoici le résultat :\n\n![](/imgs/posts/2020-01-22-lazy-load-react/image-lazy-load-blur.gif)\n\nEt ceci n'est qu'un exemple parmi tant d'autres.\n\n## Conclusion\n\nEn conclusion nous pouvons dire que le **lazy loading** est un concept très important du web d'aujourd'hui. Que ce soit le besoin de rapidité des applications ou la nécessité d'économiser de la bande passante pour les mobiles, il y a toujours une bonne raison de l'intégrer.\nPour en finir avec les images de vos applications, il est bon à savoir que si vous êtes \"too lazy\" pour mettre en place ce que je vous ai proposé plus haut, les navigateurs récents commencent à mettre en place du **lazy loading native** grâce à l’attribut \"**loading=lazy**\" à intégrer dans vos balises img.\n\nC'est ainsi que se finit ma suite d'articles sur les techniques permettant d'améliorer l’expérience utilisateur de votre site. Si vous avez appliqué les trois concepts de ce triptyque alors félicitation, votre application React est officiellement plus réactive.\n"}