{"date":"2017-09-15T00:00:00.000Z","title":"Mise en place d'un Workflow Continuous Delivery avec Fastlane pour IOS ou Android","excerpt":"Nous allons découvrir un outil qui permet d'automatiser des tâches fastidieuses en mobile.","readingTime":"16mn","authors":["ibenichou"],"categories":[],"content":"\n# Qu'est-ce que \"Fastlane\"\n\nFastlane est un outil open-source qui permet de faire du **Continuous Delivery** sous IOS et Android.\nIl permet d'automatiser un certain nombre de tâches fastidieuses comme gérer les sreenshots, les certificats, déployer votre app...\n\nVous l'avez compris, cet outil va changer votre vie.\n\nVoici la liste des libs à disposition avec Fastlane :\n\n![Fastlane tools](/imgs/posts/2017-07-17-fastlane-ios/fastlane_tools.png){:width=\"400px\"}\n\n* **Deliver**: Télécharge des captures d'écran, des métadonnées et votre application sur l'App Store en utilisant une seule commande.\n* **Snapshot**: Automatise la prise des captures d'écran localisées de votre application iOS sur tous les périphériques.\n* **Frameit**: Place rapidement vos captures d'écran dans les cadres appropriés (iphone, ipad...).\n* **Pem**: Génére et renouvèle automatiquement vos profils de notification push.\n* **Sigh**: Crée, renouvèle, télécharge et répare des profils de provisionnement.\n* **Produce**: Crée de nouvelles applications iOS sur le portail développeur Apple et iTunes Connect avec les informations minimales requises.\n* **Cert**: Crée automatiquement et conserve des certificats de signature.\n* **Scan**: Facilite l'exécution des tests de votre application iOS et Mac sur un simulateur ou un périphérique connecté.\n* **Gym**: Build et package votre application.\n* **Match**: Synchronise facilement vos certificats et profils de provisionnement à travers votre équipe en utilisant Git.\n\nSe rajoute également à cette liste :\n\n* **Pilot**: Gère vos testeurs TestFlight à partir de votre terminal\n* **Boarding**: Permet la création d'une page d'inscription simple pour les testeurs bêta TestFlight\n\n*Schéma de lanes fastlane*\n\n![Fastlane tree](/imgs/posts/2017-07-17-fastlane-ios/fastlane-tree.png){:width=\"400px\"}\n\nPersonnellement, quand j'ai vu ce que Fastlane était capable de faire j'ai limite versé une petite larmichette !\nFini le temps de tout faire à la main !\n\n*Note* : J'ai créé un projet \"bidon\" avec différents écrans et tests pour cet article.\n\n# Premiers pas\n\n#### Installation\n\n*Prérequis* : ruby >= 2.0\n\nJe vous recommande de créer un `Gemfile` pour définir les éventuelles dépendances de Fastlane.\n\n```\nsource \"https://rubygems.org\"\n\ngem \"fastlane\"\n```\n\n```\n$ bundle install\n```\n\n#### Initialisation\n\nLancer la commande suivante :\n\n```\n$ bundle exec fastlane init\n```\n\nOn vous demandera votre Apple ID, mot de passe et dans mon cas un digit code via mon Iphone.\nFastlane vous récapitulera vos informations dans  `Summary for produce` et créera votre application dans Itunes Connect et Dev Center.\nIl générera également une configuration pour vous, en fonction des informations fournies.\n\n![Fastlane files](/imgs/posts/2017-07-17-fastlane-ios/fastline-files.png){:width=\"400px\"}\n\n**Appfile**: L'Appfile stocke des informations utiles qui sont utilisées dans toutes les libs Fastlane comme votre Apple ID ou le Bundle Identifier, pour déployer vos **lanes** (voies) plus rapidement, adaptées aux besoins de votre projet.\n\nPar défaut, ce fichier ressemble à :\n\n```\napp_identifier \"com.eleven.fastlane\" # Bundle identifier de votre app\napple_id \"obiwan@kenobi.com\"  # Votre Apple adresse email\n```\n\nSi vous avez des identifiants différents pour Itunes Connect et Apple Developer, vous pouvez utiliser le code suivant :\n\n```\napp_identifier \"tools.fastlane.app\"       # Bundle identifier de votre app\n\napple_dev_portal_id \"portal@company.com\"  # Votre Apple adresse email\nitunes_connect_id \"tunes@company.com\"     # Votre Itunes Connect adresse email\n\nteam_id \"Q2CBPJ58CA\" # Le team ID du Developer Portal\nitc_team_id \"18742801\" # Le team ID du iTunes Connect\n```\n\nSi vous souhaitez accéder à ces valeurs :\n\n```\nidentifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)\nteam_id = CredentialsManager::AppfileConfig.try_fetch_value(:team_id)\n```\n\n**Fastfile**: Fichier ruby qui définit toutes vos lanes. Une lane est un ensemble d'instructions que vous souhaitez faire éxécuter par Fastlane.\n\n``` ruby\n# Fastfile - J'ai clean le fichier et j'ai créé une lane test\nfastlane_version \"2.39.2\"\n\ndefault_platform :ios\n\nplatform :ios do\n  desc \"Runs all the tests\"\n  lane :test do\n    scan # lib Fastlane qui lance vos tests.\n  end\nend\n```\n\nSi vous lancez un :\n```\n$ bundle exec fastlane test\n```\n\nIl lance alors tous les unit/ui tests de votre projet. Bien évidemment, Scan peut générer des rapports au format HTML, JSON et JUnit.\n\n![CLI scan](/imgs/posts/2017-07-17-fastlane-ios/cli-scan.png){:width=\"900px\"}\n\nMagique non ?\n\nNous allons partir du principe que je travaille en collaboration avec pleins de devs mobile sur ma super application.\nLe problème se pose au niveau des certificats et profils de provisionnement.\nHeureusement Fastlane nous met à disposition **Match**.\n\n# Match\n\nMatch implémente le concept de [codesigning guide](https://codesigning.guide){:rel=\"nofollow noreferrer\"}.\nIl permet de créer tous vos certificats et profils de provisionnement dans un compte Git distinct.\nChaque membre de l'équipe ayant accès au repo peut utiliser ces credentials pour la signature de code.\n\nMatch répare également automatiquement les credentials brisés et expirés.\nCeci est bien évidement [sécurisé](https://github.com/fastlane/fastlane/tree/master/match#is-this-secure){:rel=\"nofollow noreferrer\"}.\n\n*Note* : L'implémentation de match vous oblige à révoquer vos certificats existants.\n\nSi vous ne voulez pas révoquer vos certificats existants, mais souhaitez toujours une configuration automatisée, cert et sigh sont là pour vous.\n\n* **Cert** : Veillera à ce que vous ayez un certificat valide et sa clé privée installée sur votre machine.\n* **Sigh** : Veillera à ce que vous ayez un provisioning profile valide installé sur votre machine, qui correspond au certificat installé.\n\n#### Configuration\n\n```\n$ bundle exec fastlane match init\n```\n\n![](https://github.com/fastlane/fastlane/raw/master/match/assets/match_init.gif){:rel=\"nofollow noreferrer\"}\n\nCela vous demandera d'entrer l'url de votre repo Git. Vous pouvez aussi utiliser un lien git@ si votre machine peut se connecter en SSH sur ce repo.\n\n*Note* : Cette commande ne lit ou modifie pas les certificats ou profils.\n\nCela va créer un fichier `Matchfile` qui ressemble à :\n\n```\ngit_url \"https://gitlab.com/prims47/fastlane_article.git\"\n\ntype \"development\" # Le type par défaut, il peut être appstore, adhoc, enterprise ou development\n\n# app_identifier [\"tools.fastlane.app\", \"tools.fastlane.app2\"]\n# username \"user@fastlane.tools\" # Votre Apple Developer Portal username\n```\n\nMatch prend également en charge le stockage des certificats de plusieurs équipes dans un repo, en utilisant des branches.\nSi vous travaillez dans plusieurs équipes, assurez-vous de définir le paramètre git_branch à une valeur unique par équipe.\nDe là, la correspondance créera et utilisera automatiquement la branche spécifiée pour vous.\n\n```\n#Fastfile\nmatch(git_branch: \"team1\", username: \"user@team1.com\")\nmatch(git_branch: \"team2\", username: \"user@team2.com\")\n```\n\n\nAvant d'exécuter match pour la première fois, vous devriez envisager de supprimer vos profils et certificats existants à l'aide de la commande [match nuke](https://github.com/fastlane/fastlane/tree/master/match#nuke){:rel=\"nofollow noreferrer\"}.\n\nExécuter match :\n\n```\n$ bundle exec fastlane match appstore\n```\n\n![](https://github.com/fastlane/fastlane/raw/master/match/assets/match_appstore_small.gif){:rel=\"nofollow noreferrer\"}\n\nCela créera un nouveau certificat et un profil de provisionnement (si nécessaire) et les stockera dans votre repo Git.\nSi vous avez précédemment exécuté match, il installera automatiquement les profils existants à partir du repo Git.\n\nLes provisioning profiles sont installés dans ~ / Library / MobileDevice / Provisioning Profiles alors que les certificats et les clés privées sont installés dans votre Keychain.\n\n**Comment faire si vous devez ajouter un nouveau device ?**\n\nNon on ne va pas se connecter et le faire à la main !\nOn va utiliser l'action [register_devices](https://docs.fastlane.tools/actions/#register_devices){:rel=\"nofollow noreferrer\"} en combinaison avec match.\n\n```ruby\nlane :recette do\n  register_devices(devices_file: \"./devices.txt\")\n  match(type: \"adhoc\", force_for_new_devices: true)\nend\n```\n\n```\n#devices.txt\nDevice ID\tDevice Name\nA123456789012345678901234567890123456789\tNAME1\nB123456789012345678901234567890123456789\tNAME2\n```\n\nEn utilisant le paramètre `force_for_new_devices`, match va checker si le nombre de devices a changé depuis la dernière\nexécution et regénère automatiquement le profil de provisionnement si nécessaire.\n\nVous pouvez utiliser aussi `force: true` pour générer le profil de provisionnement à chaque exécution.\n\n#### Paramétrer Xcode\n\nAvec Xcode 8 vous pouvez définir un profil de provisionnement pour chaque target au lieu d'un provisioning profile UUID.\nEn faisant ça, Xcode sélectionne automatiquement le dernier provisioning profile corresponddant à son nom.\nDe cette manière, vous n'aurez pas à mettre à jour Xcode à chaque fois que vous générez un profil de provisionnement (ex: Quand vous ajoutez un nouveau device).\n\nVous pouvez spécifier quel profil de provisionnement utiliser dans `General` tab après avoir désactivé `Automatically manage signing`.\n\n![](/imgs/posts/2017-07-17-fastlane-ios/fastlane_xcode_sign.png){:width=\"600px\"}\n\nOn vient de voir avec quelle facilité on gère les certificats et profils de provisionnement. Maintenant on va s'attaquer au push notification profile.\n\n# PEM\n\nSi vous avez lu mon précédent article [Envoyer des push notifications via Amazon SNS en Swift 3](/fr/envoyer-push-notifications-amazon-sns-swift-3/), vous avez vite compris que c'était super \"galère\" de faire ceci à la main.\n\nMais ça c'était avant !\n\nPem est venu me sauver de cette tâche fastidieuse !\n\n`pem` permet de :\n\n* Créer un nouveau signing request\n* Créer un certificat push\n* Télécharger le certificat\n* Générer le nouveau fichier `.pem` dans le dossier courrant.\n\n`pem` ne permet pas de :\n* Couvrir la partie upload sur votre serveur/service.\n* Révoquer vos certificat existants.\n* Télécharger n'importe quel certificat existant car la clé privée n'est disponible que sur la machine sur laquelle elle a été créée.\n\nSi vous avez déjà activé un certificat push pendant au moins 30 jours, pem ne créera pas de nouveau certificat.\nSi vous voulez quand même en créer un, vous pouvez utiliser l'option `force`\n\n```ruby\n#Fastfile\ndesc \"Generate Push Certificate\"\n  lane :pushCertificat do\n    #pem(new_profile: Proc.new do |value|\n        # Code pour upload votre fichier pem sur votre serveur/service.\n      #end)\n\n    pem(generate_p12: true, save_private_key: true, p12_password: \"1234\",\n    \tpem_name: \"fastlane_pem_file\", output_path: \"/Users/prims47/Desktop/blog/Fastlane/push_certificates\", development: true\n    )\nend\n```\n\n\n```\n$ bundle exec fastlane pushCertificat\n```\n\n![](/imgs/posts/2017-07-17-fastlane-ios/fastlane_pem.jpg)\n\nEt hop, un jeu d'enfant !\n\n![](/imgs/posts/2017-07-17-fastlane-ios/fastlane_pem_apple.jpg)\n\n# Scan\n\nComme vous l'avez vu au début de l'article, `scan` permet de lancer tous les tests (sur simulateur ou device) de votre projet.\nDans le projet que je me suis créé, j'ai bien évidemment ajouté quelques tests afin de vous montrer ce qu'on peut faire.\n\nPremière chose à faire c'est d'initialiser le fichier `Scanfile` afin de configurer les paramètres par défaut :\n\n```\n$ bundle exec fastlane scan init\n```\n\n\n```\n#Scanfile\n\n#workspace \"FastlaneArticle.xcodeproj\"\nscheme \"FastlaneArticle\"\nclean true #Clean le projet à chaque execution\ncode_coverage true\n#slack_only_on_failure true\n\n#Vous pouvez spécifier sur quel iphone ou ipad vous souhaitez lancer les tests.\n#devices [\n#  \"iPhone 6s\",\n#  \"iPhone 7\"\n#]\"]\n```\n\n\nUne bonne pratique est de notifier Slack lorsque les tests sont failed. J'ai donc ajouté dans mon fichier `Fastfile` la configuration Slack :\n\n```ruby\n#...\n\nplatform :ios do\n  before_all do\n    ENV[\"SLACK_URL\"] = \"https://hooks.slack.com/services/XXXXXX\" # URL Webhook créé via Slack.\n  end\n\n  desc \"Runs all the tests\"\n  lane :test do\n    scan()\n  end\n\n  #...\nend\n```\n\n*Résultat sur Slack*\n\n![](/imgs/posts/2017-07-17-fastlane-ios/fastlane_scan_success.png){:width=\"180px\"}\n![](/imgs/posts/2017-07-17-fastlane-ios/fastlane_scan_error.png){:width=\"200px\"}\n\n# Snapshot - Frameit\n\nSi vous devez manuellement créer des screenshots pour 20 langues x 6 devices x 5 screenshots (car 5 écrans différents) = 600 screenshots. On voit tout de suite la quantité de travail énorme que demandent les screenshots.\n\nLes screenshots sont une partie importante car cela influence beaucoup l'utilisateur sur votre application.\n\nFastlane nous met à disposition deux librairies géniales, `snapshot` et `frameit`.\n\n* **Snapshot** : Comme son nom l'indique, cela génère localement les screenshots pour différents devices et langues.\nOn verra par la suite comment les uploader en utilisant `deliver`\n* **Frameit** : Permet de mettre votre screenshot créé par `snapshot` dans un cadre de périphérique tel qu'un iphone, ipad.\n\n### Snapshot\n\nInstallation de `snapshot` :\n\n```\n$ bundle exec fastlane snapshot init\n```\n\nCette commande va créer deux fichiers :\n\n* `SnapshotHelper.swift` : Helper pour effectuer les screenshots\n* `Snapfile` : Pour configurer `snapshot`\n\nIl faut tout d'abord ajouter le fichier `SnapshotHelper.swift` à notre target d'UI Tests.\nPuis dans notre classe d'ui test, dans la méthode `setUp`, il faut initialiser snapshot.\n\n```swift\noverride func setUp() {\n    super.setUp()\n    // In UI tests it is usually best to stop immediately when a failure occurs.\n    continueAfterFailure = false\n\n    let app = XCUIApplication()\n    setupSnapshot(app)\n    app.launch()\n}\n```\n\nDans chaque test il faut faire appel à la méthode `snapsot(\"Nom du screen\")`.\n\n```swift\nfunc testCarList() {\n    let app = XCUIApplication()\n\n    //Take screenshot\n    snapshot(\"01CarList\")\n}\n\nfunc testCarDetail() {\n        let app = XCUIApplication()\n        app.collectionViews.cells.otherElements.containing(.staticText, identifier:\"Dodge\").children(matching: .other).element.forceTap()\n\n        //Take screenshot\n        snapshot(\"02CarDetail\")\n    }\n```\n\n**Attention !**\n\nPour une raison étrange sur certain devices (dans mon cas iphone 5) avec certaines langues le ``tap()``ne marche pas.\nIl faut créer une méthode qui va forcer celui-ci.\n\n```swift\nextension XCUIElement {\n    func forceTap() {\n        if self.isHittable {\n            self.tap()\n        }\n\n        let coordinate: XCUICoordinate = self.coordinate(withNormalizedOffset:  CGVector(dx:0.0, dy:0.0))\n        coordinate.tap()\n    }\n}\n```\n\nConfiguration de votre `Snapfile`\n\n```\n# Snapfile\n\n# Liste des devices sur lesquels je souhaite avoir des screenshots\ndevices([\n  \"iPhone 5s\",\n  \"iPhone 6\",\n  \"iPhone 6 Plus\",\n  \"iPhone 7\",\n  \"iPhone 7 Plus\"\n])\n\n# En anglais et en français\nlanguages([\n  \"en-US\",\n  \"fr-FR\"\n])\n\nscheme \"FastlaneArticle\"\n\n# Super important sinon vous allez avoir une erreur\nproject \"../FastlaneArticle.xcodeproj\"\n\n# Plaçons-les dans ./screenshots\noutput_directory \"./screenshots\"\n\n# Et avant chaque exécution, on clean\nclear_previous_screenshots true\n```\n\nLancer la commande\n\n```shell\n$ bundle exec fastlane snapshot\n```\n\nBon c'est le moment d'aller prendre un café ou de manger une pomme ! (Oui les pommes c'est la vie ! :) )\n\n15 minutes plus tard...\n\nFastlane vous crée une page HTML récapitulant tous les devices par langues.\n\n![](/imgs/posts/2017-07-17-fastlane-ios/fastlane_snapshot_success.png){:width=\"200px\"}\n![](/imgs/posts/2017-07-17-fastlane-ios/fastlane_snapshot.png)\n\nCool non ?\n\nVous pouvez fournir des arguments supplémentaires à votre application lors du lancement.\nEn effet, vous pouvez ajouter des valeurs à votre `UserDefaults.standard`\n\n```\nlaunch_arguments([\n  \"-firstName Hatem -lastName Ben Arfa\"\n])\n```\n\n```swift\nname.text = UserDefaults.standard.string(forKey: \"firstName\")\n// name.text = \"Hatem\"\n```\n\nFastlane inclut `FASTLANE_SNAPSHOT`, qui permet de définir temporairement un `UserDefaults.standard`.\nVous pouvez l'utiliser pour détecter quand l'application est exécutée par Snapshot.\n\n```swift\nif UserDefaults.standard.bool(forKey: \"FASTLANE_SNAPSHOT\") {\n    // Check si vous utilisez le mode snapshot\n}\n```\n\nBon, maintenant qu'on a nos beaux screenshots, on va rajouter de beaux cadres non ? Allez c'est parti.\n\n### Frameit\n\n*Prérequis*\n\nPour utiliser `Frameit`, il faut avoir sur votre machine [ImageMagick](https://www.imagemagick.org/script/index.php){:rel=\"nofollow noreferrer\"}.\n\nSur mac, il suffit de faire :\n\n```shell\n$ brew install imagemagick\n```\n\nVous pouvez dès à présent essayer ce petit bijou via :\n\n```shell\n# Executer cette command dans votre dossier ou ce situe les screenshots.\n$ bundle exec fastlane frameit\n```\n\nVous avez normalement de nouvelles images qui sont arrivées telles que :\n\n![](/imgs/posts/2017-07-17-fastlane-ios/iPhone6Plus-02CarDetail-d41d8cd98f00b204e9800998ecf8427e_framed.png){:height=\"600px\"}\n\nEt si vous avez envie d'avoir l'iphone rose on fait comment ?\n\n```shell\n# Tout d'abord, mettez à jour votre liste de frames\n$ bundle exec fastlane frameit download_frames\n\n$ bundle exec fastlane frameit rose_gold\n```\n\n![](/imgs/posts/2017-07-17-fastlane-ios/iPhone6-01CarList-d41d8cd98f00b204e9800998ecf8427e_framed.png){:height=\"600px\"}\n\nVous trouverez la liste des frames [ici](https://github.com/fastlane/frameit-frames/tree/gh-pages/latest){:rel=\"nofollow noreferrer\"}.\n\nBon, c'est pas mal mais on peut encore faire mieux. Comment ? En rajoutant un titre à ce beau screenshot.\n\nDans la version 2.0 de Frameit vous pouvez maintenant ajouter un fond custom, un titre et des couleurs à vos screenshots.\n\nCréer un fichier `Framefile.json` dans le dossier screenshots.\n\n```json\n{\n  \"device_frame_version\": \"latest\",\n  \"default\": {\n    \"title\": {\n      \"color\": \"#545454\"\n    },\n    \"background\": \"./background.jpg\", // Ajoute un background\n    \"padding\": 50,\n    \"show_complete_frame\": true, // Retrécit le device et le cadre afin de tout afficher\n    \"stack_title\" : false // Spécifie si frameit doit afficher le mot-clé au-dessus du titre lorsque le mot-clé et le titre sont définis.\n  },\n  \"data\": [\n    {\n      \"filter\": \"01CarList\", // Si votre sreenshot se nomme Iphone iPhone6-01CarList-*.png alors il utilisera ses paramètres\n      \"title\": {\n        \"text\": \"Mes voitures\",\n        \"padding\": 100,\n        \"color\": \"#d21559\"\n      }\n    },\n    {\n      \"filter\": \"02CarDetail\",\n      \"title\": {\n        \"text\": \"Ma mustang\",\n        \"padding\": 100\n      }\n    }\n  ]\n}\n```\n\n![](/imgs/posts/2017-07-17-fastlane-ios/iPhone6-01CarList-d41d8cd98f00b204e9800998ecf8427e_framed_custom.png){:height=\"600px\"}\n![](/imgs/posts/2017-07-17-fastlane-ios/iPhone6-02CarDetail-d41d8cd98f00b204e9800998ecf8427e_framed_custom.png){:height=\"600px\"}\n\nAvouez c'est bad ass ? :)\n\n# Gym\n\nGym build et package vos applications iOS pour vous. Il génére un fichier `ipa` ou `app` .\n\nInstallation de `gym` afin de configurer les paramètres par défaut :\n\n```shell\n$ bundle exec fastlane gym init\n```\n\nConfiguration de votre `Gymfile`\n\n```\nscheme \"FastlaneArticle\"\n\nclean true\n\nsdk \"iphoneos10.3\" # Le SDK qui devra être utilisé pour le build de l'application\n\noutput_directory \"../build\" # Chemain où nous allons stocker le fichier .ipa\noutput_name \"Fastlane\"\n\nsilent true # Cache toutes les informations qui ne sont pas nécessaire pendant le build\n\n#configuration => Configuration utilisée pour le build. Par défaut la valeur est Release\n```\n\nNous allons créer une **lane** pour builder notre application pour Apple TestFlight\n\n```ruby\ndesc \"Submits to Apple TestFlight\"\n  lane :buildTestFlight do\n    match(app_identifier: \"com.eleven.fastlane.debug\", type: \"appstore\")\n    increment_build_number # Incrémente le chiffre du build de votre projet\n    gym(configuration: \"Debug\")\nend\n```\n\n```shell\n$ bundle exec fastlane buildTestFlight\n```\n\n*Note* : Il se peut que vous ayez une erreur dûe au fait que vous n'ayez pas de bundle identifié sur Itunes Connect. Pour remédier à ça, il faut juste en créer un via :\n\n```shell\n$ bundle exec fastlane produce -u MAIL -a com.eleven.fastlane.debug --skip_itc\n```\n\nAvouez que c'est plus facile que de le faire soi-même. Maintenant on va voir comment envoyer notre fichier ipa pour le tester via TestFlight.\n\n# Pilot\n\nPilot permet de :\n\n* Uploader et distribuer vos builds\n* Ajouter et supprimer vos testeurs\n* Récupérer des informations sur les testeurs et les devices\n* Import/export tous les testeurs disponibles\n\nPour uploader un nouveau build vous pouvez exécuter la commande:\n\n```shell\n$ bundle exec fastlane pilot upload\n```\n\nCela recherchera automatiquement un ipa dans votre répertoire courant et tentera de récupérer les informations d'identification\nde connexion à partir de votre configuration Fastlane.\n\n*Note* : Pensez bien à créer votre application sur Itunes Connect avant.\n(ou utilisez la lib [produce](https://github.com/fastlane/fastlane/tree/master/produce)){:rel=\"nofollow noreferrer\"}\n\nNous pouvons reprendre notre **lane** précédement créée et y rajouter l'instruction `pilot`\n\n```ruby\ndesc \"Submits to Apple TestFlight\"\n  lane :buildTestFlight do\n    match(app_identifier: \"com.eleven-labs.testflight\", type: \"appstore\")\n    increment_build_number # Increment le chiffre du build de votre projet\n    gym(configuration: \"Debug\", include_bitcode: true)\n    pilot(app_identifier: \"com.eleven-labs.testflight\", ipa: \"../build/Fastlane.ipa\")\nend\n```\n\n```shell\n$ bundle exec fastlane buildTestFlight\n```\n*Note*:\n1. Si comme moi vous avez une double identification via votre téléphone, il suffit de se connecter [ici](https://appleid.apple.com/account/manage){:rel=\"nofollow noreferrer\"} et de générer un password dans la section Security > APP-SPECIFIC PASSWORDS\n2. Vérifiez sur votre Itunes Connect le bundle identifier renseigné.\n\n# Deliver\n\nIl est temps de mettre en prod votre application sur Itunes Connect.\n\n```shell\n# Comme d'habitude on initialise\n$ bundle exec fastlane deliver init\n```\n\n```\n# Deliverfile\nusername \"yourItunesEmail@eleven-labs.com\"\n```\n\nIl vous suffit dans votre lane d'ajouter l'instruction :\n\n```ruby\ndeliver(force: true) # Force: true pour skip le repport HTML de verification\n```\n\nVous devriez avoir un nouveau folder metadata qui vient d'apparaître.\n\n![](https://raw.githubusercontent.com/fastlane/fastlane/master/deliver/assets/metadata.png){:rel=\"nofollow noreferrer\"}\n\nÀ vous maintenant de mettre à jour ces metadata.\n\n# Conclusion\n\nSi vous n'êtes pas tombés amoureux de Fastlane je ne comprends pas, vous aimez souffrir :)\nOn voit très rapidement que ce petit bijou nous fait gagner un temps monstre et nous évite de faire une erreur humaine (l'avantage de l'automatisation).\nAprès quelques tests et configurations vous pouvez facilement reprendre vos scripts pour les réutiliser sur d'autres projets.\n"}