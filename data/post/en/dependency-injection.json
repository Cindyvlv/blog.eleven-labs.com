{"date":"2021-09-29T00:00:00.000Z","title":"Dependency injection in Symfony","excerpt":"You work with Symfony, but the concept of dependency injection is a little blurry for you? Find out how to take advantage of the component reading this article.","readingTime":"10mn","authors":["marishka"],"categories":["php"],"content":"\n## Dependency injection\nDependency injection is a mechanism that implements the principle of inversion of control.\nThe idea is to create dynamically (_inject_) dependencies of a class using a description (a configuration file for example).\nThis method will allow us to no longer express dependencies between components in the code statically, but to determine them dynamically at execution.\n\nLet's take an example to illustrate this. Imagine that we have a class _A_, that depends on classes _B_ and _C_.\nIn my code I would need to do this:\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass B implements InterfaceB {\n    // ...\n}\n```\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass C implements InterfaceC {\n    // ...\n}\n```\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass A {\n    private B $b;\n    private C $c;\n\n    public function __construct()\n    {\n        $this->b = new B();\n        $this->c = new C();\n    }\n\n    // ...\n}\n```\n\nWith dependency injection, I will no longer need to create instances of classes _B_ and _C_ manually, I will inject them instead:\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass A {\n    private InterfaceB $b;\n    private InterfaceC $c;\n\n    public function __construct(InterfaceB $b, InterfaceC $c)\n    {\n        $this->b = $b;\n        $this->c = $c;\n    }\n\n    // ...\n}\n```\n\nSince PHP 8, I can even do this:\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass A {\n    public function __construct(\n        private InterfaceB $b,\n        private InterfaceC $c,\n    ) {\n    }\n\n    // ...\n}\n```\n\nInstances of classes _B_ and _C_ will be created by a class whose responsibility is to read configuration files and create objects.\n\nThe main advantage of dependency injection is to separate the creation of objects from their use.\nMoreover, by injecting our dependencies, we can use interfaces instead of classes and thus avoid a strong coupling between our classes.\n\n## In Symfony\nIn Symfony framework, dependency injection is done via the service _Container_, which is built by _ContainerBuilder_. The latter is initialized by the _Kernel_.\n\n### Service Container\nIn a production environment, the kernel will first look for a cached version of the _Container_ for performance concerns.\nIf it exists, the cached version is used. Otherwise, the kernel will build one based on our application's configuration.\n\nAs you know, our Symfony application's configuration is done in the _config_ folder.\nThe _ContainerBuilder_ will parse all configuration files of our application, and fetch all parameters and services that we have declared, as well as those of our dependencies.\nIt will take into account, among other things, tagged services and _Compiler passes_ (see below).\nOnce the compilation is done, a cached version of the _Container_ will be _dumped_ to be used in the following calls.\n\nTo learn more about this process, you can [read the documentation](https://symfony.com/doc/current/components/dependency_injection/workflow.html).\n\n### Service declaration\nLet's go back to our previous example, and learn how to declare our classes as services:\n\n```yaml\n# config/services.yaml\nservices:\n    App\\Services\\B:\n\n    App\\Services\\C:\n\n    App\\Services\\A:\n        arguments:\n            - '@App\\Services\\B'\n            - '@App\\Services\\C'\n```\n\nI configure each of my services separately.\nTo inject one service into another, I pass it as an argument of the second service, prefixing it with an '@'.\n\n### Autowiring\nSince version 3.4 of Symfony, we have the possibility to use the _autowiring_, which will prevent me from declaring all the services by hand:\n\n```yaml\n# config/services.yaml\nservices:\n    # configuration of default services in *this* file\n    _defaults:\n        autowire: true      # automatically inject dependencies in our services\n        autoconfigure: true # automatically declare our services as commands, event subscribers, etc.\n\n    # make classes in src/ available to be used as services\n    # this will create a service per class\n    App\\:\n        resource: '../src/*'\n        exclude: '../src/{DependencyInjection,Entity,Tests,Kernel.php}'\n\n    # ...\n```\n\nIn our services, we can inject not only other services, but also the parameters configured in the application.\nHere's an example:\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass AdminMailer {\n    private string $recipient;\n\n    public function __construct(string $adminEmail)\n    {\n        $this->recipient = $adminEmail;\n    }\n\n    // ...\n}\n```\n\n```yaml\n# config/services.yaml\nservices:\n    _defaults:\n        bind:\n            # any argument called $adminEmail in a constructor will have this value\n            $adminEmail: 'admin@example.com'\n```\n\nThese are basic examples to give you an overview of dependency injection.\nI invite you to read the [Symfony documentation on dependency injection](https://symfony.com/doc/current/service_container.html) for a global view of what is possible to do, this component is very powerful!\n\n## Tagged services\nThose who have been using Symfony for some time have probably already encountered tagged services.\nTagged services are a way to tell Symfony that your service needs to be loaded in a certain way.\nTake the following example: I want to format the exceptions in my application, for that I am going to intercept a specific event.\n\n```yaml\n# config/services.yaml\nservices:\n    App\\EventListener\\ExceptionListener:\n        tags:\n            - { name: kernel.event_listener, event: kernel.exception }\n```\n\nAll services tagged `kernel.event_listener` are loaded by the `FrameworkBundle` and are called depending on the event they are linked to.\nThere is a [multitude of tags available in Symfony](https://symfony.com/doc/current/reference/dic_tags.html), each one has a specific role.\nThus, you can act on events as seen above, as well as add Twig extensions, interact on an entity's serialization process, etc.\n\n## Custom tags and Compiler passes\nNow imagine that in my application I have a document generation system.\nI would like to implement a clean and easily maintainable solution, with a central service which, depending on the type of document desired, will delegate the generation of the document to the right service.\n\nFor this, I will create a generator per desired document type, tag them with a custom tag, and then inject them into my main document generation service.\n\nInitially, I create an interface for my generators, to make sure they all behave the same:\n\n```php\n<?php\n\nnamespace App\\Services;\n\ninterface DocumentGeneratorInterface {\n    public function supports(string $type): bool;\n    public function generate(array $data): mixed;\n}\n```\n\nNext, I prepare my main document generation service. Only it will be injected into services in my application where I will need to generate a document:\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass DocumentGenerator {\n    private array $documentGenerators;\n\n    public function addGenerator(DocumentGeneratorInterface $generator): void\n    {\n        $this->documentGenerators[] = $generator;\n    }\n\n    public function generate(array $data, string $type): mixed\n    {\n        /** @var GeneratorInterface $generator */\n        foreach ($this->documentGenerators as $generator) {\n            if (!$generator->supports($type)) {\n                continue;\n            }\n\n            return $generator->generate($data);\n        }\n\n        throw new \\LogicException(sprintf('Document of type %s cannot be handled', $type));\n    }\n}\n```\n\nFinally, I implement my generators by document type:\n```php\n<?php\n\nnamespace App\\Services;\n\nclass PDFDocumentGenerator {\n    public function supports(string $type): bool\n    {\n        return $type === 'pdf';\n    }\n\n    public function generate(array $data): mixed\n    {\n        // generation du document\n    }\n}\n```\n\n```php\n<?php\n\nnamespace App\\Services;\n\nclass CSVDocumentGenerator {\n    public function supports(string $type): bool\n    {\n        return $type === 'csv';\n    }\n\n    public function generate(array $data): mixed\n    {\n        // generation du document\n    }\n}\n```\n\nTo tell dependency injection that my generators must have a specific tag, I can declare it this way:\n\n```yaml\n# config/services.yaml\nservices:\n    _instanceof:\n        # all instances of DocumentGeneratorInterface will be automatically tagged\n        App\\Services\\DocumentGeneratorInterface:\n            tags: ['app.document_generator']\n```\n\nNow I just have to tell the dependency injection that all the services tagged `app.document_generator` should be injected into my `DocumentGenerator` class.\nFor that, I'll create a custom _Compiler pass_:\n\n```php\nnamespace App\\DependencyInjection\\Compiler;\n\nuse App\\Services\\DocumentGenerator;\nuse Symfony\\Component\\DependencyInjection\\Compiler\\CompilerPassInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\DependencyInjection\\Reference;\n\nclass DocumentGeneratorPass implements CompilerPassInterface\n{\n    public function process(ContainerBuilder $container): void\n    {\n        if (!$container->has(DocumentGenerator::class)) {\n            return;\n        }\n\n        $definition = $container->findDefinition(DocumentGenerator::class);\n\n        $taggedServices = $container->findTaggedServiceIds('app.document_generator');\n\n        foreach ($taggedServices as $id => $tags) {\n            $definition->addMethodCall('addGenerator', [new Reference($id)]);\n        }\n    }\n}\n```\n\nFinally, last step, add my _Compiler pass_ in the Kernel:\n\n```php\n// src/Kernel.php\nnamespace App;\n\nuse App\\DependencyInjection\\Compiler\\DocumentGeneratorPass;\nuse Symfony\\Component\\HttpKernel\\Kernel as BaseKernel;\n// ...\n\nclass Kernel extends BaseKernel\n{\n    // ...\n\n    protected function build(ContainerBuilder $container): void\n    {\n        $container->addCompilerPass(new DocumentGeneratorPass());\n    }\n}\n```\n\nThanks to my custom tag, I can very easily add a new type of document to generate in the application, without having to modify the rest of the application.\n\n### Learn more\nWe have just walked through dependency injection in Symfony together.\nIt is a very powerful component and central to the framework.\nIf you want to learn more, feel free to browse the [very well done documentation](https://symfony.com/doc/current/service_container.html#learn-more).\n"}