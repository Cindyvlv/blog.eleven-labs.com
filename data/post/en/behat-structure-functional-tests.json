{"date":"2016-07-19T00:00:00.000Z","title":"Behat: structure your functional tests","excerpt":"In order to ensure that your application is running well, it's important to write functional tests.","readingTime":"12mn","authors":["vcomposieux"],"categories":["php"],"content":"In order to ensure that your application is running well, it's important to write functional tests.\n\nBehat is the most used tool with Symfony to handle your functional tests and that's great because it's really a complete suite.\n\nYou should nevertheless know how to use it wisely in order to cover useful and complete test cases and that's the goal of this blog post.\n\n# Introduction\n\n## Functional testing: what's that?\nWhen we are talking about functional testing we often mean that we want to automatize human-testing scenarios over the application.\n\nHowever, it is important to write the following test types to cover the functional scope:\n* `Interface tests`: Goal here is to realize interface verifications to ensure that our web application features can be used over a browser,\n* `Integration tests`: Goal of these tests is to ensure that sour code (already unit-tested) which makes the application running is acting as it should when all components are linked together.\n\nIdea is to develop and run both integration tests and interface tests with Behat.\nBefore we can go, please note that we will use a `Selenium` server which will receive orders by `Mink` (a Behat extension) and will pilot our browser (Chrome in our configuration).\n\nTo be clear on the architecture we will use, here is a scheme that will resume the role of all elements:\n\n![\"Behat architecture schema\"](/imgs/posts/2016-07-19-behat-structure-functional-tests/behat_en.jpg)\n\n## Behat set up\nFirst step is to install Behat and its extensions as dependencies in our `composer.json` file:\n\n```json\n\"require-dev\": {\n    \"behat/behat\": \"~3.1\",\n    \"behat/symfony2-extension\": \"~2.1\",\n    \"behat/mink\": \"~1.7\",\n    \"behat/mink-extension\": \"~2.2\",\n    \"behat/mink-selenium2-driver\": \"~1.3\",\n    \"emuse/behat-html-formatter\": \"dev-master\"\n}\n```\n\nIn order to make your future contexts autoloaded, you also have to add this little `PSR-4` section:\n\n```json\n\"autoload-dev\": {\n    \"psr-4\": {\n      \"Acme\\Tests\\Behat\\Context\\\": \"features/context/\"\n    }\n}\n```\n\nNow, let's create our **behat.yml** file in our project root directory in order to define our tests execution.\n\nHere is the configuration file we will start with:\n\n```yaml\ndefault:\n    suites: ~\n    extensions:\n        Behat\\Symfony2Extension: ~\n        Behat\\MinkExtension:\n            base_url: \"http://acme.tld/\"\n            selenium2:\n                browser: chrome\n                wd_host: 'http://selenium-host:4444/wd/hub'\n            default_session: selenium2\n        emuse\\BehatHTMLFormatter\\BehatHTMLFormatterExtension:\n            name: html\n            renderer: Twig,Behat2\n            file_name: index\n            print_args: true\n            print_outp: true\n            loop_break: true\n    formatters:\n        pretty: ~\n        html:\n            output_path: %paths.base%/web/reports/behat\n```\n\nWe will talk of all of these sections in their defined order so let's start with the **suites** section which is empty at this time but we will implement it later when we will have some contexts to add into it.\n\nThen, we load some Behat extensions:\n\n* `Behat\\Symfony2Extension` will allow us to inject Symfony services into our contexts (useful for integrations tests mostly),\n* `Behat\\MinkExtension` will allow us to pilot Selenium (drive itself the Chrome browser) so we fill in all the necessary information like the hostname, the Selenium server port number and the base URL we will use for testing,\n* `emuse\\BehatHTMLFormatter\\BehatHTMLFormatterExtension` will generate a HTML report during tests execution (which is great to show to our customer for instance).\n\nFinally, in the `formatters` section we keep the `pretty` formatter in order to keep an output in our terminal and the HTML reports will be generated at the same time in the `web/reports/behat` directory in order to make them available over HTTP (it should not be a problem as you should not execute functional tests in production, be careful to restrict access in this case).\nNow that Behat is ready and configured we will prepare our functional tests that we will split into two distinct Behat suites: `integration` and `interface`.\n\n# Writing functional tests (features)\nIn our example, we will write tests in order to ensure that a new user can register over a registration page.\nWe will have to start by writing our tests scenarios (in a `.feature` file) that we will put into a `features/` directory located at the project root directory.\n\nSo for instance, we will have the following scenario:\n\nFile: `features/registration/register.feature`:\n\n\n```\nFeature: Register\n  In order to create an account\n  As a user\n  I want to be able to register on the application\n\nScenario: I register when I fill my username and password only\n  Given I am on the registration page\n    And I register with username \"johndoe\" and password \"azerty123\"\n  When I submit the form\n  Then I should see the registration confirmation</pre>\n```\n\n\n# Integration tests\n\nAs said previously, these tests are here to ensure all code written for the registration page can be executed and linked without any errors.\n\nTo do so, we will create a new integration context that concerns the registration part under directory `features/context/registration`:\n\nFile: `features/context/registration/IntegrationRegisterContext`:\n\n\n```php\n<?php\n\nnamespace Acme\\Tests\\Behat\\Context\\Registration;\n\nuse Acme\\AppBundle\\Entity\\User;\nuse Acme\\AppBundle\\Registration\\Registerer;\nuse Behat\\Behat\\Context\\Context;\n\n/**\n * Integration register context.\n */\nclass IntegrationRegisterContext implements Context\n{\n    /**\n     * Registerer\n     */\n    protected $registerer;\n\n    /**\n     * User\n     */\n    protected $user;\n\n    /**\n     * boolean\n     */\n    protected $response;\n\n    /**\n     * Constructor.\n     *\n     * @param Registerer $registerer\n     */\n    public function __construct(Registerer $registerer)\n    {\n        $this->registerer = $registerer;\n    }\n\n    /**\n     * @Given I am on the registration page\n     */\n    public function iAmOnTheRegistrationPage()\n    {\n        $this->user = new User();\n    }\n\n    /**\n     * @Given /I register with username \"(?P<username>[^\"]*)\" and password \"(?P<password>[^\"]*)\"/\n     */\n    public function iRegisterWithUsernameAndPassword($username, $password)\n    {\n        $this->user->setUsername($username);\n        $this->user->setPassword($password);\n    }\n\n    /**\n     * @When I submit the form\n     */\n    public function iSubmitTheForm()\n    {\n        $this->response = $this->registerer->register($this->user);\n    }\n\n    /**\n     * @Then I should see the registration confirmation message\n     */\n    public function iShouldSeeTheRegistrationConfirmation()\n    {\n        if (!$this->response) {\n            throw new \\RuntimeException('User is not registered.');\n        }\n    }\n}\n```\n\n\nIntegration test for this part is now done for our feature. Let's write the interface test now!\n\n# Interface tests\n\nThis test will be based on the same feature file without modifying the original written scenarios we wrote at the beginning.\nThat's why it is important to write a generic test that can be implemented both in an integration test and in an interface test.\nSo let's create that context that will be used for interface test (prefixed by Mink in our case, but you can prefix it by anything you want) under the directory `features/context/registration`.\n\nFile: `features/context/registration/MinkRegisterContext`:\n\n\n```php\n<?php\n\nnamespace Acme\\Tests\\Behat\\Context\\Registration;\n\nuse Acme\\AppBundle\\Entity\\User;\nuse Acme\\AppBundle\\Registration\\Registerer;\nuse Behat\\Behat\\Context\\Context;\nuse Behat\\MinkExtension\\Context\\MinkContext;\n\n/**\n * Mink register context.\n */\nclass MinkRegisterContext extends MinkContext\n{\n    /**\n     * @Given I am on the registration page\n     */\n    public function iAmOnTheRegistrationPage()\n    {\n        $this->visit('/register');\n    }\n\n    /**\n     * @Given /I register with username \"(?P<username>[^\"]*)\" and password \"(?P<password>[^\"]*)\"/\n     */\n    public function iRegisterWithUsernameAndPassword($username, $password)\n    {\n        $this->fillField('registration[username]', $username);\n        $this->fillField('registration[password]', $password);\n    }\n\n    /**\n     * @When I submit the form\n     */\n    public function iSubmitTheForm()\n    {\n        $this->pressButton('Register');\n    }\n\n    /**\n     * @Then I should see the registration confirmation message\n     */\n    public function iShouldSeeTheRegistrationConfirmation()\n    {\n        $this->assertPageContainsText('Congratulations, you are now registered!');\n    }\n}\n```\n\n\nWe just implemented an interface test based on the same scenario that the one we used for integration test so this class has exactly the same four methods with the same Behat annotations that we have implemented in our integration test class.\nThe only difference here is that in this context we ask Mink to ask to Selenium to do actions on the interface of our application by executing a browser instead of testing the code itself.\n\n# Context definition\n\nOne more thing now, we have to add previously created contexts in our `suites` section in the `behat.yml` configuration file.\n\n\n```yaml\nsuites:\n        integration:\n            paths:\n                - %paths.base%/features/registration\n            contexts:\n                - Acme\\Tests\\Behat\\Context\\Registration\\IntegrationRegisterContext:\n                    - \"@acme.registration.registerer\"\n        interface:\n            paths:\n                - %paths.base%/features/registration\n            contexts:\n                - Behat\\MinkExtension\\Context\\MinkContext: []\n                - Acme\\Tests\\Behat\\Context\\Registration\\MinkRegisterContext: []\n```\n\n\nIt is important to see here that we can clearly split these kind of tests into two distinct parts `integration` and `interface`: each one will be executed with its own contexts.\n\nAlso, as we have loaded the Symfony2 extension during the Behat set up, we have the possibility to inject Symfony services in our contexts and that case occurs here with the `acme.registration.registerer` service.\n\n# Tests execution\n\nIn order to run all tests, simply execute in the project root directory: `bin/behat -c behat.yml`.\nIf you want to run the integration tests only: `bin/behat -c behat.yml --suite=integration`.\nHTML report will be generated under the `web/reports/behat/` as specified in the configuration that will allow you to have a quick overview of failed tests which is cool when you have a lot of tests.\n\n# Link multiple contexts together\n\nAt last, sometime you could need information from another context. For instance, imagine that you have a second step just after the register step. You will have to create two new `IntegrationProfileContext` and `MinkProfileContext` contexts.\n\nWe will only talk about integration context in the following to simplify understanding.\n\nIn this new step `IntegrationProfileContext`, you need some information obtained in the first step `IntegrationRegisterContext`.\nThis can be achieved thanks to the `@BeforeScenario` Behat annotation.\nFile: `features/context/registration/IntegrationProfileContext`:\n\n\n```php\n<?php\n\nnamespace Acme\\Tests\\Behat\\Context\\Registration;\n\nuse Behat\\Behat\\Context\\Context;\nuse Behat\\Behat\\Hook\\Scope\\BeforeScenarioScope;\n\n/**\n * Integration registration profile  context.\n */\nclass IntegrationProfileContext implements Context\n{\n    /**\n     * IntegrationRegisterContext\n     */\n    protected $registerContext;\n\n    /**\n     * @BeforeScenario\n     */\n    public function gatherContexts(BeforeScenarioScope $scope)\n    {\n        $environment = $scope->getEnvironment();\n\n        $this->registerContext = $environment->getContext(\n            'Acme\\Tests\\Behat\\Context\\Registration\\IntegrationRegisterContext'\n        );\n    }\n}\n```\n\n\nYou now have an accessible property **$registerContext** and can access informations from this context.\n\n# Conclusion\n\nEverything starts from well-written tests which have to be thoughtful in order to allow a technical implementation on both integration tests and interface tests.\n\nThe choosen structure about classifying its tests is also important in order to quickly find tests when the application grows.\n"}