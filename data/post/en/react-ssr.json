{"date":"2017-10-12T00:00:00.000Z","title":"React SSR","excerpt":"Writing an SSR React app from scratch","readingTime":"19mn","authors":["kelfarsaoui"],"categories":["javascript"],"content":"\nFive weeks ago, our friend [Vincent Composieux](https://blog.eleven-labs.com/authors/vcomposieux/) wrote an [awesome article](https://blog.eleven-labs.com/fr/migrate-a-react-client-side-application-to-server-side-with-nextjs/) about migrating a React client-side application to server-side with [Next.JS](https://zeit.co/blog/next4){:rel=\"nofollow noreferrer\"}. But, sometimes you want to do it the plain vanilla way in order to take control over your workflow. Therefore, this article's purpose is to climb up the steps of developing an SSR React app from scratch.\n\n### A Reminder of SSR's benefits\n\nLet me state the obvious, SSR provides a better SEO as compared to a traditional client-side rendered SPA (single page application). Considering the fact that most SPAs are asynchronous, which means that they need time to load their data, they cannot be fully indexed by search engine crawlers, because these crawlers wonâ€™t wait for them to render. This fact can be taken as a given which must be unraveled. SSR also provides a faster access to your content, thanks to server rendered markup which doesnâ€™t depend on your assets to be loaded.\n\nThere are, however, some trade-offs that you have to think about. High availability is gonna cost you, big time. As a matter of fact, you are rendering your large app in your server. This needs serious resources in terms of CPU because you're way beyond serving only static assets. Interoperability is another headache to consider. You won't be able to provide a decent experience unless you overcome browser-specific code.\n\nIâ€™m gonna spare you the theatrics and get straight to the point. We're going to build a React app using SSR.\n\n### Before we get started...\n\nHere are the prerequisites that you need:\n\n- Node/[Express](https://www.npmjs.com/package/express) (for the rendering){:rel=\"nofollow noreferrer\"}\n- [React](http://reactjs.org)/[Redux](http://redux.js.org/)/[Redux-observable](https://redux-observable.js.org/) (for the client){:rel=\"nofollow noreferrer\"}\n- [React Router](https://reacttraining.com/react-router/) (for both the client and the server){:rel=\"nofollow noreferrer\"}\n- [JSON Server](https://github.com/typicode/json-server) (for the API){:rel=\"nofollow noreferrer\"}\n- [Webpack](https://webpack.js.org/) (for bundling){:rel=\"nofollow noreferrer\"}\n- [Typescript](https://typescriptlang.org) (for the fun){:rel=\"nofollow noreferrer\"}\n\nIâ€™m not gonna go through all the dependencies, but you can find them in the [`package.json`](https://github.com/elfakamal/the-wilson-post/blob/master/package.json){:rel=\"nofollow noreferrer\"}.\n\n### Step 1: Setup the project\n\nFirst things first, let's take a look at `package.json` scripts section:\n\n```json\n  ...\n  \"scripts\": {\n    \"start\": \"concurrently -k -p \\\"[{name} - {time}]\\\" -c \\\"cyan,magenta\\\" -n \\\"client,server\\\" \\\"yarn start-client\\\" \\\"yarn start-server\\\"\",\n    \"build\": \"yarn run clean && webpack -p --progress\",\n    \"clean\": \"rm -rf ./public/*\",\n    \"start-client\": \"webpack --debug --watch\",\n    \"start-server\": \"nodemon --exec ts-node src/server/index.ts --watch ./src -e ts,tsx\"\n  },\n  ...\n```\n\nAs you can see, we are [`concurrently`](https://www.npmjs.com/package/concurrently){:rel=\"nofollow noreferrer\"} running 2 instances of Node, one for the server and the other for webpack. We aren't using `webpack-dev-server` because we don't need it. We just have to watch the files and compile them to be bundled. This will allow us to serve them statically from the public path.\n\n#### Webpack\n\nAs we've seen [earlier](https://blog.eleven-labs.com/en/ecmascript-asynchronicity-dynamic-import/){:rel=\"nofollow noreferrer\"}, we're gonna split our code into 2 bundles, `main.js` and `vendor.js`. The webpack config is as follows:\n\n```js\nconst path = require('path');\nconst webpack = require('webpack');\n\nconst NODE_ENV = process.env.NODE_ENV ? process.env.NODE_ENV.toLowerCase() : 'development';\nconst mode = NODE_ENV === 'development' ? 'dev' : 'prod';\n\nmodule.exports = {\n  devtool: 'source-map',\n  entry: {\n    main: path.join(__dirname, 'src', 'client', `index.${mode}`),\n  },\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor',\n      filename: 'vendor.js',\n      minChunks(module) {\n        const context = module.context;\n        return context && context.indexOf('node_modules') >= 0;\n      },\n    }),\n  ],\n  output: {\n    path: path.join(__dirname, 'public'),\n    filename: '[name].js',\n    chunkFilename: '[name].js',\n    publicPath: '/',\n    library: '[name]',\n    libraryTarget: 'umd',\n    umdNamedDefine: true,\n  },\n  resolve: {\n    extensions: ['.js', '.jsx', '.ts', '.tsx'],\n  },\n  module: {\n    rules: [\n      ...\n    ],\n  },\n};\n```\n\nIn the output we specify the path to the directory into which Webpack is gonna place the bundles `path.join(__dirname, 'public')`. This is the same place from where the server will serve the files.\n\nThe kind of output you will have is similar to this:\n\n```bash\n$ yarn start\nyarn start v0.27.5\n$ concurrently -k -p \"[{name} - {time}]\" -c \"cyan,magenta\" -n \"client,server\" \"yarn start-client\" \"yarn start-server\"\n[server - 2017-10-11 12:57:29.361] [nodemon] 1.12.1\n[server - 2017-10-11 12:57:29.368] [nodemon] to restart at any time, enter `rs`\n[server - 2017-10-11 12:57:29.368] [nodemon] watching: /Users/kamal/code/eleven-labs/articles/ssr/the-wilson-post/src/**/*\n[server - 2017-10-11 12:57:29.368] [nodemon] starting `ts-node src/server/index.ts`\n[client - 2017-10-11 12:57:29.619]\n[client - 2017-10-11 12:57:29.619] Webpack is watching the filesâ€¦\n[client - 2017-10-11 12:57:29.619]\n[client - 2017-10-11 12:57:30.226] ts-loader: Using typescript@2.5.3 and /Users/kamal/code/eleven-labs/articles/ssr/the-wilson-post/tsconfig.json\n[server - 2017-10-11 12:57:30.508] ==> ðŸŒŽ  Listening on port 9001. Open up http://localhost:9001/ in your browser.\n[client - 2017-10-11 12:57:38.220] Hash: 86f91e22ceb773dceb73\n[client - 2017-10-11 12:57:38.220] Version: webpack 3.6.0\n[client - 2017-10-11 12:57:38.220] Time: 8609ms\n[client - 2017-10-11 12:57:38.220]         Asset       Size  Chunks                    Chunk Names\n[client - 2017-10-11 12:57:38.220]       main.js    21.8 kB       0  [emitted]         main\n[client - 2017-10-11 12:57:38.220]     styles.js  447 bytes       1  [emitted]         styles\n[client - 2017-10-11 12:57:38.220]     vendor.js    2.29 MB       2  [emitted]  [big]  vendor\n[client - 2017-10-11 12:57:38.220]   main.js.map    21.2 kB       0  [emitted]         main\n[client - 2017-10-11 12:57:38.220] styles.js.map  682 bytes       1  [emitted]         styles\n[client - 2017-10-11 12:57:38.220] vendor.js.map    2.76 MB       2  [emitted]         vendor\n```\n\n#### Client Structure\n\nLet's look at the client's structure:\n\n```txt\nâ”œâ”€â”€ src\n|   â”œâ”€â”€ client\n|   |   â”œâ”€â”€ actions\n|   |   â”œâ”€â”€ assets\n|   |   â”œâ”€â”€ components\n|   |   â”œâ”€â”€ containers\n|   |   â”œâ”€â”€ epics\n|   |   â”œâ”€â”€ reducers\n|   |   â”œâ”€â”€ routes\n|   |   â”œâ”€â”€ services\n|   |   â”œâ”€â”€ store\n|   |   â”œâ”€â”€ constants.ts\n|   |   â”œâ”€â”€ index.dev.tsx\n|   |   â””â”€â”€ index.prod.tsx\n|   â”œâ”€â”€ ...\n```\n\nThis is a typical React/Redux app that follows [Dan Abramov's recommendations](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0){:rel=\"nofollow noreferrer\"} about presentational and container components. We're going to use `redux-observable` to handle side effects, and `react-router` to show how routing can be done.\n\n### Step 2: The Routing\n\nWe are going to build an application called \"the-wilson-post\". It's a kind of article scheduler. It will help our communications manager with handling the massive amount of article requests from Eleven Labs engineers.\n\nLet's look at the routes:\n\n```ts\n// routes/index.ts\nimport App from '../containers/App';\nimport Home from '../containers/Home';\n\nexport default [\n  {\n    component: App,\n    routes: [\n      {\n        path: '/',\n        exact: true,\n        component: Home,\n      },\n    ],\n  },\n];\n```\n\nThis module exports a simple array of routes structured as a tree. This array will be fed to the `renderRoutes` function in the `react-router-config` module. `renderRoutes` aims to `mount` the route that matches the requested page URL. Below you can see how it's done in the entry file of the application:\n\n```ts\n// index.prod.jsx\nimport * as React from 'react';\nimport { render } from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { renderRoutes } from 'react-router-config';\nimport { BrowserRouter } from 'react-router-dom';\n\nimport { INITIAL_STATE } from './constants';\nimport routes from './routes';\nimport createStore from './store/prod';\n\nconst store = createStore(INITIAL_STATE);\n\nrender(\n  <Provider store={store}>\n    <BrowserRouter>\n      {renderRoutes(routes)}\n    </BrowserRouter>\n  </Provider>,\n  document.getElementById('root'),\n);\n```\n\n> **Notice**: `BrowserRouter` uses the HTML5 history API, which makes it easier for engineers to handle UI state by using the native functions it provides like: `pushState` and `replaceState`.\n\nIn React Router, routes are simple components that render their children. These children might be simple components and/or routes. That is, everything in React Router is a component. In this article, we are using `react-router v4` which introduced the Dynamic Routing concept that's based on the idea of routing while rendering.\n\n`renderRoutes` is a function that takes as an argument a list of route objects. Each one of these objects contains a `path` and a `component` property among other properties. `renderRoutes` goes through the list and matches the current requested URL to mount the appropriate component. Which makes it eligible to guarantee the dynamic aspect of routing.\n\nOur route objects also contains a `children` property, which is composed of child routes. This allows us to build components that can mount these child routes, as it can be seen in the following example where we are creating the main page component:\n\n\n```ts\n// client/containers/App.tsx\nimport * as React from 'react';\nimport { renderRoutes, RouteConfig } from 'react-router-config';\n\ninterface Props {\n  route?: RouteConfig;\n}\n\nexport default class App extends React.Component<Props, object> {\n  render() {\n    const { route } = this.props;\n\n    return (\n      <div className=\"wilson-post-app\">\n        <nav>\n          <h1>The Wilson Post</h1>\n          <div>\n            <Link to=\"/schedule-post\">Schedule a post</Link>\n          </div>\n        </nav>\n        {route && renderRoutes(route.routes)}\n      </div>\n    );\n  }\n}\n```\n\n> **Notice**: You can do the same thing by using `<Switch />` and `<Route />` components. It is recommended to see how it's done in [React Router's docs](https://reacttraining.com/react-router/web/api/Switch){:rel=\"nofollow noreferrer\"}.\n\nHere is the generated tree:\n\n```html\n<Provider>\n  <BrowserRouter>\n    <Router>\n      <Switch>\n        <Route>\n          <App>\n            ...\n            <Switch>\n              <Route>\n                <Home>\n                  ...\n                </Home>\n              </Route>\n            </Switch>\n          </App>\n        </Route>\n      </Switch>\n    </Router>\n  </BrowserRouter>\n</Provider>\n```\n\n### Step 3: The Pages\n\nIn the previous example we've seen the app component that dynamically includes child routes. In case we reached the `/` in the URL, the inclusion triggers the mounting of the `Home` component, which will display a list of articles. There will be another page that will allow us to schedule a post. Here are the final routes that we will have:\n\n```ts\n// client/routes/index.ts\nimport App from '../containers/App';\nimport Home from '../containers/Home';\nimport Scheduler from '../containers/Scheduler';\nimport NotFound from './NotFound';\n\nexport default [\n  {\n    component: App,\n    routes: [\n      {\n        path: '/',\n        exact: true,\n        component: Home,\n      },\n      {\n        path: '/schedule-post',\n        exact: true,\n        component: Scheduler,\n      },\n      {\n        path: '*',\n        component: NotFound,\n      },\n    ],\n  },\n];\n```\n\nYou will find these pages in the source code. We will talk about the `NotFound` route a little bit later.\n\n### Step 4: The API\n\nWe're gonna use JSON server for the sake of simplicity and fast scaffolding. We will mount it as an express middleware into the server:\n\n```ts\n// server/api/index.ts\nimport { create, router } from 'json-server';\nimport * as path from 'path';\n\nconst server = create();\nconst apiEndpoints = router(path.join(__dirname, 'posts.json'));\n\nserver.use(apiEndpoints);\n\nexport default server;\n```\n\nFor more info, see [my article on json-server](https://blog.eleven-labs.com/en/json-server/){:rel=\"nofollow noreferrer\"}.\n\n### Step 5: The server\n\nThe server is a classic Express app that mounts the API middleware, along with the routes middleware, the responsibility of which is to transform React components into a string, in order to serve it to the client.\n\nLet's look at the structure:\n\n```txt\nâ”œâ”€â”€ src\n|   â”œâ”€â”€ client\n|   |   â”œâ”€â”€ ...\n|   â”œâ”€â”€ server\n|   |   â”œâ”€â”€ api\n|   |   |   â”œâ”€â”€ index.ts\n|   |   |   â””â”€â”€ posts.json\n|   |   â”œâ”€â”€ middlewares\n|   |   |   â”œâ”€â”€ 404.ts\n|   |   |   â””â”€â”€ 500.ts\n|   |   â”œâ”€â”€ routes\n|   |   |   â””â”€â”€ index.tsx\n|   |   â”œâ”€â”€ templates\n|   |   |   â””â”€â”€ index.ejs\n|   |   â””â”€â”€ index.ts\n```\n\nI think it's useless to show the entire file here, so the following is the most important part:\n\n```ts\n// server/index.ts\n...\n\napp.use('/static', serveStatic(publicPath));\napp.use('/api', api);\napp.use('/', routes);\n\n// error handlers\napp.use(handler500(app.get('env')));\napp.use(handler404);\n\n...\n```\n\nWe are serving the static assets â€”namely the webpack bundles: `vendor.js`, `main.js` and `styles.js`â€” along with the API and the routes. We are also handling errors by using 404 and 500 error middlewares.\n\n### Step 6: Render React components in the server\n\nThe holy grail here is the [`renderToString`](https://reactjs.org/docs/react-dom-server.html#rendertostring){:rel=\"nofollow noreferrer\"} function from `react-dom/server`. It takes a react component and generates its HTML string:\n\n```ts\n// server/routes/index.tsx\nimport * as Express from 'express';\nimport * as React from 'react';\nimport { renderToString } from 'react-dom/server';\nimport { Provider } from 'react-redux';\nimport { renderRoutes } from 'react-router-config';\nimport { StaticRouter } from 'react-router-dom';\n\nimport routes from '../../client/routes';\nimport { getPosts } from '../../client/services/posts';\nimport createStore from '../../client/store/dev';\n\nexport default async (req: Express.Request, res: Express.Response) => {\n  const posts = await getPosts();\n  const store = createStore({ posts });\n\n  const content = renderToString(\n    <Provider store={store}>\n      <StaticRouter location={req.url}>\n        {renderRoutes(routes)}\n      </StaticRouter>\n    </Provider>,\n  );\n\n  res.render('index', { content, data: store.getState() });\n};\n```\n\nWe are using the [`StaticRouter`](https://reacttraining.com/react-router/web/api/StaticRouter){:rel=\"nofollow noreferrer\"} instead of `BrowserRouter`, because the location never changes in the server. And, by creating the store, we provide the app with initial data from the API by calling the `getPosts` service from the client. These data are finally passed to the template `index.ejs` in order to make it available to the client's store:\n\n```html\n<!-- server/templates/index.ejs -->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>The Wilson Post</title>\n    <!-- HTML5 shim, for IE6-8 support of HTML elements -->\n    <!--[if lt IE 9]>\n      <script src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"></script>\n    <![endif]-->\n  </head>\n  <body>\n    <div id=\"root\"><%- content %></div>\n    <script>\n      window.__INITIAL_STATE__ = <%- JSON.stringify(data) %>;\n    </script>\n    <script src=\"/static/vendor.js\"></script>\n    <script src=\"/static/styles.js\"></script>\n    <script src=\"/static/main.js\"></script>\n  </body>\n</html>\n```\n\n### Step 7: Handling 404\n\nHandling `404` is a little bit tricky, it actually works with our current code. When you visit an URL that the router can't match, it triggers the asterisk `*` route and mounts its component, matching the `NotFound` route:\n\n```ts\n// client/routes/index.ts\n...\n  {\n    path: '*',\n    component: NotFound,\n  },\n...\n```\n\nBut, there is a problem here; unlike the client, the server won't be aware whether it was a `404`, and will serve the page with a `200` response status. To fix it, we need to ask the router to tell the server what really happened during route matching, so that the server can update the response status based on the router's result. We can do this by using the `StaticRouter`'s context property. The idea consists of passing a context object to the `StaticRouter` so that it can be updated with the real status in the `NotFound` component:\n\nHere is the updated version that uses the context:\n\n```ts\n// server/routes/index.tsx\n...\n\ninterface StaticRouterContext {\n  status?: number;\n}\n\nexport default async (req: Express.Request, res: Express.Response) => {\n  const posts = await getPosts();\n  const store = createStore({ posts });\n  const context: StaticRouterContext = {};\n\n  const content = renderToString(\n    <Provider store={store}>\n      <StaticRouter location={req.url} context={context}>\n        {renderRoutes(routes)}\n      </StaticRouter>\n    </Provider>,\n  );\n\n  if (context.status === 404) {\n    res.status(404);\n  }\n\n  res.render('index', { content, data: store.getState() });\n};\n```\n\nBut, how are we gonna update the context? Here is the `NotFound` component that we need to display:\n\n```ts\n// client/routes/NotFound.tsx\nimport * as React from 'react';\n\nexport default (): JSX.Element => (\n  <div className=\"not-found\">\n    Not found\n  </div>\n);\n```\n\nThis component needs to change the context passed from the server. To do it, we will use the `Route` component to have access to the context property, so that we can change it:\n\nWe're gonna write a generic Status component that will do the work:\n\n```ts\n// client/routes/Status.tsx\nimport * as React from 'react';\nimport { Route, RouteComponentProps } from 'react-router-dom';\n\ninterface Props {\n  status?: number;\n  children?: React.ReactNode;\n}\n\nexport default ({ status, children }: Props): JSX.Element => (\n  <Route render={({ staticContext }: RouteComponentProps<any>) => {\n    if (staticContext) {\n      staticContext.status = status;\n    }\n\n    return children;\n  }} />\n);\n```\n\nThen we use it in our `NotFound` component, and pass the right status to it:\n\n```ts\n// client/routes/NotFound.tsx\nimport * as React from 'react';\n\nimport Status from './Status';\n\nexport default (): JSX.Element => (\n  <Status status={404}>\n    <div>Not found</div>\n  </Status>\n);\n```\n\nThis way, when the server is done matching the routes, it will end up with the context having the right status, so that it can set it to the response:\n\n```ts\n// client/routes/index.tsx\n  ...\n  if (context.status === 404) {\n    res.status(404);\n  }\n  ...\n```\n\nNow, when you go somewhere you're not supposed to, the server knows what status to set in the response, and will still serve you the application in order for the client to display the `NotFound` component.\n\n### Step 8: Redux\n\nRedux is agnostic to the environment. This makes it pretty easy to handle, as it's used exactly the same way as in the client. We create a store and pass it to the Provider component. Then, we get its state in order to give it to the client's store. This is when it gets a little bit awkward to me. We wind up doing some messy code trying to pass the data to the client. We do this by giving the data to the `index.ejs` template in order to set it as a global variable:\n\n```html\n...\n  <script>\n    window.__INITIAL_STATE__ = <%- JSON.stringify(data) %>;\n  </script>\n...\n```\n\n> **Notice**: I don't see how this can be done otherwise. But if someone has any idea about a better and cleaner way to do this, please let me know :-)\n\nHere is an update that makes it possible for the client's store to take advantage of `__INITIAL_STATE__` data:\n\n```ts\n// client/index.dev.tsx\n...\nconst win: ExtendedWindow = window as ExtendedWindow;\nconst state = win && win.__INITIAL_STATE__ ? win.__INITIAL_STATE__ : INITIAL_STATE;\nconst store = createStore(state);\n\nrender(\n  <Provider store={store}>\n    <BrowserRouter>\n      {renderRoutes(routes)}\n    </BrowserRouter>\n  </Provider>,\n  document.getElementById('root'),\n);\n```\n\nThis way we are sure we have the same display in the server and the client.\n\n### Conclusion\n\nSSR can be a piece of cake, at least before approaching the intricacies of the routing. You can find the entire code in [Github](https://github.com/elfakamal/the-wilson-post). And, please! Feel free to give your feedback :-){:rel=\"nofollow noreferrer\"}\n\nThanks for reading!\n"}