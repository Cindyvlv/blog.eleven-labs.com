{"date":"2017-06-15T00:00:00.000Z","title":"Construct and structure a Go GraphQL API","excerpt":"GraphQL was released 2 years ago and applications that use it are still rare.","readingTime":"10mn","authors":["vcomposieux"],"categories":[],"content":"GraphQL was released 2 years ago and applications that use it are still rare.\nHowever, this implementation proposed by Facebook offers many possibilities that are not available in REST APIs.\n\n# Introduction\n\nThe goal of this blog post is not to explain from the basics what is GraphQL because official documentation of the implementation located at http://graphql.org/learn explain it really well!\n\nI was interested of constructing a GraphQL API and I also wanted to have a performant API so I choose the Go language to develop it using the `graphql-go` library available here: https://github.com/graphql-go/graphql.\n\n# File structure of our API\n\nThe first thing to do (and not least!) is to create a great understandable and re-usable file structure.\n\nIndeed, our API will have to evolve in the future, for sure, so we will have to add more and more files into it such as maybe a security component, a rate limiter component, something to log requests, and so many more.\n\nHere is the file structure I propose to create in this blog post that seems to me to be a great start:\n\n```bash\n.\n├── app\n│   ├── config.go\n│   ├── config.json\n│   └── config_test.go\n├── security\n│   ├── security.go\n│   └── security_test.go\n├── mutations\n│   ├── mutations.go\n│   ├── mutations_test.go\n│   ├── user.go\n│   └── user_test.go\n├── queries\n│   ├── queries.go\n│   ├── queries_test.go\n│   ├── user.go\n│   └── user_test.go\n├── types\n│   ├── role.go\n│   ├── role_test.go\n│   ├── user.go\n│   └── user_test.go\n└── main.go\n```\n\nHere is what we have here:\n* \"app/\" will contains all Go classes and configuration files that will be needed to get our application (API) to work so we will have mainly a configuration file (JSON) `config.json` and also a `config.go` file that will load this JSON,\n* \"security/\" will group Go classes that will be used for our security component,\n* \"mutations/\" will group all of our GraphQL mutations (data changes),\n* \"queries/\" will group all of our GraphQL queries (selecting data),\n* \"types/\" will group all of our Go structures and types used by GraphQL by both queries and mutations.\n\nFinally, we will find at the root directory the `main.go` file which will be the entry point of our API.\n\nSo now that everything is clear, let's start writing our API!\n\n# API entry point\n\nTo construct our API, we will need in a first time the Go `net/http` package (because our GraphQL API will be accessible over HTTP) and also the `graphql-go` library:\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/graphql-go/graphql\"\n\t\"github.com/graphql-go/handler\"\n)\n\nfunc main() {\n\t// Todo: Implement GraphQL handler\n\n\thttp.Handle(\"/\", httpHandler)\n\tlog.Print(\"ready: listening...\\n\")\n\n\thttp.ListenAndServe(\":8383\", nil)\n}\n```\n\nYou can note here that the `httpHandler` variable that will be the HTTP handler used by GraphQL and will be executed for each request that will be made over the \"/\" URL. Also, we have to give a port number here (8383) on which our API will listen to.\n\nLet's implement the `httpHandler` which will need a schema in which we will specify two entry points: a first for the queries and a second for the mutations:\n\n```go\nschemaConfig := graphql.SchemaConfig{\n  Query: graphql.NewObject(graphql.ObjectConfig{\n    Name:   \"RootQuery\",\n    Fields: queries.GetRootFields(),\n  }),\n  Mutation: graphql.NewObject(graphql.ObjectConfig{\n    Name:   \"RootMutation\",\n    Fields: mutations.GetRootFields(),\n  }),\n}\n\nschema, err := graphql.NewSchema(schemaConfig)\n\nif err != nil {\n  log.Fatalf(\"Failed to create new schema, error: %v\", err)\n}\n\nhttpHandler := handler.New(&handler.Config{\n  Schema: &schema\n})\n```\n\nIn the case you have no data modifications but only queries, you can of course remove the mutations section from the code.\n\nHere, we are missing the `queries.GetRootFields()` and also the `mutations.GetRootFields()` methods. These methods will allow us to define our `queries` and `mutations` that will be used in our API.\n\nRather than weighing down our `main.go` file with these things, I chose to put them into two separate files: `queries/queries.go` and `mutations/mutations.go`.\n\n# Data structures\n\nBefore to go writting our first query, we will need to define our data model.\n\nIn this blog post, we will return user data with an identifier, a firstname and a lastname. So we will have to write our first file under `types/user.go`:\n\n```go\npackage types\n\nimport (\n\t\"github.com/graphql-go/graphql\"\n)\n\n// User type definition.\ntype User struct {\n\tID        int    `db:\"id\" json:\"id\"`\n\tFirstname string `db:\"firstname\" json:\"firstname\"`\n\tLastname  string `db:\"lastname\" json:\"lastname\"`\n}\n\n// UserType is the GraphQL schema for the user type.\nvar UserType = graphql.NewObject(graphql.ObjectConfig{\n\tName: \"User\",\n\tFields: graphql.Fields{\n\t\t\"id\":         &graphql.Field{Type: graphql.Int},\n\t\t\"firstname\":  &graphql.Field{Type: graphql.String},\n\t\t\"lastname\":   &graphql.Field{Type: graphql.String},\n\t},\n})\n```\n\nWe declare two things here:\n* A Go struct that will be used for mapping data from our database and to return data to the client in a JSON format,\n* A `UserType` GraphQL Field that will be used by our GraphQL API to specify fields that can be returned by our API.\n\nBy using the data model, we are now (finally) able to write our first query!\n\n# Queries\n\nLet's edit the `queries/queries.go` file in order to add a `user` named query that will be charged to return our user data:\n\n```go\npackage queries\n\nimport (\n\t\"github.com/graphql-go/graphql\"\n)\n\n// GetRootFields returns all the available queries.\nfunc GetRootFields() graphql.Fields {\n\treturn graphql.Fields{\n\t\t\"user\": GetUserQuery(),\n\t}\n}\n```\n\nWe've added a new field in our root query previously written named `user` and that will call the `GetUserQuery()` function to return its fields. This function will be defined into another file.\n\nWe will now define this function and its behavior into another dedicated file called `queries/user.go`:\n\n```go\npackage queries\n\nimport (\n\t\"../types\"\n\n\t\"github.com/graphql-go/graphql\"\n)\n\n// GetUserQuery returns the queries available against user type.\nfunc GetUserQuery() *graphql.Field {\n\treturn &graphql.Field{\n\t\tType: graphql.NewList(types.UserType),\n\t\tResolve: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\tvar users []types.User\n\n      // ... Implement the way you want to obtain your data here.\n\n\t\t\treturn users, nil\n\t\t},\n\t}\n}\n```\n\nOur first query is ready: we will use the data model `UserType` for it so you just have to implement the logic to retrieve your data here.\n\nAt this place, you can make a call on every storage engine you want to obtain your data: relational databases or not, SQL or not, file storage, memory storage, everything is possible.\n\n# Add relations to your API\n\nLet's now imagine that you have some roles defined for your users (in order to manage access to some resources).\n\nYou can also ask to your GraphQL API to return them.\n\nTo do that, we will implement a new `Role` struct and also a `RoleType` used by GraphQL.\n\nCreate the `types/role.go` containing following code:\n\n```go\npackage types\n\nimport (\n\t\"github.com/graphql-go/graphql\"\n)\n\n// Role type definition.\ntype Role struct {\n\tID   int    `db:\"id\" json:\"id\"`\n\tName string `db:\"name\" json:\"name\"`\n}\n\n// RoleType is the GraphQL schema for the user type.\nvar RoleType = graphql.NewObject(graphql.ObjectConfig{\n\tName: \"Role\",\n\tFields: graphql.Fields{\n\t\t\"id\":   &graphql.Field{Type: graphql.Int},\n\t\t\"name\": &graphql.Field{Type: graphql.String},\n\t},\n})\n```\n\nWe now have to specify to our `UserType` and we can also obtain some roles linked to the user.\n\nTo do that, edit the `types/user.go` file and add a new `graphql.Field` section to `RoleType`:\n\n```go\nvar UserType = graphql.NewObject(graphql.ObjectConfig{\n\tName: \"User\",\n\tFields: graphql.Fields{\n\t\t// ... already defined fields\n\t\t\"roles\": &graphql.Field{\n\t\t\tType: graphql.NewList(RoleType),\n\t\t\tResolve: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\t\tvar roles []Role\n\n\t\t\t\t// userID := params.Source.(User).ID\n\t\t\t\t// Implement logic to retrieve user associated roles from user id here.\n\n\t\t\t\treturn roles, nil\n\t\t\t},\n\t\t},\n\t},\n})\n```\n\nPlease note that the `Type` specified for this field is a `graphql.NewList(RoleType)` because we will return a roles list and not a single role entry.\n\nTo request against user roles using the current user data, you can use the available `params.Source`.\n\nFinally, what is interesting here is that roles queries will be only done if the roles data are requested by the GraphQL API client.\n\n# Make calls to your API\n\nStarting from there, you are able to call your API with a query like that:\n\n```bash\ncurl\n  -X POST\n  -H 'Content-Type: application/json'\n  -d '{\"query\": \"query { users { id,firstname,lastname,roles{name} } }\"}'\n  http://localhost:8383/\n\n{\"data\":{\"user\":[{\"id\":1,\"firstname\":\"Vincent\",\"lastname\":\"COMPOSIEUX\",\"roles\":[]}, ...]}}\n```\n\nOf course, as said previously, only query specified fields will be returned, that's the GraphQL main principle.\n\nGraphQL also offers a lot of great things to help you writing neat queries with among others aliases, variables and fragments.\n\nYou can read documentation of these parts here:\n\n* Aliases : http://graphql.org/learn/queries/#aliases\n* Fragments : http://graphql.org/learn/queries/#fragments\n* Variables : http://graphql.org/learn/queries/#variables\n\n# Mutations\n\nAbout mutations, le fonctionnement est identique aux requêtes. Nous allons donc créer notre première mutation et vous allez voir que ça ressemble beaucoup aux queries.\n\nCreate file `mutations/mutations.go` and specify the `RootMutation` returned by `GetRootFields()`:\n\n```go\npackage mutations\n\nimport (\n\t\"github.com/graphql-go/graphql\"\n)\n\n// GetRootFields returns all the available mutations.\nfunc GetRootFields() graphql.Fields {\n\treturn graphql.Fields{\n\t\t\"createUser\": GetCreateUserMutation(),\n\t}\n}\n```\n\nThen, we will create a mutation to create a new user in our database.\n\nLet's declare the `GetCreateUserMutation()` function in file `mutations/user.go`:\n\n```go\npackage mutations\n\nimport (\n\t\"../types\"\n\n\t\"github.com/graphql-go/graphql\"\n)\n\n// GetCreateUserMutation creates a new user and returns it.\nfunc GetCreateUserMutation() *graphql.Field {\n\treturn &graphql.Field{\n\t\tType: types.UserType,\n\t\tArgs: graphql.FieldConfigArgument{\n\t\t\t\"firstname\": &graphql.ArgumentConfig{\n\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t},\n\t\t\t\"lastname\": &graphql.ArgumentConfig{\n\t\t\t\tType: graphql.NewNonNull(graphql.String),\n\t\t\t},\n\t\t},\n\t\tResolve: func(params graphql.ResolveParams) (interface{}, error) {\n\t\t\tuser := &types.User{\n\t\t\t\tFirstname: params.Args[\"firstname\"].(string),\n\t\t\t\tLastname:  params.Args[\"lastname\"].(string),\n\t\t\t}\n\n      // Add your user in database here\n\n\t\t\treturn user, nil\n\t\t},\n\t}\n}\n```\n\nYour mutation is now ready to be used!\n\nAs you can notice, we've added an `Args` section here that allows us to define some arguments to our function, such as: `createUser(firstname: \"John\", lastname: \"Snow\")`.\n\nThis is of course possible to test our API by calling it now using the following way:\n\n```bash\ncurl\n    -X POST\n    -H 'Content-Type: application/json'\n    -d '{\"query\": \"mutation { createUser(firstname: \\\"John\\\", lastname: \\\"Snow\\\") { id,firstname,lastname } }\"}'\n    http://localhost:8383\n```\n\nYou can of course choose only the identified of the newly created user if needed.\n\n# Security\n\nMost of your APIs are certainly not public so you also need a component to handle security and that's whay we will do by using a JWT authentication (https://jwt.io/).\n\nWe will use the `dgrijalva/jwt-go` library (https://github.com/dgrijalva/jwt-go) in order to simplify the use of JWT in our Go application.\n\nSimply add in your `security/security.go` file the following content:\n\n```go\npackage security\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\tjwt \"github.com/dgrijalva/jwt-go\"\n)\n\n// Handle security middleware aims to implement a JWT authentication.\nfunc Handle(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")[7:] // 7 corresponds to \"Bearer \"\n\n\t\ttoken, _ := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t\t}\n\n      var secret = \"my-high-security-secret\" // Prefer to store this secret in a configuration file\n\n\t\t\treturn []byte(secret), nil\n\t\t})\n\n\t\tif claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {\n\t\t\tlog.Printf(\"JWT Authenticated OK (app: %s)\", claims[\"app\"])\n\n\t\t\tnext.ServeHTTP(w, r)\n\t\t}\n\t})\n}\n```\n\nWe retrieve the token sent in the `Authorization: Bearer xxx` header by the client and will compare it with a secret we've stored in our configuration file.\n\nIn the case the token is valid, the application will continue to execute the HTTP handler, elsewhere, an error will be thrown.\n\nIn order to use this security component, we will have to update our `main.go` file to import the `security` folder and also modify:\n\n```go\nhttp.Handle(\"/\", httpHandler)\n```\n\nwith:\n\n```go\nhttp.Handle(\"/\", security.Handle(httpHandler))\n```\n\nYou now have a functional and secured GraphQL API!\n\n# Conclusion\n\nThe GraphQL implementation using Go is quite simple to do thank to the available library and language performances allows to construct powerful APIs.\n\nIt is also possible to well structure your API in order to separate, especially for queries, mutations and other components.\n\nIf you want to give it a try, sources of this blog post are available here: https://github.com/eko/graphql-go-structure\n"}