{"date":"2021-01-05T00:00:00.000Z","title":"Introduction to Gitlab CI/CD","excerpt":"This article presents some of the possibilities that GitLab CI/CD offers. You will find on the Codelabs platform two tutorials linked to this article, which will show you two use cases.","readingTime":"18mn","authors":["nicolas","marishka"],"categories":["architecture"],"content":"Today if you want to set up a CI/CD on GitHub you need to “link” your repositories with Travis-ci, Circle-ci, Codeship... But did you know that GitLab integrates a CI/CD solution? This is the subject of today's article.\n\nIn this article I will just show you the possibilities that GitLab CI/CD offers to you. But if you want to dig further in the subject, I've also created a tutorial on [Eleven Labs codelabs](https://codelabs.eleven-labs.com) on how to [set up a CI on a javascript project](https://codelabs.eleven-labs.com/course/fr/gitlab-ci-js/)\n\n# CI/CD what is that?\n\nI'm not going to write yet another definition for you, beecause there exist plenty already. So here is what Wikipedia tells us for CI and CD:\n\n## CI: Continuous Integration\n> “Continuous integration is a set of practices used in software engineering consisting in verifying with each modification of source code that the result of the modifications does not produce a regression in the developed application. [...] The main goal of this practice is to detect integration problems as early as possible during development. In addition, it allows you to automate the execution of test suites and see the evolution of software development.”\n\n## CD: Continuous Delivery\n> \"Continuous delivery is a software engineering approach in which teams produce software in short cycles, allowing it to be made available anytime. The goal is to build, test, and distribute software faster.\nThe approach helps reduce the cost, time and risk associated with delivering change by taking a more incremental approach to changes in production. A simple, repeatable deployment process is key.\"\n\n# GitLab in a nutshell\nSo Gitlab is :\n- **Gitlab inc**: the company that manages the development of GitLab products\n- **Gitlab**: it is a version that you can install on your machine, server, or in the cloud easily with the [AWS Marketplace](https://aws.amazon.com/marketplace/pp/B071RFCJZK)\n- **GitLab.com**: it's a web version like GitHub or BitBucket\n\nGitLab and GitLab.com are web-based git repository managers with features like:\n - wiki,\n - issues tracking,\n - docker registry,\n- code tracking,\n- code review\n- CI/CD,\n - ...\n\nGitLab offers more features than GitHub in its free version. It is also possible to have private repositories without having a subscription.\n\n# Before we begin\nGitLab CI/CD will allow you to automate the `builds`, the `tests`, the `deployments`, etc of your applications. All of your tasks can be broken down into stages and all of your tasks and stages make up a pipeline.\n\nEach task is executed thanks to `runners`, which work thanks to an open source project named [GitLab Runner](https://gitlab.com/gitlab-org/gitlab-runner/) written in [GO](https://golang.org).\n\nYou can have your own `runners` directly on your machine or server. For more information I let you read the official documentation:\n - [GitLab Runner project page](https://docs.gitlab.com/runner/)\n - [Configuration of GitLab Runner](https://docs.gitlab.com/runner/configuration/)\n - [Advanced configuration for GitLab Runner](https://docs.gitlab.com/runner/configuration/advanced-configuration.html)\n\nGitLab also offers public runners, which save you an installation, but beware, there are quotas depending on the type of account you have. On a free account, you are entitled to 2,000 minutes of pipeline time per month. The gitlab.com public runners run on AWS.\n\n# Presentation of GitLab CI/CD\nAs I told you I will not show you how to set up a CI/CD from A to Z in this article but I will introduce you to the possibilities of the GitLab CI/CD solution.\n\n## Manifesto\nFor the CI/CD on GitLab to work you need a `.gitlab-ci.yml` manifest at the root of your project. In this manifesto you will be able to define `stages`, `jobs`, `variables`, `anchors`, etc.\n\nYou can give it another name, but you will have to change the manifest name in the web interface settings:  `Settings > CI/CD > General pipelines > Custom CI config path`\n\n## Jobs\nIn the GitLab CI/CD manifesto you can define an unlimited number of `jobs`, with constraints indicating when they should be executed or not.\n\nHere is the easiest way to declare a `job`:\n```yaml\njob:\n  script: echo 'my first job'\n```\n\nIf you want to declare several `jobs` :\n```yaml\njob:1:\n  script: echo 'my first job'\n\njob:2:\n  script: echo 'my second job'\n```\n\nNames of `jobs` must be unique and should not be part of reserved words:\n- `image`\n- `services`\n- `stages`\n- `types`\n- `before_script`\n- `after_script`\n- `variables`\n- `cache`\n\nIn the definition of a `job` only `script` is mandatory.\n\n## Script\nThe `script` declaration is the only mandatory part of a `job`. This declaration is the heart of the `job` because it is here that you will indicate the actions to be performed.\n\nIt can call one or more script(s) in your project, or even execute one or more command line(s).\n\n```yaml\njob:script:\n  script: ./bin/script/my-script.sh ## Appel d'un script de votre projet\n\njob:scripts:\n  script: ## Calls two scripts from your project\n    - ./bin/script/my-script-1.sh\n    - ./bin/script/my-script-2.sh\n\njob:command:\n  script: printenv # Execution of a command\n\njob:commands:\n  script: # Execution of two commands\n    - printenv\n    - echo $USER\n```\n\n## before_script and after_script\nThese declarations will allow you to perform actions before and after your main script. This can be interesting to divide the actions to be done during the `jobs`, or to call or execute an action before and after each `job`.\n\n```yaml\nbefore_script: # Execution of a command before each `job`\n  - echo 'start jobs'\n\nafter_script: # Execution of a command after each `job`\n  - echo 'end jobs'\n\njob:no_overwrite: # Here the job will execute the actions of the `before_script` and `after_script` by default\n  script:\n    - echo 'script'\n\njob:overwrite:before_script:\n  before_script:\n    - echo 'overwrite' # Will not perform the action defined in the `before_script` by default\n  script:\n    - echo 'script'\n\njob:overwrite:after_script:\n  script:\n    - echo 'script'\n  after_script:\n    - echo 'overwrite' # Will not perform the action defined in the `after_script` by default\n\njob:overwrite:all:\n  before_script:\n    - echo 'overwrite' # Will not perform the action defined in the `before_script` by default\n  script:\n    - echo 'script'\n  after_script:\n    - echo 'overwrite' # Will not perform the action defined in the `after_script` by default\n```\n\n## Image\nThis declaration is simply the docker image that will be used during a job or during all jobs.\n\n```yaml\nimage: alpine # Image used by all `jobs`, this will be the default image\n\njob:node: # Job using image node\n  image: node\n  script: yarn install\n\njob:alpine: # Job using default image\n  script: echo $USER\n```\n\n## Stages\nThis declaration makes it possible to group `jobs` into stages. For example, we can do a `build`, `codestyling`, `test`, `code coverage`, `deployment` step,….\n\n```yaml\nstages: # Here we declare all our steps\n  - build\n  - test\n  - deploy\n\njob:build:\n  stage: build # We declare that this `job` is part of the build step\n  script: make build\n\njob:test:unit:\n  stage: test # We declare that this `job` is part of the test step\n  script: make test-unit\n\njob:test:functional:\n  stage: test # We declare that this `job` is part of the test step\n  script: make test-functional\n\njob:deploy:\n  stage: deploy # We declare that this `job` is part of the deploy step\n  script: make deploy\n```\n![CI Stages]({{site.baseurl}}/assets/2018-09-19-introduction-gitlab-ci/ci-stages.png)\n\n## Only and except\nThese two directives allow you to put in place constraints on the execution of a task. You can say that a task will run only on the event of a push on master or run on every push in a branch except master.\n\nHere are the possibilities:\n - **branches** triggers the `job` when a push is made on the specified branches.\n - **tags** triggers the `job` when a tag is created.\n - **api** triggers the `job` when a second pipeline requests it through pipeline API.\n - **external** triggers the `job` through a CI/CD service other than GitLab.\n - **pipelines** triggers the `job` thanks to another pipeline, useful for multiprojects thanks to the API and the `CI_JOB_TOKEN` token.\n - **pushes** triggers the `job` when `push` is done by a user.\n - **schedules** triggers the `job` in accordance to a schedule to be configured in the web interface.\n - **triggers** triggers the `job` in accordance to a trigger token.\n - **web** triggers the `job` in accordance to `Run pipeline` button in the web interface.\n\n I'll show you three examples of use:\n\n### only and except simple\nIn its simplest use, only and except are declared like this:\n```yaml\njob:only:master:\n  script: make deploy\n  only:\n    - master # The job will only be performed during an event on the master branch\n\njob:except:master:\n  script: make test\n  except:master:\n    - master # The job will be performed on all branches during an event except on the master branch\n```\n### Complex only and except\n\nIn its most complex use, only and except are used like this:\n```yaml\njob:only:master:\n  script: make deploy\n  only:\n    refs:\n      - master # Will only be done on master\n    kubernetes: active # Kubernetes will be available\n    variables:\n      - $RELEASE == \"staging\" # Check that $RELEASE is \"staging\"\n      - $STAGING # Check that $STAGING is defined\n```\n### only with schedules\nFor the use of `schedules` you must first define rules in the web interface.\nYou can configure them in the Gitlab web interface: `CI/CD -> Schedules` and fill out the form.\n\n![CI Schedules]({{site.baseurl}}/assets/2018-09-19-introduction-gitlab-ci/ci-schedules.png)\n\nIf you want, you can set a custom time interval. This is what I did in my example. The definition is made as a [cron](https://en.wikipedia.org/wiki/Cron).\n\n## when\nAs with the `only` and `except` directives, the `when` directive is a constraint on the execution of the task. There are four possible modes:\n- `on_success`: the job will be executed only if all the` jobs` of the previous stage have passed\n- `on_failure`: the job will be executed only if a job fails\n- `always`: the job will be executed no matter what (even in case of failure)\n- `manual`: the job will be executed only by a manual action\n\n```yaml\nstages:\n  - build\n  - test\n  - report\n  - clean\n\njob:build:\n  stage: build\n  script:\n    - make build\n\njob:test:\n  stage: test\n  script:\n    - make test\n  when: on_success # will only run if the `job:build` job passes\n\njob:report:\n  stage: report\n  script:\n    - make report\n  when: on_failure # will run if the job `job:build` or` job:test` does not pass\n\njob:clean:\n  stage: clean\n  script:\n    - make clean # will run in all cases\n  when: always\n```\n\n## allow_failure\nThis directive is used to accept that a job fails without causing the pipeline to fail.\n\n```yaml\nstages:\n  - build\n  - test\n  - report\n  - clean\n\n...\n\nstage: clean\n  script:\n    - make clean\n    when: always\n    allow_failure: true # Will not fail the pipeline\n...\n```\n\n## tags\nAs I told you at the beginning of the article, with GitLab Runner you can host your own runners on a server which can be useful for specific configuration.\n\nEach runner that you define on your server has a name, if you put the name of the runner in `tags`, then this runner will be executed.\n\n```yaml\njob:tag:\n  script: yarn install\n  tags:\n    - shell # The runner with the name `shell` will be launched\n```\n\n## services\nThis declaration allows you to add basic services (docker container) to help you with your `jobs`.\nFor example if you want to use a database to test your application you will ask for it in `services`.\n\n```yaml\ntest:functional:\n  image: registry.gitlab.com/username/project/php:test\n  services:\n    - postgres # We call the `postgres` service as a database\n before_script:\n   - composer install -n\n script:\n   - codecept run functional\n```\n\n## environment\nThis declaration is used to define a specific environment for the deployment. You can create an environment in the GitLab web interface or just let GitLab CI/CD create it automatically.\n\nIt is possible to specify:\n  - a `name`,\n  - a `url`,\n  - an `on_stop` condition,\n  - an `action` in response to the previous condition.\n\n```yaml\n...\n\ndeploy:demo:\n  stage: deploy\n  environment: demo # Simple environmental statement\n  script:\n    - make deploy\n\ndeploy:production:\n  environment: # Extended environmental statement\n    name: production\n    url: 'https://blog.eleven-labs/fr/gitlab-ci/' # Application URL\n  script:\n    - make deploy\n```\n\nBy declaring `environments` you can, from the GitLab web interface, deploy / redeploy your application or directly access your site if you have declared a `url`. This is done in `Operations > Environment`.\n\n![CI Environment]({{site.baseurl}}/assets/2018-09-19-introduction-gitlab-ci/ci-environment.png)\n\nThe `undo` button allows you to redeploy, the `external link` button allows you to go to the application and the `remove` button allows you to remove the environment.\n\n`on_stop` and `action` will be used to add an action at the end of the deployment, if you want to stop your application on command. Useful for demonstration environments.\n\n```yaml\n...\n\ndeploy:demo:\n  script: make deploy\n  environment:\n    name: demo\n    on_stop: stop:demo\n\nstop:demo: # This job can only be visible and executed after the `deploy:demo` job\n  script: make stop\n  environment:\n    name: demo\n    action: stop\n```\n\nHere is the official link for the [environments documentation](docs.gitlab.com/ee/ci/environments.html) if you want to go further.\n\n## variables\nThis declaration allows you to define variables for all `jobs` or for a specific `job`.\nThis is equivalent to declaring environment variables.\n\n```yaml\n...\nvariables: # Declaration of variables for all `jobs`\n  SYMFONY_ENV: prod\n\nbuild:\n  script: echo ${SYMFONY_ENV} # Will display \"prod\"\n\ntest:\n  variables: # Declaration and rewrite of global variables for this `job`\n    SYMFONY_ENV: dev\n    DB_URL: '127.0.0.1'\n  script: echo ${SYMFONY_ENV} ${DB_URL} # Will display \"dev 127.0.0.1\"\n```\n\nAs with `environment` I'll let you look at the official documentation on [variables](https://docs.gitlab.com/ee/ci/yaml/#variables) if you want to go further.\n\nIt is also possible to declare variables from the GitLab web interface `Settings> CI/CD> Variables` and to specify an environment for them.\n\n![CI Variables]({{site.baseurl}}/assets/2018-09-19-introduction-gitlab-ci/ci-variables.png)\n\n## cache\nThis directive allows you to play with cache. The cache is useful for specifying a list of files and directories to cache along your pipeline. Once the pipeline is finished the cache will be destroyed.\n\nSeveral sub-directives are possible:\n- paths: mandatory, it allows you to specify the list of files and / or directories to cache\n- key: optional, it allows you to define a key for the list of files and / or directories. Personally, I still haven't seen the usefulness of it.\n- untracked: optional, it allows you to specify that files should not be tracked by your git repository in the event of a `push` during your pipeline.\n- policy: optional, it allows to say that the cache must be recovered or saved during a job (`push` or` pull`).\n\n```yaml\nstages:\n  - build\n  - deploy\n\njob:build:\n  stage: build\n  image: node:8-alpine\n  script: yarn install && yarn build\n  cache:\n    paths:\n      - build # cached directory\n    policy: push # the cache will just be backed up, no recovery of an existing cache\n\njob:deploy:\n  stage: deploy\n  script: make deploy\n  cache:\n    paths:\n      - build\n    policy: pull # cache recovery\n```\n\n## artifacts\nArtifacts are a bit like cache, but they can be retrieved from another pipeline.\nAs for the cache, you must define a list of files or / and directories that will be saved by GitLab.\nFiles are saved only if the `job` is successful.\n\nWe find five possible sub-directives:\n  - paths: mandatory, it allows you to specify the list of files and / or folders to put in `artifact`\n  - name: optional, it allows giving a name to the `artifact`. By default it will be named `artifacts.zip`\n  - untracked: optional, it allows to ignore the files defined in the `.gitignore` file\n  - when: optional, it allows to define when the`artifact` must be created. Three possible choices: `on_success`,` on_failure`, and `always`. The `on_success` value is the default.\n  - expire_in: optional, it allows you to define an expiration time\n\n```yaml\njob:\n  script: make build\n  artifacts:\n    paths:\n      - dist\n    name: artifact:build\n    when: on_success\n    expire_in: 1 weeks\n```\n\n## dependencies\nThis declaration works with `artifacts`, it makes a `job` dependent on an `artifact`. If the 'artifact' has expired or has been deleted / does not exist, then the pipeline will fail.\n\n```yaml\n\nbuild:artifact:\n  stage: build\n  script: echo hello > artifact.txt\n  artifacts: # Add an `artifact`\n    paths:\n      - artifact.txt\n\ndeploy:ko:\n  stage: deploy\n  script: cat artifact.txt\n  dependencies: # We link the job with 'build:artifact:fail' which does not exist so the pipeline will fail\n    - build:artifact:fail\n\ndeploy:ok:\n  stage: deploy\n  script: cat artifact.txt\n  dependencies: # We link the job with 'build:artifact' which exists so the pipeline will not fail\n    - build:artifact\n```\n\n## coverage\nThis declaration allows you to specify a regular expression to retrieve the code coverage for a `job`.\n\n```yaml\n...\n\ntest:unit:\n  script: echo 'Code coverage 13.13'\n  coverage: '/Code coverage \\d+\\.\\d+/'\n```\n\nThe code coverage will be visible in the `job` information in the GitLab web interface:\n\n![CI Coverage]({{site.baseurl}}/assets/2018-09-19-introduction-gitlab-ci/ci-coverage.png)\n\n## retry\nThis declaration allows to re-execute the `job` in case of failure. You must indicate the number of times you want to re-run the `job`.\n\n```yaml\njob:retry:\n  script: echo 'retry'\n  retry: 5\n```\n\n## include\nFor this functionality you will need a premium account. This functionality allows you to include \"templates\".\nThe \"templates\" can be local in your project or remotely.\n\nFiles are always evaluated first and merged recursively. You can override or replace \"template\" declarations.\n\n - local template\n\n```yaml\n# template-ci/.lint-template.yml\n\njob:lint:\n  stage: lint\n  script:\n    - yarn lint\n```\n\n - remote template\n\n```yaml\n# https://gitlab.com/awesome-project/raw/master/template-ci/.test-template.yml\n\njob:test:\n  stage: test\n  script:\n    - yarn test\n```\n\n - main manifesto\n\n```yaml\n# .gitlab-ci.yml\n\ninclude:\n  - '/template-ci/.lint-template.yml'\n  - 'https://gitlab.com/awesome-project/raw/master/template-ci/.test-template.yml'\n\nstages:\n  - lint\n  - test\n\nimage: node:9-alpine\n\njob:lint:\n  before_script:\n    - yarn install\n\njob:test:\n  script:\n    - yarn install\n    - yarn unit\n```\n\nHere is what gitlab CI/CD will interpret:\n\n```yaml\nstages:\n  - lint\n  - test\n\nimage: node:9-alpine\n\njob:lint:\n  stage: lint\n  before_script: # we override `job:lint` with `before_script`\n    - yarn install\n  script:\n    - yarn lint\n\njob:test:\n  stage: test\n  script: # we replace the `script` declaration of the \"template\" https://gitlab.com/awesome-project/raw/master/template-ci/.test-template.yml\n    - yarn install\n    - yarn unit\n```\n\nThis can be useful if your manifesto is large, and therefore more difficult to maintain.\n\n## Anchors\nThis feature allows you to reuse templates several times.\n\n```yaml\n.test_template: &test_template\n  stage: test\n  image: registry.gitlab.com/username/project/php:test\n  before_script:\n    - composer install -n\n  when: on_success\n\n.db_template:\n  services:\n    - postgres\n    - mongo\n\ntest:unit:\n  <<: *test_template\n  script:\n    - bin/phpunit --coverage-text --colors=never tests/\n\ntest:functional:\n  <<: *test_template\n  services: *db_template\n  script:\n    - codecept run functional\n```\n\nHere is what gitlab CI/CD will interpret:\n\n```yaml\ntest:unit:\n  stage: test\n  image: registry.gitlab.com/username/project/php:test\n  before_script:\n    - composer install -n\n  script:\n    - bin/phpunit --coverage-text --colors=never tests/\n  when: on_success\n\ntest:functional:\n  stage: test\n  image: registry.gitlab.com/username/project/php:test\n  services:\n    - postgres\n    - mongo\n  before_script:\n    - composer install -n\n  script:\n    - codecept run functional\n  when: on_success\n```\n\n# Resources\n\n- [GitLab Continuous Integration (GitLab CI/CD)](https://docs.gitlab.com/ee/ci/README.html)\n- [Getting started with GitLab CI/CD](https://docs.gitlab.com/ee/ci/quick_start/README.html)\n- [Configuration of your jobs with .gitlab-ci.yml](https://docs.gitlab.com/ee/ci/yaml/README.html)\n- [GitLab Runner](https://docs.gitlab.com/runner/)\n"}