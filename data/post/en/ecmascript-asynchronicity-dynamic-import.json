{"date":"2017-10-04T00:00:00.000Z","title":"ECMAScript Asynchronicity - dynamic import","excerpt":"Optimize your production code by splitting and lazy loading modules","readingTime":"18mn","authors":["kelfarsaoui"],"categories":["javascript"],"content":"\nECMAScript came up with some awesome features that demystify the concept of asynchronous programming. These features vary from promises, through asynchronous functions —and soon iterations— to lazy loading modules. Today I'm going to talk about one of the promising features in Javascript's Asynchronicity: ECMAScript's dynamic import.\n\n### Motivation\nImagine you are developing a large scale web application, with several thousands of lines of code, and dozens of dependencies. And now you are happy that you're finally building your application to be ready for production. Once you create your bundle file and load it in the page, your application might work just fine. However, because life is full of unpleasant surprises, your app might be just another disappointment and you will end up feeling annoyingly uncomfortable.\n\nWhy is that? Your bundle, my friend, is nothing less than a massive file which requires too much time in order to be loaded in your page. Given some, not so glorifying, browsers performance, you're gonna need to address the situation.\n\nFortunately for you, there are some good folks out there working on stuff that can help you, stuff like code splitting. They make sure your app is loaded in several chunks, as small as possible, in order to accelerate the loading. The tools that provide this kind of features are: [RequireJS](https://requirejs.org), [SystemJS](https://github.com/systemjs/systemjs), [Webpack](https://github.com/webpack/webpack), [Rollup](https://rollupjs.org/) and [curl](https://github.com/cujojs/curl){:rel=\"nofollow noreferrer\"}. They are capable of bundling your app and generating your bundle chunks, and especially lazy loading them, so you can load only the one that you need at a given time.\n\nTherefore, the use of dynamic import is necessary. Its main purpose is to optimize the amount of loaded code by lazy loading modules.\n\nSince we're talking about modules, let's take a look at them.\n\n### Modules\n\nECMAScript provides a module system that is similar to that of Node. Its modules are represented by simple files, and each module has its own context. This means that whatever variables, functions, etc, you declare inside of these files, they won’t pollute the global context.\n\n```js\n// add.js\nconst simpleAdd = (a, b) => a + b;\n\nconst multipleAdd = (...numbers) => numbers.reduce(simpleAdd, 0);\n\nexport default (...numbers) => multipleAdd(...numbers);\n```\n\nThe code above declares 2 local functions and exports an anonymous one. We can't use the local functions outside of this module. In the module below, we only have access to what `add.js` exports, namely the anonymous function, which we are renaming to `add`.\n\n```js\n// service.js\nimport add from './add';\n\nexport default () => {\n  console.log(add(1, 2, 3, 4));\n}\n```\n\nThe ascension of ES6 made it possible to put an end to the choice between the two protagonist systems of ES5: `CommonJS` and `AMD`. ES6 system has a declarative syntax, which makes it clear and simple. It combines their benefits, and provides an intuitive syntax that makes it easy for engineers to handle.\n\nIt even goes beyond the capabilities of ES5 system by using both synchronous and asynchronous loading, along with a static module structure. That is, you need to explicitly specify what you are importing, by using module names instead of dynamic variables. So, the following is not recommended:\n\n```js\nimport myService from `../services/${myServiceName}`;\n```\n\nThe static aspect of ES6 modules comes up with some great benefits:\n\n- It makes it easy for bundlers to eliminate unused modules and de-duplicate redundant ones when bundling. This is called Tree Shaking —which was made popular by the module bundler [Rollup](https://rollupjs.org/){:rel=\"nofollow noreferrer\"}.\n- Allows cyclic dependencies between modules.\n- Provides variable checking that we can think of as a \"shallow type checking\", which will give us the opportunity to early catch common errors.\n- Gives the possibility to add static type checking in future versions of ECMAScript.\n\nFor further reading on modules, check Dr. Axel Rauschmayer's [online book](http://exploringjs.com/es6/ch_modules.html){:rel=\"nofollow noreferrer\"} on modules.\n\n### Code splitting with Webpack\n\nWebpack offers several features to optimize your application's bundle. Code splitting is among these features. It can be done in 2 different ways: declarative and imperative. The declarative way generates several bundles based on the entries you specify in Webpack's config, while the imperative way generates bundles based on dynamic imports in your code. Let's see how the declarative one is done:\n\nHere is a classical Webpack config file:\n\n```ts\n// webpack.config.ts\nimport * as CompressionPlugin from 'compression-webpack-plugin';\nimport * as path from 'path';\nimport * as webpack from 'webpack';\n\nexport default {\n  devtool: 'source-map',\n  target: 'web',\n  entry: [\n    './src/index',\n  ],\n  plugins: [\n    new CompressionPlugin(),\n  ],\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: '[name].js',\n    chunkFilename: '[name].js',\n    publicPath: '/',\n    library: '[name]',\n    libraryTarget: 'umd',\n    umdNamedDefine: true,\n  },\n  resolve: {\n    extensions: ['.js', '.jsx'],\n  },\n  module: {\n    rules: [\n      ...\n    ],\n  },\n};\n```\n\nAfter building our app, Webpack generates only one bundle, `main.js`, with its source map `main.js.map`. And, thanks to the [`compression-webpack-plugin`](https://www.npmjs.com/package/compression-webpack-plugin){:rel=\"nofollow noreferrer\"}, we have also those files \"gzip\"ed.\n\n```bash\n$ NODE_ENV=production webpack -p\nts-loader: Using typescript@2.5.3 and /Users/kamal/code/vacs/tsconfig.json\nHash: 35488b05aa5b90774401\nVersion: webpack 3.6.0\nTime: 10955ms\n         Asset       Size  Chunks                    Chunk Names\n       main.js     406 kB       0  [emitted]  [big]  main\n   main.js.map    3.83 MB       0  [emitted]         main\n    main.js.gz    97.7 kB          [emitted]\nmain.js.map.gz     803 kB          [emitted]  [big]\n    index.html  246 bytes          [emitted]\n  [38] (webpack)/buildin/global.js 509 bytes {0} [built]\n  [50] ./src/constants.ts 173 bytes {0} [built]\n  ...\nDone in 13.48s.\n```\n\nOne of the ways you can split your bundle is by defining entry points in Webpack config. These entry points represent the chunks that will be generated. Another way is by using [CommonsChunkPlugin](https://webpack.js.org/plugins/commons-chunk-plugin/){:rel=\"nofollow noreferrer\"}. In the following example, we’re going to use both ways.\n\nHow to choose your entry points is totally up to you. In our case, we will adopt a strategy that will help us isolate vendor libraries in a single chunk. Then, we create another chunk only for our app’s code.\n\n```ts\nimport * as HTMLWebpackPlugin from 'html-webpack-plugin';\nimport * as path from 'path';\nimport * as webpack from 'webpack';\n\nexport default {\n  devtool: 'source-map',\n  entry: {\n    styles: path.join(__dirname, 'src', 'assets', 'scss', 'main.scss'),\n    main: path.join(__dirname, 'src', 'index'),\n  },\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor',\n      filename: 'vendor.js',\n      minChunks(module) {\n        const context = module.context;\n        return context && context.indexOf('node_modules') >= 0;\n      },\n    }),\n\n    new HTMLWebpackPlugin({\n      title: 'App',\n      template: './templates/index.ejs',\n    }),\n  ],\n  output: {\n    path: path.join(__dirname, 'demo'),\n    filename: '[name].js',\n    chunkFilename: '[name].js',\n    publicPath: '/',\n    library: '[name]',\n    libraryTarget: 'umd',\n    umdNamedDefine: true,\n  },\n  ...\n}\n```\n\nIn our entry property, we're specifying 2 entry points `main` and `styles`, and we're using the `CommonsChunkPlugin` to intercept vendor modules, so that we can isolate them in a single chunk `vendor.js`. This is done by the `minChunks` function of the plugin.\n\n```bash\n$ NODE_ENV=production webpack -p\nts-loader: Using typescript@2.5.3 and /Users/kamal/code/vacs/tsconfig.json\nHash: 5aabff62c38fc1681fe7\nVersion: webpack 3.6.0\nTime: 12965ms\n        Asset       Size  Chunks                    Chunk Names\n      main.js    15.3 kB       0  [emitted]         main\n    styles.js  926 bytes       1  [emitted]         styles\n    vendor.js     388 kB       2  [emitted]  [big]  vendor\n  main.js.map    66.8 kB       0  [emitted]         main\nstyles.js.map     5.8 kB       1  [emitted]         styles\nvendor.js.map    3.78 MB       2  [emitted]         vendor\n   index.html  360 bytes          [emitted]\n  [49] (webpack)/buildin/global.js 509 bytes {2} [built]\n  ...\nDone in 16.68s.\n```\n\nUntil now we've only seen how to split our code at compile time, how about runtime?\n\n### Lazy loading\n\nLazy loading is a much cooler feature than simple code splitting; not only it splits your code, but loads only the chunks you need. It allows you to incrementally load your app. This is a piece of cake for ECMAScript's `import()`, but before getting there, let's see how the legacy way was:\n\n---\n#### Webpack's `require.ensure`\n\nIn the following example we will see how to asynchronously load the `StoryEditor` component from `Editor`:\n\n```js\n// StoryEditor.jsx\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nexport default class StoryEditor extends Component {\n  ...\n}\n```\n\nHere is the Editor component that loads the `StoryEditor` component asynchronously, using the `require.ensure` method:\n\n```js\n// Editor.jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nexport default class extends React.Component {\n  static propTypes = {\n    story: PropTypes.shape().isRequired,\n  };\n\n  state = {};\n\n  componentDidMount() {\n    require.ensure(['./editors/StoryEditor'], (require) => {\n      const StoryEditor = require('./editors/StoryEditor');\n      this.setState({ entityEditor: StoryEditor });\n    });\n  }\n\n  render() {\n    const { entityEditor: EntityEditor } = this.state;\n\n    return (\n      <div className=\"editor\">\n        <div className=\"editor-header\">\n          <div className=\"editor-header-title\">Editor</div>\n          <button\n            className=\"editor-header-close\"\n            onClick={this.props.close}\n          >Close</button>\n        </div>\n        <div className=\"editor-body\">\n          {EntityEditor && <EntityEditor {...this.props} />}\n        </div>\n      </div>\n    );\n  }\n}\n```\n\nIn the `componentDidMount` lifecycle method we use `require.ensure` to load and make available the `StoryEditor` component. Then, we use the static `require` to extract and display it.\n\nSo, when we execute our code, the file that is loaded should be as follows:\n\n```js\nwebpackJsonp_name_([0],{\n\n/***/ 177:\n/***/ (function(module, exports, __webpack_require__) {\n\n... // too much code\n\nvar StoryEditor = function (_Component) {\n  _inherits(StoryEditor, _Component);\n\n  ... // too much code\n\n  return StoryEditor;\n}(_react.Component);\n\nexports.default = StoryEditor;\nmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 462:\n/***/ (function(module, exports, __webpack_require__) {\n\n... // too much code\n\nvar FormGroup = function FormGroup(_ref) {\n  ... // too much code\n};\n\nexports.default = FormGroup;\nmodule.exports = exports['default'];\n\n/***/ })\n\n});\n//# sourceMappingURL=0.js.map\n```\n\nThis ugly code is the result of transpiling and bundling the `StoryEditor` component. As you can see, it asynchronously loaded children components too, namely `FormGroup`.\n\nThere is, however, some restrictions to this approach. The `require.ensure` method resolves modules statically. It means that you need to specify the modules in string literals, that are evaluated at compile time, so you can't use variables. But, if you want to lazy load modules dynamically, ECMAScript's dynamic `import()` will have the pleasure to satisfy your request.\n\n---\n#### `import()`\n\nThe dynamic import is a pretty awesome feature ECMAScript came up with. It offers the possibility to handle cases like: computed module specifiers, conditional loading of modules, accessing exports and default exports, and many more. The [dynamic import proposal](https://github.com/tc39/proposal-dynamic-import){:rel=\"nofollow noreferrer\"} is in stage 3 at the time of this writing.\n\nLike `require.ensure`, `import()` relies on `Promise`. This implies that you have to use some polyfills like [es6-promise](https://www.npmjs.com/package/es6-promise) or [promise-polyfill](https://www.npmjs.com/package/promise-polyfill) in order to make it work. You're gonna need `babel` support too, using the [Syntax Dynamic Import](https://babeljs.io/docs/plugins/syntax-dynamic-import/) plugin that allows the parsing of `import(){:rel=\"nofollow noreferrer\"}`.\n\n```json\n// .babelrc\n{\n  \"presets\": [\"env\", \"react\"],\n  \"plugins\": [\n    \"syntax-dynamic-import\"\n  ]\n}\n```\n\nHere is the `import()` version of the previous example:\n\n```js\n  ...\n  async componentDidMount() {\n    this.setState({ entityEditor: await import('./editors/StoryEditor') });\n  }\n  ...\n```\n\nSo intuitive!\n\nIn the `require.ensure` example, we've seen how it loads a statically resolved modules. Now, what if `Editor.jsx` doesn't know which editor to load? What if we give it an array of editors, so it can load them? Let's see how `import()` handles this like a boss:\n\n```js\n// Editor.jsx\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\n\nexport default class extends React.Component {\n  static propTypes = {\n    story: PropTypes.shape().isRequired,\n    editors: PropTypes.arrayOf(PropTypes.string),\n  };\n\n  static defaultProps = {\n    editors: [\n      'StoryEditor',\n      'MessageEditor',\n    ],\n  };\n\n  state = {};\n\n  async componentDidMount() {\n    const { editors } = this.props;\n    const loadedEditors = await Promise.all(editors.map(this.importEditor));\n    this.setState({ loadedEditors });\n  }\n\n  importEditor(module) {\n   return import(`./editors/${module}`);\n  }\n\n  render() {\n    const { loadedEditors } = this.state;\n\n    return (\n      <div className=\"editor\">\n        <div className=\"editor-header\">\n          <div className=\"editor-header-title\">Editor</div>\n          <button\n            className=\"editor-header-close\"\n            onClick={this.props.close}\n          >Close</button>\n        </div>\n        <div className=\"editor-body\">\n          {loadedEditors && loadedEditors.map((editor, key) => {\n            const renderer = React.createFactory(editor);\n            return renderer({ ...this.props, key });\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n```\n\nThe `import()` statement is dynamic. Yes! But it needs something to rely on: a context. In our case, this context is the `./editors/` that we feed it.\n\n```js\n  ...\n  importEditor(module) {\n    return import(`./editors/${module}`);\n  }\n  ...\n```\n\nAt compile time, ECMAScript cannot resolve the `module` argument. It's going to systematically ignore it, and take the first static piece of the module name `./editors/`, then generate a context module using it.\n\nWait, what the heck is a context module?\n\nA context module is a kind of bundle that Webpack generates for a given directory, in order to make it possible to **dynamically** load any file in that directory. Take for example Webpack's [`require.context`](https://webpack.js.org/api/module-methods/#require-context){:rel=\"nofollow noreferrer\"} function:\n\n```js\nconst context = require.context('./editors/', true, /\\.jsx?$/);\n\ncontext.keys(); // returns [\"./StoryEditor.jsx\", \"./MessageEditor.jsx\"]\n```\n\nWe just created a context module that contains the 2 files `StoryEditor.jsx` and `MessageEditor.jsx`. Now, we can dynamically load them by simply `require`ing them:\n\n```js\nconst context = require.context('./editors/', true, /\\.jsx?$/);\n\nvar modules = ((contextRequire) => {\n  return contextRequire.keys().map(contextRequire);\n})(context);\n```\n\n_**Notice**: the context returned from `require.context` is a function that works like a local `require`, and in the same time an object that contains the paths to all the files it holds._\n\nHere is what Webpack says about `require.context`:\n> A context module is generated. It contains references to all modules in that directory that can be required with a request matching the regular expression. The context module contains a map which translates requests to module ids.\n>\n>The context module also contains some runtime logic to access the map.\n>\n>–– https://webpack.github.io/docs/context.html\n\nOkay, but what about asynchronous routing?\n\n### Example of asynchronous routing\n\nUsing `react-router` we will define some routes in our app in order to load the components of those routes asynchronously:\n\nHere are some classic routes:\n\n```js\n// routes.jsx\nimport App from './App';\nimport ListPage from './containers/ListPage';\nimport StoryPage from './containers/StoryPage';\n\nexport default [{\n  component: App,\n  routes: [\n    {\n      path: '/list',\n      exact: true,\n      component: ListPage,\n    },\n    {\n      path: '/stories/:id',\n      exact: true,\n      component: StoryPage,\n    },\n  ],\n}];\n```\n\nThe components are loaded synchronously because we're importing them statically. To do it dynamically we need to use a wrapper component that loads the other components —`ListPage` and `StoryPage`. The wrapper component uses the `componentDidMount` lifecycle method to load those components.\n\nWe are going to write it as a factory function that takes a `name` argument in order to know what to load.\n\n```js\n// asyncComponentFactory.js\nexport default name => class extends React.Component {\n  static displayName = `${name}Wrapper`;\n\n  state = {};\n\n  async componentDidMount() {\n    const component = await import(`./containers/${name}`);\n    this.setState({ component });\n  }\n\n  render() {\n    const { component } = this.state;\n\n    if (!component) {\n      return null;\n    }\n\n    const renderer = React.createFactory(component);\n    return renderer(this.props);\n  }\n};\n```\n\nThis factory returns a component class which the router renders in the page, and once it is mounted, the class imports the real component (`ListPage` or `StoryPage`) and renders it. The following explains how we should use it:\n\n```js\n// routes.jsx\nimport App from './App';\nimport AsyncComponentFactory from './asyncComponentFactory';\n\nexport default [{\n  component: App,\n  routes: [\n    {\n      path: '/list',\n      exact: true,\n      component: AsyncComponentFactory('ListPage'),\n    },\n    {\n      path: '/stories/:id',\n      exact: true,\n      component: AsyncComponentFactory('StoryPage'),\n    },\n  ],\n}];\n```\n\nNow, all you need to do is visit those routes, so that you can appreciate how amazing asynchronous import of components is. In the case of the `/list` route, React's representation of the components tree should look like this:\n\n```html\n<Route>\n  <ListPageWrapper>\n    <ListPage>\n      ...\n    </ListPage>\n  </ListPageWrapper>\n</Route>\n```\n\n### Conclusion\n\nOptimizing production performances is a boundless topic. There are many other strategies that help improving it. Thus it should be clear that Asynchronicity is merely one solution amongst other various ones that can be used to enhance production performances. I hope this post was useful and could enlighten some curious minds about ECMAScript's asynchronous loading.\n\nThanks for reading.\n"}