{"date":"2017-01-31T00:00:00.000Z","title":"RabbitMQ: Publish, Consume, and Retry Messages","excerpt":"![Swarrot Logo](/_assets/posts/2017-01-23-publier-consommer-reessayer-des-messages-rabbitmq/logo.png)","readingTime":"12mn","authors":["rpierlot"],"categories":["php"],"content":"![Swarrot Logo](/imgs/posts/2017-01-23-publier-consommer-reessayer-des-messages-rabbitmq/logo.png)\n\nRabbitMQ is a message broker, allowing to process things asynchronously. There's already an [article](https://blog.eleven-labs.com/fr/creer-rpc-rabbitmq/){:rel=\"nofollow\"} written about it, if you're not familiar with RabbitMQ.\n\nWhat I'd like to talk to you about is the lifecycle of a message, with error handling. Everything in a few lines of code.\n\nTherefore, we're going to configure a RabbitMQ virtual host, publish a message, consume it and retry publication if any error occurs.\n\n## Our Tools\n\nThe technical solution is based on two libraries:\n\n*   [RabbitMQ Admin Toolkit](https://github.com/odolbeau/rabbit-mq-admin-toolkit){:rel=\"nofollow\"} : PHP library the interacts with the HTTP API of our RabbitMQ server, to create exchanges, queues...\n*   [Swarrot](https://github.com/swarrot/swarrot){:rel=\"nofollow\"} : PHP library to consume and publish our messages.\n\nSwarrot is compatible with the amqp extension of PHP, as well as the [php-amqplib](https://github.com/php-amqplib/php-amqplib) library. The PHP extension has a certain advantage on performance (written in C) over the library, based on [benchmarks](https://odolbeau.fr/blog/benchmark-php-amqp-lib-amqp-extension-swarrot.html). To install the extension, click [here](https://serverpilot.io/community/articles/how-to-install-the-php-amqp-extension.html){:rel=\"nofollow\"}.\nThe main adversary to Swarrot, [RabbitMqBundle](https://github.com/php-amqplib/RabbitMqBundle){:rel=\"nofollow\"}, is not compatible with the PHP extension, and is not as simple in both configuration and usage.\n\n## Configuration\n\nOur first step will be to create our RabbitMQ configuration: our exchange and our queue.\n\nThe RabbitMQ Admin Toolkit library, developed by _[odolbeau](https://github.com/odolbeau){:rel=\"nofollow\"},_ allows us to configure our vhost very easily. Here is a basic configuration declaring an exchange and a queue, allowing us to send our mascot Wilson and his fellow friends to space:\n\n```yaml\n# default_vhost.yml\n'/':\n    parameters:\n        with_dl: false # If true, all queues will have a dl and the corresponding mapping with the exchange \"dl\"\n        with_unroutable: false # If true, all exchange will be declared with an unroutable config\n\n    exchanges:\n        default:\n            type: direct\n            durable: true\n\n    queues:\n        send_astronaut_to_space:\n            durable: true\n            bindings:\n                - exchange: default\n                  routing_key: send_astronaut_to_space\n```\n\nHere, we ask the creation of an exchange named \"default\", and a queue named \"send_astronaut_to_space\", bound to our exchange via a homonym routing key.\nA binding represents a relation between a queue and an exchange.\n\nLet's launch the command to create our vhost:\n\n```bash\nvendor/bin/rabbit vhost:mapping:create default_vhost.yml --host=127.0.0.1\nPassword?\nWith DL: false\nWith Unroutable: false\nCreate exchange default\nCreate queue send_astronaut_to_space\nCreate binding between exchange default and queue send_astronaut_to_space (with routing_key: send_astronaut_to_space)\n```\n\nIf you connect to the RabbitMQ management interface (ex: http://127.0.0.1:15672/), many things will appear:\n\n![Capture of exchanges created](/imgs/posts/2017-01-23-publier-consommer-reessayer-des-messages-rabbitmq/create_exchanges.png)\n\nClick on the _Exchanges_ tab: an exchange named _default_ has been created, with a binding to our queue as indicated in our terminal.\n\n![Capture of queues created](/imgs/posts/2017-01-23-publier-consommer-reessayer-des-messages-rabbitmq/create_queues.png)\n\nNow click on the _Queues_ tab: _send_astronaut_to_space_ is also here.\n\nLet's take a look at the publication and consumption of messages.\n\n## Consumption\n\nThe library helping us to consume and publish messages, Swarrot, has a Symfony bundle which will help us use it very easily in our app: [SwarrotBundle](https://github.com/swarrot/SwarrotBundle){:rel=\"nofollow\"}.\n\nThe thing we want to achieve here is to publish messages, and to consume them. Here is how it's done.\n\nAfter installing the bundle, we have to configure it:\n\n```yaml\n# app/config/config.yml\nswarrot:\n    provider: pecl # pecl or amqp_lib\n    connections:\n        rabbitmq:\n            host: '%rabbitmq_host%'\n            port: '%rabbitmq_port%'\n            login: '%rabbitmq_login%'\n            password: '%rabbitmq_password%'\n            vhost: '/'\n    consumers:\n        send_astronaut_to_space: # name of the consumer\n            processor: processor.send_astronaut_to_space # name of the service\n            extras:\n                poll_interval: 500000\n                requeue_on_error: false\n            middleware_stack:\n                - configurator: swarrot.processor.exception_catcher\n                - configurator: swarrot.processor.ack\n```\n\nThis is a configuration example. The interesting part comes around the \"consumers\" parameter.\n\nEvery message published in an exchange will be routed to a queue according to its routing jey. Therefore, we need to process a message stored in a queue. Using Swarrot, special things called _processors_ are in charge of this.\n\nTo consume a message, we need to create our own processor. As indicated in the documentation, a processor is just a Symfony service who needs to implement the _ProcessInterface_ interface.\n\n![Swarrot - Middleware stack](https://camo.githubusercontent.com/8ac89cd415aebfb1026b2278093dbcc986b126da/68747470733a2f2f646f63732e676f6f676c652e636f6d2f64726177696e67732f642f3145615f514a486f2d3970375957386c5f62793753344e494430652d41477058527a7a6974416c59593543632f7075623f773d39363026683d373230){:rel=\"nofollow\"}\n\nThe particularity of processors is that they work using middlewares, allowing to add behavior before and/or after the processing of our message (our processor). That's why there is a _middleware_stack_ parameter, that holds two things: _swarrot.processor.exception_catcher_ and _swarrot.processor.ack_. Although optional, these middlewares bring nice flexibility. We'll come back on this later on.\n\n```php\n<?php\n\nnamespace AppBundle\\Processor;\n\nuse Swarrot\\Broker\\Message;\nuse Swarrot\\Processor\\ProcessorInterface;\n\nclass SendAstronautToSpace implements ProcessorInterface\n{\n    public function process(Message $message, array $options)\n    {\n        //...\n    }\n}\n```\n\nOur _SendAstronautToSpace_ processor implements a method called _process_, which allows us to retrieve the message to consume, and use it in our application.\n\nWe've just setup the consumption of messages. What do we need to do next? See the publication part of course!\n\n## Publication\n\nOnce again, it's very simple to publish messages with Swarrot. We only need to declare a _publisher_ in our configuration, and use the SwarrotBundle publication service to publish a new message.\n\n```yaml\n# app/config/config.yml\n    consumers:\n# ...\n            middleware_stack:\n                - configurator: swarrot.processor.exception_catcher\n                - configurator: swarrot.processor.ack\n\n    messages_types:\n        send_astronaut_to_space_publisher:\n            connection: rabbitmq\n            exchange: default\n            routing_key: send_astronaut_to_space\n```\n\nThe secret is to declare a new message type, specifying the _connection_, _exchange_, and the _routing key._ Then publish a message this way:\n\n```php\n<?php\n\n$message = new Message('Wilson wants to go to space');\n$this->get('swarrot.publisher')->publish('send_astronaut_to_space_publisher', $message);\n```\n\nThe service _swarrot.publisher_ deals with publishing our message. Simple right?\n\nAfter setting up _queues_, published and consumed a message, we now have a good view of the life-cycle of a message.\n\n## Handling errors\n\nOne last aspect I'd like to share with you today is about errors while consuming your messages.\n\nSetting aside implementation problems in your code, it's possible that you encounter exceptions, due to external causes. For instance, you have a processor that makes HTTP calls to an outside service. The said service can be temporarily down, or returning an error. You need to publish a message and make sure that this one is not lost. Wouldn't it be great to publish this message again if the service does not respond? And do so after a certain amount of time?\n\nSomewhere along the way, I've been confronted to this problem. We knew such things could happen and we needed to automatically \"retry\" our messages publication.\nI'm going to show you how to proceed, keeping our example _send_astronaut_to_space._ Let's decide that we're going to retry the publication of our message 3 times maximum. To do that, we need 3 retry queues. Fortunately, configuration of retry queues and exchanges is so easy with [RabbitMQ Admin Toolkit](https://github.com/odolbeau/rabbit-mq-admin-toolkit){:rel=\"nofollow\"}: we only need one line! Let's see this more closely :\n\n```yaml\n# default_vhost.yml\n# ...\nqueues:\n    send_astronaut_to_space:\n        durable: true\n        retries: [5, 25, 100] # Create a retry exchange with 3 retry queues prefixed with send_astronaut_to_space\n        bindings:\n            - exchange: default\n              routing_key: send_astronaut_to_space\n```\n\nThe array of parameters of key _retries_ corresponds to the delay after which the message will be published again. Following the first failure, 5 seconds will go by before publishing again the message. Then 25 seconds, and finally 100\\. The behavior suits our problem perfectly...\n\nIf we launch our command one more time, here is the result:\n\n```bash\nvendor/bin/rabbit vhost:mapping:create default_vhost.yml --host=127.0.0.1\nPassword?\nWith DL: false\nWith Unroutable: false\nCreate exchange default\nCreate exchange dl\nCreate queue send_astronaut_to_space\nCreate queue send_astronaut_to_space_dl\nCreate binding between exchange dl and queue send_astronaut_to_space_dl (with routing_key: send_astronaut_to_space)\nCreate queue send_astronaut_to_space_retry_1\nCreate binding between exchange retry and queue send_astronaut_to_space_retry_1 (with routing_key: send_astronaut_to_space_retry_1)\nCreate queue send_astronaut_to_space_retry_2\nCreate binding between exchange retry and queue send_astronaut_to_space_retry_2 (with routing_key: send_astronaut_to_space_retry_2)\nCreate queue send_astronaut_to_space_retry_3\nCreate binding between exchange retry and queue send_astronaut_to_space_retry_3 (with routing_key: send_astronaut_to_space_retry_3)\nCreate binding between exchange default and queue send_astronaut_to_space (with routing_key: send_astronaut_to_space)\n```\n\nWe still create a default exchange. Then, many things are done:\n\n*   Creation of an exchange called _dl_ and queues _queues_ _send_astronaut_to_space and_ _send_astronaut_to_space_dl_ : we'll come back on this later on.\n*   Creation of an exchange called _retry_ and queues _send_astronaut_to_space_retry_1_, _send_astronaut_to_space_retry_2_ and _send_astronaut_to_space_retry_3_: here is the interesting part, all queues that will be used to do a retry of our message.\n\nNow let's configure our consumer.\n\nWith Swarrot, handling of retries is very easy to configure. Do you remember those middlewares we've seen before? Well there's a middleware for that!\n\n```yaml\n# app/config/config.yml\n    consumers:\n# ...\n            middleware_stack:\n                - configurator: swarrot.processor.exception_catcher\n                - configurator: swarrot.processor.ack\n                - configurator: swarrot.processor.retry\n                  extras:\n                      retry_exchange: 'retry'\n                      retry_attempts: 3\n                      retry_routing_key_pattern: 'send_astronaut_to_space_retry_%%attempt%%'\n\n    messages_types:\n        send_astronaut_to_space_publisher:\n            connection: rabbitmq\n            exchange: default\n            routing_key: send_astronaut_to_space\n```\n\nThe main difference with our previous configuration is located around the parameter _middleware_stack_: we need to add the processor _swarrot.processor.retry_, with its retry strategy:\n\n*   the name of the retry exchange (defined above)\n*   the number of publishing attempts\n*   the pattern of retry queues\n\nThe workflow works this way: if the message is not _acknowledged_ followingan exception the first time, it will be published in the _retry_ exchange_,_ with routing key_send_astronaut_to_space_retry_1\\._ Then, 5 seconds later, the message is published back in our main queue _send_astronaut_to_space_. If another error is encountered, it will be republished in the retry exchange, with the routing key _send_astronaut_to_space_retry_2_, and 25 seconds later the message will be back on our main queue. Same thing one last time with 100 seconds.\n\n```bash\nbin/console swarrot:consume:send_astronaut_to_space send_astronaut_to_space\n[2017-01-12 12:53:41] app.WARNING: [Retry] An exception occurred. Republish message for the 1 times (key: send_astronaut_to_space_retry_1) {\"swarrot_processor\":\"retry\",\"exception\":\"[object] (Exception(code: 0): An error occurred while consuming hello at /home/gus/dev/swarrot/src/AppBundle/Processor/SendAstronautToSpace.php:12)\"}\n[2017-01-12 12:53:46] app.WARNING: [Retry] An exception occurred. Republish message for the 2 times (key: send_astronaut_to_space_retry_2) {\"swarrot_processor\":\"retry\",\"exception\":\"[object] (Exception(code: 0): An error occurred while consuming hello at /home/gus/dev/swarrot/src/AppBundle/Processor/SendAstronautToSpace.php:12)\"}\n[2017-01-12 12:54:11] app.WARNING: [Retry] An exception occurred. Republish message for the 3 times (key: send_astronaut_to_space_retry_3) {\"swarrot_processor\":\"retry\",\"exception\":\"[object] (Exception(code: 0): An error occurred while consuming hello at /home/gus/dev/swarrot/src/AppBundle/Processor/SendAstronautToSpace.php:12)\"}\n[2017-01-12 12:55:51] app.WARNING: [Retry] Stop attempting to process message after 4 attempts {\"swarrot_processor\":\"retry\"}\n[2017-01-12 12:55:51] app.ERROR: [Ack] An exception occurred. Message #4 has been nack'ed. {\"swarrot_processor\":\"ack\",\"exception\":\"[object] (Exception(code: 0): An error occurred while consuming hello at /home/gus/dev/swarrot/src/AppBundle/Processor/SendAstronautToSpace.php:12)\"}\n[2017-01-12 12:55:51] app.ERROR: [ExceptionCatcher] An exception occurred. This exception has been caught. {\"swarrot_processor\":\"exception\",\"exception\":\"[object] (Exception(code: 0): An error occurred while consuming hello at /home/gus/dev/swarrot/src/AppBundle/Processor/SendAstronautToSpace.php:12)\"}\n```\n\nWhen creating our virtual host, we saw that an exchange called _dl ,_ associated to a queue _send_astronaut_to_space_dl_ has been created. This queue is our message's last stop if the retry mechanism is not able to successfully publish our message (an error is still encountered after each retry).\nIf we look closely the details of queue _send_astronaut_to_space_, we see that \"_x-dead-letter-exchange_\" is equal to\"_dl_\", and that \"_x-dead-letter-routing-key_\" is equal to \"_send_astronaut_to_space_\", corresponding to our binding explained previously.\n\nOn every error in our processor, the _retryProcessor_ will catch this error, and republish our message in the retry queue as many times as we've configured it. Then Swarrot will hand everything to RabbitMQ to route our message to the queue queue _send_astronaut_to_space_dl._\n\n## Conclusion\n\nSwarrot is a library that allows us to consume and publish messages in a very simple manner. Its system of middlewares increases possibility in the consumption of messages.\nTied to RabbitMQ Admin Toolkit to configure exchanges and queues, Swarrot will also let you retry your lost messages very easily.\n\n## References\n\n*   [RabbitMQ Admin Toolkit](https://github.com/odolbeau/rabbit-mq-admin-toolkit){:rel=\"nofollow\"}\n*   [Swarrot](https://github.com/swarrot/swarrot){:rel=\"nofollow\"}\n"}