{"date":"2020-01-08T00:00:00.000Z","title":"[iOS] Let's think outside the box","excerpt":"Let's use the Framework in a way that it's not supposed to be","readingTime":"17mn","authors":["thuchon"],"categories":[],"content":"\n## Introduction\n\nHi Astronauts,  I haven't written any article in a while, and today I decided to come back in style with a highly technical one, like we love them.\n\nWarning though, for this one you'll need to be focused! Even if the overall idea is pretty simple, you'll see some pretty complex code and we will push the framework and use it in a tricky way, so that it will do things that it's not supposed to ;)\n\nDon't you worry guys, I'll do my best to explain every step, and shell every piece of code.\n\nIt's been a while now since I have been working on projects in which features must be configurable.<br/>\nMost of the time, I'm asked to develop it in a way that features can be enabled or disabled remotely.\n\nWe can take as an example a burger menu, where each entry represents a feature of the app, and we want to choose which ones are available.<br/>\nIt's not that difficult to do, and it's really helpful for the business.<br/>\nNevertheless, deep down, I always told myself, there is something missing, I want to push it further.<br/>\nAnd so, this is why we're here today...\n\nToday, I'll show you how to \"drive\" the behavior of an app from a remote JSON file stored on a server.<br/>\nWTH?<br/>\nBut this guy is crazy, he spent too much time in space...<br/>\n\nIn order for the remainder of the article to be easier to understand, we will define a few keywords together so that you don't get lost in translation.<br/>\nI will use a lot the word \"module\". A module can be defined as a gathering of features that can be reused easily and that can be developed outside of an app, we can take the **Pod** as an example.<br/>\nThe next word will be \"action\", when I say \"action\": \"Do what I asked you\" in my app, for the article being, it will be a console output, an opening of a webpage, that kind of stuff.<br/>\nNow that we enlightened and defined the necessary words in order to understand clearly this article, I think it's time to move forward.<br/>\n\n**How we will proceed:**\n\nIn order to produce what we want, we'll have to make 3 languages coexist:\n\n- **JSON** for configuration\n- **Objective-C** to reach a really deep level in the framework\n- **Swift** for our app\n\n\n## A little setup\n\nFasten your seat belt, this is where everything starts.\n\nOur goal is to create an app that contains features, but does not have a behavior as a structure.<br/>\nEach feature will be defined as a module, so separated code bases that live their own lives and available without any dependencies when it needs to be used.<br/>\nOnce we understand that, we must tell ourselves that what we want to develop will be in three different parts:\n\n- The modules\n- Our app\n- The behavior of our app\n\nI will explain soon each part on its own.\n\nOur goal here is to develop an app that will be able -while running- to load some modules and make them execute some actions that they own, but without the sequence of those actions defined in the app code base.\n\nWe will then proceed in 3 steps:\n\n- Get the list of modules and actions from the server\n- Load those modules\n- Execute the actions within the modules\n\n### The modules\n\nHere, we will define 3 modules and explain what they do:\n\nFirst module\n```Swift\nimport Foundation\n@objc\n\nclass MyFirstModule: NSObject {\n\n    func sayHello() {\n        let name = String(describing: type(of: self))\n        print(\"Hello My name is \\(name)\")\n    }\n\n    func sayGoodBye() {\n        let name = String(describing: type(of: self))\n        print(\"GoodBye My name was \\(name)\")\n    }\n}\n```\nThis module is really simple, it contains two methods, **sayHello** and **sayGoodBye**. Those two methods will write on the console log the text defined within it.\n\n\nSecond module\n```Swift\nimport Foundation\n@objc\n\nclass MySecondModule: NSObject {\n\n    func sayHello() {\n        let name = String(describing: type(of: self))\n        print(\"What's up? My name is \\(name)\")\n    }\n\n    func sayGoodBye() {\n        let name = String(describing: type(of: self))\n        print(\"See you, My name was \\(name)\")\n    }\n}\n```\nThis module is a clone of the first one, the only difference is the text in the two methods.\n\n\nThird module\n```Swift\nimport UIKit\n\n@objc\nclass MyThirdModule: NSObject {\n\n    func openUrl(url: String) {\n        let uri = URL(string: url)!\n        UIApplication.shared.open(uri, options: [:], completionHandler: nil)\n    }\n}\n```\nThis third module contains only one method, it will open a safari instance and go to an url that is given as a paremeter, easy stuff.\n\nAs you can see, the modules don't own any intelligence, they just do what we ask them to do.\n\n\n### The app\n\nLet's now focus on the app, the core of the project.<br/>\nIndeed, as defined above, we will act in 3 steps:\n\n- Get our modules from the server\n- Load the modules\n- Execute the actions from the modules\n\n### Getting the modules\n\nIn order to retrieve the modules, we will use 2 libs:\n\n- Alamofire for all network calls\n- Gloss to transform from JSON to object\n\nFirst of all, getting the JSON file hosted on the server.<br/>\nHere, nothing fancy, we just do a GET call with the library Alamofire and then we transform this JSON into GenericProtocol (a class specially created by us in order to recover our data) with a little class made by me that I use in almost all my projects.\n\nThe class for transformation\n```Swift\nimport Foundation\nimport Gloss\n\nclass BinderManager {\n\n    static func readValue<T: Glossy>(json: JSON, type: T.Type) -> T? {\n        if let result = T.init(json: json) {\n            return result\n        }\n        return nil\n    }\n\n    static func readValue<T: Glossy>(json: [JSON], type: T.Type) -> [T]? {\n        if let result = [T].from(jsonArray: json) {\n            return result\n        }\n        return nil\n    }\n}\n```\nThe GenericProtocol\n```Swift\nimport Foundation\nimport Gloss\n\nstruct GenericAction: Glossy {\n    var method: String?\n    var value: String?\n\n    init?(json: JSON) {\n        self.method = \"func\" <~~ json\n        self.value = \"value\" <~~ json\n    }\n\n    func toJSON() -> JSON? {\n        return nil\n    }\n}\n\nstruct GenericProtocol: Glossy {\n\n    var name: String?\n    var realObject: AnyObject?\n    var actions: [GenericAction]?\n\n    init?(json: JSON) {\n        self.name = \"name\" <~~ json\n\n        if let programmingObject = ObjectCreator.create(self.name) {\n            self.realObject = programmingObject as AnyObject\n        }\n\n        self.actions = \"actions\" <~~ json\n    }\n\n    func toJSON() -> JSON? {\n        return nil\n    }\n}\n```\nAs you can see, I use the Gloss library for the mapping (old habit).<br/>\nOur GenericProtocol has a name, a list of actions,  and a realObject. I'll come back later on this realObject.<br/>\nAnd then the transformation from JSON to an object after the HTTP call.<br/>\n\n```Swift\nfunc getModules() {\n    let uri = \"http://plop.fr/Protocols.json\"\n    let completionHandlerHttp : (DataResponse<Any>) -> Void = { response in\n        switch response.result {\n        case .success:\n            if let jsonArray = response.value as? [JSON] {\n                if let modules = BinderManager.readValue(json: jsonArray, type: GenericProtocol.self) {\n                    self.useModules(modules: modules)\n                }\n            }\n            break\n        case .failure(let error):\n            print(error)\n            break\n        }\n    }\n\n    Alamofire.request(uri, method: .get, headers: nil).validate().responseJSON(completionHandler: completionHandlerHttp)\n}\n```\nAbove, I told you about the realObject. But what is it?<br/>\nActually, this realObject is our module, we instantiate it and keep a reference on it, I got the inspiration from the function pointers in C for the idea.\n\nLet's now move on to the loading/instanciation of our modules.\n\n### The loading of our modules\n\nThe part of the code that we will focus on here is those 3 small lines.\n```Swift\nif let programmingObject = ObjectCreator.create(self.name) {\n    self.realObject = programmingObject as AnyObject\n}\n```\nIt helps me instantiate my module based on its name.<br/>\nAt the beginning of the article, I mentionned ***Objective-C***, here we are.<br/>\nI use Objective-C to access a really low level part of the framework in order to instantiate classes based on their names.<br/>\nHere is the class that allows us to do this (because it's Objective-C, we need to separate in 2 files, the .h and the .m), then with a Bridging-Header so that the Objective-C code is visible from Swift.\n```Objective-C\n\n#import <Foundation/Foundation.h>\n\n@interface ObjectCreator : NSObject\n\n+ (id)create:(NSString *)className;\n\n@end\n\n\n#import \"ObjectCreator.h\"\n\n@implementation ObjectCreator\n\n+ (Class)create:(NSString *)className\n{\n    Class daClass = NSClassFromString(className);\n    return [daClass new];\n}\n\n@end\n```\nSo, if I sum up, we get our JSON from the HTTP call, transform this JSON into an object and instantiate some classes that contain some actions (our modules).<br/>\nOk, happy to know that, but how do we proceed to use those so called modules?<br/>\nIn the method **getModules**, we call another method **useModules**, let's check this one out.\n\n### Execute the actions within the modules\n\nFirst of all, I would like to apologize, this method is going to be hard to read.<br/>\nI already hear you coming with your \"but the cyclomatic complexity, it's impossible to read, how do you expect us to maintain this?!\"<br/>\nGuys, let's be serious, call some methods on runtime objects, come on, you already know deep down inside that it won't be that clean and it won't be just 2 lines.<br/>\nI just ask you to trust me on this one, and I'll explain you the best I can what it does.<br/>\n\n```Swift\nfunc useModules(modules: [GenericProtocol]) {\n    for module in modules {\n        if let actions = module.actions {\n            for action in actions {\n                if let method = action.method {\n                    let selector = NSSelectorFromString(method)\n                    if let obj = module.realObject, obj.responds(to: selector) {\n                        if let value = action.value {\n                            _ = obj.perform(selector, with: value)\n                        } else {\n                            _ = obj.perform(selector)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nLet's get ready to rumble!!! And explain this method line by line:\n\nWe loop on our modules' list.<br/>\nWe check that every module has a list of actions.<br/>\nWe loop on the list of actions of the module.<br/>\nWe check that the action has a method (remember that an action can have a method and a parameter).<br/>\nWe get the selector, it's the method signature.<br/>\nWe check that the realObject exists, that it has the selector.<br/>\nIf the action has a parameter then we execute this action with the parameter.<br/>\nIf the action does not have a parameter, we then just execute the action.<br/>\n\nWow, that was intense, but I think that was necessary in order that everyone understands everything.<br/>\n\nSo, now that's cool, we have an app that can have a behavior driven outside of it, but let's have a look on this behavior actually.<br/>\nLet's move forward!\n\n### The behavior of our app\n\n```JSON\n[\n    {\n        \"name\": \"GenericProtocol.MyFirstModule\",\n        \"actions\": [\n            {\n                \"func\": \"sayHello\"\n            },\n            {\n                \"func\": \"showPopup\"\n            },\n            {\n                \"func\": \"sayGoodBye\"\n            }\n        ]\n    },\n    {\n        \"name\": \"GenericProtocol.MySecondModule\",\n        \"actions\": [\n            {\n                \"func\": \"sayHello\"\n            }\n            ,\n            {\n                \"func\": \"showPlop\"\n            },\n            {\n                \"func\": \"sayGoodBye\"\n            }\n        ]\n    },\n    {\n        \"name\": \"GenericProtocol.MyThirdModule\",\n        \"actions\": [\n            {\n                \"func\": \"openUrlWithUrl:\",\n                \"value\": \"https://eleven-labs.com/\"\n            }\n        ]\n    }\n]\n```\n\nIt is just a JSON array that contains 3 objects (modules).<br/>\nThe field **name** is the name of the module, **actions** is the list of methods of the module (**func** being the name of each method and **value** the value of the parameter given to the method).<br/>\nIf you look closely, I especially added in the first two modules some actions that don't exist in the classes. I did that because we want our system to be reliable and be able to handle these kinds of cases.\n\n### Let's take a small break\n\nWe coded our modules.<br/>\nWe developped an app that is able to load and use those modules.<br/>\nWe defined the behavior of our app.<br/>\nWhat are the next steps?<br/>\nThe second to last step is to call our method **getModules** in **viewDidLoad**\n```Swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    getModules()\n    // Do any additional setup after loading the view, typically from a nib.\n}\n```\nAnd now, the last step.\nJust test what we did :)\n\n\n## It's time to run the APP\n\nSo everything is set up, we just have to run our app.\nOur beautiful app runs and what's happening?\n\nFor what we can see in the simulator, our app launches, displays our dummy screen, then opens Safari and navigates to the website of **Eleven-Labs**.<br/>\nHum, that's funny, it reminds me of the action we defined in the third module.<br/><br/>\n![AppVideo](/imgs/posts/2018-05-21-let-s-think-outside-the-box/appvideo.gif){:height=\"1104px\" width=\"621px\"}<br/><br/>\nIf we know have a look at the log console, we can see some outpouts.<br/>\nBut those outputs, we are familiar with them, aren't they the ones defined in the two first modules?!<br/><br/>\n![ConsoleOutput](/imgs/posts/2018-05-21-let-s-think-outside-the-box/console-output.png)<br/><br/>\nI think that you start to understand, right?<br/>\nAll the actions that we defined in the **JSON** file, and that really exist in our modules are then executed.<br/>\nPretty cool isn't it? :)\n\n## But why do all this?\n\nYou are probably asking yourself, but why do all this?<br/>\nFor many reasons.<br/>\nThe first one being, it's so much fun. You need to venture and try new things from time to time, push the language, push the framework or the tools you use on a daily basis.\nBreaking the bones of an app can be really useful, to help you establish new architectures, see issues from different angles and to bring you solutions for some other projects in the future.\n\nThat's it, I hope that this article gave you the motivation to try new stuff, and that it'll help you to think \"**Outside the box**\".\n\nI give you the link to download the project with everything already set up.<br/>\nYou just have to clone it, run a pod install and for the rest, you already know it.<br/>\n[The Project](https://github.com/ettibo/GenericProtocols){:rel=\"nofollow noreferrer\"}\n\nSee you space cowboys :)\n"}