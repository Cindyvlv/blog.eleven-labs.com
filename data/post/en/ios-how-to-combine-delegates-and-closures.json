{"date":"2019-07-09T00:00:00.000Z","title":"[iOS] How to combine Delegates and Closures","excerpt":"Let's make Delegates and Closures work together","readingTime":"7mn","authors":["thuchon"],"categories":[],"content":"\n### Introduction\n\nHi astronauts, today we will keep talking about mobile development, and as always native style.\n\nThis article is following the 2 previous ones, and it's mandatory that you read them before, in order to understand what's going on in this one:\n\n[Delegates VS Closures](https://blog.eleven-labs.com/en/delegates-closures/){:rel=\"nofollow noreferrer\"}\n\n[Let's talk about listeners](https://blog.eleven-labs.com/en/android-listeners/){:rel=\"nofollow noreferrer\"}\n\n\nIf you have already read the 2 previous articles, I guess you already have an idea about what this one is about.\n- Yes we already know, so please hurry up, we want to know how we can make something as sexy as the listeners but on iOS this time.\n- Ok, just a bit of technical chit-chat before, and then were are ready to go.\n\n**How are we going to proceed?**\n\nAs in the first article, so that everyone is happy, I will provide some DUMMY code for both Objective-C and Swift.\n\nAs you may know in the iOS universe, we can use both Delegates and Closures. Usually closure is used for more flexibility and it is also easier to implement. However, in some cases, graphic components for example are just made to work with a delegate or a datasource. Right now I'm thinking about 2 components: UITableView and UICollectionView.\n\nWith those 2 components, you cannot use block/closure, and you have to use a good old delegate. Usually it's not really a big issue and you can just work like that. But let's say that you have to work with many of those components on a single screen, in this case the code can start to be really messy. You'll find yourself with some huge classes, and it really starts to be difficult to produce some beautiful and elegant code. What I would like to show you today is a solution, that in my opinion is pretty clean and easy to set up.\n\n### A little setup\n\nAs in the two previous articles, we will proceed with a GET call on a URL and build a system that will notify us in case of both success and error. We will go a little bit faster than in the first article, because those are notions that you are already suppose to master.\n\nIt's time to talk about code!\n\nOur goal is to realize a class that performs a GET call on a URL. I want to notify the object that launched this request if it failed or succeeded. To avoid strong dependencies, we will use the delegate pattern, thanks to this I don't need to know the exact type of the object.\n\nLet's do this in 3 steps:\n\n- Write the protocol\n- Write the blocks/closures\n- Write a class that will inherit from the protocol and that contains our 2 blocks/closures as attributes.\n\n##### Objective-C\n\n```Objective-C\ntypedef void (^successBlock)();\ntypedef void (^failureBlock)();\n\n@protocol RequestManagerObjCDelegate\n\n- (void)onRequestSuccess;\n- (void)onRequestFailure;\n\n@end\n\n@interface RequestManagerObjCDelegateImplementation : NSObject\n{\n\n}\n\n@property (weak, nonatomic) successBlock success;\n@property (weak, nonatomic) failureBlock failure;\n\n@end\n\n@interface RequestManagerObjC : NSObject\n\n- (void)get:(NSString*)url;\n\n@property (nonatomic, weak) id delegate;\n\n@end\n```\n\nWe will now implement the class that will inherit from the protocol. It will contain the 2 methods **onRequestSuccess** and **onRequestFailure** and each of them will call the dedicated block/closure.\n\n```Objective-C\n@implementation RequestManagerObjCDelegateImplementation\n\n- (void)onRequestSuccess {\n    self.success();\n}\n\n- (void)onRequestFailure {\n    self.failure();\n}\n\n@end\n```\n\nThen, we code the class **RequestManager** that you are familiar with.\n\n```Objective-C\n@implementation RequestManagerObjC\n\n- (void)get:(NSString *)url {\n    //Do the call\n    BOOL requestSucceed = [self isSuccess];\n\n    //After the call\n    if (requestSucceed) {\n        [self.delegate onRequestSuccess];\n    } else {\n        [self.delegate onRequestFailure];\n    }\n}\n\n- (BOOL)isSuccess {\n    return YES;\n}\n\n@end\n```\n\nThen, we code the method to call our webservice.\n\n```Objective-C\n- (void)callWebService {\n\n    RequestManagerObjC* manager = [[RequestManagerObjC alloc] init];\n\n    successBlock success = ^void() {\n\n    };\n\n    failureBlock failure = ^void() {\n\n    };\n\n    RequestManagerObjCDelegateImplementation* delegate = [[RequestManagerObjCDelegateImplementation alloc] init];\n    delegate.success = success;\n    delegate.failure = failure;\n\n    manager.delegate = delegate;\n    [manager get: @\"http://plop.fr\"];\n}\n```\n\nLet's take a look on what we just coded.\n- We instantiated our **Manager**, that will call the webservice\n- We defined our two **blocks/closures**\n- We instantiated our **Delegate**\n- We assigned our two **blocks/closures**\n- We assigned the **Delegate** to the **Manager**\n- We called the webservice\n\nHere is the Swift code for the most excited ones\n\n##### Swift\n\n```Swift\nprotocol RequesterDelegateSwift {\n    func onRequestSuccess()\n    func onRequestFailure()\n}\n\nclass RequesterDelegateSwiftImplementation:  RequesterDelegateSwift {\n    var requestSuccess: ((Void) -> Void)?\n    var requestFailure: ((Void) -> Void)?\n\n    func onRequestSuccess() {\n        if let successClosure = self.requestSuccess {\n            successClosure()\n        }\n    }\n\n    func onRequestFailure() {\n        if let failureClosure = self.requestFailure {\n            failureClosure()\n        }\n    }\n}\n\nclass RequestManagerSwift {\n\n    var delegate: RequesterDelegateSwift?\n\n    func get(url: String) {\n        //Do the call\n        let requestSucceed: Bool = self.isSuccess()\n\n        //After the call\n        if requestSucceed {\n            self.delegate?.onRequestSuccess()\n        } else {\n            self.delegate?.onRequestFailure()\n        }\n    }\n\n    private func isSuccess() -> Bool {\n        return true\n    }\n}\n\nfunc callWebService() {\n\n    let manager: RequestManagerSwift = RequestManagerSwift()\n    let requesterDelegate: RequesterDelegateSwiftImplementation = RequesterDelegateSwiftImplementation()\n    requesterDelegate.requestSuccess = {\n\n     }\n\n     requesterDelegate.requestFailure = {\n\n     }\n\n     manager.delegate = requesterDelegate\n     manager.get(url: \"http://plop.fr\")\n }\n```\n\nNow, if I call the method callWebService, considering the dummy code we produced, the result will be a call to the block/closure requestSuccess.\n\n**But why do we bother to do all this?**\n\nIndeed, why do all this, especially in our case? We could just have used a **Delegate** or **Blocks/Closures** as we did in the first article. This adds a lot of complexity in the code, and it looks like we are doing the same things twice...\nAs I told you at the beginning of the article, this solution comes for a specific case. To make a **Delegate** more flexible when you have no other choice that to use this pattern.\n\n**Issues**\n\n- If the **Protocol** contains a lot of methods, then we need to re-implement a lot.\n- We also must define all **blocks/closures** related.\n- We need to redefine the **blocks/closures** for every call.\n\n**Benefits**\n\n- More flexible delegates\n- Clean code\n- Reduced methods\n- Thinner handling for the callbacks of the **Delegate**\n\n### Conclusion\n\nThis solution is not perfect, but still quite elegant and is not too heavy to implement.\nThen, I'll let you test it and give me some feedback in the comments section.\n\nSee you space cowboys :)\n"}