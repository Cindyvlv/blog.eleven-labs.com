{"date":"2016-09-01T00:00:00.000Z","title":"Custom ParamConverter","excerpt":"The following article is aimed at developers who have already used the ParamConverter, and who understand its basic principles.","readingTime":"4mn","authors":["tthuon"],"categories":[],"content":"\nIntroduction\n============\n\nThe following article is aimed at developers who have already used the ParamConverter, and who understand its basic principles.\n\nIt was written in order to explain how to solve the following issue: I needed to pass a token into a custom header, and to be able to get it back in the controllers. The goal was to avoid repeating the acquisition of the header in each one of the controllers.\n\nThe basics\n==========\n\nThe ParamConverter is a magic tool. From a controller, you just need to type-hint the argument to obtain an instance of a class based on the id in the url.\n\n```php\n<?php\n\n/**\n * @Route(\"/post/{post}\")\n */\npublic function getAction(Post $post)\n{\n    return new Response($post->getTitle());\n}\n```\n\nIn my example, Symfony has recognised the *post* token in the route. In the method signature, the *$post* variable is type hinted by the *Post* class. Through ParamConverter, Symfony will try to create an instance of the *Post* class and to assign it to the *$post* variable.\n\nI would refer you to the documentation for the basic usage of the ParamConverter: <http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html>\n\nBut what if the value I am looking for is not found in the url, for example in a header?\n\nA token in a header\n===================\n\nLet’s take another example:\n\n```php\n<?php\n\n/**\n * @Route(\"/token\")\n */\npublic function isTokenValidAction($token)\n{\n    return $this->get('app.service')->isValid($token);\n}\n```\n\nThe value of the token must pass through an *x-token* header. I will then create a ParamConverter in order to fetch the token from the header and not from the url.\n\nCreation of the Paramconverter\n==============================\n\nAll ParamConverters must implement the `Sensio\\Bundle\\FrameworkExtraBundle\\Request\\ParamConverter\\ParamConverterInterface`.\n\nThere are the apply(Request $request, ConfigurationInterface $configuration); and supports(ConfigurationInterface $configuration); methods.\n\n-   *supports* verifies that the ParamConveter can be applied with the data provided in *$configuration*. It will result in *true* if all is good, otherwise it will be *false*. In this case, the ParamConverter moves to another converter. It is possible to sort ParamConverters by priority.\n-   *apply *will apply a business rule. In our case, we will need to search for the token in the request and replace the value in the request’s *attributes*.\n\nStructure example:\n\n```php\n<?php\n\nnamespace AppBundle\\Request\\ParamConverter;\n\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\ConfigurationInterface;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\ParamConverter;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Request\\ParamConverter\\ParamConverterInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass TokenConverter implements ParamConverterInterface\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function apply(Request $request, ConfigurationInterface $configuration)\n    {\n\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supports(ConfigurationInterface $configuration)\n    {\n\n    }\n}\n```\n\nI begin with the *supports* method*. *Here, I don’t have any reference class. I will then work on the name of the variable.\n\n```php\npublic function supports(ConfigurationInterface $configuration)\n{\n    return $configuration->getName() === \"token\";\n}\n```\n\nThe method must return *true* or *false*.\n\nThen, I work on the *apply* method . It’s here that I’ll fetch the token’s value. Since I have access to the current request, I can proceed as follow:\n\n```php\npublic function apply(Request $request, ConfigurationInterface $configuration)\n{\n    $request->attributes->set($configuration->getName(), $request->headers->get('x-token'));\n\n    return true;\n}\n```\n\nDuring the building of the controller, Symfony will fetch all the values of the controller’s arguments in the *attributes *variable of the request. This is why I assign the token’s value in the *attributes *variable through the *ParameterBag* method.\n\nMy custom *ParamConverter* is complete. I can now use it.\n\nService statement\n=================\n\nA *compiler pass* will read the services with the \"request.param\\_converter\" tag. We can define a priority and a name. If there’s a priority, they will be sorted in this order.\n\n```xhtml\n<service id=\"token_converter\" class=\"AppBundle\\Request\\ParamConverter\\CrmTokenConverter\">\n    <tag name=\"request.param_converter\" converter=\"token\" />\n</service>\n```\n\nUse in the controller\n=====================\n\nIn order to use it in my controller, I add the *ParamConverter *annotation to my controller with the *name *option and the converter name given in the service.\n\n```php\n<?php\n\n/**\n * @Route(\"/token\")\n * @ParamConverter(name=\"token\", converter=\"token\")\n */\npublic function isTokenValidAction($token)\n{\n    return $this->get('app.service')->isValid($token);\n}\n```\n\nWhen I carry out my request and I use a value for the \"x-token\" header, my \"$token\" variable will then have the value of the header.\n\nSo this is how to simplify the controller and isolate a functionality in a unitary class.\n\nReferences:\n\n-   <http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html#creating-a-converter>\n-   <http://api.symfony.com/3.1/Symfony/Component/HttpKernel/Controller/ControllerResolver.html>\n-   <http://api.symfony.com/2.8/Symfony/Component/HttpFoundation/Request.html>\n-   <http://api.symfony.com/2.8/Symfony/Component/HttpFoundation/ParameterBag.html>\n"}