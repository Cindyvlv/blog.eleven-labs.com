{"date":"2016-12-05T00:00:00.000Z","title":"Create your first Atom package","excerpt":"# Introduction to Atom","readingTime":"8mn","authors":["vcomposieux"],"categories":["javascript"],"content":"# Introduction to Atom\n[Atom](https://atom.io) is an open-source text editor (mostly used by developers){:rel=\"nofollow\"} which is multi-platform and developed by GitHub company. It is based on <a href=\"http://electron.atom.io/\">Electron</a>, the Github-developed framework, which allows developers to build native desktop applications for any operating systems by writing Javascript code.\n\nThe main interesting feature of Atom is that it also has a great package management tool and packages are also written in Javascript so it's quite easy for anyone to create one. This article aims to talk about it.\nFinally, its community is also active as it already has a lot of available packages: `5 285` at this time.\nYou can browse all packages by going to the following address: [https://atom.io/packages](https://atom.io/packages){:rel=\"nofollow\"}.\n\nHowever, if you cannot find a package that fits your needs you can start creating your own and we will see how simple it is.\n\n# Generate your first package\n\nIn order to create your own package, don't worry, you will not start from scratch. Indeed, we will use the `Package Generator`  command which is brought to us by Atom core.\nTo do that, you will just have to navigate into  `Packages` -> `Package Generator` -> `Generate Atom Package`.\n\nIn order to generate your package, you can choose the language between `Javascript`  and `Coffeescript` . This article will use Javascript.\n\nWhen the command is executed, Atom will open a new window into your package project, by default named `my-package`.\n\n# Package structure\n\nWe will now see in details what's inside our package project directory:\n\n```\n├── CHANGELOG.md\n├── LICENSE.md\n├── README.md\n├── keymaps\n│   └── my-package.json         <- Key shortcuts registered by your package\n├── lib\n│   ├── my-package-view.js\n│   └── my-package.js           <- Entry point of your package\n├── menus\n│   └── my-package.json         <- Menus declaration of your package into Atom application\n├── package.json                <- Description and library dependencies of your package\n├── spec                        <- Tests directory (Jasmine) of your package\n│   ├── my-package-spec.js\n│   └── my-package-view-spec.js\n└── styles                      <- Stylesheets used by your package\n└── my-package.less\n```\n\nThe first element to add to your package is the `package.json`  file which has to contain all information of your package such as its name, version, license type, keywords that will enable you to find your package into Atom registry and also your package dependancies.\n\nPlease also note that there is a section called `activationCommands`  which allows to define the executed command when your package is loaded.\n\nNext, we have the `keymaps/my-package.json`  file which allows you to define shortcuts into your package very easily. Here is the default example:\n\n```json\n{\n  \"atom-workspace\": {\n    \"ctrl-alt-p\": \"my-package:toggle\"\n  }\n}\n```\n\nNext, we will go into your package entry point. It is located into `lib/my-package.js` file.\nThis file exports a default object which contains a `subscriptions`  property and also `activate()`  and `deactivate()`  methods.\n\nDuring package activation (inside `activate()` method), we will register a <a href=\"https://atom.io/docs/api/latest/CompositeDisposable\">CompositeDisposable</a> type object inside our `subscriptions`  property and that will allow us to add and maybe later remove some commands offered by our package:\n\n```js\nactivate(state) {\n  this.subscriptions = new CompositeDisposable();\n  this.subscriptions.add(atom.commands.add('atom-workspace', {\n    'my-package:toggle': () => this.toggle()\n  }));\n}\n```\n\nNow that our command is registered, we can test it by simply typing the following words, into the Atom command palette: `My Package: Toggle`.\nThis command will execute the code contained in the `toggle()`  method of the class and will display a little modal at the top of the window.\nYou can add as many commands as you want and I really encourage you to decouple your code.\n\n# Add settings for your package\n\nThe [Config](https://atom.io/docs/api/latest/Config){:rel=\"nofollow\"} component allows your package to have some settings.\n\nTo add a new setting, you just have to define a `config`  property into your package's class which is an object containing each settings definition, as follows:\n\n```json\nconfig: {\n  \"gitlabUrl\": {\n    \"description\": \"If you rely on a private Gitlab server, please type your base URI here (default: https://gitlab.com).\",\n    \"type\": \"string\",\n    \"default\": \"https://gitlab.com\"\n  }\n}\n```\n\nAtom settings allow multiple setting types (`boolean` , `color` , `integer` , `string` , ...) so it can fit your needs on setting values by your users.\n\nOnce it is added, if you reload your package, you will see your package settings appearing into Atom settings:\n\n![Gitlab URL Parameter](/imgs/posts/2016-12-05-create-atom-package/gitlab-url.png)\n\nIn order to retrieve the value (or default value) defined by a user for a given setting in your code, you just have to use the following line:\n\n```js\nlet gitlabUrl = atom.config.get('gitlabUrl');\n```\n\n# Components overview\n\nSo you are now ready to develop your package. We will have a quick overview of some interesting components that Atom brings to you and allows you to use in your package.\n\n## TextEditor: Interact with the text editor\n\nWith the `TextEditor` component, you will be able to insert some text into user's text editor, to save the current file, to go back and forth the history, to move the cursor into editor, to copy/paste into clipboard, to play with line indentation, to scroll, and to do so much more...\n\nHere are some examples to insert text in a specific position and to save the file automatically:\n```js\neditor.setCursorBufferPosition([row, column]);\n\neditor.insertText('foo');\neditor.save();\n```\n\n## ViewRegistry & View: Create and display your own window\n\nThese components allow you to create views (modals / windows) inside Atom and display them.\n\nYou have an example of a modal `View` into the default package:\n\n```js\nexport default class MyPackageView {\n    constructor(serializedState) {\n      // Create root element\n      this.element = document.createElement('div');\n      this.element.classList.add('my-package');\n\n      // Create message element\n      const message = document.createElement('div');\n      message.textContent = 'The MyPackage package is Alive! It\\'s ALIVE!';\n      message.classList.add('message');\n      this.element.appendChild(message);\n    }\n\n    // ...\n}\n\nlet myPackageView = new MyPackageView(state.myPackageViewState);\nlet modalPanel = atom.workspace.addModalPanel({\nitem: myPackageView.getElement(),\nvisible: false;\n});\n\nmodalPanel.show();\n```\n\n## NotificationManager & Notification: Alert your users with notifications\n\nYour package can also display a variety of notifications from \"success\" to \"fatal error\":\n\n```js\natom.notifications.addSuccess('My success notification');\natom.notifications.addInfo('My info notification');\natom.notifications.addWarning('My warning notification');\natom.notifications.addError('My error notification');\natom.notifications.addFatalError('My fatal error notification');\n```\n\n## GitRepository\n\nThis one is also really interesting: indeed, you can access all the git properties of the current git repository that is used.\nThis way, you will be able to access the current branch name, the repository remote URL and also see if a file is considered as a new or modified file. Let's see it in action:\n\n```js\nlet repository = atom.project.getRepositoryForDirectory('/path/to/project');\n\nconsole.log(repository.getOriginURL());               // -> git@github.com:eko/atom-pull-request.git\nconsole.log(repository.getShortHead());               // -> master\nconsole.log(repository.isStatusNew('/path/to/file')); // -> true\n```\n\n## And more things to discover...\n\nWe just made a review of the components that I played with but I invite you to read more on the following link if you want to go further: [https://atom.io/docs/api/latest/AtomEnvironment](https://atom.io/docs/api/latest/AtomEnvironment){:rel=\"nofollow\"}.\n\n## Test your package with specs\n\nOur package is now developed but we don't have to forget about the tests. To do that, Atom uses [Jasmine](https://jasmine.github.io){:rel=\"nofollow\"}.\n\nYour default package already has a prepared test file:\n\n```js\nimport MyPackageView from '../lib/my-package-view';\n\ndescribe('MyPackageView', () => {\n  it('has one valid test', () => {\n    expect('life').toBe('easy');\n  });\n});\n```\n\nJasmine specs tests are written in the following way:\n\n* `describe()` : A Jasmine test suite starts with a \"describe\" function which takes a name as the first argument and a function as the second,\n* `it()` : A specification is added by using this function, \"it\" has to be contained into a specification,\n* `expect()` : This one is an assertion, when we expect something to happen.\n\nThis is now your turn to play with Jasmine and test your package logic.\nIn order to run the specs tests, you just have to navigate into the following menu: `View`  -> `Packages`  -> `Run Package Specs`.\n\n# Publish your package\n\nOur package is now ready to be deployed! Let's send it.\n\n![Publish](/imgs/posts/2016-12-05-create-atom-package/publish.gif)\n\nTo do that, we will use the `apm`  CLI tool which comes with Atom when installing it.\n\nAfter pushing your code into a Github repository, simply go into your package directory and type the following command:\n\n```bash\n$ apm publish --tag v0.0.1 minor\n\nPreparing and tagging a new version ✓\nPushing v0.0.1 tag ✓\n...\n```\n\nThis command will be in charge of creating the new version tag into repository and publish this version into the Atom registry.\nCongratulations, your package is now published and available on the following URL: `https://atom.io/packages/<your-package>`!\n\n# Continuous Integration\n\nThe final step is to ensure that your package will continue to work in the future when you or your contributors will add new features but also when Atom releases a new beta version. To do that, you can use [Travis-CI](https://travis-ci.org){:rel=\"nofollow\"} on your repository with the following configuration:\n\n```yaml\nlanguage: objective-c\n\nnotifications:\n  email:\n    on_success: never\n    on_failure: change\n\nscript: 'curl -s https://raw.githubusercontent.com/nikhilkalige/docblockr/develop/spec/atom-build-package.sh | sh'\n\nenv:\n  global:\n    - APM_TEST_PACKAGES=\"\"\n\n  matrix:\n    - ATOM_CHANNEL=stable\n    - ATOM_CHANNEL=beta\n```\n\n# Conclusion\n\nI personally think that this is a little revolution to allow developers to make their own editor and bring the features they want.\n\nMoreover, the Atom API is already very rich and very simple to use and this is certainly the main reason why the community offers a large number of packages.\nTo conclude, as for all libraries, it is not useful to reinvent the wheel by creating already existing packages. The idea is to add features if they don't already exists, in order to enrich your user experience.\n"}