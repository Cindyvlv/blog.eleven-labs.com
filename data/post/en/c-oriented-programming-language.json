{"date":"2020-02-12T00:00:00.000Z","title":"Write C as oriented programming language","excerpt":"Let's write some C as an oriented programming language","readingTime":"13mn","authors":["thuchon"],"categories":[],"content":"\n## Introduction\n\nHi Astronauts, happy to see you again on this day, after a while without publishing any article.\n\nThis article changes a bit from the previous ones. My goal here is to share my tips/good practices to any developer a bit motivated. This is why we are going to see a pretty simple subject, but from another point of view.\n\nLet's not waste time, and dive directly into the subject. We are going to talk about **C**, yes, yes, I really said **C**, you know this procedural language where you need to do all the allocations and frees by yourself.<br/>\nThis language is really important, the kernel of your computer is coded in **C**, and even if it's a bit difficult, you can actually do anything with it. Starting with this language will allow you to learn any other language really easily.<br/>\nThis is why my school (damn, I feel old) teaches it as a first language, and to be frank I created a lot of softwares with it. The main issue at the time was that I didn't have the experience with programming that I have now. I have to admit that I wish I had someone to guide me and not the do the rookie mistakes I did.\n\n\n## A little setup\n\nYou are a first year student and you need to code a little software that is able to handle many users. So you tell yourself: \"actually that would be good to do some code not too complex to maintain in the future, you never know, you can have some new fields for your users in some time, like the phone number, the zip code, etc...\" (those are examples).\n\nYou have the first solution, that is coding in regular **C**, so it means a lot of code maintenance when some modifications happen, or you can take 30 minutes, and tell yourself, ok let's try to do things from a different angle. This is where I step in ;)\n\nWe need to think oriented programming even if it's procedural code.<br/>\nIn order to do this, we will use 4 components of the **C** language :\n\n- **Structures**\n- **Pointers**\n- **Chained lists**\n- **Function pointers**\n\n### Structures\n\nWe can associate them to the ancestors of the classes, there is no notion of private/public, everything is public inside of it, there are no methods, they just contain **properties** that are either primitive types, or pointers.\n\n### Pointers\n\nLately, we use a lot of references when coding, but you also have pointers, it's a variable that points to a specific address in memory. Really useful, and a whole system is going to depend on this.\n\n### Chained lists\n\nWe will use again the 2 previous notions. A chained list is a collection of structures linked to each other by some pointers.\n\n### Function pointers\n\nI think that you might have an idea of what it's based on, function pointers are not meant to access data, but to access some functions declared in memory.\n\nSo we just covered the big notions, now you know what we're going to realize.<br />\nLet's dig into it.\n\n## How to proceed:\n\nAs always, I will give you some dummy code that will run and realize a serie of tasks that will be defined in the code, so no real interactions with the user. The idea is to show you the overall idea, then it's your responsibility to use it in the real world :)\n\nHere my objective is to be able to create \"users\" and to be able to add/remove them easily, in case my code has to go in run.\n\nIn order to do so, first let's create our data models.\n\n```C\ntypedef struct list list;\nstruct list\n{\n    list *next;\n    void *obj;\n};\n```\n\nI create the structure for my chained list, the idea here is to reproduce an **Array** as you can find them in almost all languages.\nSo, as we can see, we have a pointer that points to the next link of my list (next in the structure) and a pointer of type void* that can point to any type of \"object\", because I want to be able to use this chained list for any type of structure I want to store (that's pretty convenient).\n\n```C\ntypedef struct plop plop;\nstruct plop\n{\n    void (*hello)(plop*);\n    char* name;\n};\n```\n\nThen, here comes the real \"model\" for our user objects. A structure of type **plop** that contains two attributes, **name** for the name of the user and a function pointer **hello** that takes an \"object\" of type **plop**.\n\nSo, we have our data stucture, that's cool, but what do we do now?\nWe are going to code our \"methods\" for the chained list in order to reproduce the **new**, **add**, **remove**, **getObjectAtIndex** that we use on a daily basis in our modern languages.\n\nLet's start with the **New** :\n\n```C\nlist* make_new_list() {\n    list* ptr = malloc(sizeof(list*));\n    return ptr;\n}\n\nplop* make_new_object(char *name) {\n    plop* obj = malloc(sizeof(plop*));\n    obj->name = name;\n    obj->hello = hello;\n    return obj;\n}\n```\n\n**make_new_list** creates a new list, and **make_new_object** creates a new user. Nothing difficult for now, except perhaps in **make_new_object** which assigns **hello** with a **hello** that does not exist in the function's scope. We'll get back to it later.\n\nLet's now go to the toolkit functions for our chained lists:\n\n```C\nvoid add_in_list(list* my_list, void* obj) {\n    if (my_list->obj == NULL) {\n        my_list->obj = obj;\n        return;\n    }\n    list* list_ptr = my_list;\n    while (list_ptr->next != NULL) {\n        list_ptr = list_ptr->next;\n    }\n    list* tmp_list_obj = malloc(sizeof(list*));\n    tmp_list_obj->obj = obj;\n    tmp_list_obj->next = NULL;\n    list_ptr->next = (void*)tmp_list_obj;\n}\n\nvoid remove_in_list(list* my_list, void* obj) {\n    list* tmp = my_list;\n    if (tmp->obj == obj) {\n        my_list = tmp->next;\n        return;\n    }\n    list* prev = NULL;\n    while (tmp) {\n        if (tmp->obj == obj) {\n            prev->next = tmp->next;\n            break;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n}\n\nlist* get_object_at_index(list* my_list, int index) {\n    int i = 0;\n    list* tmp = my_list;\n    while (tmp) {\n        if (i == index)\n            return tmp;\n        i++;\n        tmp = tmp->next;\n    }\n    return NULL;\n}\n```\n\nWe create the function **add_in_list** that reproduces the **Add**, the function **remove_in_list** that reproduces **Remove** and the function **get_object_at_index** that reproduces **GetObjectAtIndex**.<br/>\nPlease do notice that those 3 methods take as parameters pointers that do not have a type ```C(void*)```, it means that you can use again these 3 functions in all your projects, so keep them somewhere :)\n\n- So far so good, we have our \"models\", our functions to play with. We're are all set I think, isn't it?\n- Hum, I don't think so pal...\n- What? Did I forget something?\n- Yeah, I think you said something about the **hello** function above...\n- Oh yes, my bad, my bad. Glad that you are there, what would I do without you?\n\n```C\nvoid print_str(char* str) {\n    write(1, str, strlen(str));\n}\n\nvoid hello(plop* obj) {\n    print_str(\"Hello, my name is: \");\n    print_str(obj->name);\n    print_str(\"\\n\");\n}\n\nvoid print_list(list* my_list) {\n    list* tmp = my_list;\n    plop* obj = NULL;\n    while (tmp) {\n        obj = (plop*)(tmp->obj);\n        obj->hello(obj);\n        tmp = tmp->next;\n    }\n}\n```\n\nSo actually, it was missing a bit more than the **hello** function.<br/>\nLet's add these 3 functions that by order:\n- Write a string on the output console.\n- Take a **plop** \"object\" as a parameter and display it on the console log.\n- Loop on our chained list and call the function **hello** on every \"object\".\n\nLet's come back on the **hello** function. This function is now declared in our code, and in the function **make_new_object** we assign the function pointer of the structure newly created on this function that already has an address in the memory. We just need to pass the \"object\" as a parameter because we are not able to call the function straight on it. This idea came to me when I did some **Python**, actually in **Python** the **self** is automatically given as a parameter in every method and then we can do the calls on **self**.\n\n## The final look\n\nAs I told you before, this code is meant to be a demo in order to let you think about this way of coding, it does not really interact with the user. I will then dump all the code at once, so like that nothing more easy for you, you just have to test it (for exemple on ideone](https://ideone.com/){:rel=\"nofollow noreferrer\"})\n\n```C\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\ntypedef struct plop plop;\nstruct plop\n{\n    void (*hello)(plop*);\n    char* name;\n};\n\ntypedef struct list list;\nstruct list\n{\n    list *next;\n    void *obj;\n};\n\nplop* make_new_object(char *);\nlist* make_new_list();\nvoid print_str(char* str);\nvoid hello(plop* obj);\nvoid add_in_list(list* my_list, void* obj);\nvoid remove_in_list(list* my_list, void* obj);\nlist* get_object_at_index(list* my_list, int index);\nvoid print_list(list* my_list);\n\nint main(int ac, char **av) {\n    list* my_list = make_new_list();\n    add_in_list(my_list, make_new_object(\"Pierre\"));\n    add_in_list(my_list, make_new_object(\"Paul\"));\n    add_in_list(my_list, make_new_object(\"Jacques\"));\n    print_list(my_list);\n    return 0;\n}\n\nlist* make_new_list() {\n    list* ptr = malloc(sizeof(list*));\n    return ptr;\n}\n\nplop* make_new_object(char *name) {\n    plop* obj = malloc(sizeof(plop*));\n    obj->name = name;\n    obj->hello = hello;\n    return obj;\n}\n\nvoid print_str(char* str) {\n    write(1, str, strlen(str));\n}\n\nvoid hello(plop* obj) {\n    print_str(\"Hello, my name is: \");\n    print_str(obj->name);\n    print_str(\"\\n\");\n}\n\nvoid add_in_list(list* my_list, void* obj) {\n    if (my_list->obj == NULL) {\n        my_list->obj = obj;\n        return;\n    }\n    list* list_ptr = my_list;\n    while (list_ptr->next != NULL) {\n        list_ptr = list_ptr->next;\n    }\n    list* tmp_list_obj = malloc(sizeof(list*));\n    tmp_list_obj->obj = obj;\n    tmp_list_obj->next = NULL;\n    list_ptr->next = (void*)tmp_list_obj;\n}\n\nvoid remove_in_list(list* my_list, void* obj) {\n    list* tmp = my_list;\n    if (tmp->obj == obj) {\n        my_list = tmp->next;\n        return;\n    }\n    list* prev = NULL;\n    while (tmp) {\n        if (tmp->obj == obj) {\n            prev->next = tmp->next;\n            break;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n}\n\nlist* get_object_at_index(list* my_list, int index) {\n    int i = 0;\n    list* tmp = my_list;\n    while (tmp) {\n        if (i == index)\n            return tmp;\n        i++;\n        tmp = tmp->next;\n    }\n    return NULL;\n}\n\nvoid print_list(list* my_list) {\n    list* tmp = my_list;\n    plop* obj = NULL;\n    while (tmp) {\n        obj = (plop*)(tmp->obj);\n        obj->hello(obj);\n        tmp = tmp->next;\n    }\n}\n```\n\n## It's time to run the code\n\nSo everything is setup, you just have to run the code.\nHere not much glamorous stuff, just 3 small outputs:\n\n```Shell\nHello, my name is: Pierre\nHello, my name is: Paul\nHello, my name is: Jacques\n```\n\nPretty cool isn't it? :)\n\n- Hold on, we did all this code just for this result?\n- Yes\n- But hum, where is the magic?\n- Magic is not always visual guys, sometimes it's how it's done behind the curtains. As developers you need to challenge yourselves to do stuff in many different ways, explore new horizons.\n\n## But why do all this?\n\nYou are probably asking yourself, but why do all this?<br/>\nFor many reasons.<br/>\nThe first one is that it's really really fun. Imagine that you show this code to your dev partner, and you tell him, hey for once, let's do things like that.<br/>\nThen when you arrive to present your project, with such an architecture, the guy in charge of the review will probably say: Damn Son Where'd Yyou find this???!!! Then he will see with you how to push it further and even give you some advices for your future projects.<br/>\nAlso, it makes the code way more easy to read in my opinion, you just have a few complex functions, and then everything else is easy to understand.\nIt also teaches you how to split your code and architecture your project with way less depedencies.\n\nHere we are, as I told you at the beginning, this article is different from the previous ones, it is meant for the news developers. I hope you liked it. Please give me your feedback in the comments section.\n\nSee you space cowboys :)\n"}