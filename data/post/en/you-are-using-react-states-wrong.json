{"date":"2020-07-01T00:00:00.000Z","title":"You are using React states wrong","excerpt":"You may not be using the React states optimally and I'll explain why","readingTime":"10mn","authors":["marishka"],"categories":["javascript"],"content":"\nBehind this seductive-looking title hides an observation that I have been making more and more. Let's put things into context:\nYou are young and crazy, you just discovered React and did the tutorial. Your tic-tac-toe is all beautiful and you are beginning to work on your first single page application. Your code has lots of **states** and when you click on buttons things move all over the place like fireworks. I look at your code and I am telling you:\n\n\\- _Truth be told... that's not how I would have done it._\n\nAnd that’s normal. It is by making mistakes that you learn and this article is here to list most of the beginner mistakes that I have seen (and made) when using React **states**.\n\n## Definition\n\nA **state** is a set of variables which defines a component at a given time. In React, the change of a **state** results automatically by the re-render of the component where the **state** was declared.\n\nNow that we've gone over the basics, let's take a look at what's good and what's not.\n\n![](/imgs/posts/2020-05-20-vous-utilisez-mal-les-states/bien-pas-bien.gif)\n\n## You will not mutate your state\n\nOkay, as explained in the introduction, if you did the tutorial on the React site then you've already heard of **immutability**. This important rule is however often forgotten by most developers, which then leads their projects to the worst bugs imaginable.\n\n**Immutability** is by definition the ability to remain unchanged. And if there is one thing that the **states** of your application should be, it is **immutable**.\n\n\\- _But if we do not change the **state** of the components, our application is nothing more than a static site without flavor._\n\nDon't make me say what I didn't say. You can modify the **states** of your components, but not directly. It is good practice to create a new object corresponding to your next **state**.\n\nUsing immutability can greatly help React to detect **state** changes (it also works great with props, but that's not the issue). Because who says new object says new reference, and the difference in ref between **states** A and B is easier to compare than all the properties one by one.\n\n### Not good\n\n```jsx\nconst AComponent = () => {\n  const [object, setObject] = useState({\n    name: 'MacGuffin',\n    click: 0,\n  });\n\n  const handleClick = () => {\n    object.click = object.click + 1;\n    setObject(object);\n  };\n\n  return <div onClick={handleClick}>{object.click}</div>;\n};\n```\n\n### Good\n\n```jsx\nconst AComponent = () => {\n  const [object, setObject] = useState({\n    name: 'MacGuffin',\n    click: 0,\n  });\n\n  const handleClick = () => {\n    setObject({ ...object, click: object.click + 1 });\n  };\n\n  return <div onClick={handleClick}>{object.click}</div>;\n};\n```\n\nHere we create a new object using the ES2018 syntax, before sending it to `setObject`.\n\n## You will change your state\n\n\\- _Well the guy says everything and its opposite._\n\nYes but if I tell you that, it is to remind you that a **state** is by definition designed to evolve. So if your goal is to have information that does not change over time, then use **constants** instead. It's lighter and easier to understand.\n\n### Not good\n\n```jsx\nconst AComponent = () => {\n  const [value, setValue] = useState('Value that will not change');\n\n  return <div>{value}</div>;\n};\n```\n\n### Good\n\n```jsx\nconst AComponent = () => {\n  const value = 'Value that will not change';\n\n  return <div>{value}</div>;\n};\n```\n\nIt may be silly to remind you of this, but I have seen it and I had to mention it.\n\n## You will only change one state at a time\n\nIn life it sometimes happens that there are several **states** within the same component. In itself this is not an error, the problem comes especially in the case where one must update 2 **states** at the same time. As reviewed in the definition, each change of **state** re-renders the component and therefore the entire life cycle. You therefore understand that you should not correlate your **states** changes, otherwise you will have several re-renders in parallel, and generate synchronization bugs between 2 **states**.\n\nTo solve this issue, 2 solutions are available to us:\n\nPutting it all together in one **state** is the quick way to create a catch-all object with all of the component's variables. It’s not aesthetic, not practical and very heavy.\n\nOr... use a **reducer**. This makes it possible to manage transitions of complex **states**, by mapping the different actions to a transition identifier. This allows you to better control the renders of your components and it is generally recommended when using objects in a **state**.\n\n### Not good\n\n```jsx\nconst AComponent = () => {\n  const [object, setObject] = useState({\n    name: 'MacGuffin',\n    click: 0,\n  });\n  const [loading, setLoading] = useState(false);\n\n  const handleClick = () => {\n    setLoading(true);\n\n    generateName().then((newName) => {\n      setObject({ ...object, name: newName });\n      setLoading(false);\n    });\n  };\n\n  return loading? <Loader /> : <div onClick={handleClick}>{object.name}</div>;\n};\n```\n\n### Good\n\n```jsx\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'startGenerateName':\n      return { ...state, loading: true };\n    case 'endGenerateName':\n      return { ...state, name: action.newName, loading: false };\n    default:\n      throw new Error();\n  }\n}\n\nconst AComponent = () => {\n  const [{ loading, name }, dispatch] = useReducer(reducer, {\n    name: 'MacGuffin',\n    click: 0,\n    loading: false,\n  });\n\n  const handleClick = () => {\n    dispatch({ type: 'startGenerateName' });\n\n    generateName().then((newName) => {\n      dispatch({ type: 'endGenerateName', newName });\n    });\n  };\n\n  return loading? <Loader /> : <div onClick={handleClick}>{name}</div>;\n};\n```\n\nIn this example the change of **state** is clearly identifiable and ensures that there is only one render.\n\n## You will redistribute your states\n\nA very common mistake is to mismanage where to declare your **states**. For example, putting everything without thinking in the parent in order to have only pure components. This often results in a very heavy parent component which always re-renders all of the child components. Here there is no ready-made solution, the only advice is to trace back the shared **state** to their **closest common ancestor** and to bring the data down into the child components. However, there is a more elegant way of passing the callback functions from parent to child:\n\n```jsx\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'startGenerateName':\n      return { ...state, loading: true };\n    case 'endGenerateName':\n      return { ...state, name: action.newName, loading: false };\n    default:\n      throw new Error();\n  }\n}\n\nconst ObjectDispatch = React.createContext(null);\n\nconst ParentComponent = () => {\n  const [{ loading, name }, dispatch] = useReducer(reducer, {\n    name: 'MacGuffin',\n    click: 0,\n    loading: false,\n  });\n\n  return (\n    <ObjectDispatch.Provider value={dispatch}>\n      <ChildComponent name={name} loading={loading} />\n    </ObjectDispatch.Provider>\n  );\n};\n\nconst ChildComponent = ({ name, loading }) => {\n  const dispatch = useContext(ObjectDispatch);\n\n  const handleClick = () => {\n    dispatch({ type: 'startGenerateName' });\n\n    generateName().then((newName) => {\n      dispatch({ type: 'endGenerateName', newName });\n    });\n  };\n\n  return loading? <Loader /> : <div onClick={handleClick}>{name}</div>;\n};\n```\n\n## You will use the states when necessary\n\nThe biggest mistake I've ever seen is to believe that **states** are the only way to keep data in memory between each **state** change. There is another element of React that is persistent despite the change of **states** and that few developers use, it is the **references**. They also allow you to keep in memory variables that you want to modify without wanting to re-render the component.\n\n### Not good\n\n```jsx\nconst AComponent = () => {\n  const [object, setObject] = useState({\n    name: 'MacGuffin',\n    click: 0,\n  });\n\n  const [numberOfClics, setNumberOfClics] = useState(0);\n\n  const handleClick = () => {\n    if (numberOfClics + 1 % 10 === 0) {\n      generateName().then((newName) => {\n        setObject({ ...object, name: newName });\n      });\n    }\n    setNumberOfClics(numberOfClics + 1);\n  };\n\n  return <div onClick={handleClick}>{object.name}</div>;\n};\n```\n\n### Good\n\n```jsx\nconst AComponent = () => {\n  const [object, setObject] = useState({\n    name: 'MacGuffin',\n    click: 0,\n  });\n  const numberOfClics = useRef(0);\n\n  const handleClick = () => {\n    numberOfClics.current++;\n    if (numberOfClics.current % 10 === 0) {\n      generateName().then((newName) => {\n        setObject({ ...object, name: newName });\n      });\n    }\n  };\n\n  return <div onClick={handleClick}>{object.name}</div>;\n};\n```\nHere we want to perform an action every 10 clicks, without having to re-render the component on every click.\n\nAnother case of misuse of **states** is its use for animations. Most animations can be done with just some CSS and do not require position calculation in `setInterval` as I have seen.\n\n### Not good\n\n\n```jsx\nconst AComponent = () => {\n  const [top, setTop] = useState(0);\n\n  useEffect(() => {\n    setInterval(() => {\n      if (top < 1000) {\n        setTop(top - 10);\n      }\n    }, 100);\n  }, []);\n\n\n  return <div style={{top: top+'px'}}>I am scrolling down</div>;\n};\n```\n\n\n### Good\n\n```css\n.div-scroll-down {\n   animation: 10s scrollDown;\n}\n@keyframes scrollDown {\n  from { top: 0; }\n  to   { top: 1000px; }\n}\n```\n```jsx\nconst AComponent = () => (<div className=\"div-scroll-down\">I am scrolling down</div>);\n```\nIn this example we have transferred the responsibility of animation to CSS, which is much more optimized for this kind of work.\n\n## Conclusion\nWith these small examples, I hope I have taught you some good practices or opened your eyes to mistakes you may have made.\n\nMost of the issues highlighted in this article are pretty widespread as they are not dealt with directly in the React documentation, so there is no shame in committing this kind of blunder ;)\n"}