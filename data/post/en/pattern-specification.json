{"date":"2016-09-16T00:00:00.000Z","title":"Pattern Specification","excerpt":"Through my different professional experiences, I had to set a lot of business rules in rich web apps. One day, I stumbled upon a different way to deal with those: using the specification pattern. This method has proven to be structuring and deserves some attention if you do not know what it is.","readingTime":"9mn","authors":["rpierlot"],"categories":[],"content":"\nThrough my different professional experiences, I had to set a lot of business rules in rich web apps. One day, I stumbled upon a different way to deal with those: using the specification pattern. This method has proven to be structuring and deserves some attention if you do not know what it is.\n\n### Let's dig in\n\nImagine a simple banking application for instance. This app only has clients and bank accounts. A client can have one or multiple accounts, and your job is to create a very simple system of wire transfer between accounts of a same client with this business rule:\n\n*   A client cannot transfer money if his account has a balance equals to 0 or less.\n*   The client associated to his debiting account must be active.\n\nYou can clearly see the condition which would prevent a transfer from happening.\n\nIn a simple implementation, you would write it this way:\n\n```php\n<?php\n\nnamespace ElevenLabs\\Application;\n\nuse ElevenLabs\\Domain\\Payment\\Entity\\Account;\n\nclass TransferMoneyCommand\n{\n    /**\n     * @param Amount $accountToDebit\n     * @param Amount $accountToCredit\n     * @param float  $amount\n     */\n    public function execute(Account $accountToDebit, Account $accountToCredit, $amount)\n    {\n        if ($accountToDebit->getBalance() - $amount > 0 && $accountToDebit->getOwner()->isActive()) {\n            //transfer authorized\n            //...\n        }\n    }\n}\n```\n\nThis business rule, although trivial, needs to be implemented every time we want to do a wire transfer.\nMany constraints arise from such implementation.\n\nFirst off, if our business rule evolves, we have to change the (or all) class that uses it. Then, this implementation in a _if_ statement is really not explicit at all.\n\nThis is where the specification pattern comes into play. The main idea is to isolate the business rule, separating it from its use. It's used for validation, selection and building of business logic.\n\nMainly three types of specification exist:\n\n*   hard coded specifications\n*   parameterized specifications\n*   composite specifications\n\nA specification is driven by the following interface:\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain;\n\ninterface Specification\n{\n    /**\n     * @param $candidate\n     *\n     * @return bool\n     */\n    public function isSatisfiedBy($candidate);\n}\n```\n\n### Hard-coded Specifications\n\nThis type of specification enables us to hard code the business knowledge without having the possibility to modify the business rule from the outside.\n\nA business rule can then be translated this way:\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain\\Payment;\n\nuse ElevenLabs\\Domain\\Specification;\n\nclass AccountCanTransferMoney implements Specification\n{\n    /**\n     * @param \\ElevenLabs\\Domain\\Payment\\Entity\\Account $account\n     *\n     * @return boolean\n     */\n    public function isSatisfiedBy($account)\n    {\n         return $account->getBalance() > 0 && $account->getOwner()->isActive();\n    }\n}\n```\n\nHaving created a separated class in order to apply our business rule, we gain clarity and decoupling. Although, it appears obvious that we are condemned to only using our object $account, and that no additional info can be brought from the outside. We still can't use this type of specification in our _TransferMoneyCommand_ because it does not comply totally to our business rule (only the balance is compared).\n\n### Parameterized specifications\n\nParameterized specifications are identical to what we've been talking about, but they resolve the issue we've just mentioned, allowing us to get outside parameters to our candidate.\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain\\Payment;\n\nuse ElevenLabs\\Domain\\Specification;\n\nclass AccountCanTransferMoney implements Specification\n{\n    /** @var float */\n    private $amount;\n\n    /**\n     * @param float $amount\n     */\n    public function __construct($amount)\n    {\n        $this->amount = $amount;\n    }\n\n    /**\n     * @param \\ElevenLabs\\Domain\\Payment\\Entity\\Account $account\n     *\n     * @return boolean\n     */\n    public function isSatisfiedBy($account)\n    {\n         return $account->getBalance() - $this->amount > 0 && $account->getOwner()->isActive();\n    }\n}\n```\n\nWith this type of specifications, we keep the same pros as before, and we gain flexibility.\n\nThis is how our command would look like using our parameterized specification:\n\n```php\n<?php\n\nnamespace ElevenLabs\\Application;\n\nuse ElevenLabs\\Domain\\Payment\\Entity\\Account;\nuse ElevenLabs\\Domain\\Payment\\Specification\\AccountCanTransferMoney;\n\nclass TransferMoneyCommand\n{\n    /**\n     * @param Account $accountToDebit\n     * @param Account $accountToCredit\n     * @param float   $amount\n     */\n    public function execute(Account $accountToDebit, Account $accountToCredit, $amount)\n    {\n        $accountCanTransferMoney = new AccountCanTransferMoney($amount);\n\n        if (true === $accountCanTransferMoney->isSatisfiedBy($accountToDebit)) {\n            //transfer authorized\n            //...\n        }\n    }\n}\n\n```\n\nTo simplify my explanation on parameterized specifications, I've hard coded the instantiation of the class AccountCanTransferMoney. A noticeable improvement of this use would be to inject the specification directly into the command, in order to better unit test our command.\n\n### Composite specifications\n\nThe last type of specification I'd like to take a look into is composite specifications. Such specification bases itself on what we've seen. Indeed, it uses composition to exist. Logical operations between two (or more) specifications are part of composite specifications.\n\nThe following example explains the implementation of the AND logical operator:\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain;\n\nabstract class Composite implements Specification\n{\n    /**\n     * {@inheritdoc}\n     */\n    abstract public function isSatisfiedBy($candidate);\n\n    /**\n     * @param Specification $spec\n     *\n     * @return AndSpecification\n     */\n    public function andIsSatisfiedBy(Specification $spec)\n    {\n        return new AndSpecification($this, $spec);\n    }\n\n    //...\n}\n\nclass AndSpecification extends Composite\n{\n    /** @var Specification */\n    private $a;\n\n    /** @var Specification */\n    private $b;\n\n    /**\n     * @param Specification $a\n     * @param Specification $b\n     */\n    public function __construct(Specification $a, Specification $b)\n    {\n        $this->a = $a;\n        $this->b = $b;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function isSatisfiedBy($candidate)\n    {\n        return $this->a->isSatisfiedBy($candidate) && $this->b->isSatisfiedBy($candidate);\n    }\n}\n```\n\nThen, if we instantiate a composite spec, we can chain it to other specifications (see below), by modifying our previous _AccountCanTransferMoney_ specification:\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain\\Payment;\n\nuse ElevenLabs\\Domain\\Composite;\n\nclass AccountCanTransferMoney extends Composite\n{\n    /** @var float */\n    private $amount;\n\n    /**\n     * @param float $amount\n     */\n    public function __construct($amount = 0)\n    {\n        $this->amount = $amount;\n    }\n\n    /**\n     * @param \\ElevenLabs\\Domain\\Payment\\Entity\\Account $account\n     *\n     * @return boolean\n     */\n    public function isSatisfiedBy($account)\n    {\n         return $account->getBalance() - $this->amount > 0;\n    }\n}\n```\n\n```php\n<?php\n\nnamespace ElevenLabs\\Domain\\Payment\\Specification;\n\nuse ElevenLabs\\Domain\\Specification;\n\nclass AccountOwnerIsActive implements Specification\n{\n    /**\n     * @param \\ElevenLabs\\Domain\\Payment\\Entity\\Account $account\n     *\n     * @return boolean\n     */\n    public function isSatisfiedBy($account);\n    {\n        return $account->getOwner()->isActive();\n    }\n}\n\n```\n\nFinally, here is how we use our composition:\n\n```php\n<?php\n\nnamespace ElevenLabs\\Application;\n\nuse ElevenLabs\\Domain\\Payment\\Entity\\Account;\nuse ElevenLabs\\Domain\\Payment\\Specification\\AccountCanTransferMoney;\n\nclass TransferMoneyCommand\n{\n    /**\n     * @param Account $accountToDebit\n     * @param Account $accountToCredit\n     * @param float   $amount\n     */\n    public function execute(Account $accountToDebit, Account $accountToCredit, $amount)\n    {\n        $accountCanTransferMoney = new AccountCanTransferMoney($amount);\n        $accountOwnerIsActive = new AccountOwnerIsActive();\n        $compositeSpecification = $accountCanTransferMoney->andIsSatisfiedBy($accountOwnerIsActive);\n\n        if (true === $compositeSpecification->isSatisfiedBy($accountToDebit)) {\n            //transfer authorized\n            //...\n        }\n    }\n}\n```\n\nThe advantages of this type of specifications are obviously the support of logical operator, and therefore the creation of even more complex business rules. It's now possible to combine specifications. Flexibility is improved, but beware of additional complexity!\n\n### Recap\n\nAdvantages of the specification pattern are as follow:\n\n*   Increased decoupling because the responsability of the validation is now limited to an isolated class\n*   So it is easier to unit test specifications and classes using them\n*   We made the implicit explicit with a clear definition of business rules\n\n## References\n\n[Eric Evans & Martin Fowler - Specifications](http://martinfowler.com/apsupp/spec.pdf){:rel=\"nofollow\"}\n\n[Specification pattern: C# implementation](http://enterprisecraftsmanship.com/2016/02/08/specification-pattern-c-implementation/){:rel=\"nofollow\"}\n"}