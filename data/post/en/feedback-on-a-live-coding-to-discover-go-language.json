{"date":"2017-08-23T00:00:00.000Z","title":"Feedback on a live-coding to discover Go language","excerpt":"This blog post follows a workshop / live-coding session I organized at Eleven Labs for an initiation to Go language.","readingTime":"10mn","authors":["vcomposieux"],"categories":[],"content":"\nThis blog post follows a workshop / live-coding session I organized at Eleven Labs for an initiation to Go language.\n\nWorkshops are to me the best way to enter in a technical subject that we don't already know. It allows to practice it using a real subject, with the help of a person that knows the subject (even if this person may not be a total expert) as the workshop has been planned and organized so he could be really helpful to you.\n\nDefine a subject\n----------------\n\nThe main objective for this workshop was to allow participants (most of them never wrote a single line of Go) to walk out of these three hours of live-coding, completely understanding the logic of the Go language and knowing the main concepts.\n\nI had to find a subject that allows to practice these main concepts and also that sounds like a complex and complete application, but is in fact a simple one that could be developed quickly during the workshop. After a reflection time I've chosen to go on a concrete case on which every developer could encounter the need: a worker (or message queue).\n\nPresentation of WorkMQ\n----------------------\n\nWorkMQ is the name of the project (library) we will develop during this workshop.\n\nThe idea is pretty simple:\n\n* The application must receive messages in input and each of them has to be linked to a `Queue` (waiting line),\n* The application must process these messages by using a defined number of `Workers` (thread that will process the message),\n* The application must expose some statistics of current usage over HTTP.\n\nBefore going into details, here is a diagram representing the features of our library:\n\n![WorkMQ Diagram](/imgs/posts/2017-08-23-retour-sur-un-live-coding-de-decouverte-du-langage-go/schema.jpg)\n\nAs you can see on this diagram, we have four `Queues` defined and each of them has three `Workers`.\n\nOur library (`WorkMQ`, here the central point) will give a [Channel (a Go one)](https://golang.org/ref/spec#Channel_types){:rel=\"nofollow noreferrer\"} in which messages will be stored for corresponding queue. These messages will then be processed by the first available worker.\n\nConfiguration\n-------------\n\nFar from being the best way to manage the configuration of an application, the `json` file is still a simple one to manage it, and will allow us to write our first lines of Go by understanding the language basics.\n\nIndeed, in order to read the configuration (written in a JSON file) and transform it on a Go `struct`, we have started by defining the JSON structure we will need in the application:\n\n```json\n{\n  \"ports\": {\n    \"udp\": \":10001\",\n    \"http\": \":8080\"\n  },\n  \"queues\": {\n    \"queue.1s\": {\n      \"processor\": \"processor.logger.1s\",\n      \"num_workers\": 150\n    },\n    \"queue.2s\": {\n      \"processor\": \"processor.logger.2s\",\n      \"num_workers\": 200\n    }\n  }\n}\n```\n\nSimple and efficient, this configuration allows to define `UDP` port (on which we will receive messages), `HTTP` one (to expose usage statistics) and also the names of our `queues` and `processor` identifiers associated to each queue. We will talk about processors later.\n\nWhat is interesting in this part is that we will be able to control for each `queue`, the number of workers we want to be available.\n\nOn Go side, we've started to import core needed libraries, and I took advantage of this moment to explain the principles of namespaces in Go, project structure and how to import both internal and external libraries:\n\n```go\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n)\n```\n\nThen, we have defined the associated `struct` to each JSON elements:\n\n```go\n// Config is the configuration type definition.\ntype Config struct {\n\tPorts  PortsConfig            `json:\"ports\"`\n\tQueues map[string]QueueConfig `json:\"queues\"`\n}\n\n// PortsConfig is the \"port\" configuration section type definition.\ntype PortsConfig struct {\n\tUDP  string `json:\"udp\"`\n\tHTTP string `json:\"http\"`\n}\n\n// QueueConfig is the \"queues\" configuration section type definition.\ntype QueueConfig struct {\n\tProcessor  string `json:\"processor\"`\n\tNumWorkers int    `json:\"num_workers\"`\n}\n```\n\nUntil here, nothing special except to familiarize with data typing and Go notations.\n\nNow comes the time to write our first `function` in Go in order to read the `config.json` file that will be located at the root directory of the project:\n\n```go\nfunc GetConfig() Config {\n\tfile, _ := os.Open(\"./config.json\")\n\tdecoder := json.NewDecoder(file)\n\n\tconfig := Config{}\n\terr := decoder.Decode(&config)\n\n\tif err != nil {\n\t\tfmt.Println(\"An error occurs on configuration loading:\", err)\n\t}\n\n\treturn config\n}\n```\n\nIt is important here to discuss with participants the error handling, multiple returned values, variables declaration with and without direct assignation. To sum up, these are a lot of quick elements to know about when you are developing in Go.\n\nOur library's core\n------------------\n\nOnce configuration is ready to be exploited, we have started to write the core of our library.\nThat's also the opportunity to introduce the pointers notion, how and when use it.\n\nWe have written the data structure and also the function that will initialize the core structure of our application:\n\n```go\ntype Workmq struct {\n\tConfig     Config\n\tQueues     map[string]chan Message\n\tProcessors map[string]Processor\n\tCounters   RateCounters\n\tWorkers    []Worker\n\tWg         sync.WaitGroup\n}\n\n// Init initializes processor part\nfunc Init() *Workmq {\n\tconfig := GetConfig()\n\tprocessors := make(map[string]Processor)\n\tqueues := make(map[string]chan Message)\n\n\tcounters := RateCounters{\n\t\t\"sent\": ratecounter.NewRateCounter(1 * time.Second),\n\t}\n\n\treturn &Workmq{\n\t\tConfig:     config,\n\t\tQueues:     queues,\n\t\tProcessors: processors,\n\t\tCounters:   counters,\n\t}\n}\n```\n\nIn this piece of code which initialize a pointer of `Workmq` struct, most of the subjects I talk about are:\n* Global structure of `Workmq` (configuration, queues, processors, workers, counters, ...),\n* `Channels` notion,\n* Synchronization (wait) of `goroutines` while exploiting a `channel` into them.\n\nIn short terms, the most interesting concepts and the biggest part of the project are explained here.\n\nWorkers (part of core)\n----------------------\n\nThe `Worker` structure type is indeed a part of our core library. A worker will:\n* Be associated to a `queue` (as defined by the configuration),\n* Be associated to a `Processor` (as defined by the configuration) in order to process messages of this `queue`,\n* Retrieve the messages `channel` in order to process incoming messages,\n* Finally, retrieve an instance of `RateCounter`, an external library that we will use in order to compute the number of messages processed per second.\n\nHere is the worker definition:\n\n```go\npackage workmq\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/paulbellamy/ratecounter\"\n)\n\n// Worker struct\ntype Worker struct {\n\tID        int\n\tQueue     string\n\tMessage   <-chan Message\n\tProcessor Processor\n\tCounter   *ratecounter.RateCounter\n}\n\n// NewWorker creates a new Worker instance\nfunc NewWorker(id int, queue string, processor Processor, message <-chan Message, counter *ratecounter.RateCounter) Worker {\n\treturn Worker{ID: id, Queue: queue, Processor: processor, Message: message, Counter: counter}\n}\n\n// Process listens for a processor on the worker.\nfunc (w *Worker) Process() {\n\tfmt.Printf(\"-> Worker %d ready to process queue \\\"%s\\\"...\\n\", w.ID, w.Queue)\n\n\tfor message := range w.Message {\n\t\tw.Counter.Incr(1)\n\t\tw.Processor(w, message)\n\t}\n}\n```\n\nFirst thing important to explain as soon as you will encounter the case is the `func (w *Worker) Process() {` notation that will allow the `Process()` method to be called on a `Workmq` struct instance type only.\n\nNext, another interesting thing to explain here is the `channel` notation:\n* `<-chan`: indicates that the channel will be used for read only,\n* `chan<-`: indicates that the channel will be used for receiving data only.\n\nFinally, you can also take a tour to explain `for` loops and its notations coupling with `range` keyword.\n\nProcessors (part of core)\n-------------------------\n\nNothing really new on this part additionnally to workers when declaring our processors so I used this part to present the error handling/return and also keywords and notation to manipulate maps:\n\n```go\npackage workmq\n\nimport \"fmt\"\n\n// Processor type\ntype Processor func(worker *Worker, message Message)\n\n// AddProcessor adds a processor into the processors list\nfunc (w *Workmq) AddProcessor(name string, processor Processor) {\n\tw.Processors[name] = processor\n}\n\n// GetProcessor retrieves a processor from its name\nfunc (w *Workmq) GetProcessor(name string) (Processor, error) {\n\tif _, ok := w.Processors[name]; !ok {\n\t\treturn nil, fmt.Errorf(\"Unable to find processor '%s'\", name)\n\t}\n\n\treturn w.Processors[name], nil\n}\n\n// RemoveProcessor removes a processor from its name\nfunc (w *Workmq) RemoveProcessor(name string) {\n\tdelete(w.Processors, name)\n}\n```\n\nThe notions to explain here were some little sexy things like the `if _, ok := w.Processors[name]; !ok` notation that will allow to enter in the condition in case of errors (`!ok`) or not (`ok`) and also how to use `nil` and `error` to return an error or our processor when it is found.\n\nYou can also explain the `delete(w.Processors, name)` notation that allows to remove an element of the `map` from its name.\n\nAll of these little things seem to be nothing but are really helpful and it's important to be able to use them without googling each time to know how to achieve your goal.\n\nUDP Reception and HTTP Exposition\n---------------------------------\n\nThings were getting almost ready to work. We just had to receive our messages (using UDP) and expose some statistics (using HTTP) of our library.\n\nThen, we have two `goroutines` that are running in another threads to listen both on UDP and on HTTP servers:\n\n```go\ngo w.ListenUDP()\ngo w.ListenHTTP()\n```\n\nLet's start by UDP reception:\n\n```go\n// ListenUDP creates a UDP server that listens for new messages\nfunc (w *Workmq) ListenUDP() {\n\tdefer w.Wg.Done()\n\n\taddress, _ := net.ResolveUDPAddr(\"udp\", w.Config.Ports.UDP)\n\tconnection, _ := net.ListenUDP(\"udp\", address)\n\n\tdefer connection.Close()\n\n\tbuf := make([]byte, 1024)\n\n\tfor {\n\t\tn, _, _ := connection.ReadFromUDP(buf)\n\t\tw.Counters[\"sent\"].Incr(1)\n\n\t\tmessage := TransformStringToMessage(buf[0:n])\n\t\tw.Queues[message.Queue] <- message\n\t}\n}\n```\n\nMessages are received on a JSON format and must respect the following structure:\n\n```json\n{\n  \"queue\": \"queue.1s\",\n  \"body\": \"This is the message that should be managed by the queue 1 second.\"\n}\n```\n\nThis way, we listen on each new elements sent on configuration defined port and we transform the `[]byte` received into a `Message` structure thanks to a `TransformStringToMessage` we have defined (quite the same work as transforming JSON configuration to Go struct).\n\nFinally, we added this message to the corresponding queue channel with the `w.Queues[message.Queue] <- message` notation.\n\nAt this time, the message will be processed by the first available worker in our queue workers pool.\n\nLast step! We also had to expose some statistics using a HTTP server. In a same way, we have written a `ListenHTTP()` function that is running under a separated `goroutine`:\n\n```go\n// ListenHTTP creates a HTTP server to expose statistics information\nfunc (w *Workmq) ListenHTTP() {\n\tdefer w.Wg.Done()\n\n\thttp.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) {\n\t\tfmt.Fprintln(writer, fmt.Sprintf(\"Sent rate: %d/s\", w.Counters[\"sent\"].Rate()))\n\n\t\tvar keys []string\n\t\tfor key := range w.Queues {\n\t\t\tkeys = append(keys, key)\n\t\t}\n\n\t\tsort.Strings(keys)\n\n\t\tfor _, key := range keys {\n\t\t\tfmt.Fprintln(writer, fmt.Sprintf(\"\\n-> %s (%d workers):\", key, w.Config.Queues[key].NumWorkers))\n\t\t\tfmt.Fprintln(writer, fmt.Sprintf(\"\tAcknowledge: %d/s\", w.Counters[key].Rate()))\n\t\t\tfmt.Fprintln(writer, fmt.Sprintf(\"\tMessages: %d\", len(w.Queues[key])))\n\t\t}\n\t})\n\n\terr := http.ListenAndServe(w.Config.Ports.HTTP, nil)\n\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe error: \", err)\n\t}\n}\n```\n\nIn this code, we loop over each queue to display counters data on output.\n\nIn order to let you have a better visualization of the output, here is a sample:\n\n![HTTP Output](/imgs/posts/2017-08-23-retour-sur-un-live-coding-de-decouverte-du-langage-go/output.gif)\n\nConclusion\n----------\n\nBefore any conclusion, the open-source code of this library is available here: [https://github.com/unikorp/workmq](https://github.com/unikorp/workmq){:rel=\"nofollow noreferrer\"}.\n\nI had two main objectives for this live-coding/workshio session:\n* Allow my participants to write a complete and functional open-source library in three hours,\n* Allow my participants to discover most of the Go language features and concepts so that they are able to develop a Go library or application by themselves the day after.\n\nI think the contract is fulfilled with this workshop and I hope it will be useful to you, to discover Go language or to let your colleagues know about it.\n\nTo conclude, do not hesitate to contact Eleven Labs or me directly if you want to organize workshop sessions on web technologies.\n"}