{"date":"2017-11-09T00:00:00.000Z","title":"Build an api with Go and Buffalo","excerpt":"Presentation of http/net package and Buffalo.","readingTime":"9mn","authors":["qneyrat"],"categories":[],"content":"\nThe Go language has quickly become very popular, but there are still some people reluctant to use it for the development of their new apps. We will see here how to build a REST API quickly and easily.\n\nThe greatest feature of the Go language is its simplicity of writing. The syntax is inspired by the C language with a procedural code. It does not integrate a concept of classes but provides the mechanisms needed to write code in an object-oriented style. The code is brief and clear, KISS-oriented (Keep It Simple, Stupid). We will see how to use this language to build a web application with the **Buffalo** framework.\n\n\n### Package \"http/net\"\n\nPackage documentation: [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/){:rel=\"nofollow noreferrer\"}.\n\nFirst of all, we are going to create an http server that will listen on the `8001` entry.\n\n```go\npackage main\n\nimport \"net/http\"\n\nfunc main() {\n\t//TO DO Implement handler\n\thttp.ListenAndServe(\":8001\", nil)\n}\n```\n\nTo start the server, just run the file `main.go` with the following command:\n\n```\ngo run main.go\n```\n\nIf you try to make an http request on `127.0.0.1:8001`, the server will return you a `404` since the path is not specified. To solve this problem, it's necessary to implement a handler on `/`.\n\n```go\n// Handle registers the handler for the given pattern\n// in the DefaultServeMux.\n// The documentation for ServeMux explains how patterns are matched.\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\n```\n\nFor this, `http.Handle` needs a pattern that will match the query's path and a handler.\n\n```go\ntype Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}\n```\n\nA handler needs an object of type `ResponseWriter` and query. We will create a `handler` method. Here, for a REST API, the response must be in JSON format. We will therefore add to the header the content-type JSON and return JSON content. The `ResponseWriter` and `Write` method take a byte array as a parameter. So we cast our string containing JSON to the bytes format with the `byte[](string)` method.\n\n```go\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", \"application/json\")\n\tw.Write([]byte(`{\"message\": \"Hello world !\"}`))\n}\n```\n\nThe final code of our server gives:\n\n```go\npackage main\n\nimport \"net/http\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"content-type\", \"application/json\")\n\tw.Write([]byte(`{\"message\": \"hello world\"}`))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8001\", nil)\n}\n\n```\n\nThis time, if we launch the server and make an http request on `127.0.0.1:8001`, the server responds a code 200 with our message in JSON.\n\nThis package is very low level and quite annoying to use. The community has therefore made available various overlays, especially at the level of routing to make development easier.\n\n\n### Buffalo framework\n\n> Buffalo documentation on [http://gobuffalo.io](http://gobuffalo.io){:rel=\"nofollow noreferrer\"}.\n\nBuffalo is a library that makes web development with Go easier. It mainly uses the Gorilla libraries [https://github.com/gorilla](https://github.com/gorilla){:rel=\"nofollow noreferrer\"}.\n\nTo install buffalo run the command:\n\n`go get -u -v github.com/gobuffalo/buffalo/buffalo`\n\nAfter buffalo is installed:\n\n```\n> $ buffalo help new\nBuffalo version v0.10.1\n\nCreates a new Buffalo application\n\nUsage:\n  buffalo new [name] [flags]\n\nFlags:\n      --api                  skip all front-end code and configure for an API server\n      --ci-provider string   specify the type of ci file you would like buffalo to generate [none, travis, gitlab-ci] (default \"none\")\n      --db-type string       specify the type of database you want to use [postgres, mysql, sqlite3] (default \"postgres\")\n      --docker string        specify the type of Docker file to generate [none, multi, standard] (default \"multi\")\n  -f, --force                delete and remake if the app already exists\n  -h, --help                 help for new\n      --skip-pop             skips adding pop/soda to your app\n      --skip-webpack         skips adding Webpack to your app\n      --skip-yarn            skip to use npm as the asset package manalready exists\n      --vcs string           specify the Version control system you would like to use [none, git, bzr] (default \"git\")\n  -v, --verbose              verbosely print out the go get commands\n      --with-dep             adds github.com/golang/dep to your app\n```\n\nThe command `new` generates a new project. We will therefore create an api project without the database that is managed by `pop`. We will therefore launch this command to generate the basis of our API REST. Go to your working directory (`$GOPATH/src/your_user_name for example`) and run the following command:\n\n```\nbuffalo new api --api --skip-pop\n```\n\nThis command created the `api` folder. This includes:\n\n* The file `main.go`, this is the entry of the application;\n* The file `actions/`, it is the file containing our handlers;\n* The folder `grifts/`, this is the folder containing the commands\n\nThe rest of the files do not interest us.\n\nLaunch the server:\n\n```\nbuffalo dev\n```\n\nOpen `main.go` file:\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\t\"qneyrat/api/actions\"\n\n\t\"github.com/gobuffalo/envy\"\n)\n\nfunc main() {\n\tapp := actions.App()\n\tlog.Fatal(app.Serve())\n}\n\n```\n\nOur interest will be in the `app.Serve()` method.\n\n```go\n// ...\nserver := http.Server{\n\t\tAddr:    fmt.Sprintf(\":%s\", addr),\n\t\tHandler: a,\n\t}\n\n// ...\nerr := server.ListenAndServe()\n```\n\nAs in the first part, Buffalo starts the http server of the `http/net` package.\n\nStart a query on `127.0.0.1:3000`, this one returns us a reply JSON. Let's now see in `actions.App()` what happens.\n\n```go\nfunc App() *buffalo.App {\n\tif app == nil {\n\t\t//...\n\n\t\tapp.GET(\"/\", HomeHandler)\n\n\t}\n\n\treturn app\n}\n```\n\nThe `App()` function will attach to the instance of `*buffalo.App` the handlers of our API. Here, a handler is attached to the `/` route. The Handler `HomeHandler` is `Handler` type.\n\n```go\ntype Handler func(Context) error\n```\n\nHandler takes a `Context` parameter.\n\n```go\n// Context holds on to information as you\n// pass it down through middleware, Handlers,\n// templates, etc... It strives to make your\n// life a happier one.\ntype Context interface {\n\tcontext.Context\n\tResponse() http.ResponseWriter\n\tRequest() *http.Request\n\tSession() *Session\n\tParams() ParamValues\n\tParam(string) string\n\tSet(string, interface{})\n\tLogField(string, interface{})\n\tLogFields(map[string]interface{})\n\tLogger() Logger\n\tBind(interface{}) error\n\tRender(int, render.Renderer) error\n\tError(int, error) error\n\tWebsocket() (*websocket.Conn, error)\n\tRedirect(int, string, ...interface{}) error\n\tData() map[string]interface{}\n\tFlash() *Flash\n}\n```\n\nThe `Context` interface will contain the `http.ResponseWriter` and `*http.Request` as in the example of the first part. One can notice that `Context` has many other interfaces that will make the development of our handler easier.\n\nFor instance, to return our JSON message, we use `Render`.\n\n```go\nreturn c.Render(200, r.JSON(map[string]string{\"message\": \"Welcome to Buffalo!\"}))\n```\n\nYou can now build the application and run the server. Buffalo offers a dev mode that will automatically recompile your application when you make a change in the code. To do this, run the command:\n\n```\nbuffalo dev\n```\n\nNow, if you try to make a query on `127.0.0.1:3000`, you will get your message `Welcome to Buffalo!` in JSON.\n\nTo make the development easier Buffalo integrates the package `grifts` which allows the creation of task scripts. These scripts are declared in the `grifts` folder.\n\n```\nbuffalo task list\n```\n\nBy default, there is the `routes` command that allows you to see all routes and handlers.\n\n```\nbuffalo task routes\n```\n\nNow that buffalo has been presented, we will create new routes. You can find all the code on my github [https://github.com/qneyrat/api](https://github.com/qneyrat/api){:rel=\"nofollow noreferrer\"}.\n\nWe will manage a new resource for our api, the `user` resource. Create the `models` folder and in it the `user.go` file. We will state a `User` structure composed of an `ID`.\n\n```go\npackage models\n\nimport (\n\t\"github.com/satori/go.uuid\"\n)\n\ntype User struct {\n\tID uuid.UUID `json:\"id\"`\n}\n\n```\n\nCreate a new action in the `actions` folder to manage the user resource. Create a `users.go` file. To abstract from a database, we will create a map to store our users.\n\n```go\nvar db = make(map[uuid.UUID]models.User)\n```\n\nSo we will create a function to return to a JSON the set of users stored in \"database\" `db`. To group all the handlers that will manage our user resource, we will create an empty structure to attach our functions.\n\n```go\ntype UserResource struct{}\n\nfunc (ur UserResource) List(c buffalo.Context) error {\n\treturn c.Render(200, r.JSON(db))\n}\n```\n\nWe will now attach this new handler to a route in the `app.go` file. Before that we will prefix our routes by `/api/v1`.\n\n```go\n// /api/v1 prefix for new routes\ng := app.Group(\"/api/v1\")\n\n// new UserResource\nur := &UserResource{}\n\n// new route and handler UserResource.List\n// the path is /api/v1/users\ng.GET(\"/users\", ur.List)\n```\n\nIf you do a `get` on `/api/v1/users`, the api returns you an empty collection since there is no user yet. We will create a new handler that will create one.\n\n```go\n// Create User.\nfunc (ur UserResource) Create(c buffalo.Context) error {\n\t// new User\n\tuser := &models.User{\n\t\t// on génère un nouvel id\n\t\tID: uuid.NewV4(),\n\t}\n\t// add in database\n\tdb[user.ID] = *user\n\n\treturn c.Render(201, r.JSON(user))\n}\n\n```\n\nWe add the route in `app.go`.\n\n```go\ng.POST(\"/users\", ur.Create)\n```\n\nNow, if you do a `post` on `/api/v1/users`, the api will return a `201` and inform you that the user was created. We will check in our list of users. So we do a `get` on `/api/v1/users` and we see that we have our user in the collection. Finally, we will do a handler to display a specific user. We will create it on the route `/users/{id}`.\n\n```go\nfunc (ur UserResource) Show(c buffalo.Context) error {\n\t// get id and format to uuid\n\tid, err := uuid.FromString(c.Param(\"id\"))\n\tif err != nil {\n\t\t// if id isnt uuid\n\t\treturn c.Render(500, r.String(\"id is not uuid v4\"))\n\t}\n\n\t// get user in database\n\tuser, ok := db[id]\n\tif ok {\n\t\t// if exist return user\n\t\treturn c.Render(200, r.JSON(user))\n\t}\n\n\t// if not exist return not found\n\treturn c.Render(404, r.String(\"user not found\"))\n}\n```\n\nWe attach this new handler to our `app`.\n\n```go\ng.GET(\"/users/{id}\", ur.Show)\n```\n\nNow we create a user with a `post` on `/api/v1/users` and then we make a `get` on `/api/v1/users/{id}` replacing `{id}` with the `uuid` of the user you just created. The api returns you a code 200 with the user's information.\n\nFrom now on you have a powerful api database with tools to quickly and easily develop an api in Go. You can find all the documentation and other buffalo features on [http://gobuffalo.io](http://gobuffalo.io){:rel=\"nofollow noreferrer\"}.\n"}