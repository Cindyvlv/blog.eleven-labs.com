{"date":"2019-05-27T00:00:00.000Z","title":"Delegates vs Closures","excerpt":"Delegates VS Closures","readingTime":"9mn","authors":["thuchon"],"categories":[],"content":"\n## Introduction\n\nHi astronauts, today we're going to talk about mobile programming, and you know what? It's native development! This article will be for beginners, so we'll spend a bit of time to understand a few technical terms together before going deeper in the subject. This time we'll focus on iOS, but don't worry, I plan to do the equivalent for Android as soon as possible.\n\n**Swift and Objective-C**\n\nFor those who don't know, in iOS, you can use two different programming languages: Objective-C and Swift. Everyone is more or less using Swift now, but because of legacy, you can still find some projects made with Objective-C. This is why in this article, every piece of code will be provided in Objective-C as well as in Swift. The two langages have two different syntaxes and in addition to that, even the file structure is different:\n- In Objective-C you have a header (.h file) to declare all the accessible elements, then you will have an implementation file (.m file) that will contain the body of the methods, exactly like in C language.\n- In Swift, you have only one file (.swift file) and the accessibility will be defined depending on \"public\" or \"private\".\n\n**Protocol**\n\nJust one last notion, and I promise, we're good to go.\nIn this article, I'll use a lot the term \"Protocol\": a protocol is an interface in the Apple world, when I say interface, I mean a class that you have to inherit in order to implement some methods. It's a keyword for both Swift and Objective-C.\n\n**Delegates and Closures / Blocks**\n\nIn iOS development, you will often find 2 principles: ***delegates***, ***closures (Swift) / blocks (Objective-C)***\n\nWe will cover those two points more in detail, but before we go further it's important to know that they exist! Here are the basic principles to know! We're now done with the introduction, we can finally go deeper and have a proper look!\n\n### Delegates\n\nA delegate is a reference to an object that we don't know the exact type of. Important thing though, it inherits a protocol. Because this object inherits a protocol, we then know that we can call the methods defined in the protocol, even if we don't know in detail the given object. I think that a proper example will help you to figure out what I'm talking about.\n\nNB: The code I'll provide is just a dummy implementation so that you're able to understand the principles of which I'm talking about, it will not really do any HTTP call on the URL given as a parameter.\n\nLet's imagine that I need to do a GET. Usually, in the mobile development world, we like to handle this with 2 different callbacks for the return of the call. One is for the success case and the other one is for the error case. Our goal here is to produce a class that will do a GET on a given URL. I want to notify the object that launched this request, if it failed or succeed.\n\nIn order to avoid a strong dependance, we will use the design pattern of the delegate. Thanks to that, I don't need to know the exact type of this object. We'll then define a protocol that will contain two methods: onRequestSuccess onRequestFailure. Let's have a look at what it will look like:\n\n#### Objective-C\n\n```Objective-C\n@protocol RequesterDelegateObjc\n\n- (void)onRequestSuccess;\n- (void)onRequestFailure;\n\n@end\n```\n\nWe inherit it in the header file (.h)\n\n```Objective-C\n@interface MyClassObjC : UIViewController <RequesterDelegateObjc>\n\n@end\n```\n\nThen we implement the methods in our class like this:\n\n```Objective-C\n#import \"MyClass.h\"\n\n@implementation MyClassObjC\n\n- (void)onRequestFailure {\n\n}\n\n- (void)onRequestSuccess {\n\n}\n\n@end\n```\n\n#### Swift\n\n```Swift\nprotocol RequesterDelegateSwift {\n    func onRequestFailure()\n    func onRequestSuccess()\n}\n```\n\n```Swift\nclass MyClassSwift: UIViewController, RequesterDelegateSwift {\n\n    func onRequestFailure() {\n\n    }\n\n    func onRequestSuccess() {\n    }\n}\n```\n\nSo, we have our Class MyClass that inherits the Protocol RequesterDelegate and that implements 2 methods (onRequestSuccess, onRequestFailure). We're going to do a dummy implementation so that you have an idea of how this works:\n\n#### Objective-C\n\n```Objective-C\n#import \"MyClass.h\"\n#import \"RequestManager.h\"\n\n@implementation MyClassObjC\n\n- (void)callWebService {\n    RequestManager* manager = [[RequestManager alloc] init];\n    manager.delegate = self;\n    [manager get:@\"http://plop.fr/json\"];\n}\n\n- (void)onRequestFailure {\n\n}\n\n- (void)onRequestSuccess {\n\n}\n\n@end\n```\n\n```Objective-C\n@interface RequestManager : NSObject\n{\n\n}\n\n@property (nonatomic, weak) id delegate;\n\n- (void)get:(NSString*)url;\n```\n\n```Objective-C\n#import \"RequestManager.h\"\n\n@implementation RequestManager\n\n- (void)get:(NSString *)url {\n    //Do the call\n    BOOL requestSucceed = [self isSuccess];\n\n    //After the call\n    if (requestSucceed) {\n        [self.delegate onRequestSuccess];\n    } else {\n        [self.delegate onRequestFailure];\n    }\n}\n\n- (BOOL)isSuccess {\n    return YES;\n}\n\n@end\n```\n\n#### Swift\n\n```Swift\nclass MyClassSwift: UIViewController, RequesterDelegateSwift {\n\n    func callWebService() {\n        let manager: RequestManager = RequestManager()\n        manager.delegate = self\n        manager.get(url: \"http://plop.fr/json\")\n    }\n\n    func onRequestFailure() {\n\n    }\n\n    func onRequestSuccess() {\n    }\n}\n```\n\n```Swift\nclass RequestManager {\n\n    var delegate: RequesterDelegateSwift?\n\n    func get(url: String) {\n        //Do the call\n        let requestSucceed: Bool = self.isSuccess()\n\n        //After the call\n        if requestSucceed {\n            self.delegate?.onRequestSuccess()\n        } else {\n            self.delegate?.onRequestFailure()\n        }\n    }\n\n    private func isSuccess() -> Bool {\n        return true\n    }\n}\n```\n\n**But why do all this?**\n\nWe have a light dependency between our different objects. Indeed, RequestManager has no idea of the type of the object of its delegate, all that it cares about is to know that the object contains the two methods defined in the protocol in order to be able to call them. So, It's fine, I was able to call my webservice, I have my callback methods in which I can handle the different cases, everything seems good to me. Yes, everything is well, it works fine and it will cover a lot of cases.\n\n**Raised Issue**\n\n- But now, if we need to call many webservices in only one class, how do we do?\n- How do we do? You just showed us how to do it.\n- The issue is that by doing it this way, all the returns of your webservices will go in the methods onRequestSuccess and onRequestFailure.\n- Ha, but you are right, it raises an issue...\n\n**Solution**\n\nIn order to solve this issue, there is still the possibility to change a bit the method, add a unique id when we launch the request and receive it when the request is done and they identify to which request it belongs to. Yes it's true, we can do that, but it will quickly become \"verbose\" and not so easy to handle. One thing I like to do when I program is to avoid strong dependency (Yes, the delegate already helps with that), but even more, I like when I can move some code really easily.\n\nBut here, If I want to move my code, I need to re-implement the protocol in another class.\n- Maybe there is something easier right?\n- But guys, at the beginning, didn't he talk about block or closure?\n- What are those things?\n\n### Closures / Blocks\n\nIt's really easy, the term \"Block\" will be used in Objective-C and \"Closure\" in swift, it really is an anonymous function. For those who are coming from web and who develop in JS, it should ring a bell. Let's have a look? We are going to add one method in both classes that will allow us to use blocks/closures.\n\n#### Objective-C\n\n```Objective-C\ntypedef void (^successBlock)();\ntypedef void (^failureBlock)();\n\n- (void)callWebServiceWithBlocks {\n    RequestManager* manager = [[RequestManager alloc] init];\n    successBlock success = ^void() {\n\n    };\n\n    failureBlock failure = ^void() {\n\n    };\n    [manager get:@\"http://plop.fr/json\" success:success failure:failure];\n}\n```\n\n```Objective-C\n- (void)get:(NSString *)url success:(successBlock)successBlock failure:(failureBlock)failureBlock {\n    //Do the call\n    BOOL requestSucceed = [self isSuccess];\n\n    //After the call\n    if (requestSucceed) {\n        successBlock();\n    } else {\n        failureBlock();\n    }\n}\n```\n\n#### Swift\n\n```Swift\nfunc callWebServiceWithClosure() {\n    let manager: RequestManager = RequestManager()\n\n    let success: () -> Void = {\n\n    }\n\n    let failure: () -> Void = {\n\n    }\n\n    manager.get(url: \"http://plop.fr/json\", successClosure: success, failureClosure: failure)\n}\n```\n\n```Swift\nfunc get(url: String, successClosure: () -> Void, failureClosure: () -> Void) {\n    //Do the call\n    let requestSucceed: Bool = self.isSuccess()\n\n    //After the call\n    if requestSucceed {\n       successClosure()\n     } else {\n       failureClosure()\n    }\n}\n```\n\n## Conclusion\n\nSo, like before, we just need to call the method callWebServiceWithClosure and we have a callback for the success case and one for the error case. You're going to ask me, what is the advantage? Easy, you just don't need to inherit from an interface anymore, you maybe don't realise it yet, but it really gets easier. For the understanding also, it's easier, you see straight above the different handlings you have instead of having to look in the code in order to find how the callback handles the return of the call.\n\nAnd as I said earlier, if you have many webservices to call, you can easily isolate the code for every single one of them. The goal here is just to present you both principles, if you already are a mobile developer, it's probably something you encountered more than once. But, just a question, wouldn't it be cool to be able to merge the delegates with the blocks/closures? Hum, it seems like an interesting topic right? Let's do that together in the future in a new article? See you space cowboys :)\n"}