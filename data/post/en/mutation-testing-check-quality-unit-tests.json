{"date":"2016-10-21T00:00:00.000Z","title":"Mutation Testing - Check the quality of your unit tests","excerpt":"It is well established : unit tests are mandatory when developing an application. They allow to highlight possible regressions when code is modified, so the developer gets a certain confidence when shipping his code to production : If tests do pass, everything works correctly.","readingTime":"7mn","authors":["rgraillon"],"categories":[],"content":"\n## Unit tests and trust\n\nIt is well established : unit tests are mandatory when developing an application. They allow to highlight possible regressions when code is modified, so the developer gets a certain confidence when shipping his code to production : If tests do pass, everything works correctly.\n\nTo measure this confidence, we use code coverage as our main metric. The more your code is covered, (close to 100%), the less chance there is that regressions would fall through the net.\n\nBut be careful ! This affirmation is a pure theory !\n\n## Coverage vs protection\n\nWe are going to see that sometimes, code coverage is a false indicator of protection.\nHere is a simple example :\n\n```php\n<?php\n\nclass Astronaut {}\n\nclass SpaceShip\n{\n    private $capacity;\n    public $astronauts = [];\n\n    public function __construct($capacity)\n    {\n        $this->capacity = $capacity;\n    }\n\n    public function addAstronaut(Astronaut $astronaut)\n    {\n        if (count($this->astronauts) < $this->capacity) {\n            $this->astronauts[] = $astronaut;\n        }\n    }\n}\n```\n\nThe *SpaceShip* class has a public method *addAstronaut* which adds an instance of *Astronaut* only if maximum capacity is not reached. Let's see the associated unit test :\n\n```php\n<?php\n\nclass SpaceShipTest extends \\PHPUnit_Framework_TestCase\n{\n    public function testAddAstronaut()\n    {\n        $spaceShip = new SpaceShip(1);\n\n        $spaceShip->addAstronaut(new Astronaut());\n\n        $this->assertCount(1, $spaceShip->astronauts);\n    }\n}\n```\n\nThe test checks that the method is actually adding an entry to the astronaut array. When we launch the tests, we have a code coverage of 100% (even without assertion we would still have this result).\nBut we are not protected enough : what would happen if the *addAstronaut* method changed ?\nWould our test be sufficient to detect the regression ?\n\n### **Mutation Tests**\n\nIn order to detect breaches in your unit tests, one solution exist : **mutation tests**.\nThe principle is very simple : alter the source code to check that associated tests would fail accordingly.\n\nTo get to this, here are the required steps :\n\n-   Launch the test suite once to check that all the tests pass (it's useless to try to make a failing test fail !)\n-   Launch the test suite again but with parts of the tested code modified\n-   Check that tests fail when tested code have been mutated\n-   Start over as many times as there are possible mutations to apply\n\nOf course, we don't have to do this by hand, there are frameworks out there that are going to automate the process.\n\nBefore we go deeper, let's see some vocabulary :\n\n-   **Mutant** : Unit modification of the code (e.g: **!==** replaced by **===**)\n-   **Killed/Captured** : A mutant is said killed (or captured) if the unit test fails (positive outcome)\n-   **Escaped** : A mutant escapes if the unit test dosn't fail (negative outcome)\n-   **Uncovered** : A mutant is uncovered if no test cover the mutated code\n\n## Case study : Humbug\n\nWe are going to see [Humbug](https://github.com/padraic/humbug){:rel=\"nofollow\"}, a framework that allows us to do mutation tests in PHP.\n\nAs we execute the Humbug binary, we get the following output :\n\n```txt\n$> humbug\n...\nMutation Testing is commencing on 1 files...\n(.: killed, M: escaped, S: uncovered, E: fatal error, T: timed out)\n\nM.\n\n2 mutations were generated:\n       1 mutants were killed\n       0 mutants were not covered by tests\n       1 covered mutants were not detected\n       0 fatal errors were encountered\n       0 time outs were encountered\n\nMetrics:\n    Mutation Score Indicator (MSI): 50%\n    Mutation Code Coverage: 100%\n    Covered Code MSI: 50%\n```\n\nDamn ! A Mutant escaped ! Let's have a look at the log file :\n\n```txt\n1) \\Humbug\\Mutator\\ConditionalBoundary\\LessThan\nDiff on \\SpaceShip::addAstronaut() in src/SpaceShip.php:\n--- Original\n+++ New\n@@ @@\n     {\n-        if (count($this->astronauts) < $this->capacity) {\n+        if (count($this->astronauts) <= $this->capacity) {\n             $this->astronauts[] = $astronaut;\n         }\n     }\n }\n```\n\nAs we can see in the generated diff, tests didn't detect the operator substitution. Actually, we haven't tested the case when our spaceship is full !\nNow, let's add a test to cover this use-case :\n\n```php\n<?php\n\nclass SpaceShipTest extends \\PHPUnit_Framework_TestCase\n{\n    public function testAddsAstronautWhenShipNotFull()\n    {\n        $spaceShip = new SpaceShip(1);\n\n        $spaceShip->addAstronaut(new Astronaut());\n\n        $this->assertCount(1, $spaceShip->astronauts);\n    }\n\n    public function testDoesNotAddAstronautWhenShipFull()\n    {\n        $spaceShip = new SpaceShip(0);\n\n        $spaceShip->addAstronaut(new Astronaut());\n\n        $this->assertCount(0, $spaceShip->astronauts);\n    }\n}\n```\n\nLaunch Humbug again :\n\n```txt\n$> humbug\n...\nMutation Testing is commencing on 1 files...\n(.: killed, M: escaped, S: uncovered, E: fatal error, T: timed out)\n\n..\n\n2 mutations were generated:\n       2 mutants were killed\n       0 mutants were not covered by tests\n       0 covered mutants were not detected\n       0 fatal errors were encountered\n       0 time outs were encountered\n\nMetrics:\n    Mutation Score Indicator (MSI): 100%\n    Mutation Code Coverage: 100%\n    Covered Code MSI: 100%\n```\n\nThat's it ! This time no mutant escaped, our test suite is more efficient, and this potential bug will never reach production !\nObviously, the example chosen here is voluntarily very simple and might not be evocative, but in the core businnes logic of your application, you may have a lot more sensitive use-cases.\n\nHumbug is capable of generating a whole set of mutations :\n\n-   Comparison operator substitution (**&gt;** becomes **&gt;=**, **!==** becomes **===**, etc...)\n-   Constant substitution (**0** becomes **1**, **true** becomes **false**, etc...)\n-   Logic operator substitution (**&&**, **||**, etc...)\n-   Binary operator subsctirution (**&**, **|**, **%**, etc...)\n-   Return values substitution\n\nI'm not going to detail everything here, if wou want to know more about this, I invite you to check the [GitHub project page](https://github.com/padraic/humbug){:rel=\"nofollow\"}.\n\n## Conclusion\n\nMutation testing is a simple and efficient way of measuring unit tests fiability. Code coverage is not a very reliable metric, a code can be 100% covered without any assertion !\nHumbug allows to automate these tests, so it's possible to plug it in your continuous integration workflow. However, be aware that execution time increases exponentially when codebase grows, we want to use mutation testing where there is a true concern in priority : business code.\n"}