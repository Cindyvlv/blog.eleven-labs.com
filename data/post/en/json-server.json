{"date":"2017-08-16T00:00:00.000Z","title":"JSON Server","excerpt":"Accelerate your prototyping process by mocking your APIs using JSON Server","readingTime":"15mn","authors":["kelfarsaoui"],"categories":["javascript"],"content":"\nHello, Today I’m going to talk about [json-server](https://github.com/typicode/json-server){:rel=\"nofollow noreferrer\"}, what is it? why use it? and especially how to use it?\n\n`json-server` is a cool `npm` module, that provides an [Express](https://github.com/expressjs/express){:rel=\"nofollow noreferrer\"} server that serves a JSON API.\n\n## Why use it?\n\nLet's say you are starting to work on your awesome (Javascript, PHP, IOS, Android, … whatever) app, and you want to consume remote data of some, not finished yet, API. The first step you take consists in setting up some mocks, either hard coded in some constant (please, don't do this), or using a static JSON file, which will be a pain in the neck. Why? You're a good developer who likes to do the right thing. You want to test your app against data updates. You want to perform HTTP requests (like `GET`, `POST` …etc.), and you want to persist your updates. Unfortunately, you can't do all of this using a static file, you need to look for a way to make it dynamic. So, unless your pal who's developing the API has finished their work, you're gonna need some serious help.\n\nHere comes `json-server`, it allows you to mock the API, and provide dynamic access to data. By dynamic, I mean that we can read, add, update, and delete data (`GET`, `POST`, `PUT`, `PATCH`, `DELETE`).\n\nIt provides common URL use cases like:\n- [Routes](#routes) (`/articles/1`)\n- [Filters](#filters) (`/articles/1/comments?author.username=rpierlot`)\n- [Pagination](#pagination) (`/articles?_page=2&_limit=10`)\n- [Full text search](#full-text-search) (`/articles?q=graphql`)\n- [Relationships](#relationships) (`/articles?_embed=comments`)\n\nand other miscellaneous stuff like:\n- `CORS` & `JSONP`\n- Ability to access remote schemas\n- [Randomly generated data](#random-data)\n- [Custom routes](#custom-routes)\n- [Middlewares](#middlewares)\n- [Ability to use `json-server` as a module in your NodeJS server](#nodejs-module)\n\nOkay, let's get to it.\n\n## How to use it?\n\nThis will take less than 5 minutes!\n\n### Requirements\n\n- NodeJS & `npm`\n- An API consumer (Your code, `curl`, postman, or simply your browser)\n\n### Installation\n\nIt's pretty straightforward to set up:\n\n```bash\n$ npm install -g json-server\n\n# Or with yarn\n$ yarn global add json-server\n\n# Then create a folder in which we will put our db.json file:\n$ mkdir blog && cd $_\n\n# create our schema file\n$ touch db.json\n```\n\nTo fill it in, we can either do it by hand or use a random json generator (my favorite is [json-generator](http://json-generator.com)){:rel=\"nofollow noreferrer\"}\n\n```json\n{\n  \"articles\": [\n    {\n      \"id\": 1,\n      \"title\": \"Build an API using GO\",\n      \"authorId\": 2\n    },\n    {\n      \"id\": 2,\n      \"title\": \"Build an API using API Platform\",\n      \"authorId\": 1\n    }\n  ],\n  \"comments\": [\n    {\n      \"id\": 1,\n      \"body\": \"Brilliant\",\n      \"articleId\": 1\n    },\n    {\n      \"id\": 2,\n      \"body\": \"Awesome\",\n      \"articleId\": 2\n    }\n  ],\n  \"authors\": [\n    {\n      \"id\": 1,\n      \"username\": \"rpierlot\",\n      \"title\": \"Romain Pierlot\"\n    },\n    {\n      \"id\": 2,\n      \"username\": \"qneyrat\",\n      \"title\": \"Quentin Neyrat\"\n    }\n  ]\n}\n```\n\nNow we can run `json-server` so that we can access the endpoints that `json-server` created for us\n\n\n```bash\n$ json-server db.json\n\n  \\{^_^}/ hi!\n\n  Loading db.json\n  Done\n\n  Resources\n  http://localhost:3000/articles\n  http://localhost:3000/comments\n  http://localhost:3000/authors\n\n  Home\n  http://localhost:3000\n\n  Type s + enter at any time to create a snapshot of the database\n```\n\nGreat, we've set up our API mock. Now we can test our endpoints:\n\n```bash\n$ curl http://localhost:3000/articles\n[\n  {\n    \"id\": 1,\n    \"title\": \"Build an API using GO\",\n    \"authorId\": 2\n  },\n  {\n    \"id\": 2,\n    \"title\": \"Build an API using API Platform\",\n    \"authorId\": 1\n  }\n]\n\n$ curl http://localhost:3000/articles/1\n{\n  \"id\": 1,\n  \"title\": \"Build an API using GO\",\n  \"authorId\": 2\n}\n```\n\n<a name=\"routes\"></a>\n\n### Routes\n\nWe can use almost all kinds of URIs to perform requests:\nFor example, to insert (create) a new author, we might use:\n`POST http://localhost:3000/authors`\n\n```bash\n$ curl --data-urlencode \"title=Vincent Composieux\" --data \"username=vcomposieux\" http://localhost:3000/authors\n{\n  \"title\": \"Vincent Composieux\",\n  \"username\": \"vcomposieux\",\n  \"id\": 3\n}\n```\n\nTo read an article with article id 2: `GET http://localhost:3000/articles/2`. The same URI would be used for `PUT` and `DELETE`, to update and delete, respectively.\n\nNow, when it comes to creating a new comment in an article, one option might be: `POST http://localhost:3000/comments` And that could work to create a comment, but it's arguably outside the context of an article.\n\nAs a matter of fact, this URI is not as intuitive as it could be. It could be argued that the following URI would offer better clarity: `POST http://localhost:3000/articles/1/comments`. Now we know we're creating a comment in article id 1.\n\n```bash\n$ curl --data-urlencode \"body=Cool article ;-)\" http://localhost:3000/articles/1/comments\n{\n  \"body\": \"Cool article ;-)\",\n  \"articleId\": 1,\n  \"id\": 4\n}\n```\n\nSame with creating an article by author id 3:\n\n```bash\n$ curl --data-urlencode \"title=GraphQL\" http://localhost:3000/authors/3/articles\n{\n  \"title\": \"GraphQL\",\n  \"authorId\": \"3\",\n  \"id\": 3\n}\n```\n\n<a name=\"filters\"></a>\n\n#### Filters, sort & operators\n\n**Filtering** is done using query parameters: `GET http://localhost:3000/articles?title=GraphQL`.\n\n**Sort** is as easy as adding `_sort` & `_order` (`asc` & `desc`) query parameters:\n\n`GET http://localhost:3000/articles?_sort=likes`\n\n(Assuming we have added the `likes` field to each article). The order is ascending by default.\n\nIn case we want to sort by multiple properties, we can write our properties separated by a comma:\n\n`GET http://localhost:3000/articles?_sort=author,score&_order=desc,asc`\n\n**Operators** are suffixes used to augment our query parameters:\n\n* `_gt` (greater than), `_lt` (less than), `_gte` (greater than or equal) and `_lte` (less than or equal): `GET http://localhost:3000/comments?score_gte=5` (assuming we have a `score` field in the comments)\n* `_ne`(not equal) negation of an expression `GET http://localhost:3000/comments?articleId_ne=2`\n* `_like` is an operator that can be applied to string properties, it gives the same result as an `SQL`'s `LIKE`. `GET http://localhost:3000/articles?title_like=API`\n\n<a name=\"pagination\"></a>\n\n#### Pagination\n\nWe can use the built-in query parameters `_page` & `_limit` to paginate our results.\n`json-server` exposes `X-Total-Count` and the `Link` header that contain links to the first, next and last pages.\n\n`GET http://localhost:3000/articles?_page=1&_limit=1`\n\n```http\nHTTP/1.1 200 OK\nX-Powered-By: Express\nVary: Origin, Accept-Encoding\nAccess-Control-Allow-Credentials: true\nCache-Control: no-cache\nPragma: no-cache\nExpires: -1\nX-Total-Count: 3\nAccess-Control-Expose-Headers: X-Total-Count, Link\nLink: <http://localhost:3000/articles?_page=1&_limit=1>; rel=\"first\", <http://localhost:3000/articles?_page=2&_limit=1>; rel=\"next\", <http://localhost:3000/articles?_page=3&_limit=1>; rel=\"last\"\nX-Content-Type-Options: nosniff\nContent-Type: application/json; charset=utf-8\nContent-Length: 89\nETag: W/\"59-24+hjZrVFdbtnn+FgcogU6QvujI\"\nDate: Sun, 30 Jul 2017 17:22:34 GMT\nConnection: keep-alive\n```\n\n<a name=\"full-text-search\"></a>\n\n#### Full text search\n\nWe can implement a search feature in our app using full-text search by simply adding a `q` query parameter.\n\n```bash\n$ curl http://localhost:3000/articles?q=api\n[\n  {\n    \"id\": 1,\n    \"title\": \"Build an API using GO\",\n    \"author\": \"qneyrat\"\n  },\n  {\n    \"id\": 2,\n    \"title\": \"Build an API using API Platform\",\n    \"author\": \"rpierlot\"\n  }\n]\n```\n\n<a name=\"relationships\"></a>\n\n#### Relationships\n\n\nWe can see relationships using `_embed` & `_expand` parameters.\n* `_embed` allows us to see the children resources like `comments`: `GET http://localhost:3000/articles?_embed=comments`\n* `_expand` allows us to see the parent resources like `articles`: `GET http://localhost:3000/comments?_expand=article`\n\n```bash\n$ curl http://localhost:3000/articles?author=vincent&_embed=comments\n[\n  {\n    \"title\": \"GraphQL\",\n    \"author\": \"vincent\",\n    \"id\": 3,\n    \"comments\": [\n      {\n        \"body\": \"nice\",\n        \"articleId\": 3,\n        \"id\": 3\n      },\n      {\n        \"body\": \"great!\",\n        \"articleId\": 3,\n        \"id\": 4\n      }\n    ]\n  }\n]\n\n\n$ curl http://localhost:3000/comments?_expand=article\n[\n  {\n    \"id\": 1,\n    \"body\": \"Brilliant\",\n    \"articleId\": 1,\n    \"article\": {\n      \"id\": 1,\n      \"title\": \"Build an API using GO\",\n      \"author\": \"qneyrat\"\n    }\n  },\n  {\n    \"id\": 2,\n    \"body\": \"Awesome\",\n    \"articleId\": 2,\n    \"article\": {\n      \"id\": 2,\n      \"title\": \"Build an API using API Platform\",\n      \"author\": \"rpierlot\"\n    }\n  },\n  ...\n]\n```\n\nUntil now, we've seen only the routes part of `json-server`, there are a lot more things we can do, let's see what's next.\n\n<a name=\"random-data\"></a>\n\n### Randomly generated data\n\nThe [basic example in Typicode's docs](https://github.com/typicode/json-server#generate-random-data) presents a simple script that generates the `users` endpoint. Here we are going to write endpoints that serve randomly generated data using a data faker module. Personally, I use [faker.js](https://github.com/Marak/faker.js), but there are others that you can explore like [Chance](https://github.com/chancejs/chancejs) and [Casual](https://github.com/boo1ean/casual){:rel=\"nofollow noreferrer\"}.\n\nThe random aspect of the generation occurs only once, and that's when we run the script. This means that `json-server` won't give us a different response for each request. Eventually, we have to install our fake data tool, then write the generation script:\n\n```bash\n$ yarn add faker\n$ touch generate.js\n```\n\nKeep in mind that the script must export a function that exclusively returns an object with keys (endpoints) inside.\n\n```js\n// generate.js\nconst faker = require('faker');\n\nmodule.exports = () => ({\n  messages: [...Array(3)].map((value, index) => ({\n    id: index + 1,\n    name: faker.hacker.noun(),\n    status: faker.hacker.adjective(),\n    description: faker.hacker.phrase(),\n  })),\n});\n```\n\nThen run json-server by giving it the generation script:\n\n```bash\n$ json-server generate.js\n\n  \\{^_^}/ hi!\n\n  Loading generate.js\n  Done\n\n  Resources\n  http://localhost:3000/messages\n\n  Home\n  http://localhost:3000\n\n  Type s + enter at any time to create a snapshot of the database\n```\n\nAnd the results would be something like:\n\n```bash\n$ curl http://localhost:3000/messages\n[\n  {\n    \"id\": 1,\n    \"name\": \"driver\",\n    \"status\": \"cross-platform\",\n    \"description\": \"If we connect the system, we can get to the ADP panel through the redundant PCI protocol!\"\n  },\n  {\n    \"id\": 2,\n    \"name\": \"monitor\",\n    \"status\": \"1080p\",\n    \"description\": \"Try to synthesize the CSS driver, maybe it will navigate the bluetooth matrix!\"\n  },\n  {\n    \"id\": 3,\n    \"name\": \"hard drive\",\n    \"status\": \"virtual\",\n    \"description\": \"Use the redundant SMS program, then you can compress the bluetooth port!\"\n  }\n]\n```\n\nAnd we can still perform requests on it as we've seen in the [routes](#routes) section.\n\n<a name=\"custom-routes\"></a>\n\n### Custom routes\n\nLet's imagine we are supposed to perform requests on several different endpoints on our future API, and these endpoints don't have the same URIs:\n\n```url\n/api/dashboard\n/api/groups/ducks/stats\n/auth/users\n/rpierlot/articles\n```\n\n`json-server` allows us to specify route rewrites. We can address this problem by using a map that resolves the actual routes in our json schema:\n\n```json\n{\n  \"/api/:view\": \"/:view\",\n  \"/api/groups/:planet/stats\": \"/stats?planet=:planet\",\n  \"/:user/articles\": \"/articles?author=:user\",\n  \"/auth/users\": \"/users\"\n}\n```\n\nSo, when we start `json-server` it shows us the route rewrites we are using :\n\n```bash\n$ json-server --watch db2.json --routes routes.json\n\n  \\{^_^}/ hi!\n\n  Loading db2.json\n  Loading routes.json\n  Done\n\n  Resources\n  http://localhost:3000/users\n  http://localhost:3000/dashboard\n  http://localhost:3000/stats\n  http://localhost:3000/articles\n\n  Other routes\n  /api/:view -> /:view\n  /api/groups/:planet/stats -> /stats?planet=:planet\n  /:user/articles -> /articles?author=:user\n  /auth/users -> /users\n\n  Home\n  http://localhost:3000\n\n  Type s + enter at any time to create a snapshot of the database\n  Watching...\n```\n\nNow we can perform our custom requests to see the results:\n\n```bash\n$ curl http://localhost:3000/api/dashboard\n{\n  \"visits\": 3881,\n  \"views\": 625128,\n  \"shares\": 7862\n}\n\n$ curl http://localhost:3000/api/groups/ducks/stats\n[\n  {\n    \"planet\": \"ducks\",\n    \"stats\": {\n      \"points\": 5625,\n      \"ships\": 8\n    }\n  }\n]\n```\n\n<a name=\"middlewares\"></a>\n\n### Middlewares\n\nIn case we want to augment our `json-server` instance with a specific behavior, we have the possibility to do so using custom middlewares, these middlewares are passed to the express server the same way we would do it when developing a classic express app. In this section, we're going to explore a useful example of a feature that is usually necessary.\n\nImagine we want to access a resource on the API, but it turns out that this resource is secured. We can say that it's just about data and assume that we'll be satisfied by just returning it, then we use `json-server` to provide the data without worrying about security. But, we know that something's odd, we want our app to be ready when our future API is ready, in order to test the whole thing together. So, instead of bypassing it, let's use middlewares to set up an authentication layer.\n\n```js\n// auth.js\nconst auth = require('basic-auth');\n\nmodule.exports = (req, res, next) => {\n  var user = auth(req);\n\n  if (typeof user === 'undefined' || user.name !== 'kamal' || user.pass !== 'secret') {\n    // We will discuss this line later in this section.\n    res.header('WWW-Authenticate', 'Basic realm=\"Access to the API\"');\n    return res.status(401).send({ error: 'Unauthorized' });\n  }\n\n  next();\n};\n```\n\nNow run the `json-server` command with the `--middlewares` option:\n\n```bash\n$ json-server --watch db2.json --routes routes.json --middlewares auth.js\n```\n\nNotice: the `--middlewares` option accepts a list of files. `--middlewares file1.js file2.js file3.js`.\n\nNow let's test our authentication layer:\n\n```bash\n$ curl http://localhost:3000/api/groups/ducks/stats\n{\n  \"error\": \"Unauthorized\"\n}\n```\n\nAnd we can see `json-server`'s log with the `401` HTTP status:\n\n```bash\nGET /api/groups/ducks/stats 401 12.180 ms - 29\n```\n\nWhen we display the headers of this response, we recognize this header `WWW-Authenticate: Basic realm=\"Access to the API\"`:\n\n```http\nHTTP/1.1 401 Unauthorized\nX-Powered-By: Express\nVary: Origin, Accept-Encoding\nAccess-Control-Allow-Credentials: true\nCache-Control: no-cache\nPragma: no-cache\nExpires: -1\nWWW-Authenticate: Basic realm=\"Access to the API\"\nContent-Type: application/json; charset=utf-8\nContent-Length: 29\nETag: W/\"1d-t1Z3N2Fd2Yqi/vcyFQaHaMeQEew\"\nDate: Thu, 03 Aug 2017 09:59:57 GMT\nConnection: keep-alive\n```\n\nHere is what Mozilla Developer Network tells about it:\n\n> The `WWW-Authenticate` and `Proxy-Authenticate` response headers define the authentication method that should be used to gain access to a resource. They need to specify which authentication scheme is used so that the client that wishes to authorize knows how to provide the credentials.\n>\n> <cite>[HTTP authentication : `WWW-Authenticate` and `Proxy-Authenticate` headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#WWW-Authenticate_and_Proxy-Authenticate_headers){:rel=\"nofollow noreferrer\"}</cite>\n\nThen we test again, and this time we add credentials to our request (Notice: `curl`'s `--user` option is not restricted to basic authentication, we can do other types of authentication, [see here](https://ec.haxx.se/http-auth.html)){:rel=\"nofollow noreferrer\"}:\n\n```bash\n$ curl --user kamal:secret http://localhost:3000/api/groups/ducks/stats\n[\n  {\n    \"planet\": \"ducks\",\n    \"stats\": {\n      \"points\": 5625,\n      \"ships\": 8\n    }\n  }\n]\n```\n\nGreat! Obviously, it's a `200` HTTP status :-D\n\n```bash\nGET /api/groups/ducks/stats 200 4.609 ms - 94\n```\n\n<a name=\"nodejs-module\"></a>\n\n### As a NodeJS module\n\n`json-server` is an `express` application, which means that we can use it in an existing node/express app to achieve special behaviors. Here is a simple example that shows how to customize the logger:\n\n`json-server` uses [`morgan`](https://github.com/expressjs/morgan) for logs, and the default format that it uses is the [`dev`](https://github.com/expressjs/morgan#dev) log format, which doesn't expose all the info that we want, we need to use the [standard Apache combined log outpout format](https://github.com/expressjs/morgan#combined){:rel=\"nofollow noreferrer\"} instead:\n\n```js\n// server.js\nimport express from 'express';\nimport api from './api';\n\nconst port = 9001;\nconst app = express();\nconst API_ROOT = `http://localhost:${port}/api`;\n\napp.use('/api', api);\n\napp.listen(port, error => {\n  if (error) {\n    console.error(error);\n  } else {\n    console.info('==> 🌎  Listening on port %s. Open up %s in your browser.', port, API_ROOT);\n  }\n});\n```\n\n\n```js\n// api.js\nimport { create, defaults, rewriter, router } from 'json-server';\nimport morgan from 'morgan';\nimport rewrites from './routes.json';\n\nconst server = create();\nconst apiEndpoints = router('db2.json');\n// Deactivate the existing logger\nconst middlewares = defaults({ logger: false });\n\n// Here we use our own logging format\nserver.use(morgan('combined', { colors: true }));\n\nserver.use(rewriter(rewrites));\nserver.use(middlewares);\nserver.use(apiEndpoints);\n\nexport default server;\n```\n\nThen we run our server:\n\n```bash\n$ nodemon --exec babel-node server.js\n==> 🌎  Listening on port 9001. Open up http://localhost:9001/api/ in your browser.\n```\n\nHere we can see our custom logs in the console:\n\n```bash\n$ curl --user kamal:secret http://localhost:9001/api/groups/ducks/stats\n::1 - kamal [11/Aug/2017:15:04:58 +0000] \"GET /api/groups/ducks/stats HTTP/1.1\" 200 187 \"-\" \"curl/7.51.0\"\n\n# or with Chrome\n::1 - - [10/Aug/2017:08:57:04 +0000] \"GET /api/ HTTP/1.1\" 200 - \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\"\n```\n\n## Conclusion\n\n`json-server` has drastically decreased the time of scaffolding an API. Amongst the possibilities that we've seen, there are lots of use cases you can explore in order to use json-server, like logging customization, testing, reconciliation between micro-services, serverless applications ...etc.\n\nI hope this post did shed some light on how we can use json-server. I tried to bring some useful use cases we encounter every day. If you still want to learn more about using it or even its inner working, I recommend exploring its [github project](https://github.com/typicode/json-server){:rel=\"nofollow noreferrer\"}.\n\nThanks for reading!\n"}