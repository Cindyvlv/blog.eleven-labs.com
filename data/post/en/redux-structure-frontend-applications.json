{"date":"2017-01-20T00:00:00.000Z","title":"Redux: Structure your frontend applications","excerpt":"Javascript ecosystem is really rich: full of developers but also full of frameworks and libraries.","readingTime":"7mn","authors":["vcomposieux"],"categories":["javascript"],"content":"Javascript ecosystem is really rich: full of developers but also full of frameworks and libraries.\n\nWhen you want to develop a frontend application, whatever its rendering framework, you will have to structure things into your project in order to organize the data management with views. This case occurs particularly when you use component rendering frameworks like `React` or `VueJS`.\nHistorically, this has been needed by [React](https://facebook.github.io/react/) so that's why Facebook has open sourced its tool named [Flux](http://facebook.github.io/flux/){:rel=\"nofollow\"}.\n\nHere is the philosophy:\n\n![Flux Diagram](/imgs/posts/2017-01-20-redux-structure-frontend-applications/flux-diagram.png)\n\nYour application declare `actions`  for each components. These actions allow you to define the state of your data which is stored in a `store` . This stores continually maintains your `view`  up-to-date.\nWe have a drawback in this case because you have to define one store per component. This is working but on large applications you can feel limited with it.\nIn June 2015, Dan Abramov has launched [Redux](http://redux.js.org/){:rel=\"nofollow\"} which simplify store management because you only have one store for all your application.\n\nAll of your application components can access to the whole state.\n\nFor more information about Redux/Flux differences I encourage you to have a look at [Dan's answer](http://stackoverflow.com/questions/32461229/why-use-redux-over-facebook-flux/32920459#32920459){:rel=\"nofollow\"} on this subject.\n\n# Installation\n\nThis article will deal about how to install and use Redux on your own projects.\nPlease keep in mind that Redux can be used with multiple rendering frameworks like React or VueJS.\nTo install Redux, you will just need the `redux` npm (or yarn) package.\n\nIf you use Redux into a React application, you will also need the `react-redux`  package or even the `vue-redux`  if you want to use it on a VueJS project.\n\n```bash\n$ yarn add redux\n```\n\nNothing more, you can now start to use Redux.\n\n# Basic usage\n\nAs previously described, you will have to instanciate a new `store`  that will allow to store the state of all your application.\nIn order to instanciate this store, you will have to give to it some `reducers` . Reducers contain methods that change the state of your application.\nThese state changes occur when an `action`  is dispatched by your application.\n\nHere we are, we have the 3 things needed by a Redux application: `actions`, `reducers` and a `store`.\nWe will use a simple practical case: a counter that we can increment or decrement with a given value.\n\nHere is our target arborescence:\n\n```\nsrc/\n├── actions\n│   └── counter.js\n├── constants\n│   └── ActionTypes.js\n├── reducers\n│   ├── another.js\n│   ├── counter.js\n│   └── index.js\n└── store\n    └── configureStore.js\n```\n\n## Actions\n\nLet's write an actions containing file that will implement our 2 actions: increment and decrement.\nBefore all, we will store these actions names into constants in order to keep our code clear and comprehensible as we will always call these constants in all of our code.\n\nStart by creating a `src/constants/ActionTypes.js`  file with the following content:\n\n```js\nexport const INCREMENT = 'INCREMENT';\nexport const DECREMENT = 'DECREMENT';\n```\n\nGreat, we will now write actions that correspond to these constants in a `src/actions/counter.js` file:\n\n```js\nimport * as types from '../constants/ActionTypes';\n\nexport const increment = (value) => ({ type: types.INCREMENT, value });\nexport const decrement = (value) => ({ type: types.DECREMENT, value });\n```\n\nYou have just created your 2 actions (`increment`  and `decrement`) which each have a type property (required) and a value to add or remove to the current counter value.\n\n## Reducers\n\nWe will now write reducers functions that correspond to the actions we previously wrote in order to update the value in our application state.\n\nThis will be written in the `src/reducers/counter.js` file:\n\n```js\nimport { INCREMENT, DECREMENT } from '../constants/ActionTypes';\n\nconst initialState = {\n  current: 0,\n};\n\nexport default function counter(state = initialState, action) {\n  switch (action.type) {\n    case INCREMENT:\n      return {\n        current: state.current += action.value,\n      };\n\n    case DECREMENT:\n      return {\n        current: state.current -= action.value,\n      };\n\n    default:\n      return state;\n  }\n}\n```\n\nYou got the idea, we have our actions wrapped into a `switch() { case ... }`  and directly return the store updated with new values.\nYou can also observe that we have initialized an initial state (initialState) in order to prepare our application state with some default values.\n\n`Note:` You can write as many reducers as you need in your application so you can clearly split your code application.\n\nOnly point if you declare multiple reducers into your application is that you will have to combine them here in a file named `src/reducers/index.js`  as follows:\n\n```js\nimport { combineReducers } from 'redux';\n\nimport counter from './counter';\nimport another from './another';\n\nconst reducers = combineReducers({\n  counter,\n  another,\n});\n\nexport default reducers;\n```\n\n## Store\n\nYou have your actions and your reducers so let's dive into the final step: store creation!\nStore will be created in a `src/store/configureStore.js`  file with only these couple of lines:\n\n```js\nimport { createStore } from 'redux';\nimport reducers from '../reducers';\n\nconst configureStore = () => {\n  return createStore(\n    reducers,\n  );\n};\n\nexport default configureStore;\n```\n\nYou just have to call the Redux's `createStore()`  API function in order to create your store.\nIn order to go further, please note that this function can take a maximum of 3 arguments:\n\n* one or many combines reducers,\n* a pre-loaded state (*optional*), corresponding to an initial state,\n* some \"enhancers\" (*optionals*), which are some callbacks such as middlewares.\n\nA middleware is a callback that is executed each time Redux can the `dispatch()`  function so each time an action is triggered.\n\nHere is a simple middleware that logs each dispatched actions:\n\n```js\nimport { createStore, applyMiddleware } from 'redux'\nimport reducers from '../reducers';\n\nfunction logger({ getState }) {\n  return (next) => (action) => {\n    console.log('will dispatch', action)\n    return next(action)\n  }\n}\n\nconst configureStore = () => {\n  return createStore(\n    reducers,\n    applyMiddleware(logger)\n  );\n};\n\nexport default configureStore;\n```\n\nDo not forget to call the `applyMiddleware()` function when you pass your function to the store argument.\n\n# React use case\n\nPrinciples are exactly the same when you want to use Redux on a React application. However, the `react-redux`  library brings some cool additional features to fit with React.\nIndeed, thanks to this library, you will be able to map your React components `props`  with the Redux state and actions.\n\nLet's take a concrete case: a `Counter`  component which could be a component for our previous use case:\n\n```js\nimport React, { PropTypes } from 'react';\nimport { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\n\nimport * as CounterActions from '../actions/counter';\n\nconst Counter = ({ children, value, actions }) => (\n  <div>\n    <button>Increment</button>\n    <button>Decrement</button>\n  </div>\n);\n\nCounter.propTypes = {\n  children: PropTypes.object.isRequired,\n  value: PropTypes.number.isRequired,\n  actions: PropTypes.object.isRequired,\n};\n\nconst mapStateToProps = state => ({\n  value: state.counter.current,\n});\n\nconst mapDispatchToProps = dispatch => ({\n  actions: bindActionCreators(CounterActions, dispatch),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(Counter);\n```\n\nThis way, we are able to retrieve our props values which came from the Redux store but also an `actions` property that will allow us to dispatch Redux events when we will call it.\n\nMain things to note here are:\n\n* `mapStateToProps`  is a function that allows to map our Redux **state properties** with `React properties`,\n* `mapDispatchToProps`  is a function that allows to map Redux `actions` with `React properties`.\n\nThese two functions are applied thanks to the `connect()`  function brought by the `react-redux` library.\n\n`Note:` We have to use the `bindActionCreators()`  function over our `CounterActions`  because this is an object that contains actions functions so this function will allows React to call the `dispatch()`  Redux function when React will call the functions in order to have them correctly triggered.\n\n# Conclusion\n\nIf we put in parallel the download numbers of Redux (`1 303 720 download over the previous month)` with the `2 334 221 downloads of React`, we can conclude that Redux is today `very used` and seems very much `appreciated` by developers because it's a `simple` solution that can greatly help you to structure your application.\nRedux brings, in my opinion, a `real solution` to structure complex (or large) business applications and bring that to the React and VueJS (and others) communities.\n"}