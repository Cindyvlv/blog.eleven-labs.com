{"date":"2020-10-13T00:00:00.000Z","title":"Domain anemia","excerpt":"Are you suffering from domain anemia? Let's look at what an anemic domain model is and how things can change.","readingTime":"9mn","authors":["rpierlot"],"categories":["php"],"content":"\nToday I’d like to talk about something that we see quite often in applications: anemic domains.\n\nWhat’s that you might ask? It’s simply the fact that objects responsible for modeling your business logic... do not contain any of it. Seems strange reading it like this right? Let’s look at some examples to have a better understanding of what I’m saying.\n\nLet’s begin with a simple one: say you want to create a new blog post. In a typical application you’d use your favorite ORM to deal with inserting your shiny new entity into your database. You have a controller handling your HTTP request, and then a service that creates a new Article entity, setting all the right properties for this new stuff.\n\n```php\nClass Article\n{\n    public const STATUS_DRAFT = 'draft';\n    public const STATUS_PUBLISHED = 'published';\n\n    private string $title;\n    private string $content;\n    private string $status;\n    private \\DateTime $createdAt;\n    private \\DateTime $updatedAt;\n\n    public function __construct()\n    {\n        $this->createdAt = new \\DateTime();\n    }\n\n    public function getTitle(): string\n    {\n        return $this->title;\n    }\n\n    public function setTitle(string $title): void\n    {\n        $this->title = $title;\n    }\n\n    public function getContent(): string\n    {\n        return $this->content;\n    }\n\n    public function setContent(string $content): void\n    {\n        $this->content = $content;\n    }\n\n    public function getStatus(): string\n    {\n        return $this->status;\n    }\n\n    public function setStatus(string $status): void\n    {\n        $this->status = $status;\n    }\n\n    public function getCreatedAt(): \\DateTime\n    {\n        return $this->createdAt;\n    }\n\n    public function getUpdatedAt(): ?\\DateTime\n    {\n        return $this->updatedAt;\n    }\n\n    public function setUpdatedAt(\\DateTime $updatedAt): void\n    {\n        $this->updatedAt = $updatedAt;\n    }\n}\n```\nThe service layer looks like this:\n\n```php\n\nclass ArticleService\n{\n    public function create(string $title, $string $content): Article\n    {\n        $article = new Article();\n        $article->setTitle($title);\n        $article->setContent($content);\n        $article->setStatus(Article::STATUS_DRAFT);\n\n        $this->orm->save($article);\n\n        return $article;\n    }\n\n    public function publish(Article $article): void\n    {\n        $article->setStatus(Article::STATUS_PUBLISHED);\n        $article->setUpdatedAt(new \\DateTime());\n\n        $this->orm->save($article);\n    }\n}\n```\n\nLooking back at our code, you might be thinking « it looks pretty standard to me, what’s wrong with it? ». Well, if you look at it conceptually, does it make sense? Is it logical to create an empty shell `new Article()` with no properties at all at first? Then setting a title? Then a content? I doubt that you'd be comfortable reading a blank page with nothing in it.\n\n### Time goes by\n\nLet’s add a business rule: you cannot publish an article without at least having a title and a content.\n\nYou’ll change the publish method in your service like this:\n\n```php\n// class ArticleService\n    public function publish(Article $a)\n    {\n        if (strlen($article->getTitle()) === 0 || strlen($article->getContent())) {\n            throw new CannotPublishException();\n        }\n\n        //...\n    }\n```\n\nYour Article object is just a data bag, and not useful at all. The service layer is the one making sure your entity is valid.\nThis is somehow very weird to shift all the responsibilities of an object to something outside itself. An article should be able to protect its invariants, so that you are sure to end up having a valid state.\n\nHaving such responsibilities will, in the future, allow you or one of your team members to write things like this:\n\n```php\n$article = new Article();\n$article->setStatus(Article::STATUS_PUBLISHED);\n$article->setContent(‘Today we are going to...’);\n$this->orm->save($article);\n```\n\nThis means that you created an article without a title. In the real world it seems quite odd, so why not translate this real world requirement into an explicit thing? Isn’t it what programming is about, translating real processes into code?\n\nMoreover, how would you test this? Again by setting all properties by hand, and asserting that they are all equal. But is it a relevant test? What about change, adding a new business requirement?\n\nThis is what's called an anemic domain model. A class with a bunch of getters and setters, but no behavior. It does nothing on its own.\n\nA domain object must be responsible for its own state, as opposed to this anemic Article.\n\n### Mindshift\n\nShifting from an anemic model to a rich model does not have to be a massive effort. It's mostly a change in how we perceive the domain of our application: the heart of your software.\nFrom our previous example, we can simply make the following changes:\n\n```php\nclass Article\n{\n    //...\n    private function __construct(string $title, string $content): void\n    {\n        $this->title = $title;\n        $this->content = $content;\n        $this->status = self::STATUS_DRAFT;\n        $this->createdAt = new \\DateTime();\n    }\n\n    static public function createDraft(string $title, string $content): Article\n    {\n        return new self($title, $content);\n    }\n\n    public function publish(): void\n    {\n        if (strlen($title) === 0 || strlen($content) === 0) {\n            throw new CannotPublishException();\n        }\n\n        $this->status = self::STATUS_PUBLISHED;\n        $this->updatedAt = new \\DateTime();\n    }\n\n    public function getTitle(): string;\n    public function getContent(): string;\n    public function getCreatedAt(): string;\n    public function getUpdatedAt(): string;\n}\n```\n\nWith a richer domain model, your service could look a bit like this:\n\n```php\n//class ArticleService\n    public function create(string $title, string $content)\n    {\n        $article = Article::createDraft($title, $content);\n        $this->orm->save($article);\n    }\n\n    public function publish(Article $article)\n    {\n        $article->publish();\n        $this->orm->save($article);\n    }\n```\n\nAlthough this example is very basic, we see a shift in responsibility between the service layer and the domain object. And that seems far more understandable than before.\nTests can now focus only on business logic without needing to deal with the service layer, which is kept thin.\n\nRich domain objects enable you to have valid states and make sure it stays this way, through the class constructor or using static methods to build your objects.\n\nYou will also notice that Article has methods with far more descriptive names. `createDraft` and `publish` are domain concepts, they relate to business requirements shared between all parties of the software. The language used in the code is now aligned with the business.\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Interestingly too, with an Explicit Model there are generally far less lines of code than with an Anemic Model (think client+model). The Explicit Model can be easily tested with confidence. The Anemic Model can have 10,000 tests with doubt.</p>&mdash; Vaughn Vernon (@VaughnVernon) <a href=\"https://twitter.com/VaughnVernon/status/1009183261866639360?ref_src=twsrc%5Etfw\">June 19, 2018</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nI think most of this anemia comes from how ORM/framework explains to you how to deal with objects and database, but we lose sight of what really is object oriented design: transposing problems into code ; combining behavior and data.\n\nMoving from an anemic domain to a rich one is not for every use case, but if you have a certain amount of business logic, you'd better try it.\n\nFor sure there are downsides to defining domain objects with actual behaviors. For instance, you’ll have to adapt how objects are built by your ORM (if you use one) into objects. But that will quickly be forgotten once you discover how it changes the way you test and think about your domain model.\n\nTake a look at this article from Matthias Noback regarding an interesting solution for dealing with database and domain objects: [https://matthiasnoback.nl/2018/03/ormless-a-memento-like-pattern-for-object-persistence/](https://matthiasnoback.nl/2018/03/ormless-a-memento-like-pattern-for-object-persistence/)\n\nThanks [Guillem](https://twitter.com/buraitopengin) for the feedbacks!\n\n## Resources\n\n- [Anemic Domain Model - Fowler](https://martinfowler.com/bliki/AnemicDomainModel.html)\n- [A blog engine using rich domain objects](https://github.com/dddinphp/blog-cqrs)\n"}