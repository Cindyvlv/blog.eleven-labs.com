{"date":"2020-05-13T00:00:00.000Z","title":"PHP & Serverless with Bref - part 2","excerpt":"How to deploy PHP applications to AWS Lambda with Bref","readingTime":"10mn","authors":["marishka"],"categories":["php"],"content":"\nThis article is a follow-up to this [first part](https://blog.eleven-labs.com/en/en/php-serverless-part-1/) which introduces serverless computing. In this second part, we will first see what the *layers* are in AWS Lambda and how to implement them. Then we will see how to use the Bref framework.\n\n## AWS Lambda\n\n### How it works\n\nAn AWS Lambda environment includes:\n\n- the runtime of the chosen language (Java, Go, PowerShell, Node.js, C #, Python, Ruby by default)\n- the implementation of *Lambda runtime API*, i.e. the lifecycle of the execution of the environment and the invocation of serverless functions\n\nThe lifecycle of a Lambda runtime consists of an initialization phase and several (as many as necessary) invocation phases.\n\nThe initialization phase represents the time between the moment when the environment starts the runtime and the moment when the code of a function is executed. This phase is performed only once during the life cycle of the environment.\n\nAfter initialization, the execution environment goes into the invocation phase and will constantly check and execute tasks, until the environment shuts down.\n\nSince November 2018, it is possible to declare your own runtimes for Lambda functions, but also to incorporate reusable components in the form of *Layers*.\n\nYou can implement a runtime in any language. A runtime is a program that executes the `handler` of a Lambda function when it is called. A runtime can be included in the function deployment package in the form of an executable file named `bootstrap` (we will see an example later in this article).\n\n### Layers\n\nA Lambda function can be configured to download additional code and content as a layer. A layer is a ZIP archive that contains libraries, a custom runtime or other dependencies.\n\nIf you have already written serverless functions in Node.js, you know that you must package the entire `node_modules` folder for every function (since they are deployed independently from each other). This slows down the deployment process and makes the builds slow.\n\nBut now, it is possible to publish the `node_modules` folder as a shared and reusable layer for all our functions. This means that we could have a layer for our custom runtime, another layer which contains our dependencies and configure our functions to use these 2 layers. Note that a function has a limit of 5 layers.\n\n### Example\n\n**PHP function**\n\nTake the following simple function as an example:\n\n```php\n// src/profession.php\nfunction occupation()\n{\n    $jobs = [\n        'Fireman',\n        'Astronaut',\n        'Super hero',\n        'Pilot',\n        'Professional cook',\n        'Artist',\n    ];\n\n    return ['occupation' => $jobs[array_rand($jobs)]];\n}\n```\n\n**PHP layer**\n\nI am going to create a `layers/php` folder in my application and I will place my layer there.\nTo create a custom runtime, we need a `bootstrap` file which will contain the logic of our runtime in charge of invoking our functions.\n\nWe also need a PHP executable capable of interpreting our code. I'm going to create a `bin` folder in my layer folder to place my `php` binary. To generate a binary, I recommend you read [this article](https://aws.amazon.com/blogs/compute/scripting-languages-for-aws-lambda-running-php-ruby-and-go/).\n\nWhen deploying a layer, it is placed in the `/opt` folder in the containers. So my `bootstrap` file could look like this:\n\n```bash\n#!/bin/sh\n\n#go into the source directory\ncd $LAMBDA_TASK_ROOT\n\n#execute the runtime\n/opt/bin/php /opt/runtime.php\n```\n\nHere is an example of `runtime.php` inspired by the [article on the AWS blog](https://aws.amazon.com/blogs/apn/aws-lambda-custom-runtime-for-php-a-practical-example/).\nWe will use `Guzzle` to make HTTP calls, therefore I will first execute the following command:\n\n```\ncomposer require guzzlehttp/guzzle\n```\n\n```php\n<?php\n\n// Invoke Composer's autoloader to use Guzzle\nrequire $_ENV['LAMBDA_TASK_ROOT'] . '/vendor/autoload.php';\n\n// Request processing loop => barring unrecoverable failure, this loop runs until the environment shuts down\ndo {\n    // Ask the runtime API for a request to handle\n    $request = getNextRequest();\n\n    // Obtain the function name from the _HANDLER environment variable and ensure the function's code is available\n    list($handlerFile, $handlerFunction) = explode(\".\", $_ENV['_HANDLER']);\n    require_once $_ENV['LAMBDA_TASK_ROOT'] . '/src/' . $handlerFile . '.php';\n\n    // Execute the desired function and obtain the response\n    $response = $handlerFunction($request['payload']);\n\n    // Submit the response back to the runtime API\n    sendResponse($request['invocationId'], $response);\n} while (true);\n\nfunction getNextRequest()\n{\n    $client = new \\GuzzleHttp\\Client();\n    $response = $client->get(sprintf(\n        'http://%s/2018-06-01/runtime/invocation/next',\n        $_ENV['AWS_LAMBDA_RUNTIME_API']\n    ));\n\n    return [\n        'invocationId' => $response->getHeader('Lambda-Runtime-Aws-Request-Id')[0],\n        'payload' => json_decode((string) $response->getBody(), true),\n    ];\n}\n\nfunction sendResponse($invocationId, $response)\n{\n    $client = new \\GuzzleHttp\\Client();\n    $client->post(\n        sprintf(\n            'http://%s/2018-06-01/runtime/invocation/%s/response',\n            $_ENV['AWS_LAMBDA_RUNTIME_API'],\n            $invocationId\n        ),\n        ['body' => $response]\n    );\n}\n```\n\nTo summarize, we currently have the following file structure:\n\n```\nlayers/\n    php/\n        bin/\n            php #binary file\n        bootstrap\n        runtime.php\nsrc/\n    profession.php\nvendor/\n    guzzlehttp/\n```\n\n**Deployment**\n\nI will use the *serverless* framework to deploy my layer and my function:\n\n```yaml\n# serverless.yml\nservice: php-serverless\nprovider:\n  name: aws\n  runtime: provided\n  region: eu-west-3\n  memorySize: 512\n\nlayers:\n  php:\n    path: layers/php\n\nfunctions:\n  occupation:\n    handler: profession.occupation\n    layers:\n      - {Ref: PhpLambdaLayer}\n```\n\nAs we can see, in my `occupation` function, the `handler` contains the name of my file `profession.php` and the `occupation` method. This is how I configured it in `runtime.php`:\n\n```php\n//...\nlist($handlerFile, $handlerFunction) = explode(\".\", $_ENV['_HANDLER']);\nrequire_once $_ENV['LAMBDA_TASK_ROOT'] . '/src/' . $handlerFile . '.php';\n$response = $handlerFunction($request['payload']);\n```\n\nIt is therefore up to us to configure the way we name the handlers and the way to call them in the runtime.\n\nThe name of our layer `PhpLambdaLayer` corresponds to its CloudFormation reference. You can read the details [here](https://www.serverless.com/framework/docs/providers/aws/guide/layers/#aws---layers).\n\nTo deploy the function and the layer, execute the following command:\n\n```bash\n$ sls deploy\n\nServerless: Packaging service...\n#...\nServerless: Stack update finished...\nService Information\nservice: php-serverless\nstage: dev\nregion: eu-west-3\nstack: php-serverless-dev\nresources: 7\napi keys:\n  None\nendpoints:\n  None\nfunctions:\n  occupation: php-serverless-dev-occupation\nlayers:\n  php: arn:aws:lambda:eu-west-3:087017887086:layer:php:1\n```\n\nFinally, let's invoke the `occupation` function:\n\n```bash\n$ sls invoke -f occupation -l\n{\n  \"occupation\": \"Fireman\"\n}\n--------------------------------------------------------------------\nSTART RequestId: d09f2191-7233-47d3-a4fe-8de2a621a608 Version: $LATEST\nEND RequestId: d09f2191-7233-47d3-a4fe-8de2a621a608\nREPORT RequestId: d09f2191-7233-47d3-a4fe-8de2a621a608  Duration: 38.15 ms  Billed Duration: 300 ms  Memory Size: 512 MB  Max Memory Used: 59 MB  Init Duration: 191.10 ms\n```\n\n**Summary**\n\nSo we just made a working example with a *layer* capable of executing PHP code.\n\nNow imagine that you have a large application, say a REST API in Symfony, that you would like to deploy on AWS Lambda. It would be necessary to develop a much more advanced runtime capable of integrating with the *front controller of Symfony*, and why not with the *console* as well. We would also have to modify the PHP layer to add all the libraries we would need and to recompile the PHP binary.\n\nFortunately for us, an *open source* solution exists to manage all of this: [Bref](https://bref.sh/).\n\n## Bref\n\nBref is an open source Composer package that allows us to deploy PHP applications on AWS Lambda. It is developed by [Matthieu Napoli](https://mnapoli.fr/).\n\nBref provides:\n\n- the documentation\n- PHP runtimes for AWS Lambda\n- deployment tools\n- integration with PHP frameworks\n\nI suggest we deploy a Symfony application on AWS Lambda using Bref.\n\n### Symfony application\n\nTo create my application:\n\n```bash\n$ composer create-project symfony / skeleton sf-serverless-example\n```\n\nNext, let's modify the default controller as follows (to use the same example as above):\n\n```php\nnamespace App\\Controller;\n\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\n\nclass DefaultController\n{\n    public function index()\n    {\n        $jobs = [\n            'Fireman',\n            'Astronaut',\n            'Super hero',\n            'Pilot',\n            'Professional cook',\n            'Artist',\n        ];\n\n        return new JsonResponse([\n            'occupation' => $jobs[array_rand($jobs)],\n        ]);\n    }\n}\n```\n\nNow let's add the Bref library:\n\n```bash\n$ composer require bref/bref\n```\n\nFinally, let's configure the deployment with *serverless* framework:\n\n```yaml\n# serverless.yml\nservice: php-serverless-sf-bref\nprovider:\n  name: aws\n  region: eu-west-3\n  runtime: provided\n  environment:\n    # Symfony environment variables\n    APP_ENV: prod\n\nplugins:\n  - ./vendor/bref/bref\n\nfunctions:\n  website:\n    handler: public/index.php\n    timeout: 28 # API Gateway has a timeout of 29 seconds\n    layers:\n      - ${bref:layer.php-74-fpm}\n    events:\n      - http: 'ANY /'\n      - http: 'ANY /{proxy+}'\n  console:\n    handler: bin/console\n    timeout: 120 # in seconds\n    layers:\n      - ${bref:layer.php-74} # PHP\n      - ${bref:layer.console} # The \"console\" layer\n```\n\nThe list of layers made available by Bref can be consulted [here](https://runtimes.bref.sh/). I also recommend that you read the Bref documentation, it is very clear and provides plenty of examples that you may need.\n\nWe need to keep in mind that with most cloud providers the filesystem is read only. Hence, we need to change the `logs` and `cache` folders of our application:\n\n```php\npublic function getLogDir()\n{\n    // When on the lambda only /tmp is writeable\n    if (getenv('LAMBDA_TASK_ROOT') !== false) {\n        return '/tmp/log/';\n    }\n\n    return parent::getLogDir();\n}\n\npublic function getCacheDir()\n{\n    // When on the lambda only /tmp is writeable\n    if (getenv('LAMBDA_TASK_ROOT') !== false) {\n        return '/tmp/cache/'.$this->environment;\n    }\n\n    return parent::getCacheDir();\n}\n```\n\nLast step, deployment:\n\n```bash\n$ sls deploy\n\nServerless: Packaging service...\nService Information\nservice: php-serverless-sf-bref\nstage: dev\nregion: eu-west-3\nstack: php-serverless-sf-bref-dev\nresources: 15\napi keys:\n  None\nendpoints:\n  ANY - https://maeck9uwyf.execute-api.eu-west-3.amazonaws.com/dev\n  ANY - https://maeck9uwyf.execute-api.eu-west-3.amazonaws.com/dev/{proxy+}\nfunctions:\n  website: php-serverless-sf-bref-dev-website\n  console: php-serverless-sf-bref-dev-console\nlayers:\n  None\n```\n\nMy application is available on the URL indicated in the endpoints. Here is the result:\n\n![](/imgs/posts/2020-05-07-php-serverless-part-2/example.png)\n\nThat's it. We just deployed a Symfony application to AWS Lambda using Bref!\nAs you can see, it is a pretty straight forward process...\n\nYou can now enjoy deploying PHP applications to a serverless infrastructure :)\n"}